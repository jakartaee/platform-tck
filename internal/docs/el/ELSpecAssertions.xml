<?xml version = "1.0" encoding = "US-ASCII"?>
<!DOCTYPE spec SYSTEM "https://raw.githubusercontent.com/eclipse-ee4j/jakartaee-tck/master/internal/docs/dtd/spec_assertions.dtd">
<!--

    Copyright (c) 2018 Oracle and/or its affiliates. All rights reserved.

    This program and the accompanying materials are made available under the
    terms of the Eclipse Public License v. 2.0, which is available at
    http://www.eclipse.org/legal/epl-2.0.

    This Source Code may also be made available under the following Secondary
    Licenses when the conditions for such availability set forth in the
    Eclipse Public License v. 2.0 are satisfied: GNU General Public License,
    version 2 with the GNU Classpath Exception, which is available at
    https://www.gnu.org/software/classpath/license.html.

    SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0

-->

<?xml-stylesheet href = 'file:///files/workspaces/tools/docs/xsl/assertions/spec_assertions_comments.xsl' type = 'text/xsl'?>
<spec>
	<!-- @(#)ELSpecAssertions.xml 1.0 03/23/06 -->
	<next-available-id>52</next-available-id>
	<previous-id>48</previous-id>
	<technology>EL</technology>
	<id>EL</id>
	<name>Expression Language</name>
	<version>3.0</version>
	<location-names>
		<chapters>
			<chapter id="1" name="Language Syntax and Semantics">
				<sections>
					<section id="1" name="Overview" />
					<section id="1.1" name="EL in a nutshell" />
					<section id="2" name="EL Expressions" />
					<section id="2.1" name="Eval-expression" />
					<section id="2.1.1" name="Eval-expressions as value expressions" />
					<section id="2.1.2" name="Eval-expressions as method expressions" />
					<section id="2.2" name="Literal-expression" />
					<section id="2.3" name="Composite expressions" />
					<section id="2.4" name="Syntax restrictions" />
					<section id="3" name="Literals" />
					<section id="4" name="Errors, Warnings, Default Values" />
					<section id="5" name="Resolution of Model Objects and their Properties" />
					<section id="6" name="Operators [] and ." />
					<section id="7" name="Arithmetic Operators" />
					<section id="7.1" name="Binary operators - A {+,-,*} B" />
					<section id="7.2" name="Binary operator - A {/,div} B" />
					<section id="7.3" name="Binary operator - A {%,mod} B" />
					<section id="7.4" name="Unary minus operator - -A" />
					<section id="8" name="String Concatenation Operator - A {+,cat} B" />
					<section id="9" name="Relational Operators" />
					<section id="9.1" name="A {&lt;,>,&lt;=,>=,lt,gt,le,ge} B" />
					<section id="9.2" name="A {==,!=,eq,ne} B" />
					<section id="10" name="Logical Operators" />
					<section id="10.1" name="Binary operator - A {&amp;&amp;,||,and,or} B" />
					<section id="11" name="Empty Operator - empty A" />
					<section id="12" name="Conditional Operator - A ? B : C" />
					<section id="13" name="Assignment Operator - A = B" />
					<section id="14" name="Semicolon Operator - A ; B" />
					<section id="15" name="Parentheses" />
					<section id="16" name="Operator Precedence" />
					<section id="17" name="Reserved Words" />
					<section id="18" name="Functions" />
					<section id="19" name="Variables" />
					<section id="20" name="Lambda Expressions" />
					<section id="21" name="Enums" />
					<section id="22" name="Static Field and Method Reference" />
					<section id="22.1" name="Access Restrictions and Imports" />
					<section id="22.2" name="Imports of Classes and Packages" />
					<section id="22.3" name="Special Fields and Methods" />
					<section id="23" name="Type Conversion" />
					<section id="23.1" name="To Coerce a Value X to Type Y" />
					<section id="23.2" name="Coerce A to String" />
					<section id="23.3" name="Coerce A to Number type N" />
					<section id="23.4" name="Coerce A to Character" />
					<section id="23.5" name="Coerce A to Boolean or boolean" />
					<section id="23.6" name="Coerce A to an Enum Type T" />
					<section id="23.7" name="Coerce A to Any Other Type T" />
					<section id="19" name="Collected Syntax " />
				</sections>
			</chapter>
			<chapter id="2" name="Operations on Collection Objects">
				<sections>
					<section id="2" name="Construction of Collection Objects" />
					<section id="2.1" name="Set Construction" />
					<section id="2.2" name="List Construction" />
					<section id="2.3" name="Map Construction" />
					<section id="3" name="Collection Operations" />
					<section id="3.1" name="Stream and Pipeline" />
					<section id="3.2" name="Operator Syntax Description" />
					<section id="3.3" name="Implementation Classes" />
					<section id="3.4" name="Functions" />
					<section id="3.5" name="filter" />
					<section id="3.6" name="map" />
					<section id="3.7" name="flatMap" />
					<section id="3.8" name="distinct" />
					<section id="3.9" name="sorted" />
					<section id="3.10" name="forEach" />
					<section id="3.11" name="peek" />
					<section id="3.12" name="iterator" />
					<section id="3.13" name="limit" />
					<section id="3.14" name="substream" />
					<section id="3.15" name="toArray" />
					<section id="3.16" name="toList" />
					<section id="3.17" name="reduce" />
					<section id="3.18" name="max" />
					<section id="3.19" name="min" />
					<section id="3.20" name="average" />
					<section id="3.21" name="sum" />
					<section id="3.22" name="count" />
					<section id="3.23" name="anyMatch" />
					<section id="3.24" name="allMatch" />
					<section id="3.25" name="noneMatch" />
					<section id="3.26" name="findFirst" />
				</sections>
			</chapter>
		</chapters>
	</location-names>
	<assertions>
		<assertion required="true" impl-spec="false" defined-by="technology"
			status="active" testable="true">
			<id>EL:SPEC:45</id>
			<description>Once parsed, an expression can optionally be evaluated
				one or
				more times. [ExprParsedEvalMany]</description>
			<location chapter="1" section="2" />
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology"
			status="active" testable="true">
			<id>EL:SPEC:1</id>
			<description>An eval-expression is formed by using the constructs
				${expr} or
				#{expr}. Both constructs are parsed and evaluated in
				exactly the same way by
				the EL, even though they might carry
				different meanings in the technology
				that is using the EL.
				[PoundDollarSameMeaning]</description>
			<location chapter="1" section="2.1" />
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology"
			status="active" testable="true">
			<id>EL:SPEC:2</id>
			<description>Nested eval-expressions, such as ${item[${i}]}, are
				illegal.
				[NestedEvalExprIllegal]</description>
			<location chapter="1" section="2.1" />
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology"
			status="active" testable="true">
			<id>EL:SPEC:3</id>
			<description>When parsing a value expression, an expected type is
				provided. In
				the case of an rvalue, the expected type is what the
				result of the expression
				evaluation is coerced to. [RValueCoercion]</description>
			<location chapter="1" section="2.1.1" />
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology"
			status="active" testable="false">
			<id>EL:SPEC:4</id>
			<description>When parsing lvalues, the expected type is ignored and
				the
				provided value is coerced to the actual type of the property the
				expression
				points to, before that property is set. [LValueCoercion]</description>
			<location chapter="1" section="2.1.1" />
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology"
			status="active" testable="true">
			<id>EL:SPEC:5</id>
			<description>There is no coercion performed by method expressions.
				[MethodExprSignature]</description>
			<location chapter="1" section="2.1.2" />
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology"
			status="active" testable="true">
			<id>EL:SPEC:6</id>
			<description>A literal-expression does not use the ${expr} or #{expr}
				constructs, and simply evaluates to the text of the expression, of
				type
				String. Upon evaluation, an expected type of something other
				than String can
				be provided. [LiteralExprEval]</description>
			<location chapter="1" section="2.2" />
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology"
			status="active" testable="true">
			<id>EL:SPEC:7</id>
			<description>To generate literal values that include the character
				sequence
				"${" or ?#{?, the developer can choose to use a composite
				expression as shown
				in the example: [ELSyntaxAsLiteral]</description>
			<location chapter="1" section="2.2" />
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology"
			status="active" testable="true">
			<id>EL:SPEC:8</id>
			<description>The escape characters \$ and \# can be used to escape
				what would
				otherwise be treated as an eval-expression.
				[ELSyntaxEscape]</description>
			<location chapter="1" section="2.2" />
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology"
			status="active" testable="true">
			<id>EL:SPEC:9</id>
			<description>A literal-expression can be used anywhere a value
				expression can
				be used. [LiteralExprAnywhereValueExprUsed]</description>
			<location chapter="1" section="2.2" />
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology"
			status="active" testable="true">
			<id>EL:SPEC:10</id>
			<description>A literal-expression can also be used as a method
				expression that
				returns a non-void return value. The standard EL
				coercion rules then apply if
				the return type of the method
				expression is not java.lang.String.
				[LiteralExprAsMethodExpr]</description>
			<location chapter="1" section="2.2" />
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology"
			status="active" testable="true">
			<id>EL:SPEC:11</id>
			<description>With composite expressions, eval-expressions are
				evaluated from
				left to right, coerced to Strings (according to the
				EL type conversion
				rules), and concatenated with any intervening
				literal-expressions.
				[CompositeExprEval]</description>
			<location chapter="1" section="2.3" />
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology"
			status="active" testable="true">
			<id>EL:SPEC:12</id>
			<description>It is illegal to mix ${} and #{} constructs in a
				composite
				expression. [CannotMixTwoSyntax]</description>
			<location chapter="1" section="2.3" />
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology"
			status="active" testable="false">
			<id>EL:SPEC:13</id>
			<description>There are literals for boolean, integer, floating point,
				string,
				and null in an eval-expression. [EvalExpressionLiterals]</description>
			<location chapter="1" section="3" />
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:13.1</id>
					<description>The boolean literal has values true and false</description>
					<location chapter="1" section="3" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:13.2</id>
					<description>The integer literal is defined by the IntegerLiteral
						construct.</description>
					<location chapter="1" section="3" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:13.3</id>
					<description>The floating point literal is defined by the
						FloatingPointLiteral construct</description>
					<location chapter="3" section="1" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:13.4</id>
					<description>The string literal is defined with single and double
						quotes</description>
					<location chapter="3" section="1" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:13.5</id>
					<description>In a string literal, " is escaped as \", ' is escaped
						as \',
						and \ is escaped as \\. Quotes only need to be escaped in a
						string value
						enclosed in the same type of quote</description>
					<location chapter="3" section="1" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:13.6</id>
					<description>The null literal has a null value.</description>
					<location chapter="3" section="1" />
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology"
			status="active" testable="false">
			<id>EL:SPEC:14</id>
			<description>The EL does not provide warnings, just default values
				and errors.
				Default values are type-correct values that are assigned
				to a subexpression
				when there is some problem. An error is an
				exception thrown (to be handled by
				the environment where the EL is
				used). [DefaultValuesAndErrors]</description>
			<location chapter="1" section="4" />
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology"
			status="active" testable="true">
			<id>EL:SPEC:15</id>
			<description>The dot and index operators have equivalent
				functionality.
				[DotAndIndexOperatorsSame]</description>
			<location chapter="1" section="6" />
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology"
			status="active" testable="false">
			<id>EL:SPEC:16</id>
			<description>To evaluate expr-a[expr-b]:</description>
			<location chapter="1" section="6" />
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="false">
					<id>EL:SPEC:16.1</id>
					<description>Evaluate expr-a into value-a</description>
					<location chapter="1" section="6" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="false">
					<id>EL:SPEC:16.2</id>
					<description>If value-a is null:</description>
					<location chapter="1" section="6" />
					<sub-assertions>
						<assertion required="true" impl-spec="false" defined-by="technology"
							status="active" testable="false">
							<id>EL:SPEC:16.2.1</id>
							<description>If expr-a[expr-b] is the last property being
								resolved:</description>
							<location chapter="1" section="6" />
							<sub-assertions>
								<assertion required="true" impl-spec="false" defined-by="technology"
									status="active" testable="false">
									<id>EL:SPEC:16.2.1.1</id>
									<description>If the expression is a value expression and
										ValueExpression.getValue(context) was called to initiate this
										expression evaluation, return null.</description>
									<location chapter="1" section="6" />
								</assertion>
								<assertion required="true" impl-spec="false" defined-by="technology"
									status="active" testable="false">
									<id>EL:SPEC:16.2.1.2</id>
									<description>Otherwise, throw PropertyNotFoundException</description>
									<location chapter="1" section="6" />
								</assertion>
							</sub-assertions>
						</assertion>
						<assertion required="true" impl-spec="false" defined-by="technology"
							status="active" testable="false">
							<id>EL:SPEC:16.2.2</id>
							<description>Otherwise, return null.</description>
							<location chapter="1" section="6" />
						</assertion>
					</sub-assertions>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="false">
					<id>EL:SPEC:16.3</id>
					<description>Evaluate expr-b into value-b </description>
					<location chapter="1" section="6" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="false">
					<id>EL:SPEC:16.4</id>
					<description>If value-b is null</description>
					<location chapter="1" section="6" />
					<sub-assertions>
						<assertion required="true" impl-spec="false" defined-by="technology"
							status="active" testable="false">
							<id>EL:SPEC:16.4.1</id>
							<description>If expr-a[expr-b] is the last property being
								resolved:</description>
							<location chapter="1" section="6" />
							<sub-assertions>
								<assertion required="true" impl-spec="false" defined-by="technology"
									status="active" testable="false">
									<id>EL:SPEC:16.4.1.1</id>
									<description>If the expression is a value expression and
										ValueExpression.getValue(context) was called to initiate this
										expression evaluation, return null.</description>
									<location chapter="1" section="6" />
								</assertion>
								<assertion required="true" impl-spec="false" defined-by="technology"
									status="active" testable="false">
									<id>EL:SPEC:16.4.1.2</id>
									<description>Otherwise, throw PropertyNotFoundException</description>
									<location chapter="1" section="6" />
								</assertion>
							</sub-assertions>
						</assertion>
						<assertion required="true" impl-spec="false" defined-by="technology"
							status="active" testable="false">
							<id>EL:SPEC:16.4.2</id>
							<description>Otherwise, return null.</description>
							<location chapter="1" section="6" />
						</assertion>
					</sub-assertions>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="false">
					<id>EL:SPEC:16.5</id>
					<description>If the expression is a value expression:</description>
					<location chapter="1" section="6" />
					<sub-assertions>
						<assertion required="true" impl-spec="false" defined-by="technology"
							status="active" testable="false">
							<id>EL:SPEC:16.5.1</id>
							<description>If expr-a[expr-b] is the last property being
								resolved:</description>
							<location chapter="1" section="6" />
							<sub-assertions>
								<assertion required="true" impl-spec="false" defined-by="technology"
									status="active" testable="false">
									<id>EL:SPEC:16.5.1.1</id>
									<description>If ValueExpression.getValue(context) was called to
										initiate this expression evaluation, invoke
										elResolver.getValue(context, value-a, value-b)</description>
									<location chapter="1" section="6" />
								</assertion>
								<assertion required="true" impl-spec="false" defined-by="technology"
									status="active" testable="false">
									<id>EL:SPEC:16.5.1.2</id>
									<description>If ValueExpression.getType(context) was called,
										invoke
										elResolver.getType(context, value-a, value-b).</description>
									<location chapter="1" section="6" />
								</assertion>
								<assertion required="true" impl-spec="false" defined-by="technology"
									status="active" testable="false">
									<id>EL:SPEC:16.5.1.3</id>
									<description>If ValueExpression.isReadOnly(context) was called,
										invoke
										elResolver.isReadOnly(context, value-a, value-b).</description>
									<location chapter="1" section="6" />
								</assertion>
								<assertion required="true" impl-spec="false" defined-by="technology"
									status="active" testable="false">
									<id>EL:SPEC:16.5.1.4</id>
									<description>If ValueExpression.setValue(context, val) was
										called,
										invoke elResolver.setValue(context, value-a, value-b,
										val).</description>
									<location chapter="1" section="6" />
								</assertion>
							</sub-assertions>
						</assertion>
						<assertion required="true" impl-spec="false" defined-by="technology"
							status="active" testable="false">
							<id>EL:SPEC:16.5.2</id>
							<description>Otherwise, invoke elResolver.getValue(value-a,
								value-b)</description>
							<location chapter="1" section="6" />
						</assertion>
					</sub-assertions>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="false">
					<id>EL:SPEC:16.6</id>
					<description>Otherwise, the expression is a method expression</description>
					<location chapter="1" section="6" />
					<sub-assertions>
						<assertion required="true" impl-spec="false" defined-by="technology"
							status="active" testable="false">
							<id>EL:SPEC:16.6.1</id>
							<description>If expr-a[expr-b] is the last property being
								resolved:</description>
							<location chapter="1" section="6" />
							<sub-assertions>
								<assertion required="true" impl-spec="false" defined-by="technology"
									status="active" testable="false">
									<id>EL:SPEC:16.6.1.1</id>
									<description>Coerce value-b to String</description>
									<location chapter="1" section="6" />
								</assertion>
								<assertion required="true" impl-spec="false" defined-by="technology"
									status="active" testable="false">
									<id>EL:SPEC:16.6.1.2</id>
									<description>Find the method on object value-a with name
										value-b and
										with the set of expected parameter types provided
										at parse time. If the
										method does not exist, or the return
										type does not match the expected
										return type provided at parse
										time, throw MethodNotFoundException.</description>
									<location chapter="1" section="6" />
								</assertion>
								<assertion required="true" impl-spec="false" defined-by="technology"
									status="active" testable="false">
									<id>EL:SPEC:16.6.1.3</id>
									<description>If MethodExpression.invoke(context, params) was
										called,
										invoke the found method with the parameters passed to
										the invoke method</description>
									<location chapter="1" section="6" />
								</assertion>
								<assertion required="true" impl-spec="false" defined-by="technology"
									status="active" testable="false">
									<id>EL:SPEC:16.6.1.4</id>
									<description>If MethodExpression.getMethodInfo(context) was
										called,
										construct and return a new MethodInfo object.</description>
									<location chapter="1" section="6" />
								</assertion>
							</sub-assertions>
						</assertion>
						<assertion required="true" impl-spec="false" defined-by="technology"
							status="active" testable="false">
							<id>EL:SPEC:16.6.2</id>
							<description>Otherwise invoke elResolver.getValue(value-a,
								value-b).</description>
							<location chapter="1" section="6" />
						</assertion>
					</sub-assertions>
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology"
			status="active" testable="false">
			<id>EL:SPEC:17</id>
			<description>Binary operators - A { +,-,* } B</description>
			<location chapter="1" section="7.1" />
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:46</id>
					<description>If the operator is a +, and either A or B is a
						String,
						then + is
						a string concatenation operator.</description>
					<location chapter="1" section="7.1" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:17.1</id>
					<description>If A and B are null, return (Long) 0</description>
					<location chapter="1" section="7.1" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="false">
					<id>EL:SPEC:17.2</id>
					<description>If A or B is a BigDecimal, coerce both to BigDecimal
						and then:</description>
					<location chapter="1" section="7.1" />
					<sub-assertions>
						<assertion required="true" impl-spec="false" defined-by="technology"
							status="active" testable="true">
							<id>EL:SPEC:17.2.1</id>
							<description>If operator is +, return A.add(B)</description>
							<location chapter="1" section="7.1" />
						</assertion>
						<assertion required="true" impl-spec="false" defined-by="technology"
							status="active" testable="true">
							<id>EL:SPEC:17.2.2</id>
							<description>If operator is -, return A.subtract(B)</description>
							<location chapter="1" section="7.1" />
						</assertion>
						<assertion required="true" impl-spec="false" defined-by="technology"
							status="active" testable="true">
							<id>EL:SPEC:17.2.3</id>
							<description>If operator is *, return A.multiply(B)</description>
							<location chapter="1" section="7.1" />
						</assertion>
					</sub-assertions>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="false">
					<id>EL:SPEC:17.3</id>
					<description>If A or B is Float, Double, or a String containing
						".", "e", or
						"E":</description>
					<location chapter="1" section="7.1" />
					<sub-assertions>
						<assertion required="true" impl-spec="false" defined-by="technology"
							status="active" testable="true">
							<id>EL:SPEC:17.3.1</id>
							<description>If A or B is BigInteger, coerce both A and B to
								BigDecimal
								and apply operator.</description>
							<location chapter="1" section="7.1" />
						</assertion>
						<assertion required="true" impl-spec="false" defined-by="technology"
							status="active" testable="true">
							<id>EL:SPEC:17.3.2</id>
							<description>Otherwise, coerce both A and B to Double and apply
								operator</description>
							<location chapter="1" section="7.1" />
						</assertion>
					</sub-assertions>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="false">
					<id>EL:SPEC:17.4</id>
					<description>If A or B is BigInteger, coerce both to BigInteger and
						then:</description>
					<location chapter="1" section="7.1" />
					<sub-assertions>
						<assertion required="true" impl-spec="false" defined-by="technology"
							status="active" testable="true">
							<id>EL:SPEC:17.4.1</id>
							<description>If operator is +, return A.add(B)</description>
							<location chapter="1" section="7.1" />
						</assertion>
						<assertion required="true" impl-spec="false" defined-by="technology"
							status="active" testable="true">
							<id>EL:SPEC:17.4.2</id>
							<description>If operator is -, return A.subtract(B)</description>
							<location chapter="1" section="7.1" />
						</assertion>
						<assertion required="true" impl-spec="false" defined-by="technology"
							status="active" testable="true">
							<id>EL:SPEC:17.4.3</id>
							<description>If operator is *, return A.multiply(B)</description>
							<location chapter="1" section="7.1" />
						</assertion>
					</sub-assertions>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:17.5</id>
					<description>Otherwise coerce both A and B to Long and apply
						operator.</description>
					<location chapter="1" section="7.1" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:17.6</id>
					<description>If application of operator against A and B results in
						an
						exception, error.</description>
					<location chapter="1" section="7.1" />
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology"
			status="active" testable="false">
			<id>EL:SPEC:18</id>
			<description>Binary operator - A { / or div } B</description>
			<location chapter="1" section="7.2" />
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:18.1</id>
					<description>If A and B are null, return (Long) 0</description>
					<location chapter="1" section="7.2" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:18.2</id>
					<description>If A or B is a BigDecimal or a BigInteger, coerce both
						to
						BigDecimal and return A.divide(B, BigDecimal.ROUND_HALF_UP)</description>
					<location chapter="1" section="7.2" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:18.3</id>
					<description>Otherwise, coerce both A and B to Double and apply
						operator.</description>
					<location chapter="1" section="7.2" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:23.4</id>
					<description>If application of operator against A and B results in
						an
						exception, error.</description>
					<location chapter="1" section="7.2" />
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology"
			status="active" testable="false">
			<id>EL:SPEC:19</id>
			<description>Binary Operator - A { % or mod } B</description>
			<location chapter="1" section="7.3" />
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:19.1</id>
					<description>If A and B are null, return (Long)0</description>
					<location chapter="1" section="7.3" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:19.2</id>
					<description>If A or B is a BigDecimal, Float, Double, or String
						containing
						., e, or E, coerce both A and B to Double and apply
						operator</description>
					<location chapter="1" section="7.3" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:19.3</id>
					<description>If A or B is a BigInteger, coerce both to BigInteger
						and return
						A.remainder(B).</description>
					<location chapter="1" section="7.3" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:19.4</id>
					<description>Otherwise coerce both A and B to Long and apply
						operator.</description>
					<location chapter="1" section="7.3" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:19.5</id>
					<description>If operator results in exception, error</description>
					<location chapter="1" section="7.3" />
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology"
			status="active" testable="false">
			<id>EL:SPEC:20</id>
			<description>Unary minus operator - -A</description>
			<location chapter="1" section="7.4" />
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:20.1</id>
					<description>If A is null, return (Long) 0</description>
					<location chapter="1" section="7.4" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:20.2</id>
					<description>If A is a BigDecimal or BigInteger, return A.negate()</description>
					<location chapter="1" section="7.4" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="false">
					<id>EL:SPEC:20.3</id>
					<description>If A is a String:</description>
					<location chapter="1" section="7.4" />
					<sub-assertions>
						<assertion required="true" impl-spec="false" defined-by="technology"
							status="active" testable="true">
							<id>EL:SPEC:20.3.1</id>
							<description>If A contains ".", "e", or "E", coerce to a Double
								and apply
								operator.</description>
							<location chapter="1" section="7.4" />
						</assertion>
						<assertion required="true" impl-spec="false" defined-by="technology"
							status="active" testable="true">
							<id>EL:SPEC:20.3.2</id>
							<description>Otherwise, coerce to a Long and apply operator</description>
							<location chapter="1" section="7.4" />
						</assertion>
						<assertion required="true" impl-spec="false" defined-by="technology"
							status="active" testable="true">
							<id>EL:SPEC:20.3.3</id>
							<description>If operation results in exception, error.</description>
							<location chapter="1" section="7.4" />
						</assertion>
					</sub-assertions>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="false">
					<id>EL:SPEC:20.4</id>
					<description>If A is Byte, Short, Integer, Long, Float, Double:</description>
					<location chapter="1" section="7.4" />
					<sub-assertions>
						<assertion required="true" impl-spec="false" defined-by="technology"
							status="active" testable="true">
							<id>EL:SPEC:20.4.1</id>
							<description>retain the type and apply the operator.</description>
							<location chapter="1" section="7.4" />
						</assertion>
						<assertion required="true" impl-spec="false" defined-by="technology"
							status="active" testable="true">
							<id>EL:SPEC:20.4.2</id>
							<description>If application of operator results in exception,
								error.</description>
							<location chapter="1" section="7.4" />
						</assertion>
					</sub-assertions>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:20.5</id>
					<description>Otherwise, error</description>
					<location chapter="1" section="7.4" />
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology"
			status="active" testable="false">
			<id>EL:SPEC:47</id>
			<description>String Concatenation Operator - A {+, cat} B</description>
			<location chapter="1" section="8" />
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:47.1</id>
					<description>The + operator is a string concatenation
						operator if
						and only if
						at least one of the operands
						is a String.</description>
					<location chapter="1" section="8.1" />
					<sub-assertions>
						<assertion required="true" impl-spec="false" defined-by="technology"
							status="active" testable="true">
							<id>EL:SPEC:47.1.1</id>
							<description>Coerce A and B to String.</description>
							<location chapter="1" section="8.1" />
						</assertion>
						<assertion required="true" impl-spec="false" defined-by="technology"
							status="active" testable="true">
							<id>EL:SPEC:47.1.2</id>
							<description>Return the concatenated string of A and B.</description>
							<location chapter="1" section="8.1" />
						</assertion>
					</sub-assertions>
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology"
			status="active" testable="false">
			<id>EL:SPEC:21</id>
			<description>Relational operators - A { &lt;,>,&lt;=,=>,lt,gt,le,ge }
				B</description>
			<location chapter="1" section="9.1" />
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:21.1</id>
					<description>If A==B, and operator is &lt;=, le, >=, or ge, return
						true</description>
					<location chapter="1" section="9.1" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:21.2</id>
					<description>If A or B is null, return false.</description>
					<location chapter="1" section="9.1" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:21.3</id>
					<description>If A or B is BigDecimal, coerce both A and B to
						BigDecimal and
						use the return value of A.compareTo(B).</description>
					<location chapter="1" section="9.1" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:21.4</id>
					<description>If A or B is Float or Double coerce both A and B to
						Double and
						apply operator.</description>
					<location chapter="1" section="9.1" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:21.5</id>
					<description>If A or B is BigInteger, coerce both A and B to
						BigInteger and
						use the return value of A.compareTo(B)</description>
					<location chapter="1" section="9.1" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:21.6</id>
					<description>If A or B is Byte, Short, Character, Integer, or Long,
						coerce
						both A and B to Long and apply operator.</description>
					<location chapter="1" section="9.1" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:21.7</id>
					<description>If A or B is String coerce both A and B to String,
						compare
						lexically.</description>
					<location chapter="1" section="9.1" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="false">
					<id>EL:SPEC:21.8</id>
					<description>If A is Comparable: </description>
					<location chapter="1" section="9.1" />
					<sub-assertions>
						<assertion required="true" impl-spec="false" defined-by="technology"
							status="active" testable="true">
							<id>EL:SPEC:21.8.1</id>
							<description>If A.compareTo(B) throws an exception, error</description>
							<location chapter="1" section="9.1" />
						</assertion>
						<assertion required="true" impl-spec="false" defined-by="technology"
							status="active" testable="true">
							<id>EL:SPEC:21.8.2</id>
							<description>Otherwise return the result of A.compareTo(B)</description>
							<location chapter="1" section="9.1" />
						</assertion>
					</sub-assertions>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="false">
					<id>EL:SPEC:21.9</id>
					<description>If B is Comparable, then:</description>
					<location chapter="1" section="9.1" />
					<sub-assertions>
						<assertion required="true" impl-spec="false" defined-by="technology"
							status="active" testable="true">
							<id>EL:SPEC:21.9.1</id>
							<description>If B.compareTo(A) throws exception, error</description>
							<location chapter="1" section="9.1" />
						</assertion>
						<assertion required="true" impl-spec="false" defined-by="technology"
							status="active" testable="true">
							<id>EL:SPEC:21.9.2</id>
							<description>Otherwise use result of B.compareTo(A)</description>
							<location chapter="1" section="9.1" />
						</assertion>
					</sub-assertions>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:21.10</id>
					<description>Otherwise, error</description>
					<location chapter="1" section="9.1" />
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology"
			status="active" testable="false">
			<id>EL:SPEC:22</id>
			<description>Relational Operators - A { ==, !=, eq, ne } B</description>
			<location chapter="1" section="9.2" />
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:22.1</id>
					<description>If A == B, apply operator.</description>
					<location chapter="1" section="9.2" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:22.2</id>
					<description>If A or B is null, return false for == or eq, true for
						!= or ne</description>
					<location chapter="1" section="9.2" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="false">
					<id>EL:SPEC:22.3</id>
					<description>If A or B is BigDecimal, coerce both A and B to
						BigDecimal and
						then:</description>
					<location chapter="1" section="9.2" />
					<sub-assertions>
						<assertion required="true" impl-spec="false" defined-by="technology"
							status="active" testable="true">
							<id>EL:SPEC:22.3.1</id>
							<description>If operator is == or eq, return A.equals(B)</description>
							<location chapter="1" section="9.2" />
						</assertion>
						<assertion required="true" impl-spec="false" defined-by="technology"
							status="active" testable="true">
							<id>EL:SPEC:22.3.2</id>
							<description>If operator is != or ne, return !A.equals(B)</description>
							<location chapter="1" section="9.2" />
						</assertion>
					</sub-assertions>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:22.4</id>
					<description>If A or B is Float or Double coerce both A and B to
						Double and
						apply operator.</description>
					<location chapter="1" section="9.2" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="false">
					<id>EL:SPEC:22.5</id>
					<description>If A or B is BigInteger, coerce both A and B to
						BigInteger and
						then:</description>
					<location chapter="1" section="9.2" />
					<sub-assertions>
						<assertion required="true" impl-spec="false" defined-by="technology"
							status="active" testable="true">
							<id>EL:SPEC:22.5.1</id>
							<description>If operator is == or eq, return A.equals(B)</description>
							<location chapter="1" section="9.2" />
						</assertion>
						<assertion required="true" impl-spec="false" defined-by="technology"
							status="active" testable="true">
							<id>EL:SPEC:22.5.2</id>
							<description>If operator is != or ne, return !A.equals(B)</description>
							<location chapter="1" section="9.2" />
						</assertion>
					</sub-assertions>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:22.6</id>
					<description>If A or B is Byte, Short, Character, Integer, or Long,
						coerce
						both A and B to Long and apply operator.</description>
					<location chapter="1" section="9.2" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:22.7</id>
					<description>If A or B is Boolean coerce both A and B to Boolean,
						apply
						operator.</description>
					<location chapter="1" section="9.2" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:22.8</id>
					<description>If A or B is an enum, coerce both A and B to enum,
						apply
						operator</description>
					<location chapter="1" section="9.2" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:22.9</id>
					<description>If A or B is String coerce both A and B to String and
						compare
						lexically</description>
					<location chapter="1" section="9.2" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:22.10</id>
					<description>If error occurs calling A.equals(B), error</description>
					<location chapter="1" section="9.2" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:22.11</id>
					<description>Otherwise apply operator to result of A.equals(B).</description>
					<location chapter="1" section="9.2" />
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology"
			status="active" testable="false">
			<id>EL:SPEC:23</id>
			<description>Binary Operator - A { &amp;&amp;, ||, and, or } B</description>
			<location chapter="1" section="9.1" />
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:23.1</id>
					<description>Coerce both A and B to Boolean and apply operator.</description>
					<location chapter="1" section="9.1" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:23.2</id>
					<description>The operator stops as soon as the expression can be
						determined, i.e., A and B and C and D ? if B is false, then only A
						and B is
						evaluated.</description>
					<location chapter="1" section="9.1" />
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology"
			status="active" testable="false">
			<id>EL:SPEC:24</id>
			<description>Logical Operators</description>
			<location chapter="1" section="10" />
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="false">
					<id>EL:SPEC:24.2</id>
					<description>Binary operator - A {&amp;&amp;,||,and,or} B</description>
					<location chapter="1" section="10.1" />
					<sub-assertions>
						<assertion required="true" impl-spec="false" defined-by="technology"
							status="active" testable="true">
							<id>EL:SPEC:24.2.1</id>
							<description>Coerce both A and B to Boolean, apply operator.</description>
							<location chapter="1" section="10.2" />
						</assertion>
					</sub-assertions>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="false">
					<id>EL:SPEC:24.1</id>
					<description>Unary operator - { !, not } A</description>
					<location chapter="1" section="10.2" />
					<sub-assertions>
						<assertion required="true" impl-spec="false" defined-by="technology"
							status="active" testable="true">
							<id>EL:SPEC:24.1.1</id>
							<description>Coerce A to Boolean and apply operator.</description>
							<location chapter="1" section="10.2" />
						</assertion>
					</sub-assertions>
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology"
			status="active" testable="false">
			<id>EL:SPEC:25</id>
			<description>Empty operator - empty A</description>
			<location chapter="1" section="11" />
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:25.1</id>
					<description>If A is null, return true</description>
					<location chapter="1" section="11" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:25.2</id>
					<description>If A is an emtpy String, return true.</description>
					<location chapter="1" section="11" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:25.3</id>
					<description>If A is an empty array, then return true.</description>
					<location chapter="1" section="11" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:25.4</id>
					<description>If A is an emtpy Map, then return true.</description>
					<location chapter="1" section="11" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:25.5</id>
					<description>If A is an empty Collection, then return true.</description>
					<location chapter="1" section="11" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:25.6</id>
					<description>Otherwise return false</description>
					<location chapter="1" section="11" />
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology"
			status="active" testable="false">
			<id>EL:SPEC:26</id>
			<description>Conditional Operator - A ? B : C</description>
			<location chapter="1" section="12" />
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="false">
					<id>EL:SPEC:26.1</id>
					<description>Evaluate B or C, depending on the result of the
						evaluation of
						A.
						Coerce A to Boolean:
					</description>
					<location chapter="1" section="12" />
					<sub-assertions>
						<assertion required="true" impl-spec="false" defined-by="technology"
							status="active" testable="true">
							<id>EL:SPEC:26.1.1</id>
							<description>If A is true, evaluate and return B</description>
							<location chapter="1" section="12" />
						</assertion>
						<assertion required="true" impl-spec="false" defined-by="technology"
							status="active" testable="true">
							<id>EL:SPEC:26.1.2</id>
							<description>If A is false, evaluate and return C</description>
							<location chapter="1" section="12" />
						</assertion>
					</sub-assertions>
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology"
			status="active" testable="false">
			<id>EL:SPEC:48</id>
			<description>Assignment Operator - A = B</description>
			<location chapter="1" section="13" />
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="false">
					<id>EL:SPEC:48.1</id>
					<description>Assign the value of B to A. A must be a lvalue,
						otherwise, a
						PropertyNotWritableException will be thrown.
					</description>
					<location chapter="1" section="13" />
					<sub-assertions>
						<assertion required="true" impl-spec="false" defined-by="technology"
							status="active" testable="true">
							<id>EL:SPEC:48.1.1</id>
							<description>Evluate expr-a, up to the last property reolution,
								to
								(base-a, prop-a)</description>
							<location chapter="1" section="13" />
						</assertion>
						<assertion required="true" impl-spec="false" defined-by="technology"
							status="active" testable="true">
							<id>EL:SPEC:48.1.2</id>
							<description>Evaluate expr-b, to value-b</description>
							<location chapter="1" section="13" />
						</assertion>
						<assertion required="true" impl-spec="false" defined-by="technology"
							status="active" testable="true">
							<id>EL:SPEC:48.1.3</id>
							<description>Invoke ELResolver.setValue(base-a, prop-a, value-b)</description>
							<location chapter="1" section="13" />
						</assertion>
						<assertion required="true" impl-spec="false" defined-by="technology"
							status="active" testable="true">
							<id>EL:SPEC:48.1.4</id>
							<description>Return value-b</description>
							<location chapter="1" section="13" />
						</assertion>
					</sub-assertions>
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology"
			status="active" testable="false">
			<id>EL:SPEC:49</id>
			<description>Semicolon Operator - A ; B</description>
			<location chapter="1" section="14" />
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:49.1</id>
					<description>To evaluate A;B, A is first evaluated, and its value
						is
						discarded. B is then evaluated and its value is returned.</description>
					<location chapter="1" section="14" />
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology"
			status="active" testable="true">
			<id>EL:SPEC:27</id>
			<description>Parentheses can be used to change precedence</description>
			<location chapter="1" section="15" />
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology"
			status="active" testable="true">
			<id>EL:SPEC:28</id>
			<description>Operator precedence (highest to lowest) - [] . then (),
				then
				-(unary) not ! empty, then * / div % mod, then + - (binary),
				then &lt; >
				&lt;= >= lt gt le ge, then == != eq ne, then &amp;&amp;
				and, then || or, then
				? : then -> then = then ;</description>
			<location chapter="1" section="16" />
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology"
			status="active" testable="true">
			<id>EL:SPEC:29</id>
			<description>Qualified functions with a namespace prefix have
				precedence over
				the operators. [FunctionPrecedenceOverOperators]</description>
			<location chapter="1" section="16" />
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology"
			status="active" testable="false">
			<id>EL:SPEC:30</id>
			<description>The following words are reserved for the language and
				must not be
				used as identifiers.
				and eq gt true instanceof
				or ne le
				false empty
				not lt ge
				null div mod
			</description>
			<location chapter="1" section="17" />
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology"
			status="active" testable="true">
			<id>EL:SPEC:31</id>
			<description>EL functions are mapped, resolved and bound at parse
				time.
				[ELFunctionsBinding]</description>
			<location chapter="1" section="18" />
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology"
			status="active" testable="false">
			<id>EL:SPEC:32</id>
			<description>It is the responsibility of the FunctionMapper class to
				provide
				the mapping of namespace-qualified functions to static
				methods of specific
				classes when expressions are created.
				[FunctionMapperMapping]</description>
			<location chapter="1" section="18" />
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology"
			status="active" testable="true">
			<id>EL:SPEC:33</id>
			<description>If no FunctionMapper is provided (by passing in null),
				functions
				are disabled. [FunctionMapperNull]</description>
			<location chapter="1" section="" />
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology"
			status="active" testable="true">
			<id>EL:SPEC:34</id>
			<description>EL variables are mapped, resolved and bound at parse
				time.
				[ELVariablesBinding]</description>
			<location chapter="1" section="19" />
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology"
			status="active" testable="false">
			<id>EL:SPEC:35</id>
			<description>It is the responsibility of the VariableMapper class to
				provide
				the mapping of EL variables to ValueExpressions when
				expressions are created.
				[VariableMapperMapping]</description>
			<location chapter="1" section="19" />
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology"
			status="active" testable="true">
			<id>EL:SPEC:36</id>
			<description>If no VariableMapper is provided to a ValueExpression,
				variable
				mapping is disabled. [VariableMapperNull]</description>
			<location chapter="1" section="19" />
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology"
			status="active" testable="false">
			<id>EL:SPEC:50</id>
			<description>Lambda Expressions</description>
			<location chapter="1" section="20" />
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:50.1</id>
					<description>x->x+1</description>
					<location chapter="1" section="20" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:50.2</id>
					<description>(x,y)->x+y</description>
					<location chapter="1" section="20" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:50.3</id>
					<description>((x,y)->x+y)(3,4) evaluates to 7.</description>
					<location chapter="1" section="20" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:50.4</id>
					<description>v = (x,y)->x+y</description>
					<location chapter="1" section="20" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:50.5</id>
					<description>v(3,4) evaluates to 7</description>
					<location chapter="1" section="20" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:50.6</id>
					<description>fact = n -> n==0? 1: n*fact(n-1); fact(5) evaluates to
						120</description>
					<location chapter="1" section="20" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:50.7</id>
					<description>It can also be passed as an argument to a method, and
						be
						invoked in the method, by invoking
						javax.el.LambdaExpression.invoke(), such
						as
						employees.where(e->e.firstName == 'Larry')</description>
					<location chapter="1" section="20" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:50.8</id>
					<description>A Lambda expression can be nested within another
						Lambda
						expression, like
						customers.select(c->[c.name,
						c.orders.sum(o->o.total)])</description>
					<location chapter="1" section="20" />
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology"
			status="active" testable="false">
			<id>EL:SPEC:37</id>
			<description>To coerce a value X to type Y</description>
			<location chapter="1" section="23.1" />
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="false">
					<id>EL:SPEC:37.1</id>
					<description>If X is of a primitive type, Let X' be the equivalent
						'boxed
						form' of X, otherwise, Let X' be the same as X.</description>
					<location chapter="1" section="23.1" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="false">
					<id>EL:SPEC:37.2</id>
					<description>If Y is of a primitive type, Let Y' be the equivalent
						'boxed
						form' of Y. Otherwise, let Y' be the same as Y.</description>
					<location chapter="1" section="23.1" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:37.3</id>
					<description>Apply the rules in Sections 1.18.2-1.18.7 for coercing
						X' to Y'</description>
					<location chapter="1" section="23.1" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:37.4</id>
					<description>If Y is a primitive type, then the result is found by
						'unboxing' the result of the coercion. If the result of the
						coercion is
						null, then error.</description>
					<location chapter="1" section="23.1" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:37.5</id>
					<description>If Y is not a primitive type, then the result is the
						result of
						the coercion.</description>
					<location chapter="1" section="23.1" />
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology"
			status="active" testable="true">
			<id>EL:SPEC:38</id>
			<description>Coerce A to String</description>
			<location chapter="1" section="23.2" />
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:38.1</id>
					<description>If A is a String: return A</description>
					<location chapter="1" section="23.2" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:38.2</id>
					<description>If A is null, return an empty String ("").</description>
					<location chapter="1" section="23.2" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:38.3</id>
					<description>If A is Enum, return A.name()</description>
					<location chapter="1" section="23.2" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:38.4</id>
					<description>If A.toString() throws exception, error.</description>
					<location chapter="1" section="23.2" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:38.5</id>
					<description>Otherwise return A.toString()</description>
					<location chapter="1" section="23.2" />
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology"
			status="active" testable="false">
			<id>EL:SPEC:39</id>
			<description>Coerce A to Number type N</description>
			<location chapter="1" section="23.3" />
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:39.1</id>
					<description>If A is null or "", return 0</description>
					<location chapter="1" section="23.3" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:39.2</id>
					<description>If A is Character, convert to short, apply numeric
						rules below.</description>
					<location chapter="1" section="23.3" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:39.3</id>
					<description>If A is a Boolean, then error.</description>
					<location chapter="1" section="23.3" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:39.4</id>
					<description>If A is Number type N, return A</description>
					<location chapter="1" section="23.3" />
				</assertion>
				<assertion required="true" impl-spec="true" defined-by="technology"
					status="active" testable="false">
					<id>EL:SPEC:39.5</id>
					<description>If A is a Number, coerce quietly to type N using the
						following
						algorithm:</description>
					<location chapter="1" section="23.3" />
					<sub-assertions>
						<assertion required="true" impl-spec="false" defined-by="technology"
							status="active" testable="false">
							<id>EL:SPEC:39.5.1</id>
							<description>If N is BigInteger:</description>
							<location chapter="1" section="23.3" />
							<sub-assertions>
								<assertion required="true" impl-spec="false" defined-by="technology"
									status="active" testable="true">
									<id>EL:SPEC:39.5.1.1</id>
									<description>If A is a BigDecimal, return A.toBigInteger()</description>
									<location chapter="1" section="23.3" />
								</assertion>
								<assertion required="true" impl-spec="false" defined-by="technology"
									status="active" testable="true">
									<id>EL:SPEC:39.5.1.2</id>
									<description>Otherwise, return
										BigInteger.valueOf(A.longValue())</description>
									<location chapter="1" section="23.3" />
								</assertion>
							</sub-assertions>
						</assertion>
						<assertion required="true" impl-spec="false" defined-by="technology"
							status="active" testable="false">
							<id>EL:SPEC:39.5.2</id>
							<description>If N is BigDecimal</description>
							<location chapter="1" section="23.3" />
							<sub-assertions>
								<assertion required="true" impl-spec="false" defined-by="technology"
									status="active" testable="true">
									<id>EL:SPEC:39.5.2.1</id>
									<description>If A is a BigInteger, return new BigDecimal(A)</description>
									<location chapter="1" section="23.3" />
								</assertion>
								<assertion required="true" impl-spec="false" defined-by="technology"
									status="active" testable="true">
									<id>EL:SPEC:39.5.2.2</id>
									<description>Otherwise, return new BigDecimal(A.doubleValue())</description>
									<location chapter="1" section="23.3" />
								</assertion>
							</sub-assertions>
						</assertion>
						<assertion required="true" impl-spec="false" defined-by="technology"
							status="active" testable="true">
							<id>EL:SPEC:39.5.3</id>
							<description>If N is Byte, return new Byte(A.byteValue())</description>
							<location chapter="1" section="23.3" />
						</assertion>
						<assertion required="true" impl-spec="false" defined-by="technology"
							status="active" testable="true">
							<id>EL:SPEC:39.5.4</id>
							<description>If N is Short, return new Short(A.shortValue())</description>
							<location chapter="1" section="23.3" />
						</assertion>
						<assertion required="true" impl-spec="false" defined-by="technology"
							status="active" testable="true">
							<id>EL:SPEC:39.5.5</id>
							<description>If N is Integer, return new Integer(A.intValue())</description>
							<location chapter="1" section="23.3" />
						</assertion>
						<assertion required="true" impl-spec="false" defined-by="technology"
							status="active" testable="true">
							<id>EL:SPEC:39.5.6</id>
							<description>If N is Long, return new Long(A.longValue())</description>
							<location chapter="1" section="23.3" />
						</assertion>
						<assertion required="true" impl-spec="false" defined-by="technology"
							status="active" testable="true">
							<id>EL:SPEC:39.5.7</id>
							<description>If N is Float, return new Float(A.floatValue())</description>
							<location chapter="1" section="23.3" />
						</assertion>
						<assertion required="true" impl-spec="false" defined-by="technology"
							status="active" testable="true">
							<id>EL:SPEC:39.5.8</id>
							<description>If N is Double, return new Double(A.doubleValue())</description>
							<location chapter="1" section="23.3" />
						</assertion>
						<assertion required="true" impl-spec="false" defined-by="technology"
							status="active" testable="true">
							<id>EL:SPEC:39.5.9</id>
							<description>Otherwise, error.</description>
							<location chapter="1" section="23.3" />
						</assertion>
					</sub-assertions>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="false">
					<id>EL:SPEC:39.6</id>
					<description>If A is String, then:</description>
					<location chapter="1" section="23.3" />
					<sub-assertions>
						<assertion required="true" impl-spec="false" defined-by="technology"
							status="active" testable="false">
							<id>EL:SPEC:39.6.1</id>
							<description>If N is BigDecimal then:</description>
							<location chapter="1" section="23.3" />
							<sub-assertions>
								<assertion required="true" impl-spec="false" defined-by="technology"
									status="active" testable="true">
									<id>EL:SPEC:39.6.1.1</id>
									<description>If new BigDecimal(A) throws an exception then
										error.</description>
									<location chapter="1" section="23.3" />
								</assertion>
								<assertion required="true" impl-spec="false" defined-by="technology"
									status="active" testable="true">
									<id>EL:SPEC:39.6.1.2</id>
									<description>Otherwise, return new BigDecimal(A).</description>
									<location chapter="1" section="23.3" />
								</assertion>
							</sub-assertions>
						</assertion>
					</sub-assertions>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="false">
					<id>EL:SPEC:39.7</id>
					<description>If N is BigInteger then</description>
					<location chapter="1" section="23.3" />
					<sub-assertions>
						<assertion required="true" impl-spec="false" defined-by="technology"
							status="active" testable="true">
							<id>EL:SPEC:39.7.1</id>
							<description>If new BigInteger(A) throws an exception then error.</description>
							<location chapter="1" section="23.3" />
						</assertion>
						<assertion required="true" impl-spec="false" defined-by="technology"
							status="active" testable="true">
							<id>EL:SPEC:39.7.2</id>
							<description>Otherwise, return new BigInteger(A).</description>
							<location chapter="1" section="23.3" />
						</assertion>
						<assertion required="true" impl-spec="false" defined-by="technology"
							status="active" testable="true">
							<id>EL:SPEC:39.7.3</id>
							<description>If N.valueOf(A) throws an exception, then error.</description>
							<location chapter="1" section="23.3" />
						</assertion>
						<assertion required="true" impl-spec="false" defined-by="technology"
							status="active" testable="true">
							<id>EL:SPEC:39.7.4</id>
							<description>Otherwise, return N.valueOf(A).</description>
							<location chapter="1" section="23.3" />
						</assertion>
					</sub-assertions>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:39.8</id>
					<description>Otherwise error.</description>
					<location chapter="1" section="23.3" />
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology"
			status="active" testable="false">
			<id>EL:SPEC:40</id>
			<description>Coerce A to Character</description>
			<location chapter="1" section="23.4" />
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:40.1</id>
					<description>If A is null or "". return (char) 0</description>
					<location chapter="1" section="23.4" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:40.2</id>
					<description>If A is Character, then return A</description>
					<location chapter="1" section="23.4" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:40.3</id>
					<description>If A is Boolean, error.</description>
					<location chapter="1" section="23.4" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:40.4</id>
					<description>If A is Number, coerce quietly to type Short, then
						return a
						Character whose numeric value is equivalent to that
						Short.</description>
					<location chapter="1" section="23.4" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:40.5</id>
					<description>If A is String, return A.charAt(0)</description>
					<location chapter="1" section="23.4" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:40.6</id>
					<description>All other types will result in an error.</description>
					<location chapter="1" section="23.4" />
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology"
			status="active" testable="false">
			<id>EL:SPEC:41</id>
			<description>Coerce A to Boolean</description>
			<location chapter="1" section="23.5" />
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:41.1</id>
					<description>If A is null or "", return false</description>
					<location chapter="1" section="23.5" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:41.2</id>
					<description>Otherwise if A is Boolean, return A</description>
					<location chapter="1" section="23.5" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:41.3</id>
					<description>Otherwise if A is String, and Boolean.valueOf(A) does
						not throw
						an exception, return it.</description>
					<location chapter="1" section="23.5" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:41.4</id>
					<description>Otherwise error.</description>
					<location chapter="1" section="23.5" />
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology"
			status="active" testable="false">
			<id>EL:SPEC:42</id>
			<description>Coerce A to an Enum Type T</description>
			<location chapter="1" section="23.6" />
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:42.1</id>
					<description>If A is null, return null</description>
					<location chapter="1" section="23.6" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:42.2</id>
					<description>If A is assignable to T, coerce quietly</description>
					<location chapter="1" section="23.6" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:42.3</id>
					<description>If A is "", return null.</description>
					<location chapter="1" section="23.6" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:42.4</id>
					<description>If A is a String call Enum.valueOf(T.getClass(), A)
						and return
						the result.</description>
					<location chapter="1" section="23.6" />
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology"
			status="active" testable="false">
			<id>EL:SPEC:43</id>
			<description>Coerce A to any other type T</description>
			<location chapter="1" section="23.7" />
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:43.1</id>
					<description>If A is null, return null.</description>
					<location chapter="1" section="23.7" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:43.2</id>
					<description>If A is assignable to T, coerce quietly.</description>
					<location chapter="1" section="23.7" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:43.3</id>
					<description>If A is String, and T has no Property Editor, then if
						A is ""
						return null, otherwise error.</description>
					<location chapter="1" section="23.7" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:43.4</id>
					<description>If A is String, and T's PropertyEditor throws
						exception, then
						if A is "" return null, otherwise error.</description>
					<location chapter="1" section="23.7" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:43.5</id>
					<description>Otherwise, apply T's PropertyEditor</description>
					<location chapter="1" section="23.7" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:43.6</id>
					<description>Otherwise, error</description>
					<location chapter="1" section="23.7" />
				</assertion>
			</sub-assertions>
		</assertion>

		<!-- Start Chapter 2, Operations on Collection Objects -->
		<assertion required="true" impl-spec="false" defined-by="technology"
			status="active" testable="true">
			<id>EL:SPEC:44</id>
			<description>All Expressions must be Serializable</description>
			<location chapter="2" section="1" />
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology"
			status="active" testable="false">
			<id>EL:SPEC:51</id>
			<description>
				Construct an instance of java.lang.util.Set&lt;Object&gt;.
			</description>
			<location chapter="2" section="2.2.1" />
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:51.1</id>
					<description>SetData := '{' DataList '}'</description>
					<location chapter="2" section="2.2.1.1" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:51.2</id>
					<description>DataList := (expression (',' expression)* )?</description>
					<location chapter="2" section="2.2.1.1" />
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology"
			status="active" testable="false">
			<id>EL:SPEC:52</id>
			<description>
				Construct an instance of java.lang.util.List&lt;Object&gt;.
			</description>
			<location chapter="2" section="2.2.2" />
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:52.1</id>
					<description>ListData := '{' DataList '}'</description>
					<location chapter="2" section="2.2.2.1" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:52.2</id>
					<description>DataList := (expression (',' expression)* )?</description>
					<location chapter="2" section="2.2.2.1" />
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology"
			status="active" testable="false">
			<id>EL:SPEC:53</id>
			<description>
				Construct an instance of java.lang.util.Map&lt;Object&gt;.
			</description>
			<location chapter="2" section="2.2.3" />
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:53.1</id>
					<description>Map := '{' MapEntries '}'</description>
					<location chapter="2" section="2.2.3.1" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:53.2</id>
					<description>MapEntries := (MapEntry (',' MapEntry)* )?</description>
					<location chapter="2" section="2.2.3.1" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:53.3</id>
					<description>MapEntry := expression ':' expression</description>
					<location chapter="2" section="2.2.3.1" />
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology"
			status="active" testable="true">
			<id>EL:SPEC:54</id>
			<description>Some methods have optional parameters. The
				declarations
				of the
				methods with all possible combinations of the
				parameters are
				listed in the
				syntax sections, as if they are
				overloaded. A null
				parameter is not allowed,
				and will result in
				NullPointerException.</description>
			<location chapter="2" section="2.3.2" />
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology"
			status="active" testable="true">
			<id>EL:SPEC:55</id>
			<description>
				An instant of Stream is obtained by calling the method
				stream()
				of a collection. The methods in this class support the
				stream
				operations and
				are described in Section 2.3.5 to Section
				2.3.24.
			</description>
			<location chapter="2" section="2.3.3.1" />
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology"
			status="active" testable="false">
			<id>EL:SPEC:56</id>
			<description>
				The following are methods in an Optional&lt;T&gt; </description>
			<location chapter="2" section="2.3.3.2" />
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:56.1</id>
					<description>
						T get() Returns the value held by the Optional, or
						throws an
						ELException if the Optional is empty.
					</description>
					<location chapter="2" section="2.3.3.2" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:56.2</id>
					<description>
						T orElse(T other) Returns the value held by the
						Optional, or
						the value other if the Optional is empty.
					</description>
					<location chapter="2" section="2.3.3.2" />
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology"
					status="active" testable="true">
					<id>EL:SPEC:56.3</id>
					<description>
						T orElseGet((()->T) other) Returns the value held by the
						Optional, or the value returned by the lambda expression
						other if
						the
						Optional is empty.
					</description>
					<location chapter="2" section="2.3.3.2" />
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion defined-by="technology" status="active" testable="true"
			impl-spec="true" required="true">
			<id>EL:SPEC:57</id>
			<description>Some operations takes functions (lambda expressions) as
				parameters. Again, we used the notion (arg1Type,
				...)-&gt;returnType
				to
				describe the argument types and the
				return type of a function.</description>
			<location chapter="2" section="2.3.4" />
			<sub-assertions>
				<assertion defined-by="technology" status="active" testable="true"
					impl-spec="true" required="true">
					<id>EL:SPEC:57.1</id>
					<description>predicate S -&gt; boolean
						This function takes the input
						argument, usually the element of the
						source stream, and determines
						if it
						satisfies some criteria</description>
					<location chapter="2" section="2.3.4.1" />
				</assertion>
				<assertion defined-by="technology" status="active" testable="true"
					impl-spec="true" required="true">
					<id>EL:SPEC:57.2</id>
					<description>booleanSupplier () -&gt; boolean
						This function takes
						noarguments, and returns a boolean
						value.</description>
					<location chapter="2" section="2.3.4.2" />
				</assertion>
				<assertion defined-by="technology" status="active" testable="true"
					impl-spec="true" required="true">
					<id>EL:SPEC:57.3</id>
					<description>mapper S -> R
						This function maps, or transforms the
						input
						argument, usually the
						element of the source stream, to the
						result.</description>
					<location chapter="2" section="2.3.4.3" />
				</assertion>
				<assertion defined-by="technology" status="active" testable="true"
					impl-spec="true" required="true">
					<id>EL:SPEC:57.4</id>
					<description>
						comparator
						(S, S) -&gt; int
						This function compares two
						arguments, usually the elements of the
						source stream, and returns a
						negative integer, zero, or a positive
						integer, if the first
						argument is
						respectively less than, equal
						to, or greater than the
						second argument.
					</description>
					<location chapter="2" section="2.3.4.4" />
				</assertion>
				<assertion defined-by="technology" status="active" testable="true"
					impl-spec="true" required="true">
					<id>EL:SPEC:57.5</id>
					<description>
						consumer S -&gt; void
						This function processes the input
						argument, usually the element of the
						source stream, and returns
						nothing.
					</description>
					<location chapter="2" section="2.3.4.5" />
				</assertion>
				<assertion defined-by="technology" status="active" testable="true"
					impl-spec="true" required="true">
					<id>EL:SPEC:57.6</id>
					<description>
						binaryOperator (S, S) -&gt; S
						This function applies a
						binary
						operation to the input
						arguments, and returns the result.
						The first argument
						is usually an internal
						accumulator, and the
						second argument is usually the
						element of the source stream. The
						arguments and the result are of the same
						type.
					</description>
					<location chapter="2" section="2.3.4.6" />
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion defined-by="technology" status="active" testable="true"
			impl-spec="true" required="true">
			<id>EL:SPEC:58</id>
			<description>
				The filter method
				produces a stream containing the source
				stream
				elements for which
				the predicate function return true. The
				argument
				of
				predicate
				function represents the element to test.
			</description>
			<location chapter="2" section="2.3.5" />
			<sub-assertions>
				<assertion defined-by="technology" status="active" testable="true"
					impl-spec="true" required="true">
					<id>EL:SPEC:58.1</id>
					<description>
						Stream&lt;S&gt; </description>
					<location chapter="2" section="2.3.5.1" />
				</assertion>
				<assertion defined-by="technology" status="active" testable="true"
					impl-spec="true" required="true">
					<id>EL:SPEC:58.2</id>
					<description>
						Stream&lt;S&gt;.filter((S-&gt;boolean) predicate)
					</description>
					<location chapter="2" section="2.3.5.1" />
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion defined-by="technology" status="active" testable="true"
			impl-spec="true" required="true">
			<id>EL:SPEC:59</id>
			<description>
				The map method produces a stream by applying the mapper
				function
				on the elements of the source stream. The argument of
				mapper function
				represents the element to process.
			</description>
			<location chapter="2" section="2.3.6" />
			<sub-assertions>
				<assertion defined-by="technology" status="active" testable="true"
					impl-spec="true" required="true">
					<id>EL:SPEC:59.1</id>
					<description>
						Stream&lt;R&gt; Stream&lt;S&gt;.map((S-&gt;R)mapper)
					</description>
					<location chapter="2" section="2.3.6.1" />
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion defined-by="technology" status="active" testable="true"
			impl-spec="true" required="true">
			<id>EL:SPEC:60</id>
			<description>
				The flatMap method produces a stream by mapping each of the
				source elements to another stream and then concatenating the mapped streams.
				If the mapper function does not return a Stream, the behavior is undefined.
				source elements to zero or more elements.
			</description>
			<location chapter="2" section="2.3.7" />
			<sub-assertions>
				<assertion defined-by="technology" status="active" testable="true"
					impl-spec="true" required="true">
					<id>EL:SPEC:60.1</id>
					<description>
						Stream&lt;R&gt;
						Stream&lt;S&gt;.flatMap((S-&gt;Stream&lt;R&gt;) mapper)
					</description>
					<location chapter="2" section="2.3.7.1" />
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion defined-by="technology" status="active" testable="true"
			impl-spec="true" required="true">
			<id>EL:SPEC:61</id>
			<description>
				The distinct method produces a stream containing the
				elements of
				the source stream that are distinct, according to
				Object.equals.
			</description>
			<location chapter="2" section="2.3.8" />
			<sub-assertions>
				<assertion defined-by="technology" status="active" testable="true"
					impl-spec="true" required="true">
					<id>EL:SPEC:61.1</id>
					<description>
						Stream&lt;S&gt; Stream&lt;S&gt;.distinct()
					</description>
					<location chapter="2" section="2.3.8.1" />
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion defined-by="technology" status="active" testable="true"
			impl-spec="true" required="true">
			<id>EL:SPEC:62</id>
			<description>
				The sorted method produces a stream containing the
				elements of
				the source
				stream in sorted order. If no comparator is
				specified, the elements
				are sorted in natural order, and a
				ELException is thrown if the
				elements do
				not implement
				java.lang.Comparable. If a comparator is
				specified, the elements
				are
				sorted with the provided comparator.
			</description>
			<location chapter="2" section="2.3.9" />
			<sub-assertions>
				<assertion defined-by="technology" status="active" testable="true"
					impl-spec="true" required="true">
					<id>EL:SPEC:62.1</id>
					<description>
						Stream&lt;S&gt; Stream&lt;S&gt;.sorted()
					</description>
					<location chapter="2" section="2.3.9.1" />
				</assertion>
				<assertion defined-by="technology" status="active" testable="true"
					impl-spec="true" required="true">
					<id>EL:SPEC:62.2</id>
					<description>
						Stream&lt;S&gt; Stream&lt;S&gt;.sorted((p,q)-&gt;int)
						comparator)
					</description>
					<location chapter="2" section="2.3.9.1" />
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion defined-by="technology" status="active" testable="false"
			impl-spec="true" required="true">
			<id>EL:SPEC:63</id>
			<description>
				The forEach method invokes the consumer function for each
				element in the source
				stream. This method always returns null.
			</description>
			<location chapter="2" section="2.3.10" />
			<sub-assertions>
				<assertion defined-by="technology" status="active" testable="true"
					impl-spec="true" required="true">
					<id>EL:SPEC:63.1</id>
					<description>
						Object stream&lt;S&gt;.forEach(((S)-&gt;void)consumer)
					</description>
					<location chapter="2" section="2.3.10.1" />
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion defined-by="technology" status="active" testable="false"
			impl-spec="true" required="true">
			<id>EL:SPEC:64</id>
			<description>
				The peek method produces a stream containing the elements of the
				source stream, and
				invokes the consumer function for each element in the
				stream.
			</description>
			<location chapter="2" section="2.3.11" />
			<sub-assertions>
				<assertion defined-by="technology" status="active" testable="true"
					impl-spec="true" required="true">
					<id>EL:SPEC:64.1</id>
					<description>
						Stream&lt;S&gt; Stream&lt;S&gt;.peek(((S)-&gt;void)consumer)
					</description>
					<location chapter="2" section="2.3.11.1" />
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion defined-by="technology" status="active" testable="false"
			impl-spec="true" required="true">
			<id>EL:SPEC:65</id>
			<description>
				The iterator method returns an iterator for the source stream, 
				suitable for use in Java codes.
			</description>
			<location chapter="2" section="2.3.11" />
			<sub-assertions>
				<assertion defined-by="technology" status="active" testable="true"
					impl-spec="true" required="true">
					<id>EL:SPEC:65.1</id>
					<description>
						Iterator&lt;S&gt; Stream&lt;S&gt;.iterator()
					</description>
					<location chapter="2" section="2.3.11.1" />
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion defined-by="technology" status="active" testable="false"
			impl-spec="true" required="true">
			<id>EL:SPEC:66</id>
			<description>
				The limit method produces a stream containing the first count
				number of elements of the source stream.
			</description>
			<location chapter="2" section="2.3.13" />
			<sub-assertions>
				<assertion defined-by="technology" status="active" testable="true"
					impl-spec="true" required="true">
					<id>EL:SPEC:66.1</id>
					<description>
						Stream&lt;S&gt; Stream&lt;S&gt;.limit(long count)
					</description>
					<location chapter="2" section="2.3.13.1" />
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion defined-by="technology" status="active" testable="false"
			impl-spec="true" required="true">
			<id>EL:SPEC:67</id>
			<description>
				The substream method produces a stream containing the source
				elements, skipping the first start elements, and including the rest of the
				elements in the stream if end is not specified, or the next (end - start)
				elements in the stream if end is specified.
			</description>
			<location chapter="2" section="2.3.14" />
			<sub-assertions>
				<assertion defined-by="technology" status="active" testable="true"
					impl-spec="true" required="true">
					<id>EL:SPEC:67.1</id>
					<description>
						Stream&lt;S&gt; Stream&lt;S&gt;.substream(long start)
					</description>
					<location chapter="2" section="2.3.14.1" />
				</assertion>
				<assertion defined-by="technology" status="active" testable="true"
					impl-spec="true" required="true">
					<id>EL:SPEC:67.2</id>
					<description>
						Stream&lt;S&gt; Stream&lt;S&gt;.substream(long start,
						long end)
					</description>
					<location chapter="2" section="2.3.14.1" />
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion defined-by="technology" status="active" testable="false"
			impl-spec="true" required="true">
			<id>EL:SPEC:68</id>
			<description>
				the toArray method returns an array containing the elements of
				the source stream.
			</description>
			<location chapter="2" section="2.3.15" />
			<sub-assertions>
				<assertion defined-by="technology" status="active" testable="true"
					impl-spec="true" required="true">
					<id>EL:SPEC:68.1</id>
					<description>
						S[] Stream&lt;S&gt;.toArray()
					</description>
					<location chapter="2" section="2.3.15.1" />
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion defined-by="technology" status="active" testable="false"
			impl-spec="true" required="true">
			<id>EL:SPEC:69</id>
			<description>
				The toList 
			</description>
			<location chapter="2" section="2.3.16" />
			<sub-assertions>
				<assertion defined-by="technology" status="active" testable="true"
					impl-spec="true" required="true">
					<id>EL:SPEC:69.1</id>
					<description>
						S[] Stream&lt;S&gt;.toList()
					</description>
					<location chapter="2" section="2.3.16.1" />
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion defined-by="technology" status="active" testable="false"
			impl-spec="true" required="true">
			<id>EL:SPEC:70</id>
			<description>
				The reduce method with a seed value starts by assigning the seed
				value to an internal accumulator. Then for each of the elements in the
				source stream, the next accumulator value is computed, by invoking the
				binaryOperator function, with the current accumulator value as the first
				argument and the current element as the second argument. The final
				accumulator value is returned
			</description>
			<location chapter="2" section="2.3.17" />
			<sub-assertions>
				<assertion defined-by="technology" status="active" testable="true"
					impl-spec="true" required="true">
					<id>EL:SPEC:70.1</id>
					<description>
						Optional&lt;S&gt; Stream&lt;S&gt;.reduce(((S,S)-&gt;S)
						binaryOperator)
					</description>
					<location chapter="2" section="2.3.17.1" />
				</assertion>
				<assertion defined-by="technology" status="active" testable="true"
					impl-spec="true" required="true">
					<id>EL:SPEC:70.2</id>
					<description>
						S Stream&lt;S&gt;.reduce(S seed, ((S,S)-&gt;S)
						binaryOperator))
					</description>
					<location chapter="2" section="2.3.17.1" />
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion defined-by="technology" status="active" testable="false"
			impl-spec="true" required="true">
			<id>EL:SPEC:71</id>
			<description>
				The max method computes the maximum of the elelments in the
				source stream. If the comparator function is specified, it is used for
				comparisons. If no comparator function is specified, the elements themselves
				are compared, and must implement Comparable, otherwise an ELException is
				thrown.
			</description>
			<location chapter="2" section="2.3.18" />
			<sub-assertions>
				<assertion defined-by="technology" status="active" testable="true"
					impl-spec="true" required="true">
					<id>EL:SPEC:71.1</id>
					<description>
						Optional Stream&lt;S&gt;.max()
					</description>
					<location chapter="2" section="2.3.18.1" />
				</assertion>
				<assertion defined-by="technology" status="active" testable="true"
					impl-spec="true" required="true">
					<id>EL:SPEC:71.2</id>
					<description>
						Optional Stream&lt;S&gt;.max(((p,q)-&gt;int) comparator)
					</description>
					<location chapter="2" section="2.3.18.1" />
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion defined-by="technology" status="active" testable="false"
			impl-spec="true" required="true">
			<id>EL:SPEC:72</id>
			<description>
				The min method computes the minimum of the elelments in the
				source stream. If the comparator function is specified, it is used for
				comparisons. If no comparator function is specified, the elements themselves
				are compared, and must implement Comparable, otherwise an ELException is
				thrown.
			</description>
			<location chapter="2" section="2.3.19" />
			<sub-assertions>
				<assertion defined-by="technology" status="active" testable="true"
					impl-spec="true" required="true">
					<id>EL:SPEC:72.1</id>
					<description>
						Optional Stream&lt;S&gt;.min()
					</description>
					<location chapter="2" section="2.3.19.1" />
				</assertion>
				<assertion defined-by="technology" status="active" testable="true"
					impl-spec="true" required="true">
					<id>EL:SPEC:72.2</id>
					<description>
						Optional Stream&lt;S&gt;.min(((p,q)-&gt;int) comparator)
					</description>
					<location chapter="2" section="2.3.19.1" />
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion defined-by="technology" status="active" testable="false"
			impl-spec="true" required="true">
			<id>EL:SPEC:73</id>
			<description>
				The average method computes the average of all elements in the
				source stream by first computes the sum of the elements and then divides the
				sum by the number of elements. The elements are coerced to Number types
				according to Section 1.23.3 during the computation.
				This method returns zero
				for an empty stream.
			</description>
			<location chapter="2" section="2.3.20" />
			<sub-assertions>
				<assertion defined-by="technology" status="active" testable="true"
					impl-spec="true" required="true">
					<id>EL:SPEC:73.1</id>
					<description>
						Optional Stream&lt;S&gt;.average()
					</description>
					<location chapter="2" section="2.3.20.1" />
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion defined-by="technology" status="active" testable="false"
			impl-spec="true" required="true">
			<id>EL:SPEC:74</id>
			<description>
				The sum method computes the sum of all elements in the source
				stream. The elements are coerced to Number types according to Section 1.23.3
				during the computation.
				This method returns zero for an empty stream.
			</description>
			<location chapter="2" section="2.3.21" />
			<sub-assertions>
				<assertion defined-by="technology" status="active" testable="true"
					impl-spec="true" required="true">
					<id>EL:SPEC:74.1</id>
					<description>
						Number Stream&lt;S&gt;.sum()
					</description>
					<location chapter="2" section="2.3.21.1" />
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion defined-by="technology" status="active" testable="false"
			impl-spec="true" required="true">
			<id>EL:SPEC:79</id>
			<description>
				This method returns the count of elements in the source stream.
			</description>
			<location chapter="2" section="2.3.22" />
			<sub-assertions>
				<assertion defined-by="technology" status="active" testable="true"
					impl-spec="true" required="true">
					<id>EL:SPEC:79.1</id>
					<description>
						Long Stream&lt;S&gt;.count()
					</description>
					<location chapter="2" section="2.3.22.1" />
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion defined-by="technology" status="active" testable="false"
			impl-spec="true" required="true">
			<id>EL:SPEC:75</id>
			<description>
				The anyMatch method returns an Optional of true if any element
				in the source stream satisfies the test given by the predicate. It returns
				an empty Optional if the stream is empty.
			</description>
			<location chapter="2" section="2.3.23" />
			<sub-assertions>
				<assertion defined-by="technology" status="active" testable="true"
					impl-spec="true" required="true">
					<id>EL:SPEC:75.1</id>
					<description>
						Optional&lt;boolean&gt;
						Stream&lt;S&gt;.anyMatch((S-&gt;boolean) predicate)
					</description>
					<location chapter="2" section="2.3.23.1" />
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion defined-by="technology" status="active" testable="false"
			impl-spec="true" required="true">
			<id>EL:SPEC:76</id>
			<description>
				The allMatch method returns an Optional of true if all elements
				in the source stream satisfy the test given by the predicate. It returns an
				empty Optional if the stream is empty.
			</description>
			<location chapter="2" section="2.3.24" />
			<sub-assertions>
				<assertion defined-by="technology" status="active" testable="true"
					impl-spec="true" required="true">
					<id>EL:SPEC:76.1</id>
					<description>
						Optional&lt;boolean&gt;
						Stream&lt;S&gt;.allMatch((S-&gt;boolean) predicate)
					</description>
					<location chapter="2" section="2.3.24.1" />
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion defined-by="technology" status="active" testable="false"
			impl-spec="true" required="true">
			<id>EL:SPEC:77</id>
			<description>
				The nonematch method returns an Optional of true if none of the
				elements in the source stream satisfies the test given by the predicate. It
				returns an empty Optional if the stream is empty.
			</description>
			<location chapter="2" section="2.3.25" />
			<sub-assertions>
				<assertion defined-by="technology" status="active" testable="true"
					impl-spec="true" required="true">
					<id>EL:SPEC:77.1</id>
					<description>
						Optional&lt;boolean&gt;
						Stream&lt;S&gt;.noneMatch((S-&gt;boolean) predicate)
					</description>
					<location chapter="2" section="2.3.25.1" />
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion defined-by="technology" status="active" testable="false"
			impl-spec="true" required="true">
			<id>EL:SPEC:78</id>
			<description>
				The findFirst method returns an Optional containing the first
				element in the stream, or an empty Optional if the stream is empty.
			</description>
			<location chapter="2" section="2.3.26" />
			<sub-assertions>
				<assertion defined-by="technology" status="active" testable="true"
					impl-spec="true" required="true">
					<id>EL:SPEC:78.1</id>
					<description>
						Optional&lt;S&gt; Stream&lt;S&gt;.findFirst()
					</description>
					<location chapter="2" section="2.3.26.1" />
				</assertion>
			</sub-assertions>
		</assertion>
	</assertions>
</spec>
