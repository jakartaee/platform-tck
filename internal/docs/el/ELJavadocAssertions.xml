<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE javadoc SYSTEM "https://raw.githubusercontent.com/eclipse-ee4j/jakartaee-tck/master/internal/docs/dtd/javadoc_assertions.dtd">
<!--

    Copyright (c) 2018, 2022 Oracle and/or its affiliates and others.
    All rights reserved.

    This program and the accompanying materials are made available under the
    terms of the Eclipse Public License v. 2.0, which is available at
    http://www.eclipse.org/legal/epl-2.0.

    This Source Code may also be made available under the following Secondary
    Licenses when the conditions for such availability set forth in the
    Eclipse Public License v. 2.0 are satisfied: GNU General Public License,
    version 2 with the GNU Classpath Exception, which is available at
    https://www.gnu.org/software/classpath/license.html.

    SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0

-->

<javadoc>
  <next-available-id>414</next-available-id>
  <previous-id>410</previous-id>
  <technology>EL</technology>
  <id>EL</id>
  <name>Expression Language</name>
  <version>5.0</version>
  <assertions>
    <!-- ********************************************************************************** -->
    <!-- ********************************************************************************** -->
    <!-- UNMODIFIED ASSERTIONS LISTED BELOW -->
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>1</id>
      <description>Creates a new read/write ArrayELResolver.</description>
      <package>jakarta.el</package>
      <class-interface>ArrayELResolver</class-interface>
      <method name="ArrayELResolver" return-type="ArrayELResolver" />
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>2</id>
      <description>Creates a new ArrayELResolver whose read-only status is determined by the given parameter.</description>
      <package>jakarta.el</package>
      <class-interface>ArrayELResolver</class-interface>
      <method name="ArrayELResolver" return-type="ArrayELResolver">
        <parameters>
          <parameter>boolean</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>3</id>
      <description>If the base object is a Java language array, returns the most general type that this resolver accepts for the property argument. Otherwise, returns null. Assuming the base is an array, this method will always return Integer.class. This is because arrays accept integers for their index.</description>
      <package>jakarta.el</package>
      <class-interface>ArrayELResolver</class-interface>
      <method name="getCommonPropertyType" return-type="java.lang.Class">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>4</id>
      <description>Always returns null, since there is no reason to iterate through set set of all integers. The #getCommonPropertyType method returns sufficient information about what properties this resolver accepts.</description>
      <package>jakarta.el</package>
      <class-interface>ArrayELResolver</class-interface>
      <method name="getFeatureDescriptors" return-type="java.util.Iterator">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>5</id>
      <description>If the base object is an array, returns the most general acceptable type for a value in this array. If the base is a array, the propertyResolved property of the ELContext object must be set to true by this resolver, before returning. If this property is not true after this method is called, the caller should ignore the return value. Assuming the base is an array, this method will always return base.getClass().getComponentType(), which is the most general type of component that can be stored at any given index in the array.</description>
      <package>jakarta.el</package>
      <class-interface>ArrayELResolver</class-interface>
      <method name="getType" return-type="java.lang.Class">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>6</id>
      <description>If the base object is a Java language array, returns the value at the given index. The index is specified by the property argument, and coerced into an integer. If the coercion could not be performed, an IllegalArgumentException is thrown. If the index is out of bounds, null is returned. If the base is a Java language array, the propertyResolved property of the ELContext object must be set to true by this resolver, before returning. If this property is not true after this method is called, the caller should ignore the return value.</description>
      <package>jakarta.el</package>
      <class-interface>ArrayELResolver</class-interface>
      <method name="getValue" return-type="java.lang.Object">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>7</id>
      <description>If the base object is a Java language array, returns whether a call to #setValue will always fail. If the base is a Java language array, the propertyResolved property of the ELContext object must be set to true by this resolver, before returning. If this property is not true after this method is called, the caller should ignore the return value. If this resolver was constructed in read-only mode, this method will always return true. Otherwise, it returns false.</description>
      <package>jakarta.el</package>
      <class-interface>ArrayELResolver</class-interface>
      <method name="isReadOnly" return-type="boolean">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>8</id>
      <description>If the base object is a Java language array, attempts to set the value at the given index with the given value. The index is specified by the property argument, and coerced into an integer. If the coercion could not be performed, an IllegalArgumentException is thrown. If the index is out of bounds, a PropertyNotFoundException is thrown. If the base is a Java language array, the propertyResolved property of the ELContext object must be set to true by this resolver, before returning. If this property is not true after this method is called, the caller can safely assume no value was set. If this resolver was constructed in read-only mode, this method will always throw PropertyNotWritableException.</description>
      <package>jakarta.el</package>
      <class-interface>ArrayELResolver</class-interface>
      <method name="setValue" return-type="void">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>9</id>
      <description>Creates a new read/write BeanELResolver.</description>
      <package>jakarta.el</package>
      <class-interface>BeanELResolver</class-interface>
      <method name="BeanELResolver" return-type="BeanELResolver" />
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>10</id>
      <description>Creates a new BeanELResolver whose read-only status is determined by the given parameter.</description>
      <package>jakarta.el</package>
      <class-interface>BeanELResolver</class-interface>
      <method name="BeanELResolver" return-type="BeanELResolver">
        <parameters>
          <parameter>boolean</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>11</id>
      <description>If the base object is not null, returns the most general type that this resolver accepts for the property argument. Otherwise, returns null. Assuming the base is not null, this method will always return Object.class. This is because any object is accepted as a key and is coerced into a string.</description>
      <package>jakarta.el</package>
      <class-interface>BeanELResolver</class-interface>
      <method name="getCommonPropertyType" return-type="java.lang.Class">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>12</id>
      <description>If the base object is not null, returns an Iterator containing the set of JavaBeans properties available on the given object. Otherwise, returns null. The Iterator returned must contain zero or more instances of java.beans.FeatureDescriptor. Each info object contains information about a property in the bean, as obtained by calling the BeanInfo.getPropertyDescriptors method. The FeatureDescriptor is initialized using the same fields as are present in the PropertyDescriptor, with the additional required named attributes "type" and "resolvableAtDesignTime" set as follows: ELResolver#TYPE - The runtime type of the property, from PropertyDescriptor.getPropertyType(). ELResolver#RESOLVABLE_AT_DESIGN_TIME - true.</description>
      <package>jakarta.el</package>
      <class-interface>BeanELResolver</class-interface>
      <method name="getFeatureDescriptors" return-type="java.util.Iterator">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>13</id>
      <description>If the base object is not null, returns the most general acceptable type that can be set on this bean property. If the base is not null, the propertyResolved property of the ELContext object must be set to true by this resolver, before returning. If this property is not true after this method is called, the caller should ignore the return value. The provided property will first be coerced to a String. If there is a BeanInfoProperty for this property and there were no errors retrieving it, the propertyType of the propertyDescriptor is returned. Otherwise, a PropertyNotFoundException is thrown.</description>
      <package>jakarta.el</package>
      <class-interface>BeanELResolver</class-interface>
      <method name="getType" return-type="java.lang.Class">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>14</id>
      <description>If the base object is not null, returns the current value of the given property on this bean. If the base is not null, the propertyResolved property of the ELContext object must be set to true by this resolver, before returning. If this property is not true after this method is called, the caller should ignore the return value. The provided property name will first be coerced to a String. If the property is a readable property of the base object, as per the JavaBeans specification, then return the result of the getter call. If the getter throws an exception, it is propagated to the caller. If the property is not found or is not readable, a PropertyNotFoundException is thrown.</description>
      <package>jakarta.el</package>
      <class-interface>BeanELResolver</class-interface>
      <method name="getValue" return-type="java.lang.Object">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>15</id>
      <description>If the base object is not null, returns whether a call to #setValue will always fail. If the base is not null, the propertyResolved property of the ELContext object must be set to true by this resolver, before returning. If this property is not true after this method is called, the caller can safely assume no value was set. If this resolver was constructed in read-only mode, this method will always return true. The provided property name will first be coerced to a String. If property is a writable property of base, false is returned. If the property is found but is not writable, true is returned. If the property is not found, a PropertyNotFoundException is thrown.</description>
      <package>jakarta.el</package>
      <class-interface>BeanELResolver</class-interface>
      <method name="isReadOnly" return-type="boolean">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>16</id>
      <description>If the base object is not null, attempts to set the value of the given property on this bean. If the base is not null, the propertyResolved property of the ELContext object must be set to true by this resolver, before returning. If this property is not true after this method is called, the caller can safely assume no value was set. If this resolver was constructed in read-only mode, this method will always throw PropertyNotWritableException. The provided property name will first be coerced to a String. If property is a writable property of base (as per the JavaBeans Specification), the setter method is called (passing value). If the property exists but does not have a setter, then a PropertyNotFoundException is thrown. If the property does not exist, a PropertyNotFoundException is thrown.</description>
      <package>jakarta.el</package>
      <class-interface>BeanELResolver</class-interface>
      <method name="setValue" return-type="void">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>24</id>
      <description>Adds the given resolver to the list of component resolvers. Resolvers are consulted in the order in which they are added.</description>
      <package>jakarta.el</package>
      <class-interface>CompositeELResolver</class-interface>
      <method name="add" return-type="void">
        <parameters>
          <parameter>jakarta.el.ELResolver</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>25</id>
      <description />
      <package>jakarta.el</package>
      <class-interface>CompositeELResolver</class-interface>
      <method name="CompositeELResolver" return-type="CompositeELResolver" />
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>26</id>
      <description>Returns the most general type that this resolver accepts for the property argument, given a base object. One use for this method is to assist tools in auto-completion. The result is obtained by querying all component resolvers. The Class returned is the most specific class that is a common superclass of all the classes returned by each component resolver's getCommonPropertyType method. If null is returned by a resolver, it is skipped.</description>
      <package>jakarta.el</package>
      <class-interface>CompositeELResolver</class-interface>
      <method name="getCommonPropertyType" return-type="java.lang.Class">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>27</id>
      <description>Returns information about the set of variables or properties that can be resolved for the given base object. One use for this method is to assist tools in auto-completion. The results are collected from all component resolvers. The propertyResolved property of the ELContext is not relevant to this method. The results of all ELResolvers are concatenated. The Iterator returned is an iterator over the collection of FeatureDescriptor objects returned by the iterators returned by each component resolver's getFeatureDescriptors method. If null is returned by a resolver, it is skipped.</description>
      <package>jakarta.el</package>
      <class-interface>CompositeELResolver</class-interface>
      <method name="getFeatureDescriptors" return-type="java.util.Iterator">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>28</id>
      <description>For a given base and property, attempts to identify the most general type that is acceptable for an object to be passed as the value parameter in a future call to the #setValue method. The result is obtained by querying all component resolvers. If this resolver handles the given (base, property) pair, the propertyResolved property of the ELContext object must be set to true by the resolver, before returning. If this property is not true after this method is called, the caller should ignore the return value. First, propertyResolved is set to false on the provided ELContext. Next, for each component resolver in this composite: The getType() method is called, passing in the provided context, base and property. If the ELContext's propertyResolved flag is false then iteration continues. Otherwise, iteration stops and no more component resolvers are considered. The value returned by getType() is returned by this method. If none of the component resolvers were able to perform this operation, the value null is returned and the propertyResolved flag remains set to false. Any exception thrown by component resolvers during the iteration is propagated to the caller of this method.</description>
      <package>jakarta.el</package>
      <class-interface>CompositeELResolver</class-interface>
      <method name="getType" return-type="java.lang.Class">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>29</id>
      <description>Attempts to resolve the given property object on the given base object by querying all component resolvers. If this resolver handles the given (base, property) pair, the propertyResolved property of the ELContext object must be set to true by the resolver, before returning. If this property is not true after this method is called, the caller should ignore the return value. First, propertyResolved is set to false on the provided ELContext. Next, for each component resolver in this composite: The getValue() method is called, passing in the provided context, base and property. If the ELContext's propertyResolved flag is false then iteration continues. Otherwise, iteration stops and no more component resolvers are considered. The value returned by getValue() is returned by this method. If none of the component resolvers were able to perform this operation, the value null is returned and the propertyResolved flag remains set to false. Any exception thrown by component resolvers during the iteration is propagated to the caller of this method.</description>
      <package>jakarta.el</package>
      <class-interface>CompositeELResolver</class-interface>
      <method name="getValue" return-type="java.lang.Object">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>30</id>
      <description>For a given base and property, attempts to determine whether a call to #setValue will always fail. The result is obtained by querying all component resolvers. If this resolver handles the given (base, property) pair, the propertyResolved property of the ELContext object must be set to true by the resolver, before returning. If this property is not true after this method is called, the caller should ignore the return value. First, propertyResolved is set to false on the provided ELContext. Next, for each component resolver in this composite: The isReadOnly() method is called, passing in the provided context, base and property. If the ELContext's propertyResolved flag is false then iteration continues. Otherwise, iteration stops and no more component resolvers are considered. The value returned by isReadOnly() is returned by this method. If none of the component resolvers were able to perform this operation, the value false is returned and the propertyResolved flag remains set to false. Any exception thrown by component resolvers during the iteration is propagated to the caller of this method.</description>
      <package>jakarta.el</package>
      <class-interface>CompositeELResolver</class-interface>
      <method name="isReadOnly" return-type="boolean">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>31</id>
      <description>Attempts to set the value of the given property object on the given base object. All component resolvers are asked to attempt to set the value. If this resolver handles the given (base, property) pair, the propertyResolved property of the ELContext object must be set to true by the resolver, before returning. If this property is not true after this method is called, the caller can safely assume no value has been set. First, propertyResolved is set to false on the provided ELContext. Next, for each component resolver in this composite: The setValue() method is called, passing in the provided context, base, property and value. If the ELContext's propertyResolved flag is false then iteration continues. Otherwise, iteration stops and no more component resolvers are considered. If none of the component resolvers were able to perform this operation, the propertyResolved flag remains set to false. Any exception thrown by component resolvers during the iteration is propagated to the caller of this method.</description>
      <package>jakarta.el</package>
      <class-interface>CompositeELResolver</class-interface>
      <method name="setValue" return-type="void">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="false">
      <id>32</id>
      <description />
      <package>jakarta.el</package>
      <class-interface>ELContext</class-interface>
      <method name="ELContext" return-type="ELContext" />
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>33</id>
      <description>Returns the context object associated with the given key. The ELContext maintains a collection of context objects relevant to the evaluation of an expression. These context objects are used by ELResolvers. This method is used to retrieve the context with the given key from the collection. By convention, the object returned will be of the type specified by the key. However, this is not required and the key is used strictly as a unique identifier.</description>
      <package>jakarta.el</package>
      <class-interface>ELContext</class-interface>
      <method name="getContext" return-type="java.lang.Object">
        <parameters>
          <parameter>java.lang.Class</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>34</id>
      <description>Retrieves the ELResolver associated with this context. The ELContext maintains a reference to the ELResolver that will be consulted to resolve variables and properties during an expression evaluation. This method retrieves the reference to the resolver. Once an ELContext is constructed, the reference to the ELResolver associated with the context cannot be changed.</description>
      <package>jakarta.el</package>
      <class-interface>ELContext</class-interface>
      <method name="getELResolver" return-type="jakarta.el.ELResolver" />
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>35</id>
      <description>Retrieves the FunctionMapper associated with this ELContext.</description>
      <package>jakarta.el</package>
      <class-interface>ELContext</class-interface>
      <method name="getFunctionMapper" return-type="jakarta.el.FunctionMapper" />
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>36</id>
      <description>Get the Locale stored by a previous invocation to #setLocale. If this method returns non null, this Locale must be used for all localization needs in the implementation. The Locale must not be cached to allow for applications that change Locale dynamically.</description>
      <package>jakarta.el</package>
      <class-interface>ELContext</class-interface>
      <method name="getLocale" return-type="java.util.Locale" />
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>37</id>
      <description>Retrieves the VariableMapper associated with this ELContext.</description>
      <package>jakarta.el</package>
      <class-interface>ELContext</class-interface>
      <method name="getVariableMapper" return-type="jakarta.el.VariableMapper" />
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>38</id>
      <description>Returns whether an ELResolver has successfully resolved a given (base, property) pair. The CompositeELResolver checks this property to determine whether it should consider or skip other component resolvers.</description>
      <package>jakarta.el</package>
      <class-interface>ELContext</class-interface>
      <method name="isPropertyResolved" return-type="boolean" />
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>39</id>
      <description>Associates a context object with this ELContext. The ELContext maintains a collection of context objects relevant to the evaluation of an expression. These context objects are used by ELResolvers. This method is used to add a context object to that collection. By convention, the contextObject will be of the type specified by the key. However, this is not required and the key is used strictly as a unique identifier.</description>
      <package>jakarta.el</package>
      <class-interface>ELContext</class-interface>
      <method name="putContext" return-type="void">
        <parameters>
          <parameter>java.lang.Class</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="false">
      <id>42</id>
      <description>Constructs an ELContextEvent object to indicate that an ELContext has been created.</description>
      <package>jakarta.el</package>
      <class-interface>ELContextEvent</class-interface>
      <method name="ELContextEvent" return-type="ELContextEvent">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="false">
      <id>43</id>
      <description>Returns the ELContext that was created. This is a type-safe equivalent of the #getSource method.</description>
      <package>jakarta.el</package>
      <class-interface>ELContextEvent</class-interface>
      <method name="getELContext" return-type="jakarta.el.ELContext" />
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="false">
      <id>44</id>
      <description>Invoked when a new ELContext has been created.</description>
      <package>jakarta.el</package>
      <class-interface>ELContextListener</class-interface>
      <method name="contextCreated" return-type="void">
        <parameters>
          <parameter>jakarta.el.ELContextEvent</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="false">
      <id>45</id>
      <description>Creates an ELException with no detail message.</description>
      <package>jakarta.el</package>
      <class-interface>ELException</class-interface>
      <method name="ELException" return-type="ELException" />
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="false">
      <id>46</id>
      <description>Creates an ELException with the provided detail message.</description>
      <package>jakarta.el</package>
      <class-interface>ELException</class-interface>
      <method name="ELException" return-type="ELException">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="false">
      <id>47</id>
      <description>Creates an ELException with the given cause.</description>
      <package>jakarta.el</package>
      <class-interface>ELException</class-interface>
      <method name="ELException" return-type="ELException">
        <parameters>
          <parameter>java.lang.Throwable</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="false">
      <id>48</id>
      <description>Creates an ELException with the given detail message and root cause.</description>
      <package>jakarta.el</package>
      <class-interface>ELException</class-interface>
      <method name="ELException" return-type="ELException">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.Throwable</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="false">
      <id>49</id>
      <description />
      <package>jakarta.el</package>
      <class-interface>ELResolver</class-interface>
      <method name="ELResolver" return-type="ELResolver" />
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>50</id>
      <description>Returns the most general type that this resolver accepts for the property argument, given a base object. One use for this method is to assist tools in auto-completion. This assists tools in auto-completion and also provides a way to express that the resolver accepts a primitive value, such as an integer index into an array. For example, the ArrayELResolver will accept any int as a property, so the return value would be Integer.class.</description>
      <package>jakarta.el</package>
      <class-interface>ELResolver</class-interface>
      <method name="getCommonPropertyType" return-type="java.lang.Class">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>51</id>
      <description>Returns information about the set of variables or properties that can be resolved for the given base object. One use for this method is to assist tools in auto-completion. If the base parameter is null, the resolver must enumerate the list of top-level variables it can resolve. The Iterator returned must contain zero or more instances of java.beans.FeatureDescriptor, in no guaranteed order. In the case of primitive types such as int, the value null must be returned. This is to prevent the useless iteration through all possible primitive values. A return value of null indicates that this resolver does not handle the given base object or that the results are too complex to represent with this method and the #getCommonPropertyType method should be used instead. Each FeatureDescriptor will contain information about a single variable or property. In addition to the standard properties, the FeatureDescriptor must have two named attributes (as set by the setValue method): #TYPE - The value of this named attribute must be an instance of java.lang.Class and specify the runtime type of the variable or property. #RESOLVABLE_AT_DESIGN_TIME - The value of this named attribute must be an instance of java.lang.Boolean and indicates whether it is safe to attempt to resolve this property at design-time. For instance, it may be unsafe to attempt a resolution at design time if the ELResolver needs access to a resource that is only available at runtime and no acceptable simulated value can be provided. The caller should be aware that the Iterator returned might iterate through a very large or even infinitely large set of properties. Care should be taken by the caller to not get stuck in an infinite loop. This is a "best-effort" list. Not all ELResolvers will return completely accurate results, but all must be callable at both design-time and runtime (i.e. whether or not Beans.isDesignTime() returns true), without causing errors. The propertyResolved property of the ELContext is not relevant to this method. The results of all ELResolvers are concatenated in the case of composite resolvers.</description>
      <package>jakarta.el</package>
      <class-interface>ELResolver</class-interface>
      <method name="getFeatureDescriptors" return-type="java.util.Iterator">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>52</id>
      <description>For a given base and property, attempts to identify the most general type that is acceptable for an object to be passed as the value parameter in a future call to the #setValue method. If this resolver handles the given (base, property) pair, the propertyResolved property of the ELContext object must be set to true by the resolver, before returning. If this property is not true after this method is called, the caller should ignore the return value. This is not always the same as getValue().getClass(). For example, in the case of an ArrayELResolver, the getType method will return the element type of the array, which might be a superclass of the type of the actual element that is currently in the specified array element.</description>
      <package>jakarta.el</package>
      <class-interface>ELResolver</class-interface>
      <method name="getType" return-type="java.lang.Class">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>53</id>
      <description>Attempts to resolve the given property object on the given base object. If this resolver handles the given (base, property) pair, the propertyResolved property of the ELContext object must be set to true by the resolver, before returning. If this property is not true after this method is called, the caller should ignore the return value.</description>
      <package>jakarta.el</package>
      <class-interface>ELResolver</class-interface>
      <method name="getValue" return-type="java.lang.Object">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>54</id>
      <description>For a given base and property, attempts to determine whether a call to #setValue will always fail. If this resolver handles the given (base, property) pair, the propertyResolved property of the ELContext object must be set to true by the resolver, before returning. If this property is not true after this method is called, the caller should ignore the return value.</description>
      <package>jakarta.el</package>
      <class-interface>ELResolver</class-interface>
      <method name="isReadOnly" return-type="boolean">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>55</id>
      <description>Attempts to set the value of the given property object on the given base object. If this resolver handles the given (base, property) pair, the propertyResolved property of the ELContext object must be set to true by the resolver, before returning. If this property is not true after this method is called, the caller can safely assume no value has been set.</description>
      <package>jakarta.el</package>
      <class-interface>ELResolver</class-interface>
      <method name="setValue" return-type="void">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>56</id>
      <description>Determines whether the specified object is equal to this Expression. The result is true if and only if the argument is not null, is an Expression object that is the of the same type (ValueExpression or MethodExpression), and has an identical parsed representation. Note that two expressions can be equal if their expression Strings are different. For example, ${fn1:foo()} and ${fn2:foo()} are equal if their corresponding FunctionMappers mapped fn1:foo and fn2:foo to the same method.</description>
      <package>jakarta.el</package>
      <class-interface>Expression</class-interface>
      <method name="equals" return-type="boolean">
        <parameters>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="false">
      <id>57</id>
      <description />
      <package>jakarta.el</package>
      <class-interface>Expression</class-interface>
      <method name="Expression" return-type="Expression" />
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>58</id>
      <description>Returns the original String used to create this Expression, unmodified. This is used for debugging purposes but also for the purposes of comparison (e.g. to ensure the expression in a configuration file has not changed). This method does not provide sufficient information to re-create an expression. Two different expressions can have exactly the same expression string but different function mappings. Serialization should be used to save and restore the state of an Expression.</description>
      <package>jakarta.el</package>
      <class-interface>Expression</class-interface>
      <method name="getExpressionString" return-type="java.lang.String" />
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>59</id>
      <description>Returns the hash code for this Expression. See the note in the #equals method on how two expressions can be equal if their expression Strings are different. Recall that if two objects are equal according to the equals(Object) method, then calling the hashCode method on each of the two objects must produce the same integer result. Implementations must take special note and implement hashCode correctly.</description>
      <package>jakarta.el</package>
      <class-interface>Expression</class-interface>
      <method name="hashCode" return-type="int" />
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>60</id>
      <description>Returns whether this expression was created from only literal text. This method must return true if and only if the expression string this expression was created from contained no unescaped EL delimeters (${...} or #{...}).</description>
      <package>jakarta.el</package>
      <class-interface>Expression</class-interface>
      <method name="isLiteralText" return-type="boolean" />
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>62</id>
      <description>Parses an expression into a MethodExpression for later evaluation. Use this method for expressions that refer to methods. If the expression is a String literal, a MethodExpression is created, which when invoked, returns the String literal, coerced to expectedReturnType. An ELException is thrown if expectedReturnType is void or if the coercion of the String literal to the expectedReturnType yields an error (see Section "1.16 Type Conversion"). This method should perform syntactic validation of the expression. If in doing so it detects errors, it should raise an ELException.</description>
      <package>jakarta.el</package>
      <class-interface>ExpressionFactory</class-interface>
      <method name="createMethodExpression" return-type="jakarta.el.MethodExpression">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.Class</parameter>
          <parameter>java.lang.Class[]</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>63</id>
      <description>Parses an expression into a ValueExpression for later evaluation. Use this method for expressions that refer to values. This method should perform syntactic validation of the expression. If in doing so it detects errors, it should raise an ELException.</description>
      <package>jakarta.el</package>
      <class-interface>ExpressionFactory</class-interface>
      <method name="createValueExpression" return-type="jakarta.el.ValueExpression">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.Class</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>64</id>
      <description>Creates a ValueExpression that wraps an object instance. This method can be used to pass any object as a ValueExpression. The wrapper ValueExpression is read only, and returns the wrapped object via its getValue() method, optionally coerced.</description>
      <package>jakarta.el</package>
      <class-interface>ExpressionFactory</class-interface>
      <method name="createValueExpression" return-type="jakarta.el.ValueExpression">
        <parameters>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Class</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="false">
      <id>65</id>
      <description />
      <package>jakarta.el</package>
      <class-interface>ExpressionFactory</class-interface>
      <method name="ExpressionFactory" return-type="ExpressionFactory" />
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="false">
      <id>66</id>
      <description />
      <package>jakarta.el</package>
      <class-interface>FunctionMapper</class-interface>
      <method name="FunctionMapper" return-type="FunctionMapper" />
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>67</id>
      <description>Resolves the specified prefix and local name into a java.lang.Method. Returns null if no function could be found that matches the given prefix and local name.</description>
      <package>jakarta.el</package>
      <class-interface>FunctionMapper</class-interface>
      <method name="resolveFunction" return-type="java.lang.reflect.Method">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>68</id>
      <description>If the base object is a list, returns the most general type that this resolver accepts for the property argument. Otherwise, returns null. Assuming the base is a List, this method will always return Integer.class. This is because Lists accept integers as their index.</description>
      <package>jakarta.el</package>
      <class-interface>ListELResolver</class-interface>
      <method name="getCommonPropertyType" return-type="java.lang.Class">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>69</id>
      <description>Always returns null, since there is no reason to iterate through set set of all integers. The #getCommonPropertyType method returns sufficient information about what properties this resolver accepts.</description>
      <package>jakarta.el</package>
      <class-interface>ListELResolver</class-interface>
      <method name="getFeatureDescriptors" return-type="java.util.Iterator">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>70</id>
      <description>If the base object is a list, returns the most general acceptable type for a value in this list. If the base is a List, the propertyResolved property of the ELContext object must be set to true by this resolver, before returning. If this property is not true after this method is called, the caller should ignore the return value. Assuming the base is a List, this method will always return Object.class. This is because Lists accept any object as an element.</description>
      <package>jakarta.el</package>
      <class-interface>ListELResolver</class-interface>
      <method name="getType" return-type="java.lang.Class">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>71</id>
      <description>If the base object is a list, returns the value at the given index. The index is specified by the property argument, and coerced into an integer. If the coercion could not be performed, an IllegalArgumentException is thrown. If the index is out of bounds, null is returned. If the base is a List, the propertyResolved property of the ELContext object must be set to true by this resolver, before returning. If this property is not true after this method is called, the caller should ignore the return value.</description>
      <package>jakarta.el</package>
      <class-interface>ListELResolver</class-interface>
      <method name="getValue" return-type="java.lang.Object">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>72</id>
      <description>If the base object is a list, returns whether a call to #setValue will always fail. If the base is a List, the propertyResolved property of the ELContext object must be set to true by this resolver, before returning. If this property is not true after this method is called, the caller should ignore the return value. If this resolver was constructed in read-only mode, this method will always return true. If a List was created using java.util.Collections#unmodifiableList, this method must return true. Unfortunately, there is no Collections API method to detect this. However, an implementation can create a prototype unmodifiable List and query its runtime type to see if it matches the runtime type of the base object as a workaround.</description>
      <package>jakarta.el</package>
      <class-interface>ListELResolver</class-interface>
      <method name="isReadOnly" return-type="boolean">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>73</id>
      <description>Creates a new read/write ListELResolver.</description>
      <package>jakarta.el</package>
      <class-interface>ListELResolver</class-interface>
      <method name="ListELResolver" return-type="ListELResolver" />
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>74</id>
      <description>Creates a new ListELResolver whose read-only status is determined by the given parameter.</description>
      <package>jakarta.el</package>
      <class-interface>ListELResolver</class-interface>
      <method name="ListELResolver" return-type="ListELResolver">
        <parameters>
          <parameter>boolean</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>75</id>
      <description>If the base object is a list, attempts to set the value at the given index with the given value. The index is specified by the property argument, and coerced into an integer. If the coercion could not be performed, an IllegalArgumentException is thrown. If the index is out of bounds, a PropertyNotFoundException is thrown. If the base is a List, the propertyResolved property of the ELContext object must be set to true by this resolver, before returning. If this property is not true after this method is called, the caller can safely assume no value was set. If this resolver was constructed in read-only mode, this method will always throw PropertyNotWritableException. If a List was created using java.util.Collections#unmodifiableList, this method must throw PropertyNotWritableException. Unfortunately, there is no Collections API method to detect this. However, an implementation can create a prototype unmodifiable List and query its runtime type to see if it matches the runtime type of the base object as a workaround.</description>
      <package>jakarta.el</package>
      <class-interface>ListELResolver</class-interface>
      <method name="setValue" return-type="void">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>76</id>
      <description>If the base object is a map, returns the most general type that this resolver accepts for the property argument. Otherwise, returns null. Assuming the base is a Map, this method will always return Object.class. This is because Maps accept any object as a key.</description>
      <package>jakarta.el</package>
      <class-interface>MapELResolver</class-interface>
      <method name="getCommonPropertyType" return-type="java.lang.Class">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>77</id>
      <description>If the base object is a map, returns an Iterator containing the set of keys available in the Map. Otherwise, returns null. The Iterator returned must contain zero or more instances of java.beans.FeatureDescriptor. Each info object contains information about a key in the Map, and is initialized as follows: displayName - The return value of calling the toString method on this key, or "null" if the key is null. name - Same as displayName property. shortDescription - Empty string expert - false hidden - false preferred - true In addition, the following named attributes must be set in the returned FeatureDescriptors: ELResolver#TYPE - The return value of calling the getClass() method on this key, or null if the key is null. ELResolver#RESOLVABLE_AT_DESIGN_TIME - true</description>
      <package>jakarta.el</package>
      <class-interface>MapELResolver</class-interface>
      <method name="getFeatureDescriptors" return-type="java.util.Iterator">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>78</id>
      <description>If the base object is a map, returns the most general acceptable type for a value in this map. If the base is a Map, the propertyResolved property of the ELContext object must be set to true by this resolver, before returning. If this property is not true after this method is called, the caller should ignore the return value. Assuming the base is a Map, this method will always return Object.class. This is because Maps accept any object as the value for a given key.</description>
      <package>jakarta.el</package>
      <class-interface>MapELResolver</class-interface>
      <method name="getType" return-type="java.lang.Class">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>79</id>
      <description>If the base object is a map, returns the value associated with the given key, as specified by the property argument. If the key was not found, null is returned. If the base is a Map, the propertyResolved property of the ELContext object must be set to true by this resolver, before returning. If this property is not true after this method is called, the caller should ignore the return value. Just as in java.util.Map#get, just because null is returned doesn't mean there is no mapping for the key; it's also possible that the Map explicitly maps the key to null.</description>
      <package>jakarta.el</package>
      <class-interface>MapELResolver</class-interface>
      <method name="getValue" return-type="java.lang.Object">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>80</id>
      <description>If the base object is a map, returns whether a call to #setValue will always fail. If the base is a Map, the propertyResolved property of the ELContext object must be set to true by this resolver, before returning. If this property is not true after this method is called, the caller should ignore the return value. If this resolver was constructed in read-only mode, this method will always return true. If a Map was created using java.util.Collections#unmodifiableMap, this method must return true. Unfortunately, there is no Collections API method to detect this. However, an implementation can create a prototype unmodifiable Map and query its runtime type to see if it matches the runtime type of the base object as a workaround.</description>
      <package>jakarta.el</package>
      <class-interface>MapELResolver</class-interface>
      <method name="isReadOnly" return-type="boolean">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>81</id>
      <description>Creates a new read/write MapELResolver.</description>
      <package>jakarta.el</package>
      <class-interface>MapELResolver</class-interface>
      <method name="MapELResolver" return-type="MapELResolver" />
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>82</id>
      <description>Creates a new MapELResolver whose read-only status is determined by the given parameter.</description>
      <package>jakarta.el</package>
      <class-interface>MapELResolver</class-interface>
      <method name="MapELResolver" return-type="MapELResolver">
        <parameters>
          <parameter>boolean</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>83</id>
      <description>If the base object is a map, attempts to set the value associated with the given key, as specified by the property argument. If the base is a Map, the propertyResolved property of the ELContext object must be set to true by this resolver, before returning. If this property is not true after this method is called, the caller can safely assume no value was set. If this resolver was constructed in read-only mode, this method will always throw PropertyNotWritableException. If a Map was created using java.util.Collections#unmodifiableMap, this method must throw PropertyNotWritableException. Unfortunately, there is no Collections API method to detect this. However, an implementation can create a prototype unmodifiable Map and query its runtime type to see if it matches the runtime type of the base object as a workaround.</description>
      <package>jakarta.el</package>
      <class-interface>MapELResolver</class-interface>
      <method name="setValue" return-type="void">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>84</id>
      <description>Evaluates the expression relative to the provided context, and returns information about the actual referenced method.</description>
      <package>jakarta.el</package>
      <class-interface>MethodExpression</class-interface>
      <method name="getMethodInfo" return-type="jakarta.el.MethodInfo">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="false">
      <id>86</id>
      <description />
      <package>jakarta.el</package>
      <class-interface>MethodExpression</class-interface>
      <method name="MethodExpression" return-type="MethodExpression" />
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>87</id>
      <description>Returns the name of the method</description>
      <package>jakarta.el</package>
      <class-interface>MethodInfo</class-interface>
      <method name="getName" return-type="java.lang.String" />
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>88</id>
      <description>Returns the parameter types of the method</description>
      <package>jakarta.el</package>
      <class-interface>MethodInfo</class-interface>
      <method name="getParamTypes" return-type="java.lang.Class[]" />
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>89</id>
      <description>Returns the return type of the method</description>
      <package>jakarta.el</package>
      <class-interface>MethodInfo</class-interface>
      <method name="getReturnType" return-type="java.lang.Class" />
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="false">
      <id>90</id>
      <description>Creates a new instance of MethodInfo with the given information.</description>
      <package>jakarta.el</package>
      <class-interface>MethodInfo</class-interface>
      <method name="MethodInfo" return-type="MethodInfo">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.Class</parameter>
          <parameter>java.lang.Class[]</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="false">
      <id>91</id>
      <description>Creates a MethodNotFoundException with no detail message.</description>
      <package>jakarta.el</package>
      <class-interface>MethodNotFoundException</class-interface>
      <method name="MethodNotFoundException" return-type="MethodNotFoundException" />
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="false">
      <id>92</id>
      <description>Creates a MethodNotFoundException with the provided detail message.</description>
      <package>jakarta.el</package>
      <class-interface>MethodNotFoundException</class-interface>
      <method name="MethodNotFoundException" return-type="MethodNotFoundException">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="false">
      <id>93</id>
      <description>Creates a MethodNotFoundException with the given root cause.</description>
      <package>jakarta.el</package>
      <class-interface>MethodNotFoundException</class-interface>
      <method name="MethodNotFoundException" return-type="MethodNotFoundException">
        <parameters>
          <parameter>java.lang.Throwable</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="false">
      <id>94</id>
      <description>Creates a MethodNotFoundException with the given detail message and root cause.</description>
      <package>jakarta.el</package>
      <class-interface>MethodNotFoundException</class-interface>
      <method name="MethodNotFoundException" return-type="MethodNotFoundException">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.Throwable</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="false">
      <id>95</id>
      <description>Creates a PropertyNotFoundException with no detail message.</description>
      <package>jakarta.el</package>
      <class-interface>PropertyNotFoundException</class-interface>
      <method name="PropertyNotFoundException" return-type="PropertyNotFoundException" />
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="false">
      <id>96</id>
      <description>Creates a PropertyNotFoundException with the provided detail message.</description>
      <package>jakarta.el</package>
      <class-interface>PropertyNotFoundException</class-interface>
      <method name="PropertyNotFoundException" return-type="PropertyNotFoundException">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="false">
      <id>97</id>
      <description>Creates a PropertyNotFoundException with the given root cause.</description>
      <package>jakarta.el</package>
      <class-interface>PropertyNotFoundException</class-interface>
      <method name="PropertyNotFoundException" return-type="PropertyNotFoundException">
        <parameters>
          <parameter>java.lang.Throwable</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="false">
      <id>98</id>
      <description>Creates a PropertyNotFoundException with the given detail message and root cause.</description>
      <package>jakarta.el</package>
      <class-interface>PropertyNotFoundException</class-interface>
      <method name="PropertyNotFoundException" return-type="PropertyNotFoundException">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.Throwable</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="false">
      <id>99</id>
      <description>Creates a PropertyNotWritableException with no detail message.</description>
      <package>jakarta.el</package>
      <class-interface>PropertyNotWritableException</class-interface>
      <method name="PropertyNotWritableException" return-type="PropertyNotWritableException" />
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="false">
      <id>100</id>
      <description>Creates a PropertyNotWritableException with the provided detail message.</description>
      <package>jakarta.el</package>
      <class-interface>PropertyNotWritableException</class-interface>
      <method name="PropertyNotWritableException" return-type="PropertyNotWritableException">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="false">
      <id>101</id>
      <description>Creates a PropertyNotWritableException with the given root cause.</description>
      <package>jakarta.el</package>
      <class-interface>PropertyNotWritableException</class-interface>
      <method name="PropertyNotWritableException" return-type="PropertyNotWritableException">
        <parameters>
          <parameter>java.lang.Throwable</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="false">
      <id>102</id>
      <description>Creates a PropertyNotWritableException with the given detail message and root cause.</description>
      <package>jakarta.el</package>
      <class-interface>PropertyNotWritableException</class-interface>
      <method name="PropertyNotWritableException" return-type="PropertyNotWritableException">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.Throwable</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>103</id>
      <description>If the base object is a ResourceBundle, returns the most general type that this resolver accepts for the property argument. Otherwise, returns null. Assuming the base is a ResourceBundle, this method will always return String.class.</description>
      <package>jakarta.el</package>
      <class-interface>ResourceBundleELResolver</class-interface>
      <method name="getCommonPropertyType" return-type="java.lang.Class">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>104</id>
      <description>If the base object is a ResourceBundle, returns an Iterator containing the set of keys available in the ResourceBundle. Otherwise, returns null. The Iterator returned must contain zero or more instances of java.beans.FeatureDescriptor. Each info object contains information about a key in the ResourceBundle, and is initialized as follows: displayName - The String key name - Same as displayName property. shortDescription - Empty string expert - false hidden - false preferred - true In addition, the following named attributes must be set in the returned FeatureDescriptors: ELResolver#TYPE - String.class ELResolver#RESOLVABLE_AT_DESIGN_TIME - true</description>
      <package>jakarta.el</package>
      <class-interface>ResourceBundleELResolver</class-interface>
      <method name="getFeatureDescriptors" return-type="java.util.Iterator">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>105</id>
      <description>If the base object is an instance of ResourceBundle, return null, since the resolver is read only. If the base is ResourceBundle, the propertyResolved property of the ELContext object must be set to true by this resolver, before returning. If this property is not true after this method is called, the caller should ignore the return value.</description>
      <package>jakarta.el</package>
      <class-interface>ResourceBundleELResolver</class-interface>
      <method name="getType" return-type="java.lang.Class">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>106</id>
      <description>If the base object is an instance of ResourceBundle, the provided property will first be coerced to a String. The Object returned by getObject on the base ResourceBundle will be returned. If the base is ResourceBundle, the propertyResolved property of the ELContext object must be set to true by this resolver, before returning. If this property is not true after this method is called, the caller should ignore the return value.</description>
      <package>jakarta.el</package>
      <class-interface>ResourceBundleELResolver</class-interface>
      <method name="getValue" return-type="java.lang.Object">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>107</id>
      <description>If the base object is not null and an instanceof ResourceBundle, return true.</description>
      <package>jakarta.el</package>
      <class-interface>ResourceBundleELResolver</class-interface>
      <method name="isReadOnly" return-type="boolean">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>108</id>
      <description />
      <package>jakarta.el</package>
      <class-interface>ResourceBundleELResolver</class-interface>
      <method name="ResourceBundleELResolver" return-type="ResourceBundleELResolver" />
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>109</id>
      <description>If the base object is a ResourceBundle, throw a PropertyNotWritableException.</description>
      <package>jakarta.el</package>
      <class-interface>ResourceBundleELResolver</class-interface>
      <method name="setValue" return-type="void">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>110</id>
      <description>Returns the type the result of the expression will be coerced to after evaluation.</description>
      <package>jakarta.el</package>
      <class-interface>ValueExpression</class-interface>
      <method name="getExpectedType" return-type="java.lang.Class" />
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>111</id>
      <description>Evaluates the expression relative to the provided context, and returns the most general type that is acceptable for an object to be passed as the value parameter in a future call to the #setValue method. This is not always the same as getValue().getClass(). For example, in the case of an expression that references an array element, the getType method will return the element type of the array, which might be a superclass of the type of the actual element that is currently in the specified array element.</description>
      <package>jakarta.el</package>
      <class-interface>ValueExpression</class-interface>
      <method name="getType" return-type="java.lang.Class">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>112</id>
      <description>Evaluates the expression relative to the provided context, and returns the resulting value. The resulting value is automatically coerced to the type returned by getExpectedType(), which was provided to the ExpressionFactory when this expression was created.</description>
      <package>jakarta.el</package>
      <class-interface>ValueExpression</class-interface>
      <method name="getValue" return-type="java.lang.Object">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>113</id>
      <description>Evaluates the expression relative to the provided context, and returns true if a call to #setValue will always fail.</description>
      <package>jakarta.el</package>
      <class-interface>ValueExpression</class-interface>
      <method name="isReadOnly" return-type="boolean">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>114</id>
      <description>Evaluates the expression relative to the provided context, and sets the result to the provided value.</description>
      <package>jakarta.el</package>
      <class-interface>ValueExpression</class-interface>
      <method name="setValue" return-type="void">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="false">
      <id>115</id>
      <description />
      <package>jakarta.el</package>
      <class-interface>ValueExpression</class-interface>
      <method name="ValueExpression" return-type="ValueExpression" />
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>116</id>
      <description />
      <package>jakarta.el</package>
      <class-interface>VariableMapper</class-interface>
      <method name="resolveVariable" return-type="jakarta.el.ValueExpression">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>117</id>
      <description>Assign a ValueExpression to an EL variable, replacing any previously assignment to the same variable. The assignment for the variable is removed if the expression is null.</description>
      <package>jakarta.el</package>
      <class-interface>VariableMapper</class-interface>
      <method name="setVariable" return-type="jakarta.el.ValueExpression">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>jakarta.el.ValueExpression</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="false">
      <id>118</id>
      <description />
      <package>jakarta.el</package>
      <class-interface>VariableMapper</class-interface>
      <method name="VariableMapper" return-type="VariableMapper" />
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>40</id>
      <description>Sets the Locale for this instance. This method may be called by the party creating the instance, such as JavaServer Faces or JSP, to enable the EL implementation to provide localized messages to the user. If no Locale is set, the implementation must use the locale returned by Locale.getDefault( ).</description>
      <package>jakarta.el</package>
      <class-interface>ELContext</class-interface>
      <method name="setLocale" return-type="void">
        <parameters>
          <parameter>java.util.Locale</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>85</id>
      <description>If a String literal is specified as the expression, returns the String literal coerced to the expected return type of the method signature. An ELException is thrown if expectedReturnType is void or if the coercion of the String literal to the expectedReturnType yields an error (see Section "1.18 Type Conversion" of the EL specification). If not a String literal, evaluates the expression relative to the provided context, invokes the method that was found using the supplied parameters, and returns the result of the method invocation. Any parameters passed to this method is ignored if isLiteralText() or isParmetersProvided() is true.</description>
      <package>jakarta.el</package>
      <class-interface>MethodExpression</class-interface>
      <method name="invoke" return-type="java.lang.Object">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object[]</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:121</id>
      <description>if the given index is out of bounds for this array.</description>
      <package>jakarta.el</package>
      <class-interface>ArrayELResolver</class-interface>
      <method name="getType" return-type="java.lang.Class">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.PropertyNotFoundException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:122</id>
      <description>if context is null</description>
      <package>jakarta.el</package>
      <class-interface>ArrayELResolver</class-interface>
      <method name="getType" return-type="java.lang.Class">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>java.lang.NullPointerException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="false">
      <id>EL:JAVADOC:123</id>
      <description>if an exception was thrown while performing the property or variable resolution. The thrown exception must be included as the cause property of this exception, if available.</description>
      <package>jakarta.el</package>
      <class-interface>ArrayELResolver</class-interface>
      <method name="getType" return-type="java.lang.Class">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.ELException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:124</id>
      <description>if the property could not be coerced into an integer.</description>
      <package>jakarta.el</package>
      <class-interface>ArrayELResolver</class-interface>
      <method name="getValue" return-type="java.lang.Object">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>java.lang.IllegalArgumentException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:125</id>
      <description>if context is null.</description>
      <package>jakarta.el</package>
      <class-interface>ArrayELResolver</class-interface>
      <method name="getValue" return-type="java.lang.Object">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>java.lang.NullPointerException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="false">
      <id>EL:JAVADOC:126</id>
      <description>if an exception was thrown while performing the property or variable resolution. The thrown exception must be included as the cause property of this exception, if available.</description>
      <package>jakarta.el</package>
      <class-interface>ArrayELResolver</class-interface>
      <method name="getValue" return-type="java.lang.Object">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.ELException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:127</id>
      <description>if the given index is out of bounds for this array.</description>
      <package>jakarta.el</package>
      <class-interface>ArrayELResolver</class-interface>
      <method name="isReadOnly" return-type="boolean">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.PropertyNotFoundException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:128</id>
      <description>if context is null</description>
      <package>jakarta.el</package>
      <class-interface>ArrayELResolver</class-interface>
      <method name="isReadOnly" return-type="boolean">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>java.lang.NullPointerException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="false">
      <id>EL:JAVADOC:129</id>
      <description>if an exception was thrown while performing the property or variable resolution. The thrown exception must be included as the cause property of this exception, if available.</description>
      <package>jakarta.el</package>
      <class-interface>ArrayELResolver</class-interface>
      <method name="isReadOnly" return-type="boolean">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.ELException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:130</id>
      <description>if the class of the specified element prevents it from being added to this array.</description>
      <package>jakarta.el</package>
      <class-interface>ArrayELResolver</class-interface>
      <method name="setValue" return-type="void">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>java.lang.ClassCastException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:131</id>
      <description>if context is null.</description>
      <package>jakarta.el</package>
      <class-interface>ArrayELResolver</class-interface>
      <method name="setValue" return-type="void">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>java.lang.NullPointerException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:132</id>
      <description>if the property could not be coerced into an integer, or if some aspect of the specified element prevents it from being added to this array.</description>
      <package>jakarta.el</package>
      <class-interface>ArrayELResolver</class-interface>
      <method name="setValue" return-type="void">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>java.lang.IllegalArgumentException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:133</id>
      <description>if this resolver was constructed in read-only mode.</description>
      <package>jakarta.el</package>
      <class-interface>ArrayELResolver</class-interface>
      <method name="setValue" return-type="void">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.PropertyNotWritableException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:134</id>
      <description>if the given index is out of bounds for this array.</description>
      <package>jakarta.el</package>
      <class-interface>ArrayELResolver</class-interface>
      <method name="setValue" return-type="void">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.PropertyNotFoundException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="false">
      <id>EL:JAVADOC:135</id>
      <description>if an exception was thrown while performing the property or variable resolution. The thrown exception must be included as the cause property of this exception, if available.</description>
      <package>jakarta.el</package>
      <class-interface>ArrayELResolver</class-interface>
      <method name="setValue" return-type="void">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.ELException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:136</id>
      <description>if context is null</description>
      <package>jakarta.el</package>
      <class-interface>BeanELResolver</class-interface>
      <method name="getType" return-type="java.lang.Class">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>java.lang.NullPointerException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:137</id>
      <description>if base is not null and the specified property does not exist or is not readable.</description>
      <package>jakarta.el</package>
      <class-interface>BeanELResolver</class-interface>
      <method name="getType" return-type="java.lang.Class">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.PropertyNotFoundException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="false">
      <id>EL:JAVADOC:138</id>
      <description>if an exception was thrown while performing the property or variable resolution. The thrown exception must be included as the cause property of this exception, if available.</description>
      <package>jakarta.el</package>
      <class-interface>BeanELResolver</class-interface>
      <method name="getType" return-type="java.lang.Class">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.ELException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:139</id>
      <description>if context is null.</description>
      <package>jakarta.el</package>
      <class-interface>BeanELResolver</class-interface>
      <method name="getValue" return-type="java.lang.Object">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>java.lang.NullPointerException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:140</id>
      <description>if base is not null and the specified property does not exist or is not readable.</description>
      <package>jakarta.el</package>
      <class-interface>BeanELResolver</class-interface>
      <method name="getValue" return-type="java.lang.Object">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.PropertyNotFoundException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="false">
      <id>EL:JAVADOC:141</id>
      <description>if an exception was thrown while performing the property or variable resolution. The thrown exception must be included as the cause property of this exception, if available.</description>
      <package>jakarta.el</package>
      <class-interface>BeanELResolver</class-interface>
      <method name="getValue" return-type="java.lang.Object">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.ELException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:142</id>
      <description>If the base object is not null, invoke the method, with the given parameters on this bean. The return value from the method is returned. If the base is not null, the propertyResolved property of the ELContext object must be set to true by this resolver, before returning. If this property is not true after this method is called, the caller should ignore the return value. The provided method object will first be coerced to a String. The methods in the bean is then examined and an attempt will be made to select one for invocation. If no suitable can be found, a MethodNotFoundException is thrown. If the given paramTypes is not null, select the method with the given name and parameter types. Else select the method with the given name that has the same number of parameters. If there are more than one such method, the method selection process is undefined. Else select the method with the given name that takes a variable number of arguments. Note the resolution for overloaded methods will likely be clarified in a future version of the spec. The provide parameters are coerced to the correcponding parameter types of the method, and the method is then invoked.</description>
      <package>jakarta.el</package>
      <class-interface>BeanELResolver</class-interface>
      <method name="invoke" return-type="java.lang.Object">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Class[]</parameter>
          <parameter>java.lang.Object[]</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:143</id>
      <description>if no suitable method can be found.</description>
      <package>jakarta.el</package>
      <class-interface>BeanELResolver</class-interface>
      <method name="invoke" return-type="java.lang.Object">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Class[]</parameter>
          <parameter>java.lang.Object[]</parameter>
        </parameters>
        <throw>jakarta.el.MethodNotFoundException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="false">
      <id>EL:JAVADOC:144</id>
      <description>if an exception was thrown while performing (base, method) resolution. The thrown exception must be included as the cause property of this exception, if available. If the exception thrown is an InvocationTargetException, extract its cause and pass it to the ELException constructor.</description>
      <package>jakarta.el</package>
      <class-interface>BeanELResolver</class-interface>
      <method name="invoke" return-type="java.lang.Object">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Class[]</parameter>
          <parameter>java.lang.Object[]</parameter>
        </parameters>
        <throw>jakarta.el.ELException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:145</id>
      <description>if context is null</description>
      <package>jakarta.el</package>
      <class-interface>BeanELResolver</class-interface>
      <method name="isReadOnly" return-type="boolean">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>java.lang.NullPointerException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:146</id>
      <description>if base is not null and the specified property does not exist.</description>
      <package>jakarta.el</package>
      <class-interface>BeanELResolver</class-interface>
      <method name="isReadOnly" return-type="boolean">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.PropertyNotFoundException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="false">
      <id>EL:JAVADOC:147</id>
      <description>if an exception was thrown while performing the property or variable resolution. The thrown exception must be included as the cause property of this exception, if available.</description>
      <package>jakarta.el</package>
      <class-interface>BeanELResolver</class-interface>
      <method name="isReadOnly" return-type="boolean">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.ELException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:148</id>
      <description>if context is null.</description>
      <package>jakarta.el</package>
      <class-interface>BeanELResolver</class-interface>
      <method name="setValue" return-type="void">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>java.lang.NullPointerException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:149</id>
      <description>if base is not null and the specified property does not exist.</description>
      <package>jakarta.el</package>
      <class-interface>BeanELResolver</class-interface>
      <method name="setValue" return-type="void">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.PropertyNotFoundException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:150</id>
      <description>if this resolver was constructed in read-only mode, or if there is no setter for the property.</description>
      <package>jakarta.el</package>
      <class-interface>BeanELResolver</class-interface>
      <method name="setValue" return-type="void">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.PropertyNotWritableException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="false">
      <id>EL:JAVADOC:151</id>
      <description>if an exception was thrown while performing the property or variable resolution. The thrown exception must be included as the cause property of this exception, if available.</description>
      <package>jakarta.el</package>
      <class-interface>BeanELResolver</class-interface>
      <method name="setValue" return-type="void">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.ELException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:152</id>
      <description>Constructor</description>
      <package>jakarta.el</package>
      <class-interface>BeanNameELResolver</class-interface>
      <method name="BeanNameELResolver" return-type="BeanNameELResolver">
        <parameters>
          <parameter>jakarta.el.BeanNameResolver</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:153</id>
      <description>Always returns String.class, since a bean name is a String.</description>
      <package>jakarta.el</package>
      <class-interface>BeanNameELResolver</class-interface>
      <method name="getCommonPropertyType" return-type="java.lang.Class">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:154</id>
      <description>Always returns null, since there is no reason to iterate through a list of one element: bean name.</description>
      <package>jakarta.el</package>
      <class-interface>BeanNameELResolver</class-interface>
      <method name="getFeatureDescriptors" return-type="java.util.Iterator">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:155</id>
      <description>If the base is null and the property is a name resolvable by the BeanNameResolver, return the type of the bean. If the name is resolvable by the BeanNameResolver, the propertyResolved property of the ELContext object must be set to true by the resolver, before returning. If this property is not true after this method is called, the caller can safely assume no value has been set.</description>
      <package>jakarta.el</package>
      <class-interface>BeanNameELResolver</class-interface>
      <method name="getType" return-type="java.lang.Class">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:156</id>
      <description>if context is null.</description>
      <package>jakarta.el</package>
      <class-interface>BeanNameELResolver</class-interface>
      <method name="getType" return-type="java.lang.Class">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>java.lang.NullPointerException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:157</id>
      <description>if an exception was thrown while performing the property or variable resolution. The thrown exception must be included as the cause property of this exception, if available.</description>
      <package>jakarta.el</package>
      <class-interface>BeanNameELResolver</class-interface>
      <method name="getType" return-type="java.lang.Class">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.ELException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:159</id>
      <description>if context is null.</description>
      <package>jakarta.el</package>
      <class-interface>BeanNameELResolver</class-interface>
      <method name="getValue" return-type="java.lang.Object">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>java.lang.NullPointerException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:160</id>
      <description>if an exception was thrown while performing the property or variable resolution. The thrown exception must be included as the cause property of this exception, if available.</description>
      <package>jakarta.el</package>
      <class-interface>BeanNameELResolver</class-interface>
      <method name="getValue" return-type="java.lang.Object">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.ELException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:161</id>
      <description>If the base is null and the property is a name resolvable by the BeanNameResolver, attempts to determine if the bean is writable. If the name is resolvable by the BeanNameResolver, the propertyResolved property of the ELContext object must be set to true by the resolver, before returning. If this property is not true after this method is called, the caller can safely assume no value has been set.</description>
      <package>jakarta.el</package>
      <class-interface>BeanNameELResolver</class-interface>
      <method name="isReadOnly" return-type="boolean">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:162</id>
      <description>if context is null.</description>
      <package>jakarta.el</package>
      <class-interface>BeanNameELResolver</class-interface>
      <method name="isReadOnly" return-type="boolean">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>java.lang.NullPointerException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:163</id>
      <description>if an exception was thrown while performing the property or variable resolution. The thrown exception must be included as the cause property of this exception, if available.</description>
      <package>jakarta.el</package>
      <class-interface>BeanNameELResolver</class-interface>
      <method name="isReadOnly" return-type="boolean">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.ELException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:164</id>
      <description>If the base is null and the property is a name that is resolvable by the BeanNameResolver, the bean in the BeanNameResolver is set to the given value. If the name is resolvable by the BeanNameResolver, or if the BeanNameResolver allows creating a new bean, the propertyResolved property of the ELContext object must be set to true by the resolver, before returning. If this property is not true after this method is called, the caller can safely assume no value has been set.</description>
      <package>jakarta.el</package>
      <class-interface>BeanNameELResolver</class-interface>
      <method name="setValue" return-type="void">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:165</id>
      <description>if context is null</description>
      <package>jakarta.el</package>
      <class-interface>BeanNameELResolver</class-interface>
      <method name="setValue" return-type="void">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>java.lang.NullPointerException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:166</id>
      <description>if the BeanNameResolver does not allow the bean to be modified.</description>
      <package>jakarta.el</package>
      <class-interface>BeanNameELResolver</class-interface>
      <method name="setValue" return-type="void">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.PropertyNotWritableException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:167</id>
      <description>if an exception was thrown while attempting to set the bean with the given name. The thrown exception must be included as the cause property of this exception, if available.</description>
      <package>jakarta.el</package>
      <class-interface>BeanNameELResolver</class-interface>
      <method name="setValue" return-type="void">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.ELException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:168</id>
      <description />
      <package>jakarta.el</package>
      <class-interface>BeanNameResolver</class-interface>
      <method name="BeanNameResolver" return-type="BeanNameResolver" />
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:169</id>
      <description>Allow creating a bean of the given name if it does not exist.</description>
      <package>jakarta.el</package>
      <class-interface>BeanNameResolver</class-interface>
      <method name="canCreateBean" return-type="boolean">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:170</id>
      <description>Returns the bean known by its name.</description>
      <package>jakarta.el</package>
      <class-interface>BeanNameResolver</class-interface>
      <method name="getBean" return-type="java.lang.Object">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:171</id>
      <description>Indicates if the bean of the given name is read-only or writable</description>
      <package>jakarta.el</package>
      <class-interface>BeanNameResolver</class-interface>
      <method name="isReadOnly" return-type="boolean">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:172</id>
      <description>Sets a value to a bean of the given name. If the bean of the given name does not exist and if #canCreateBean is true, one is created with the given value.</description>
      <package>jakarta.el</package>
      <class-interface>BeanNameResolver</class-interface>
      <method name="setBeanValue" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:173</id>
      <description>if the bean cannot be modified or created.</description>
      <package>jakarta.el</package>
      <class-interface>BeanNameResolver</class-interface>
      <method name="setBeanValue" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.PropertyNotWritableException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:174</id>
      <description>If the provided resolver is null.</description>
      <package>jakarta.el</package>
      <class-interface>CompositeELResolver</class-interface>
      <method name="add" return-type="void">
        <parameters>
          <parameter>jakarta.el.ELResolver</parameter>
        </parameters>
        <throw>java.lang.NullPointerException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:175</id>
      <description>if context is null</description>
      <package>jakarta.el</package>
      <class-interface>CompositeELResolver</class-interface>
      <method name="getType" return-type="java.lang.Class">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>java.lang.NullPointerException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:176</id>
      <description>if the given (base, property) pair is handled by this ELResolver but the specified variable or property does not exist or is not readable.</description>
      <package>jakarta.el</package>
      <class-interface>CompositeELResolver</class-interface>
      <method name="getType" return-type="java.lang.Class">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.PropertyNotFoundException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:177</id>
      <description>if an exception was thrown while performing the property or variable resolution. The thrown exception must be included as the cause property of this exception, if available.</description>
      <package>jakarta.el</package>
      <class-interface>CompositeELResolver</class-interface>
      <method name="getType" return-type="java.lang.Class">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.ELException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:178</id>
      <description>if context is null</description>
      <package>jakarta.el</package>
      <class-interface>CompositeELResolver</class-interface>
      <method name="getValue" return-type="java.lang.Object">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>java.lang.NullPointerException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:179</id>
      <description>if the given (base, property) pair is handled by this ELResolver but the specified variable or property does not exist or is not readable.</description>
      <package>jakarta.el</package>
      <class-interface>CompositeELResolver</class-interface>
      <method name="getValue" return-type="java.lang.Object">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.PropertyNotFoundException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:180</id>
      <description>if an exception was thrown while performing the property or variable resolution. The thrown exception must be included as the cause property of this exception, if available.</description>
      <package>jakarta.el</package>
      <class-interface>CompositeELResolver</class-interface>
      <method name="getValue" return-type="java.lang.Object">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.ELException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:181</id>
      <description>Attemps to resolve and invoke the given method on the given base object by querying all component resolvers. If this resolver handles the given (base, method) pair, the propertyResolved property of the ELContext object must be set to true by the resolver, before returning. If this property is not true after this method is called, the caller should ignore the return value. First, propertyResolved is set to false on the provided ELContext. Next, for each component resolver in this composite: The invoke() method is called, passing in the provided context, base, method, paramTypes, and params. If the ELContext's propertyResolved flag is false then iteration continues. Otherwise, iteration stops and no more component resolvers are considered. The value returned by getValue() is returned by this method. If none of the component resolvers were able to perform this operation, the value null is returned and the propertyResolved flag remains set to false. Any exception thrown by component resolvers during the iteration is propagated to the caller of this method.</description>
      <package>jakarta.el</package>
      <class-interface>CompositeELResolver</class-interface>
      <method name="invoke" return-type="java.lang.Object">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Class[]</parameter>
          <parameter>java.lang.Object[]</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:182</id>
      <description>if context is null</description>
      <package>jakarta.el</package>
      <class-interface>CompositeELResolver</class-interface>
      <method name="isReadOnly" return-type="boolean">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>java.lang.NullPointerException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:183</id>
      <description>if the given (base, property) pair is handled by this ELResolver but the specified variable or property does not exist.</description>
      <package>jakarta.el</package>
      <class-interface>CompositeELResolver</class-interface>
      <method name="isReadOnly" return-type="boolean">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.PropertyNotFoundException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:184</id>
      <description>if an exception was thrown while performing the property or variable resolution. The thrown exception must be included as the cause property of this exception, if available.</description>
      <package>jakarta.el</package>
      <class-interface>CompositeELResolver</class-interface>
      <method name="isReadOnly" return-type="boolean">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.ELException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:185</id>
      <description>if context is null</description>
      <package>jakarta.el</package>
      <class-interface>CompositeELResolver</class-interface>
      <method name="setValue" return-type="void">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>java.lang.NullPointerException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:186</id>
      <description>if the given (base, property) pair is handled by this ELResolver but the specified variable or property does not exist.</description>
      <package>jakarta.el</package>
      <class-interface>CompositeELResolver</class-interface>
      <method name="setValue" return-type="void">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.PropertyNotFoundException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:187</id>
      <description>if the given (base, property) pair is handled by this ELResolver but the specified variable or property is not writable.</description>
      <package>jakarta.el</package>
      <class-interface>CompositeELResolver</class-interface>
      <method name="setValue" return-type="void">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.PropertyNotWritableException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:188</id>
      <description>if an exception was thrown while attempting to set the property or variable. The thrown exception must be included as the cause property of this exception, if available.</description>
      <package>jakarta.el</package>
      <class-interface>CompositeELResolver</class-interface>
      <method name="setValue" return-type="void">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.ELException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:192</id>
      <description>Installs a Lambda argument map, in preparation for the evaluation of a Lambda expression. The arguments in the map will be in scope during the evaluation of the Lambda expression.</description>
      <package>jakarta.el</package>
      <class-interface>ELContext</class-interface>
      <method name="enterLambdaScope" return-type="void">
        <parameters>
          <parameter>java.util.Map</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:193</id>
      <description>Exits the Lambda expression evaluation. The Lambda argument map that was previously installed is removed.</description>
      <package>jakarta.el</package>
      <class-interface>ELContext</class-interface>
      <method name="exitLambdaScope" return-type="void" />
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:194</id>
      <description>if key is null.</description>
      <package>jakarta.el</package>
      <class-interface>ELContext</class-interface>
      <method name="getContext" return-type="java.lang.Object">
        <parameters>
          <parameter>java.lang.Class</parameter>
        </parameters>
        <throw>java.lang.NullPointerException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:195</id>
      <description>Retrieves the ImportHandler associated with this ELContext.</description>
      <package>jakarta.el</package>
      <class-interface>ELContext</class-interface>
      <method name="getImportHandler" return-type="jakarta.el.ImportHandler" />
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:196</id>
      <description>Retrieves the Lambda argument associated with a formal parameter. If the Lambda expression is nested within other Lambda expressions, the arguments for the current Lambda expression is first searched, and if not found, the arguments for the immediate nesting Lambda expression then searched, and so on.</description>
      <package>jakarta.el</package>
      <class-interface>ELContext</class-interface>
      <method name="getLambdaArgument" return-type="java.lang.Object">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:198</id>
      <description>if key is null or contextObject is null.</description>
      <package>jakarta.el</package>
      <class-interface>ELContext</class-interface>
      <method name="putContext" return-type="void">
        <parameters>
          <parameter>java.lang.Class</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>java.lang.NullPointerException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:200</id>
      <description>Add an user defined ELResolver to the list of ELResolvers. Can be called multiple times. The new ELResolver is placed ahead of the default ELResolvers. The list of the ELResolvers added this way are ordered chronologically.</description>
      <package>jakarta.el</package>
      <class-interface>ELManager</class-interface>
      <method name="addELResolver" return-type="void">
        <parameters>
          <parameter>jakarta.el.ELResolver</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:202</id>
      <description>Define a bean in the local bean repository</description>
      <package>jakarta.el</package>
      <class-interface>ELManager</class-interface>
      <method name="defineBean" return-type="java.lang.Object">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:203</id>
      <description />
      <package>jakarta.el</package>
      <class-interface>ELManager</class-interface>
      <method name="ELManager" return-type="ELManager" />
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:204</id>
      <description>Return the ELContext used for parsing and evaluating EL expressions. If there is currently no ELContext, a default instance of StandardELContext is returned.</description>
      <package>jakarta.el</package>
      <class-interface>ELManager</class-interface>
      <method name="getELContext" return-type="jakarta.el.StandardELContext" />
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:206</id>
      <description>Import a class. The imported class must be loadable from the classloader, at class resolution time.</description>
      <package>jakarta.el</package>
      <class-interface>ELManager</class-interface>
      <method name="importClass" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:207</id>
      <description>if the name is not a full class name.</description>
      <package>jakarta.el</package>
      <class-interface>ELManager</class-interface>
      <method name="importClass" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.el.ELException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:208</id>
      <description>Import a package. At the class resolution time, the imported package name will be used to construct the full class name, which will then be used to load the class. Inherently, this is less efficient than importing a class.</description>
      <package>jakarta.el</package>
      <class-interface>ELManager</class-interface>
      <method name="importPackage" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:209</id>
      <description>Maps a static method to an EL function.</description>
      <package>jakarta.el</package>
      <class-interface>ELManager</class-interface>
      <method name="mapFunction" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.reflect.Method</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:210</id>
      <description>Set the ELContext used for parsing and evaluating EL expressions. The supplied ELContext will not be modified, except for the context object map.</description>
      <package>jakarta.el</package>
      <class-interface>ELManager</class-interface>
      <method name="setELContext" return-type="jakarta.el.ELContext">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:211</id>
      <description>Assign a ValueExpression to an EL variable, replacing any previous assignment to the same variable. The assignment for the variable is removed if the expression is null.</description>
      <package>jakarta.el</package>
      <class-interface>ELManager</class-interface>
      <method name="setVariable" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>jakarta.el.ValueExpression</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:212</id>
      <description>Define a bean in a local bean repository, hiding other beans of the same name.</description>
      <package>jakarta.el</package>
      <class-interface>ELProcessor</class-interface>
      <method name="defineBean" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:213</id>
      <description>Define an EL function in the local function mapper.</description>
      <package>jakarta.el</package>
      <class-interface>ELProcessor</class-interface>
      <method name="defineFunction" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:215</id>
      <description>if the method (with or without the signature) is not a declared method of the class, or if the method signature is not valid.</description>
      <package>jakarta.el</package>
      <class-interface>ELProcessor</class-interface>
      <method name="defineFunction" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>java.lang.NoSuchMethodException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:218</id>
      <description>Define an EL function in the local function mapper.</description>
      <package>jakarta.el</package>
      <class-interface>ELProcessor</class-interface>
      <method name="defineFunction" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.reflect.Method</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:219</id>
      <description>if any of the arguements is null.</description>
      <package>jakarta.el</package>
      <class-interface>ELProcessor</class-interface>
      <method name="defineFunction" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.reflect.Method</parameter>
        </parameters>
        <throw>java.lang.NullPointerException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:220</id>
      <description />
      <package>jakarta.el</package>
      <class-interface>ELProcessor</class-interface>
      <method name="ELProcessor" return-type="ELProcessor" />
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:221</id>
      <description>Evaluates an EL expression.</description>
      <package>jakarta.el</package>
      <class-interface>ELProcessor</class-interface>
      <method name="eval" return-type="java.lang.Object">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:222</id>
      <description>Return the ELManager used for EL porcessing.</description>
      <package>jakarta.el</package>
      <class-interface>ELProcessor</class-interface>
      <method name="getELManager" return-type="jakarta.el.ELManager" />
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:223</id>
      <description>Evaluates an EL expression, and coerces the result to the specified type.</description>
      <package>jakarta.el</package>
      <class-interface>ELProcessor</class-interface>
      <method name="getValue" return-type="java.lang.Object">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.Class</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:224</id>
      <description>Sets an expression with a new value. The target expression is evaluated, up to the last property resolution, and the resultant (base, property) pair is set to the provided value.</description>
      <package>jakarta.el</package>
      <class-interface>ELProcessor</class-interface>
      <method name="setValue" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:225</id>
      <description>if one of the property resolutions failed because a specified variable or property does not exist or is not readable.</description>
      <package>jakarta.el</package>
      <class-interface>ELProcessor</class-interface>
      <method name="setValue" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.PropertyNotFoundException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:226</id>
      <description>if the final variable or property resolution failed because the specified variable or property is not writable.</description>
      <package>jakarta.el</package>
      <class-interface>ELProcessor</class-interface>
      <method name="setValue" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.PropertyNotWritableException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:227</id>
      <description>if an exception was thrown while attempting to set the property or variable. The thrown exception must be included as the cause property of this exception, if available.</description>
      <package>jakarta.el</package>
      <class-interface>ELProcessor</class-interface>
      <method name="setValue" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.ELException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:228</id>
      <description>Assign an EL expression to an EL variable. The expression is parsed, but not evaluated, and the parsed expression is mapped to the EL variable in the local variable map. Any previously assigned expression to the same variable will be replaced. If the expression is null, the variable will be removed.</description>
      <package>jakarta.el</package>
      <class-interface>ELProcessor</class-interface>
      <method name="setVariable" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:229</id>
      <description>Converts an object to a specific type. An ELException is thrown if an error occurs during the conversion.</description>
      <package>jakarta.el</package>
      <class-interface>ELResolver</class-interface>
      <method name="convertToType" return-type="java.lang.Object">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Class</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:230</id>
      <description>thrown if errors occur.</description>
      <package>jakarta.el</package>
      <class-interface>ELResolver</class-interface>
      <method name="convertToType" return-type="java.lang.Object">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Class</parameter>
        </parameters>
        <throw>jakarta.el.ELException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:231</id>
      <description>if the given (base, property) pair is handled by this ELResolver but the specified variable or property does not exist or is not readable.</description>
      <package>jakarta.el</package>
      <class-interface>ELResolver</class-interface>
      <method name="getType" return-type="java.lang.Class">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.PropertyNotFoundException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:232</id>
      <description>if an exception was thrown while performing the property or variable resolution. The thrown exception must be included as the cause property of this exception, if available.</description>
      <package>jakarta.el</package>
      <class-interface>ELResolver</class-interface>
      <method name="getType" return-type="java.lang.Class">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.ELException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:233</id>
      <description>if context is null</description>
      <package>jakarta.el</package>
      <class-interface>ELResolver</class-interface>
      <method name="getValue" return-type="java.lang.Object">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>java.lang.NullPointerException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:234</id>
      <description>if the given (base, property) pair is handled by this ELResolver but the specified variable or property does not exist or is not readable.</description>
      <package>jakarta.el</package>
      <class-interface>ELResolver</class-interface>
      <method name="getValue" return-type="java.lang.Object">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.PropertyNotFoundException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:235</id>
      <description>if an exception was thrown while performing the property or variable resolution. The thrown exception must be included as the cause property of this exception, if available.</description>
      <package>jakarta.el</package>
      <class-interface>ELResolver</class-interface>
      <method name="getValue" return-type="java.lang.Object">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.ELException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:236</id>
      <description>Attemps to resolve and invoke the given method on the given base object. If this resolver handles the given (base, method) pair, the propertyResolved property of the ELContext object must be set to true by the resolver, before returning. If this property is not true after this method is called, the caller should ignore the return value. A default implementation is provided that returns null so that existing classes that extend ELResolver can continue to function.</description>
      <package>jakarta.el</package>
      <class-interface>ELResolver</class-interface>
      <method name="invoke" return-type="java.lang.Object">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Class[]</parameter>
          <parameter>java.lang.Object[]</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:237</id>
      <description>if no suitable method can be found.</description>
      <package>jakarta.el</package>
      <class-interface>ELResolver</class-interface>
      <method name="invoke" return-type="java.lang.Object">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Class[]</parameter>
          <parameter>java.lang.Object[]</parameter>
        </parameters>
        <throw>jakarta.el.MethodNotFoundException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:238</id>
      <description>if an exception was thrown while performing (base, method) resolution. The thrown exception must be included as the cause property of this exception, if available. If the exception thrown is an InvocationTargetException, extract its cause and pass it to the ELException constructor.</description>
      <package>jakarta.el</package>
      <class-interface>ELResolver</class-interface>
      <method name="invoke" return-type="java.lang.Object">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Class[]</parameter>
          <parameter>java.lang.Object[]</parameter>
        </parameters>
        <throw>jakarta.el.ELException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:239</id>
      <description>if context is null</description>
      <package>jakarta.el</package>
      <class-interface>ELResolver</class-interface>
      <method name="isReadOnly" return-type="boolean">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>java.lang.NullPointerException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:240</id>
      <description>if the given (base, property) pair is handled by this ELResolver but the specified variable or property does not exist.</description>
      <package>jakarta.el</package>
      <class-interface>ELResolver</class-interface>
      <method name="isReadOnly" return-type="boolean">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.PropertyNotFoundException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:241</id>
      <description>if an exception was thrown while performing the property or variable resolution. The thrown exception must be included as the cause property of this exception, if available.</description>
      <package>jakarta.el</package>
      <class-interface>ELResolver</class-interface>
      <method name="isReadOnly" return-type="boolean">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.ELException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:242</id>
      <description>if context is null</description>
      <package>jakarta.el</package>
      <class-interface>ELResolver</class-interface>
      <method name="setValue" return-type="void">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>java.lang.NullPointerException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:243</id>
      <description>if the given (base, property) pair is handled by this ELResolver but the specified variable or property does not exist.</description>
      <package>jakarta.el</package>
      <class-interface>ELResolver</class-interface>
      <method name="setValue" return-type="void">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.PropertyNotFoundException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:244</id>
      <description>if the given (base, property) pair is handled by this ELResolver but the specified variable or property is not writable.</description>
      <package>jakarta.el</package>
      <class-interface>ELResolver</class-interface>
      <method name="setValue" return-type="void">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.PropertyNotWritableException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:245</id>
      <description>if an exception was thrown while attempting to set the property or variable. The thrown exception must be included as the cause property of this exception, if available.</description>
      <package>jakarta.el</package>
      <class-interface>ELResolver</class-interface>
      <method name="setValue" return-type="void">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.ELException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:251</id>
      <description>thrown if an error results from applying the conversion rules.</description>
      <package>jakarta.el</package>
      <class-interface>ExpressionFactory</class-interface>
      <method name="coerceToType" return-type="java.lang.Object">
        <parameters>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Class</parameter>
        </parameters>
        <throw>jakarta.el.ELException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:252</id>
      <description>Thrown if there are syntactical errors in the provided expression.</description>
      <package>jakarta.el</package>
      <class-interface>ExpressionFactory</class-interface>
      <method name="createMethodExpression" return-type="jakarta.el.MethodExpression">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.Class</parameter>
          <parameter>java.lang.Class[]</parameter>
        </parameters>
        <throw>jakarta.el.ELException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:253</id>
      <description>if paramTypes is null.</description>
      <package>jakarta.el</package>
      <class-interface>ExpressionFactory</class-interface>
      <method name="createMethodExpression" return-type="jakarta.el.MethodExpression">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.Class</parameter>
          <parameter>java.lang.Class[]</parameter>
        </parameters>
        <throw>java.lang.NullPointerException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:254</id>
      <description>Thrown if expectedType is null.</description>
      <package>jakarta.el</package>
      <class-interface>ExpressionFactory</class-interface>
      <method name="createValueExpression" return-type="jakarta.el.ValueExpression">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.Class</parameter>
        </parameters>
        <throw>java.lang.NullPointerException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:255</id>
      <description>Thrown if there are syntactical errors in the provided expression.</description>
      <package>jakarta.el</package>
      <class-interface>ExpressionFactory</class-interface>
      <method name="createValueExpression" return-type="jakarta.el.ValueExpression">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.Class</parameter>
        </parameters>
        <throw>jakarta.el.ELException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:256</id>
      <description>Thrown if expectedType is null.</description>
      <package>jakarta.el</package>
      <class-interface>ExpressionFactory</class-interface>
      <method name="createValueExpression" return-type="jakarta.el.ValueExpression">
        <parameters>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Class</parameter>
        </parameters>
        <throw>java.lang.NullPointerException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:258</id>
      <description>Creates a new instance of a ExpressionFactory. This method uses the following ordered lookup procedure to determine the ExpressionFactory implementation class to load: Use the Services API (as detailed in the JAR specification). If a resource with the name of META-INF/services/jakarta.el.ExpressionFactory exists, then its first line, if present, is used as the UTF-8 encoded name of the implementation class. Use the properties file "lib/el.properties" in the JRE directory. If this file exists and it is readable by the java.util.Properties.load(InputStream) method, and it contains an entry whose key is "jakarta.el.ExpressionFactory", then the value of that entry is used as the name of the implementation class. Use the jakarta.el.ExpressionFactory system property. If a system property with this name is defined, then its value is used as the name of the implementation class. Use a platform default implementation.</description>
      <package>jakarta.el</package>
      <class-interface>ExpressionFactory</class-interface>
      <method name="newInstance" return-type="jakarta.el.ExpressionFactory" />
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:259</id>
      <description>Create a new instance of a ExpressionFactory, with optional properties. This method uses the same lookup procedure as the one used in newInstance(). If the argument properties is not null, and if the implementation contains a constructor with a single parameter of type java.util.Properties, then the constructor is used to create the instance. Properties are optional and can be ignored by an implementation. The name of a property should start with "jakarta.el." The following are some suggested names for properties. jakarta.el.cacheSize</description>
      <package>jakarta.el</package>
      <class-interface>ExpressionFactory</class-interface>
      <method name="newInstance" return-type="jakarta.el.ExpressionFactory">
        <parameters>
          <parameter>java.util.Properties</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:260</id>
      <description>Adds a static method that can be used as a function.</description>
      <package>jakarta.el</package>
      <class-interface>FunctionMapper</class-interface>
      <method name="mapFunction" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.reflect.Method</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:262</id>
      <description>Import a class.</description>
      <package>jakarta.el</package>
      <class-interface>ImportHandler</class-interface>
      <method name="importClass" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:263</id>
      <description>if the name is not a full class name.</description>
      <package>jakarta.el</package>
      <class-interface>ImportHandler</class-interface>
      <method name="importClass" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.el.ELException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:264</id>
      <description />
      <package>jakarta.el</package>
      <class-interface>ImportHandler</class-interface>
      <method name="ImportHandler" return-type="ImportHandler" />
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:265</id>
      <description>Import all the classes in a package.</description>
      <package>jakarta.el</package>
      <class-interface>ImportHandler</class-interface>
      <method name="importPackage" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:266</id>
      <description>Resolve a class name from its imports.</description>
      <package>jakarta.el</package>
      <class-interface>ImportHandler</class-interface>
      <method name="resolve" return-type="java.lang.Class">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:273</id>
      <description>if not enough arguments are provided</description>
      <package>jakarta.el</package>
      <class-interface>LambdaExpression</class-interface>
      <method name="invoke" return-type="java.lang.Object">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object[]</parameter>
        </parameters>
        <throw>jakarta.el.ELException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:274</id>
      <description>Creates a new LambdaExpression.</description>
      <package>jakarta.el</package>
      <class-interface>LambdaExpression</class-interface>
      <method name="LambdaExpression" return-type="LambdaExpression">
        <parameters>
          <parameter>java.util.List</parameter>
          <parameter>jakarta.el.ValueExpression</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:275</id>
      <description>if the given index is out of bounds for this list.</description>
      <package>jakarta.el</package>
      <class-interface>ListELResolver</class-interface>
      <method name="getType" return-type="java.lang.Class">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.PropertyNotFoundException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:276</id>
      <description>if context is null</description>
      <package>jakarta.el</package>
      <class-interface>ListELResolver</class-interface>
      <method name="getType" return-type="java.lang.Class">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>java.lang.NullPointerException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:277</id>
      <description>if an exception was thrown while performing the property or variable resolution. The thrown exception must be included as the cause property of this exception, if available.</description>
      <package>jakarta.el</package>
      <class-interface>ListELResolver</class-interface>
      <method name="getType" return-type="java.lang.Class">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.ELException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:278</id>
      <description>if the property could not be coerced into an integer.</description>
      <package>jakarta.el</package>
      <class-interface>ListELResolver</class-interface>
      <method name="getValue" return-type="java.lang.Object">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>java.lang.IllegalArgumentException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:279</id>
      <description>if context is null.</description>
      <package>jakarta.el</package>
      <class-interface>ListELResolver</class-interface>
      <method name="getValue" return-type="java.lang.Object">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>java.lang.NullPointerException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:280</id>
      <description>if an exception was thrown while performing the property or variable resolution. The thrown exception must be included as the cause property of this exception, if available.</description>
      <package>jakarta.el</package>
      <class-interface>ListELResolver</class-interface>
      <method name="getValue" return-type="java.lang.Object">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.ELException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:281</id>
      <description>if the given index is out of bounds for this list.</description>
      <package>jakarta.el</package>
      <class-interface>ListELResolver</class-interface>
      <method name="isReadOnly" return-type="boolean">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.PropertyNotFoundException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:282</id>
      <description>if context is null</description>
      <package>jakarta.el</package>
      <class-interface>ListELResolver</class-interface>
      <method name="isReadOnly" return-type="boolean">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>java.lang.NullPointerException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:283</id>
      <description>if an exception was thrown while performing the property or variable resolution. The thrown exception must be included as the cause property of this exception, if available.</description>
      <package>jakarta.el</package>
      <class-interface>ListELResolver</class-interface>
      <method name="isReadOnly" return-type="boolean">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.ELException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:284</id>
      <description>if the class of the specified element prevents it from being added to this list.</description>
      <package>jakarta.el</package>
      <class-interface>ListELResolver</class-interface>
      <method name="setValue" return-type="void">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>java.lang.ClassCastException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:285</id>
      <description>if context is null, or if the value is null and this List does not support null elements.</description>
      <package>jakarta.el</package>
      <class-interface>ListELResolver</class-interface>
      <method name="setValue" return-type="void">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>java.lang.NullPointerException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:286</id>
      <description>if the property could not be coerced into an integer, or if some aspect of the specified element prevents it from being added to this list.</description>
      <package>jakarta.el</package>
      <class-interface>ListELResolver</class-interface>
      <method name="setValue" return-type="void">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>java.lang.IllegalArgumentException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:287</id>
      <description>if this resolver was constructed in read-only mode, or if the set operation is not supported by the underlying list.</description>
      <package>jakarta.el</package>
      <class-interface>ListELResolver</class-interface>
      <method name="setValue" return-type="void">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.PropertyNotWritableException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:288</id>
      <description>if the given index is out of bounds for this list.</description>
      <package>jakarta.el</package>
      <class-interface>ListELResolver</class-interface>
      <method name="setValue" return-type="void">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.PropertyNotFoundException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:289</id>
      <description>if an exception was thrown while performing the property or variable resolution. The thrown exception must be included as the cause property of this exception, if available.</description>
      <package>jakarta.el</package>
      <class-interface>ListELResolver</class-interface>
      <method name="setValue" return-type="void">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.ELException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:290</id>
      <description>if context is null</description>
      <package>jakarta.el</package>
      <class-interface>MapELResolver</class-interface>
      <method name="getType" return-type="java.lang.Class">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>java.lang.NullPointerException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:291</id>
      <description>if an exception was thrown while performing the property or variable resolution. The thrown exception must be included as the cause property of this exception, if available.</description>
      <package>jakarta.el</package>
      <class-interface>MapELResolver</class-interface>
      <method name="getType" return-type="java.lang.Class">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.ELException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:292</id>
      <description>if the key is of an inappropriate type for this map (optionally thrown by the underlying Map).</description>
      <package>jakarta.el</package>
      <class-interface>MapELResolver</class-interface>
      <method name="getValue" return-type="java.lang.Object">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>java.lang.ClassCastException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:293</id>
      <description>if context is null, or if the key is null and this map does not permit null keys (the latter is optionally thrown by the underlying Map).</description>
      <package>jakarta.el</package>
      <class-interface>MapELResolver</class-interface>
      <method name="getValue" return-type="java.lang.Object">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>java.lang.NullPointerException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:294</id>
      <description>if an exception was thrown while performing the property or variable resolution. The thrown exception must be included as the cause property of this exception, if available.</description>
      <package>jakarta.el</package>
      <class-interface>MapELResolver</class-interface>
      <method name="getValue" return-type="java.lang.Object">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.ELException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:295</id>
      <description>if context is null</description>
      <package>jakarta.el</package>
      <class-interface>MapELResolver</class-interface>
      <method name="isReadOnly" return-type="boolean">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>java.lang.NullPointerException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:296</id>
      <description>if an exception was thrown while performing the property or variable resolution. The thrown exception must be included as the cause property of this exception, if available.</description>
      <package>jakarta.el</package>
      <class-interface>MapELResolver</class-interface>
      <method name="isReadOnly" return-type="boolean">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.ELException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:297</id>
      <description>if the class of the specified key or value prevents it from being stored in this map.</description>
      <package>jakarta.el</package>
      <class-interface>MapELResolver</class-interface>
      <method name="setValue" return-type="void">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>java.lang.ClassCastException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:298</id>
      <description>if context is null, or if this map does not permit null keys or values, and the specified key or value is null.</description>
      <package>jakarta.el</package>
      <class-interface>MapELResolver</class-interface>
      <method name="setValue" return-type="void">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>java.lang.NullPointerException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:299</id>
      <description>if some aspect of this key or value prevents it from being stored in this map.</description>
      <package>jakarta.el</package>
      <class-interface>MapELResolver</class-interface>
      <method name="setValue" return-type="void">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>java.lang.IllegalArgumentException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:300</id>
      <description>if an exception was thrown while performing the property or variable resolution. The thrown exception must be included as the cause property of this exception, if available.</description>
      <package>jakarta.el</package>
      <class-interface>MapELResolver</class-interface>
      <method name="setValue" return-type="void">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.ELException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:301</id>
      <description>if this resolver was constructed in read-only mode, or if the put operation is not supported by the underlying map.</description>
      <package>jakarta.el</package>
      <class-interface>MapELResolver</class-interface>
      <method name="setValue" return-type="void">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.PropertyNotWritableException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:302</id>
      <description>if context is null</description>
      <package>jakarta.el</package>
      <class-interface>MethodExpression</class-interface>
      <method name="getMethodInfo" return-type="jakarta.el.MethodInfo">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
        </parameters>
        <throw>java.lang.NullPointerException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:303</id>
      <description>if one of the property resolutions failed because a specified variable or property does not exist or is not readable.</description>
      <package>jakarta.el</package>
      <class-interface>MethodExpression</class-interface>
      <method name="getMethodInfo" return-type="jakarta.el.MethodInfo">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
        </parameters>
        <throw>jakarta.el.PropertyNotFoundException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:304</id>
      <description>if no suitable method can be found.</description>
      <package>jakarta.el</package>
      <class-interface>MethodExpression</class-interface>
      <method name="getMethodInfo" return-type="jakarta.el.MethodInfo">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
        </parameters>
        <throw>jakarta.el.MethodNotFoundException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:305</id>
      <description>if an exception was thrown while performing property or variable resolution. The thrown exception must be included as the cause property of this exception, if available.</description>
      <package>jakarta.el</package>
      <class-interface>MethodExpression</class-interface>
      <method name="getMethodInfo" return-type="jakarta.el.MethodInfo">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
        </parameters>
        <throw>jakarta.el.ELException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:306</id>
      <description>if context is null</description>
      <package>jakarta.el</package>
      <class-interface>MethodExpression</class-interface>
      <method name="invoke" return-type="java.lang.Object">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object[]</parameter>
        </parameters>
        <throw>java.lang.NullPointerException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:307</id>
      <description>if one of the property resolutions failed because a specified variable or property does not exist or is not readable.</description>
      <package>jakarta.el</package>
      <class-interface>MethodExpression</class-interface>
      <method name="invoke" return-type="java.lang.Object">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object[]</parameter>
        </parameters>
        <throw>jakarta.el.PropertyNotFoundException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:308</id>
      <description>if no suitable method can be found.</description>
      <package>jakarta.el</package>
      <class-interface>MethodExpression</class-interface>
      <method name="invoke" return-type="java.lang.Object">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object[]</parameter>
        </parameters>
        <throw>jakarta.el.MethodNotFoundException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:309</id>
      <description>if a String literal is specified and expectedReturnType of the MethodExpression is void or if the coercion of the String literal to the expectedReturnType yields an error (see Section "1.18 Type Conversion").</description>
      <package>jakarta.el</package>
      <class-interface>MethodExpression</class-interface>
      <method name="invoke" return-type="java.lang.Object">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object[]</parameter>
        </parameters>
        <throw>jakarta.el.ELException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:310</id>
      <description>if an exception was thrown while performing property or variable resolution. The thrown exception must be included as the cause property of this exception, if available. If the exception thrown is an InvocationTargetException, extract its cause and pass it to the ELException constructor.</description>
      <package>jakarta.el</package>
      <class-interface>MethodExpression</class-interface>
      <method name="invoke" return-type="java.lang.Object">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object[]</parameter>
        </parameters>
        <throw>jakarta.el.ELException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:311</id>
      <description>Return whether this MethodExpression was created with parameters. This method must return true if and only if parameters are specified in the EL, using the expr-a.expr-b(...) syntax.</description>
      <package>jakarta.el</package>
      <class-interface>MethodExpression</class-interface>
      <method name="isParametersProvided" return-type="boolean" />
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:312</id>
      <description>Use isParametersProvided instead.</description>
      <package>jakarta.el</package>
      <class-interface>MethodExpression</class-interface>
      <method name="isParmetersProvided" return-type="boolean" />
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:313</id>
      <description>if context is null</description>
      <package>jakarta.el</package>
      <class-interface>ResourceBundleELResolver</class-interface>
      <method name="getType" return-type="java.lang.Class">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>java.lang.NullPointerException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:314</id>
      <description>if context is null</description>
      <package>jakarta.el</package>
      <class-interface>ResourceBundleELResolver</class-interface>
      <method name="getValue" return-type="java.lang.Object">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>java.lang.NullPointerException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:315</id>
      <description>if an exception was thrown while performing the property or variable resolution. The thrown exception must be included as the cause property of this exception, if available.</description>
      <package>jakarta.el</package>
      <class-interface>ResourceBundleELResolver</class-interface>
      <method name="getValue" return-type="java.lang.Object">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.ELException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:316</id>
      <description>if context is null</description>
      <package>jakarta.el</package>
      <class-interface>ResourceBundleELResolver</class-interface>
      <method name="isReadOnly" return-type="boolean">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>java.lang.NullPointerException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:317</id>
      <description>if context is null.</description>
      <package>jakarta.el</package>
      <class-interface>ResourceBundleELResolver</class-interface>
      <method name="setValue" return-type="void">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>java.lang.NullPointerException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:318</id>
      <description>Always thrown if base is an instance of ReasourceBundle.</description>
      <package>jakarta.el</package>
      <class-interface>ResourceBundleELResolver</class-interface>
      <method name="setValue" return-type="void">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.PropertyNotWritableException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:319</id>
      <description>Add a custom ELResolver to the context. The list of the custom ELResolvers will be accessed in the order they are added. A custom ELResolver added to the context cannot be removed.</description>
      <package>jakarta.el</package>
      <class-interface>StandardELContext</class-interface>
      <method name="addELResolver" return-type="void">
        <parameters>
          <parameter>jakarta.el.ELResolver</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:320</id>
      <description>Returns the context object associated with the given key. The ELContext maintains a collection of context objects relevant to the evaluation of an expression. These context objects are used by ELResolvers. This method is used to retrieve the context with the given key from the collection. By convention, the object returned will be of the type specified by the key. However, this is not required and the key is used strictly as a unique identifier.</description>
      <package>jakarta.el</package>
      <class-interface>StandardELContext</class-interface>
      <method name="getContext" return-type="java.lang.Object">
        <parameters>
          <parameter>java.lang.Class</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:321</id>
      <description>if key is null.</description>
      <package>jakarta.el</package>
      <class-interface>StandardELContext</class-interface>
      <method name="getContext" return-type="java.lang.Object">
        <parameters>
          <parameter>java.lang.Class</parameter>
        </parameters>
        <throw>java.lang.NullPointerException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:323</id>
      <description>Construct (if needed) and return a default FunctionMapper.</description>
      <package>jakarta.el</package>
      <class-interface>StandardELContext</class-interface>
      <method name="getFunctionMapper" return-type="jakarta.el.FunctionMapper" />
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:325</id>
      <description>Construct (if needed) and return a default VariableMapper() {</description>
      <package>jakarta.el</package>
      <class-interface>StandardELContext</class-interface>
      <method name="getVariableMapper" return-type="jakarta.el.VariableMapper" />
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:326</id>
      <description>Associates a context object with this ELContext. The ELContext maintains a collection of context objects relevant to the evaluation of an expression. These context objects are used by ELResolvers. This method is used to add a context object to that collection. By convention, the contextObject will be of the type specified by the key. However, this is not required and the key is used strictly as a unique identifier.</description>
      <package>jakarta.el</package>
      <class-interface>StandardELContext</class-interface>
      <method name="putContext" return-type="void">
        <parameters>
          <parameter>java.lang.Class</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:327</id>
      <description>if key is null or contextObject is null.</description>
      <package>jakarta.el</package>
      <class-interface>StandardELContext</class-interface>
      <method name="putContext" return-type="void">
        <parameters>
          <parameter>java.lang.Class</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>java.lang.NullPointerException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:329</id>
      <description>Construct a StandardELContext from another ELContext.</description>
      <package>jakarta.el</package>
      <class-interface>StandardELContext</class-interface>
      <method name="StandardELContext" return-type="StandardELContext">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:330</id>
      <description>Returns the type of the property. Always returns String.class, since a field name is a String.</description>
      <package>jakarta.el</package>
      <class-interface>StaticFieldELResolver</class-interface>
      <method name="getCommonPropertyType" return-type="java.lang.Class">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:331</id>
      <description>Returns the properties that can be resolved. Always returns null, since there is no reason to iterate through a list of one element: field name.</description>
      <package>jakarta.el</package>
      <class-interface>StaticFieldELResolver</class-interface>
      <method name="getFeatureDescriptors" return-type="java.util.Iterator">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:332</id>
      <description>Returns the type of a static field. If the base object is an instance of ELClassand the property is a String, the propertyResolved property of the ELContext object must be set to true by the resolver, before returning. If this property is not true after this method is called, the caller can safely assume no value has been set. If the property is the string "class", returns java.lang.Class.class. If the property string is a public static field of class specified in ELClass, return the type of the static field.</description>
      <package>jakarta.el</package>
      <class-interface>StaticFieldELResolver</class-interface>
      <method name="getType" return-type="java.lang.Class">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:333</id>
      <description>if context is null.</description>
      <package>jakarta.el</package>
      <class-interface>StaticFieldELResolver</class-interface>
      <method name="getType" return-type="java.lang.Class">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>java.lang.NullPointerException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:334</id>
      <description>if field is not a public static filed of the class, or if the field is inacessible.</description>
      <package>jakarta.el</package>
      <class-interface>StaticFieldELResolver</class-interface>
      <method name="getType" return-type="java.lang.Class">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.PropertyNotFoundException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:336</id>
      <description>if context is null.</description>
      <package>jakarta.el</package>
      <class-interface>StaticFieldELResolver</class-interface>
      <method name="getValue" return-type="java.lang.Object">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>java.lang.NullPointerException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:337</id>
      <description>if the specified class does not exist, or if the field is not a public static filed of the class, or if the field is inacessible.</description>
      <package>jakarta.el</package>
      <class-interface>StaticFieldELResolver</class-interface>
      <method name="getValue" return-type="java.lang.Object">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.PropertyNotFoundException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:339</id>
      <description>if no suitable method can be found.</description>
      <package>jakarta.el</package>
      <class-interface>StaticFieldELResolver</class-interface>
      <method name="invoke" return-type="java.lang.Object">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Class[]</parameter>
          <parameter>java.lang.Object[]</parameter>
        </parameters>
        <throw>jakarta.el.MethodNotFoundException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:340</id>
      <description>if an exception was thrown while performing (base, method) resolution. The thrown exception must be included as the cause property of this exception, if available. If the exception thrown is an InvocationTargetException, extract its cause and pass it to the ELException constructor.</description>
      <package>jakarta.el</package>
      <class-interface>StaticFieldELResolver</class-interface>
      <method name="invoke" return-type="java.lang.Object">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Class[]</parameter>
          <parameter>java.lang.Object[]</parameter>
        </parameters>
        <throw>jakarta.el.ELException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:341</id>
      <description>Inquires whether the static field is writable. If the base object is an instance of ELClassand the property is a String, the propertyResolved property of the ELContext object must be set to true by the resolver, before returning. If this property is not true after this method is called, the caller can safely assume no value has been set. Always returns a true because writing to a static field is not allowed.</description>
      <package>jakarta.el</package>
      <class-interface>StaticFieldELResolver</class-interface>
      <method name="isReadOnly" return-type="boolean">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:342</id>
      <description>if context is null.</description>
      <package>jakarta.el</package>
      <class-interface>StaticFieldELResolver</class-interface>
      <method name="isReadOnly" return-type="boolean">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>java.lang.NullPointerException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:343</id>
      <description>Attempts to write to a static field. If the base object is an instance of ELClassand the property is String, a PropertyNotWritableException will always be thrown, because writing to a static field is not allowed.</description>
      <package>jakarta.el</package>
      <class-interface>StaticFieldELResolver</class-interface>
      <method name="setValue" return-type="void">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:344</id>
      <description>if context is null</description>
      <package>jakarta.el</package>
      <class-interface>StaticFieldELResolver</class-interface>
      <method name="setValue" return-type="void">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>java.lang.NullPointerException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:345</id>
      <description />
      <package>jakarta.el</package>
      <class-interface>StaticFieldELResolver</class-interface>
      <method name="setValue" return-type="void">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.PropertyNotWritableException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:346</id>
      <description />
      <package>jakarta.el</package>
      <class-interface>StaticFieldELResolver</class-interface>
      <method name="StaticFieldELResolver" return-type="StaticFieldELResolver" />
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:347</id>
      <description>Converts an object to a specific type. An ELException is thrown if an error occurs during the conversion.</description>
      <package>jakarta.el</package>
      <class-interface>TypeConverter</class-interface>
      <method name="convertToType" return-type="java.lang.Object">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Class</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:348</id>
      <description>thrown if errors occur.</description>
      <package>jakarta.el</package>
      <class-interface>TypeConverter</class-interface>
      <method name="convertToType" return-type="java.lang.Object">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Class</parameter>
        </parameters>
        <throw>jakarta.el.ELException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:349</id>
      <description>Returns the most general type that this resolver accepts for the property argument, given a base object. One use for this method is to assist tools in auto-completion. This assists tools in auto-completion and also provides a way to express that the resolver accepts a primitive value, such as an integer index into an array. For example, the ArrayELResolver will accept any int as a property, so the return value would be Integer.class.</description>
      <package>jakarta.el</package>
      <class-interface>TypeConverter</class-interface>
      <method name="getCommonPropertyType" return-type="java.lang.Class">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:350</id>
      <description>Returns information about the set of variables or properties that can be resolved for the given base object. One use for this method is to assist tools in auto-completion. If the base parameter is null, the resolver must enumerate the list of top-level variables it can resolve. The Iterator returned must contain zero or more instances of java.beans.FeatureDescriptor, in no guaranteed order. In the case of primitive types such as int, the value null must be returned. This is to prevent the useless iteration through all possible primitive values. A return value of null indicates that this resolver does not handle the given base object or that the results are too complex to represent with this method and the #getCommonPropertyType method should be used instead. Each FeatureDescriptor will contain information about a single variable or property. In addition to the standard properties, the FeatureDescriptor must have two named attributes (as set by the setValue method): #TYPE - The value of this named attribute must be an instance of java.lang.Class and specify the runtime type of the variable or property. #RESOLVABLE_AT_DESIGN_TIME - The value of this named attribute must be an instance of java.lang.Boolean and indicates whether it is safe to attempt to resolve this property at design-time. For instance, it may be unsafe to attempt a resolution at design time if the ELResolver needs access to a resource that is only available at runtime and no acceptable simulated value can be provided. The caller should be aware that the Iterator returned might iterate through a very large or even infinitely large set of properties. Care should be taken by the caller to not get stuck in an infinite loop. This is a "best-effort" list. Not all ELResolvers will return completely accurate results, but all must be callable at both design-time and runtime (i.e. whether or not Beans.isDesignTime() returns true), without causing errors. The propertyResolved property of the ELContext is not relevant to this method. The results of all ELResolvers are concatenated in the case of composite resolvers.</description>
      <package>jakarta.el</package>
      <class-interface>TypeConverter</class-interface>
      <method name="getFeatureDescriptors" return-type="java.util.Iterator">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:351</id>
      <description>For a given base and property, attempts to identify the most general type that is acceptable for an object to be passed as the value parameter in a future call to the #setValue method. If this resolver handles the given (base, property) pair, the propertyResolved property of the ELContext object must be set to true by the resolver, before returning. If this property is not true after this method is called, the caller should ignore the return value. This is not always the same as getValue().getClass(). For example, in the case of an ArrayELResolver, the getType method will return the element type of the array, which might be a superclass of the type of the actual element that is currently in the specified array element.</description>
      <package>jakarta.el</package>
      <class-interface>TypeConverter</class-interface>
      <method name="getType" return-type="java.lang.Class">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:352</id>
      <description>if the given (base, property) pair is handled by this ELResolver but the specified variable or property does not exist or is not readable.</description>
      <package>jakarta.el</package>
      <class-interface>TypeConverter</class-interface>
      <method name="getType" return-type="java.lang.Class">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.PropertyNotFoundException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:353</id>
      <description>if an exception was thrown while performing the property or variable resolution. The thrown exception must be included as the cause property of this exception, if available.</description>
      <package>jakarta.el</package>
      <class-interface>TypeConverter</class-interface>
      <method name="getType" return-type="java.lang.Class">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.ELException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:354</id>
      <description>Attempts to resolve the given property object on the given base object. If this resolver handles the given (base, property) pair, the propertyResolved property of the ELContext object must be set to true by the resolver, before returning. If this property is not true after this method is called, the caller should ignore the return value.</description>
      <package>jakarta.el</package>
      <class-interface>TypeConverter</class-interface>
      <method name="getValue" return-type="java.lang.Object">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:355</id>
      <description>if context is null</description>
      <package>jakarta.el</package>
      <class-interface>TypeConverter</class-interface>
      <method name="getValue" return-type="java.lang.Object">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>java.lang.NullPointerException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:356</id>
      <description>if the given (base, property) pair is handled by this ELResolver but the specified variable or property does not exist or is not readable.</description>
      <package>jakarta.el</package>
      <class-interface>TypeConverter</class-interface>
      <method name="getValue" return-type="java.lang.Object">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.PropertyNotFoundException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:357</id>
      <description>if an exception was thrown while performing the property or variable resolution. The thrown exception must be included as the cause property of this exception, if available.</description>
      <package>jakarta.el</package>
      <class-interface>TypeConverter</class-interface>
      <method name="getValue" return-type="java.lang.Object">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.ELException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:358</id>
      <description>For a given base and property, attempts to determine whether a call to #setValue will always fail. If this resolver handles the given (base, property) pair, the propertyResolved property of the ELContext object must be set to true by the resolver, before returning. If this property is not true after this method is called, the caller should ignore the return value.</description>
      <package>jakarta.el</package>
      <class-interface>TypeConverter</class-interface>
      <method name="isReadOnly" return-type="boolean">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:359</id>
      <description>if context is null</description>
      <package>jakarta.el</package>
      <class-interface>TypeConverter</class-interface>
      <method name="isReadOnly" return-type="boolean">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>java.lang.NullPointerException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:360</id>
      <description>if the given (base, property) pair is handled by this ELResolver but the specified variable or property does not exist.</description>
      <package>jakarta.el</package>
      <class-interface>TypeConverter</class-interface>
      <method name="isReadOnly" return-type="boolean">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.PropertyNotFoundException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:361</id>
      <description>if an exception was thrown while performing the property or variable resolution. The thrown exception must be included as the cause property of this exception, if available.</description>
      <package>jakarta.el</package>
      <class-interface>TypeConverter</class-interface>
      <method name="isReadOnly" return-type="boolean">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.ELException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:362</id>
      <description>Attempts to set the value of the given property object on the given base object. If this resolver handles the given (base, property) pair, the propertyResolved property of the ELContext object must be set to true by the resolver, before returning. If this property is not true after this method is called, the caller can safely assume no value has been set.</description>
      <package>jakarta.el</package>
      <class-interface>TypeConverter</class-interface>
      <method name="setValue" return-type="void">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:363</id>
      <description>if context is null</description>
      <package>jakarta.el</package>
      <class-interface>TypeConverter</class-interface>
      <method name="setValue" return-type="void">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>java.lang.NullPointerException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:364</id>
      <description>if the given (base, property) pair is handled by this ELResolver but the specified variable or property does not exist.</description>
      <package>jakarta.el</package>
      <class-interface>TypeConverter</class-interface>
      <method name="setValue" return-type="void">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.PropertyNotFoundException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:365</id>
      <description>if the given (base, property) pair is handled by this ELResolver but the specified variable or property is not writable.</description>
      <package>jakarta.el</package>
      <class-interface>TypeConverter</class-interface>
      <method name="setValue" return-type="void">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.PropertyNotWritableException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:366</id>
      <description>if an exception was thrown while attempting to set the property or variable. The thrown exception must be included as the cause property of this exception, if available.</description>
      <package>jakarta.el</package>
      <class-interface>TypeConverter</class-interface>
      <method name="setValue" return-type="void">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.ELException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:367</id>
      <description />
      <package>jakarta.el</package>
      <class-interface>TypeConverter</class-interface>
      <method name="TypeConverter" return-type="TypeConverter" />
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:368</id>
      <description>if context is null.</description>
      <package>jakarta.el</package>
      <class-interface>ValueExpression</class-interface>
      <method name="getType" return-type="java.lang.Class">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
        </parameters>
        <throw>java.lang.NullPointerException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:369</id>
      <description>if one of the property resolutions failed because a specified variable or property does not exist or is not readable.</description>
      <package>jakarta.el</package>
      <class-interface>ValueExpression</class-interface>
      <method name="getType" return-type="java.lang.Class">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
        </parameters>
        <throw>jakarta.el.PropertyNotFoundException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:370</id>
      <description>if an exception was thrown while performing property or variable resolution. The thrown exception must be included as the cause property of this exception, if available.</description>
      <package>jakarta.el</package>
      <class-interface>ValueExpression</class-interface>
      <method name="getType" return-type="java.lang.Class">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
        </parameters>
        <throw>jakarta.el.ELException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:371</id>
      <description>if context is null.</description>
      <package>jakarta.el</package>
      <class-interface>ValueExpression</class-interface>
      <method name="getValue" return-type="java.lang.Object">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
        </parameters>
        <throw>java.lang.NullPointerException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:372</id>
      <description>if one of the property resolutions failed because a specified variable or property does not exist or is not readable.</description>
      <package>jakarta.el</package>
      <class-interface>ValueExpression</class-interface>
      <method name="getValue" return-type="java.lang.Object">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
        </parameters>
        <throw>jakarta.el.PropertyNotFoundException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:373</id>
      <description>if an exception was thrown while performing property or variable resolution. The thrown exception must be included as the cause property of this exception, if available.</description>
      <package>jakarta.el</package>
      <class-interface>ValueExpression</class-interface>
      <method name="getValue" return-type="java.lang.Object">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
        </parameters>
        <throw>jakarta.el.ELException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:374</id>
      <description>Returns a ValueReference for this expression instance.</description>
      <package>jakarta.el</package>
      <class-interface>ValueExpression</class-interface>
      <method name="getValueReference" return-type="jakarta.el.ValueReference">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:375</id>
      <description>if context is null.</description>
      <package>jakarta.el</package>
      <class-interface>ValueExpression</class-interface>
      <method name="isReadOnly" return-type="boolean">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
        </parameters>
        <throw>java.lang.NullPointerException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:376</id>
      <description>if one of the property resolutions failed because a specified variable or property does not exist or is not readable.</description>
      <package>jakarta.el</package>
      <class-interface>ValueExpression</class-interface>
      <method name="isReadOnly" return-type="boolean">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
        </parameters>
        <throw>jakarta.el.PropertyNotFoundException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:377</id>
      <description>if an exception was thrown while performing property or variable resolution. The thrown exception must be included as the cause property of this exception, if available. * @throws NullPointerException if context is null</description>
      <package>jakarta.el</package>
      <class-interface>ValueExpression</class-interface>
      <method name="isReadOnly" return-type="boolean">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
        </parameters>
        <throw>jakarta.el.ELException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:378</id>
      <description>if context is null.</description>
      <package>jakarta.el</package>
      <class-interface>ValueExpression</class-interface>
      <method name="setValue" return-type="void">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>java.lang.NullPointerException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:379</id>
      <description>if one of the property resolutions failed because a specified variable or property does not exist or is not readable.</description>
      <package>jakarta.el</package>
      <class-interface>ValueExpression</class-interface>
      <method name="setValue" return-type="void">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.PropertyNotFoundException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:380</id>
      <description>if the final variable or property resolution failed because the specified variable or property is not writable.</description>
      <package>jakarta.el</package>
      <class-interface>ValueExpression</class-interface>
      <method name="setValue" return-type="void">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.PropertyNotWritableException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:381</id>
      <description>if an exception was thrown while attempting to set the property or variable. The thrown exception must be included as the cause property of this exception, if available.</description>
      <package>jakarta.el</package>
      <class-interface>ValueExpression</class-interface>
      <method name="setValue" return-type="void">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.el.ELException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:382</id>
      <description />
      <package>jakarta.el</package>
      <class-interface>ValueReference</class-interface>
      <method name="getBase" return-type="java.lang.Object" />
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:383</id>
      <description />
      <package>jakarta.el</package>
      <class-interface>ValueReference</class-interface>
      <method name="getProperty" return-type="java.lang.Object" />
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:384</id>
      <description />
      <package>jakarta.el</package>
      <class-interface>ValueReference</class-interface>
      <method name="ValueReference" return-type="ValueReference">
        <parameters>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
    <!-- ********************************************************************************** -->
    <!-- ********************************************************************************** -->
    <!-- MODIFIED ASSERTIONS LISTED BELOW -->
    <!-- The original assertion is followed by the modified version -->
    <!-- of the assertion. Users must edit the file to verify -->
    <!-- that the modified assertion is correct. User should then -->
    <!-- delete the original assertion or use the style sheet -->
    <!-- that removes them automatically.  The original and modified -->
    <!-- assertions differ by their IDs, notice the original assertion -->
    <!-- now ends with "__OLD" -->
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>41</id>
      <description>Called to indicate that a ELResolver has successfully resolved a given (base, property) pair. Use #setPropertyResolved(Object, Object) if resolved is true and to notify EvaluationListeners. The CompositeELResolver checks this property to determine whether it should consider or skip other component resolvers.</description>
      <package>jakarta.el</package>
      <class-interface>ELContext</class-interface>
      <method name="setPropertyResolved" return-type="void">
        <parameters>
          <parameter>boolean</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>61</id>
      <description>Coerces an object to a specific type according to the EL type conversion rules. The custom type conversions in the ELResolvers are not considered. An ELException is thrown if an error results from applying the conversion rules.</description>
      <package>jakarta.el</package>
      <class-interface>ExpressionFactory</class-interface>
      <method name="coerceToType" return-type="java.lang.Object">
        <parameters>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Class</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:158</id>
      <description>If the base object is null and the property is a name that is resolvable by the BeanNameResolver, returns the value resolved by the BeanNameResolver. If name is resolved by the BeanNameResolver, the propertyResolved property of the ELContext object must be set to true by this resolver, before returning. If this property is not true after this method is called, the caller should ignore the return value.</description>
      <package>jakarta.el</package>
      <class-interface>BeanNameELResolver</class-interface>
      <method name="getValue" return-type="java.lang.Object">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:199</id>
      <description>Register a BeanNameResolver. Construct a BeanNameELResolver with the BeanNameResolver and add it to the list of ELResolvers. Once registered, the BeanNameResolver cannot be removed.</description>
      <package>jakarta.el</package>
      <class-interface>ELManager</class-interface>
      <method name="addBeanNameResolver" return-type="void">
        <parameters>
          <parameter>jakarta.el.BeanNameResolver</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:205</id>
      <description>Return the ExpressionFactory instance used for EL evaluations.</description>
      <package>jakarta.el</package>
      <class-interface>ELManager</class-interface>
      <method name="getExpressionFactory" return-type="jakarta.el.ExpressionFactory" />
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:214</id>
      <description>if the specified class does not exists.</description>
      <package>jakarta.el</package>
      <class-interface>ELProcessor</class-interface>
      <method name="defineFunction" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>java.lang.ClassNotFoundException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:216</id>
      <description>if any of the arguments is null.</description>
      <package>jakarta.el</package>
      <class-interface>ELProcessor</class-interface>
      <method name="defineFunction" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>java.lang.NullPointerException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:272</id>
      <description>Invoke the encapsulated Lambda expression. The supplied arguments are matched, in the same order, to the formal parameters. If there are more arguments than the formal parameters, the extra arguments are ignored. If there are less arguments than the formal parameters, an ELException is thrown. The actual Lambda arguments are added to the ELContext and are available during the evaluation of the Lambda expression. They are removed after the evaluation.</description>
      <package>jakarta.el</package>
      <class-interface>LambdaExpression</class-interface>
      <method name="invoke" return-type="java.lang.Object">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object[]</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:322</id>
      <description>Construct (if needed) and return a default ELResolver. Retrieves the ELResolver associated with this context. This is a CompositeELResover consists of an ordered list of ELResolvers. A BeanNameELResolver for beans defined locally Any custom ELResolvers An ELResolver supporting the collection operations A StaticFieldELResolver for resolving static fields A MapELResolver for resolving Map properties A ResourceBundleELResolver for resolving ResourceBundle properties A ListELResolver for resolving List properties An ArrayELResolver for resolving array properties A BeanELResolver for resolving bean properties</description>
      <package>jakarta.el</package>
      <class-interface>StandardELContext</class-interface>
      <method name="getELResolver" return-type="jakarta.el.ELResolver" />
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:335</id>
      <description>Returns the value of a static field. If the base object is an instance of ELClass and the property is String, the propertyResolved property of the ELContext object must be set to true by this resolver, before returning. If this property is not true after this method is called, the caller should ignore the return value. If the property is the string "class", return the java.lang.Class instance of the class specified in ELClass. If the property is a public static field of class specified in ELClass, return the value of the static field. An Enum constant is a public static field of an Enum object, and is a special case of this.</description>
      <package>jakarta.el</package>
      <class-interface>StaticFieldELResolver</class-interface>
      <method name="getValue" return-type="java.lang.Object">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:338</id>
      <description>Invokes a public static method or the constructor for a class. If the base object is an instance of ELClass and the method is a String, the propertyResolved property of the ELContext object must be set to true by the resolver, before returning. If this property is not true after this method is called, the caller should ignore the return value. Invoke the public static method specified by method. The process involved in the method selection is the same as that used in BeanELResolver. As a special case, if the name of the method is "&lt;init&gt;", the constructor for the class will be invoked.</description>
      <package>jakarta.el</package>
      <class-interface>StaticFieldELResolver</class-interface>
      <method name="invoke" return-type="java.lang.Object">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Class[]</parameter>
          <parameter>java.lang.Object[]</parameter>
        </parameters>
      </method>
    </assertion>
    <!-- ********************************************************************************** -->
    <!-- ********************************************************************************** -->
    <!-- REMOVED ASSERTIONS LISTED BELOW -->
    <assertion required="true" impl-spec="false" status="removed" testable="true">
      <modified />
      <id>EL:JAVADOC:17</id>
      <description />
      <package>jakarta.el</package>
      <class-interface>BeanELResolver.BeanProperties</class-interface>
      <method name="BeanELResolver.BeanProperties" return-type="BeanELResolver.BeanProperties">
        <parameters>
          <parameter>java.lang.Class</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="removed" testable="true">
      <modified />
      <id>EL:JAVADOC:18</id>
      <description />
      <package>jakarta.el</package>
      <class-interface>BeanELResolver.BeanProperties</class-interface>
      <method name="getBeanProperty" return-type="jakarta.el.BeanELResolver.BeanELResolver.BeanProperty">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="removed" testable="true">
      <modified />
      <id>EL:JAVADOC:19</id>
      <description />
      <package>jakarta.el</package>
      <class-interface>BeanELResolver.BeanProperty</class-interface>
      <method name="BeanELResolver.BeanProperty" return-type="BeanELResolver.BeanProperty">
        <parameters>
          <parameter>java.lang.Class</parameter>
          <parameter>java.beans.PropertyDescriptor</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="removed" testable="true">
      <modified />
      <id>EL:JAVADOC:20</id>
      <description />
      <package>jakarta.el</package>
      <class-interface>BeanELResolver.BeanProperty</class-interface>
      <method name="getPropertyType" return-type="java.lang.Class" />
    </assertion>
    <assertion required="true" impl-spec="false" status="removed" testable="true">
      <modified />
      <id>EL:JAVADOC:21</id>
      <description />
      <package>jakarta.el</package>
      <class-interface>BeanELResolver.BeanProperty</class-interface>
      <method name="getReadMethod" return-type="java.lang.reflect.Method" />
    </assertion>
    <assertion required="true" impl-spec="false" status="removed" testable="true">
      <modified />
      <id>EL:JAVADOC:22</id>
      <description />
      <package>jakarta.el</package>
      <class-interface>BeanELResolver.BeanProperty</class-interface>
      <method name="getWriteMethod" return-type="java.lang.reflect.Method" />
    </assertion>
    <assertion required="true" impl-spec="false" status="removed" testable="true">
      <modified />
      <id>EL:JAVADOC:23</id>
      <description />
      <package>jakarta.el</package>
      <class-interface>BeanELResolver.BeanProperty</class-interface>
      <method name="isReadOnly" return-type="boolean" />
    </assertion>
    <assertion required="true" impl-spec="false" status="removed" testable="true">
      <modified />
      <id>EL:JAVADOC:119</id>
      <description>Creates a new instance of a ExpressionFactory. This method uses the following ordered lookup procedure to determine the ExpressionFactory implementation class to load: Use the Services API (as detailed in the JAR specification). If a resource with the name of META-INF/services/jakarta.el.ExpressionFactory exists, then its first line, if present, is used as the UTF-8 encoded name of the implementation class. Use the properties file "lib/el.properties" in the JRE directory. If this file exists and it is readable by the java.util.Properties.load(InputStream) method, and it contains an entry whose key is "jakarta.el.ExpressionFactory", then the value of that entry is used as the name of the implementation class. Use the jakarta.el.ExpressionFactory system property. If a system property with this name is defined, then its value is used as the name of the implementation class. Use a platform default implementation.</description>
      <package>jakarta.el</package>
      <class-interface>ExpressionFactory</class-interface>
      <method name="newInstance" return-type="ExpressionFactory" />
    </assertion>
    <assertion required="true" impl-spec="false" status="removed" testable="true">
      <modified />
      <id>EL:JAVADOC:120</id>
      <description>Create a new instance of a ExpressionFactory, with optional properties. This method uses the same lookup procedure as the one used in newInstance(). If the argument properties is not null, and if the implementation contains a constructor with a single parameter of type java.util.Properties, then the constructor is used to create the instance. Properties are optional and can be ignored by an implementation. The name of a property should start with "jakarta.el." The following are some suggested names for properties. jakarta.el.cacheSize</description>
      <package>jakarta.el</package>
      <class-interface>ExpressionFactory</class-interface>
      <method name="newInstance" return-type="ExpressionFactory">
        <parameters>
          <parameter>java.util.Properties</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="removed" testable="true">
      <modified />
      <id>EL:JAVADOC:189</id>
      <description>Constructor</description>
      <package>jakarta.el</package>
      <class-interface>ELClass</class-interface>
      <method name="ELClass" return-type="ELClass">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="removed" testable="true">
      <modified />
      <id>EL:JAVADOC:190</id>
      <description>Returns the class name for the specified class.</description>
      <package>jakarta.el</package>
      <class-interface>ELClass</class-interface>
      <method name="getClassName" return-type="java.lang.String" />
    </assertion>
    <assertion required="true" impl-spec="false" status="removed" testable="true">
      <modified />
      <id>EL:JAVADOC:191</id>
      <description>Registers a listener to the ELContext.</description>
      <package>jakarta.el</package>
      <class-interface>ELContext</class-interface>
      <method name="addListener" return-type="void">
        <parameters>
          <parameter>java.util.EventListener</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="removed" testable="true">
      <modified />
      <id>EL:JAVADOC:197</id>
      <description>Returns the list of registered listeners.</description>
      <package>jakarta.el</package>
      <class-interface>ELContext</class-interface>
      <method name="getListeners" return-type="java.util.List" />
    </assertion>
    <assertion required="true" impl-spec="false" status="removed" testable="true">
      <modified />
      <id>EL:JAVADOC:201</id>
      <description>Register a listener. Used only for EvaluationListeners in 3.0, but possibly to used for other listeners.</description>
      <package>jakarta.el</package>
      <class-interface>ELManager</class-interface>
      <method name="addListener" return-type="void">
        <parameters>
          <parameter>java.util.EventListener</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="removed" testable="true">
      <modified />
      <id>EL:JAVADOC:217</id>
      <description>if the specified class does not exists.</description>
      <package>jakarta.el</package>
      <class-interface>ELProcessor</class-interface>
      <method name="defineFunction" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>ClassNoFoundException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="removed" testable="true">
      <modified />
      <id>EL:JAVADOC:246</id>
      <description>Constructor</description>
      <package>jakarta.el</package>
      <class-interface>EvaluationEvent</class-interface>
      <method name="EvaluationEvent" return-type="EvaluationEvent">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="removed" testable="true">
      <modified />
      <id>EL:JAVADOC:247</id>
      <description>Retruns the ELContext used in the evaluation of the expression.</description>
      <package>jakarta.el</package>
      <class-interface>EvaluationEvent</class-interface>
      <method name="getELContext" return-type="jakarta.el.ELContext" />
    </assertion>
    <assertion required="true" impl-spec="false" status="removed" testable="true">
      <modified />
      <id>EL:JAVADOC:248</id>
      <description>Returns the original expression String</description>
      <package>jakarta.el</package>
      <class-interface>EvaluationEvent</class-interface>
      <method name="getExpressionString" return-type="java.lang.String" />
    </assertion>
    <assertion required="true" impl-spec="false" status="removed" testable="true">
      <modified />
      <id>EL:JAVADOC:249</id>
      <description>Receives notification after an EL expression is evaluated</description>
      <package>jakarta.el</package>
      <class-interface>EvaluationListener</class-interface>
      <method name="afterEvaluation" return-type="void">
        <parameters>
          <parameter>jakarta.el.EvaluationEvent</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="removed" testable="true">
      <modified />
      <id>EL:JAVADOC:250</id>
      <description>Receives notification before an EL expression is evaluated</description>
      <package>jakarta.el</package>
      <class-interface>EvaluationListener</class-interface>
      <method name="beforeEvaluation" return-type="void">
        <parameters>
          <parameter>jakarta.el.EvaluationEvent</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="removed" testable="true">
      <modified />
      <id>EL:JAVADOC:257</id>
      <description>Retrieves an ELResolver that implements the Query Operators as described in Chapter 2 of the specification. This ELResolver relsoves the method invocation on the pair (base, property) when base is an Iterable and property is the name of the operator. Therefore, the operators behave like built-in methods of Iterables. See EL.2 for detailed descriptions of these operators, the arguments, and the return values.</description>
      <package>jakarta.el</package>
      <class-interface>ExpressionFactory</class-interface>
      <method name="getQueryOperatorELResolver" return-type="jakarta.el.ELResolver" />
    </assertion>
    <assertion required="true" impl-spec="false" status="removed" testable="true">
      <modified />
      <id>EL:JAVADOC:261</id>
      <description>Return the key for the collection</description>
      <package>jakarta.el</package>
      <class-interface>Grouping</class-interface>
      <method name="getKey" return-type="java.lang.Object" />
    </assertion>
    <assertion required="true" impl-spec="false" status="removed" testable="false">
      <modified />
      <id>EL:JAVADOC:267</id>
      <description>Creates a InvalidOperationException with no detail message.</description>
      <package>jakarta.el</package>
      <class-interface>InvalidOperationException</class-interface>
      <method name="InvalidOperationException" return-type="InvalidOperationException" />
    </assertion>
    <assertion required="true" impl-spec="false" status="removed" testable="false">
      <modified />
      <id>EL:JAVADOC:268</id>
      <description>Creates a InvalidOperationException with the provided detail message.</description>
      <package>jakarta.el</package>
      <class-interface>InvalidOperationException</class-interface>
      <method name="InvalidOperationException" return-type="InvalidOperationException">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="removed" testable="false">
      <modified />
      <id>EL:JAVADOC:269</id>
      <description>Creates a InvalidOperationException with the given root cause.</description>
      <package>jakarta.el</package>
      <class-interface>InvalidOperationException</class-interface>
      <method name="InvalidOperationException" return-type="InvalidOperationException">
        <parameters>
          <parameter>java.lang.Throwable</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="removed" testable="false">
      <modified />
      <id>EL:JAVADOC:270</id>
      <description>Creates a InvalidOperationException with the given detail message and root cause.</description>
      <package>jakarta.el</package>
      <class-interface>InvalidOperationException</class-interface>
      <method name="InvalidOperationException" return-type="InvalidOperationException">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.Throwable</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="removed" testable="true">
      <modified />
      <id>EL:JAVADOC:271</id>
      <description>Retrieves the formal parameters of the Lambda expression</description>
      <package>jakarta.el</package>
      <class-interface>LambdaExpression</class-interface>
      <method name="getFormalParameters" return-type="java.util.List" />
    </assertion>
    <assertion required="true" impl-spec="false" status="removed" testable="true">
      <modified />
      <id>EL:JAVADOC:324</id>
      <description>Construct (if need) and return an ImportHandler</description>
      <package>jakarta.el</package>
      <class-interface>StandardELContext</class-interface>
      <method name="getImportHandler" return-type="jakarta.el.ImportHandler" />
    </assertion>
    <assertion required="true" impl-spec="false" status="removed" testable="true">
      <modified />
      <id>EL:JAVADOC:328</id>
      <description>Construct a default ELContext for a stand-alone environment.</description>
      <package>jakarta.el</package>
      <class-interface>StandardELContext</class-interface>
      <method name="StandardELContext" return-type="StandardELContext">
        <parameters>
          <parameter>jakarta.el.ELResolver</parameter>
        </parameters>
      </method>
    </assertion>
    <!-- ********************************************************************************** -->
    <!-- ********************************************************************************** -->
    <!-- NEW ASSERTIONS LISTED BELOW -->
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <modified />
      <id>EL:JAVADOC:385</id>
      <description>Returns whether the given name is resolved by the BeanNameResolver</description>
      <package>jakarta.el</package>
      <class-interface>BeanNameResolver</class-interface>
      <method name="isNameResolved" return-type="boolean">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <modified />
      <id>EL:JAVADOC:386</id>
      <description>Converts an object to a specific type. An ELException is thrown if an error occurs during the conversion.</description>
      <package>jakarta.el</package>
      <class-interface>CompositeELResolver</class-interface>
      <method name="convertToType" return-type="java.lang.Object">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Class</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <modified />
      <id>EL:JAVADOC:387</id>
      <description>thrown if errors occur.</description>
      <package>jakarta.el</package>
      <class-interface>CompositeELResolver</class-interface>
      <method name="convertToType" return-type="java.lang.Object">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Class</parameter>
        </parameters>
        <throw>jakarta.el.ELException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <modified />
      <id>EL:JAVADOC:388</id>
      <description>Constructor</description>
      <package>jakarta.el</package>
      <class-interface>ELClass</class-interface>
      <method name="ELClass" return-type="ELClass">
        <parameters>
          <parameter>java.lang.Class</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <modified />
      <id>EL:JAVADOC:389</id>
      <description>Returns the Class instance</description>
      <package>jakarta.el</package>
      <class-interface>ELClass</class-interface>
      <method name="getKlass" return-type="java.lang.Class" />
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <modified />
      <id>EL:JAVADOC:390</id>
      <description>Registers an evaluation listener to the ELContext.</description>
      <package>jakarta.el</package>
      <class-interface>ELContext</class-interface>
      <method name="addEvaluationListener" return-type="void">
        <parameters>
          <parameter>jakarta.el.EvaluationListener</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <modified />
      <id>EL:JAVADOC:391</id>
      <description>Converts an object to a specific type. If a custom converter in the ELResolver handles this conversion, it is used. Otherwise the standard coercions is applied. An ELException is thrown if an error occurs during the conversion.</description>
      <package>jakarta.el</package>
      <class-interface>ELContext</class-interface>
      <method name="convertToType" return-type="java.lang.Object">
        <parameters>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Class</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <modified />
      <id>EL:JAVADOC:392</id>
      <description>thrown if errors occur.</description>
      <package>jakarta.el</package>
      <class-interface>ELContext</class-interface>
      <method name="convertToType" return-type="java.lang.Object">
        <parameters>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Class</parameter>
        </parameters>
        <throw>jakarta.el.ELException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <modified />
      <id>EL:JAVADOC:393</id>
      <description>Returns the list of registered evaluation listeners.</description>
      <package>jakarta.el</package>
      <class-interface>ELContext</class-interface>
      <method name="getEvaluationListeners" return-type="java.util.List" />
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <modified />
      <id>EL:JAVADOC:394</id>
      <description>Inquires if the name is a LambdaArgument</description>
      <package>jakarta.el</package>
      <class-interface>ELContext</class-interface>
      <method name="isLambdaArgument" return-type="boolean">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <modified />
      <id>EL:JAVADOC:395</id>
      <description>Notifies the listeners after an EL expression is evaluated</description>
      <package>jakarta.el</package>
      <class-interface>ELContext</class-interface>
      <method name="notifyAfterEvaluation" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <modified />
      <id>EL:JAVADOC:396</id>
      <description>Notifies the listeners before an EL expression is evaluated</description>
      <package>jakarta.el</package>
      <class-interface>ELContext</class-interface>
      <method name="notifyBeforeEvaluation" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <modified />
      <id>EL:JAVADOC:397</id>
      <description>Notifies the listeners when the (base, property) pair is resolved</description>
      <package>jakarta.el</package>
      <class-interface>ELContext</class-interface>
      <method name="notifyPropertyResolved" return-type="void">
        <parameters>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <modified />
      <id>EL:JAVADOC:398</id>
      <description>Called to indicate that a ELResolver has successfully resolved a given (base, property) pair and to notify the EvaluationListeners. The CompositeELResolver checks this property to determine whether it should consider or skip other component resolvers.</description>
      <package>jakarta.el</package>
      <class-interface>ELContext</class-interface>
      <method name="setPropertyResolved" return-type="void">
        <parameters>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <modified />
      <id>EL:JAVADOC:399</id>
      <description>Register an evaluation listener.</description>
      <package>jakarta.el</package>
      <class-interface>ELManager</class-interface>
      <method name="addEvaluationListener" return-type="void">
        <parameters>
          <parameter>jakarta.el.EvaluationListener</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <modified />
      <id>EL:JAVADOC:400</id>
      <description>Receives notification after an EL expression is evaluated</description>
      <package>jakarta.el</package>
      <class-interface>EvaluationListener</class-interface>
      <method name="afterEvaluation" return-type="void">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <modified />
      <id>EL:JAVADOC:401</id>
      <description>Receives notification before an EL expression is evaluated</description>
      <package>jakarta.el</package>
      <class-interface>EvaluationListener</class-interface>
      <method name="beforeEvaluation" return-type="void">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <modified />
      <id>EL:JAVADOC:402</id>
      <description />
      <package>jakarta.el</package>
      <class-interface>EvaluationListener</class-interface>
      <method name="EvaluationListener" return-type="EvaluationListener" />
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <modified />
      <id>EL:JAVADOC:403</id>
      <description>Receives notification when the (base, property) pair is resolved</description>
      <package>jakarta.el</package>
      <class-interface>EvaluationListener</class-interface>
      <method name="propertyResolved" return-type="void">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <modified />
      <id>EL:JAVADOC:404</id>
      <description>Retrieve a function map containing a pre-configured function mapping. It must include the following functions. linq:range linq:repeat linq:_empty</description>
      <package>jakarta.el</package>
      <class-interface>ExpressionFactory</class-interface>
      <method name="getInitFunctionMap" return-type="java.util.Map" />
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <modified />
      <id>EL:JAVADOC:405</id>
      <description>Retrieves an ELResolver that implements the operations in collections. This ELResolver resolves the method invocation on the pair (base, property) when base is a Collection or a Map, and property is the name of the operation. See EL.2 for detailed descriptions of these operators, their arguments, and return values.</description>
      <package>jakarta.el</package>
      <class-interface>ExpressionFactory</class-interface>
      <method name="getStreamELResolver" return-type="jakarta.el.ELResolver" />
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <modified />
      <id>EL:JAVADOC:406</id>
      <description>is elContext is null</description>
      <package>jakarta.el</package>
      <class-interface>LambdaExpression</class-interface>
      <method name="invoke" return-type="java.lang.Object">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
          <parameter>java.lang.Object[]</parameter>
        </parameters>
        <throw>java.lang.NullPointerException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <modified />
      <id>EL:JAVADOC:407</id>
      <description>Invoke the encapsulated Lambda expression. The supplied arguments are matched, in the same order, to the formal parameters. If there are more arguments than the formal parameters, the extra arguments are ignored. If there are less arguments than the formal parameters, an ELException is thrown. The actual Lambda arguments are added to the ELContext and are available during the evaluation of the Lambda expression. They are removed after the evaluation. The ELContext set by LambdaExpression#setELContext is used in the evaluation of the lambda Expression.</description>
      <package>jakarta.el</package>
      <class-interface>LambdaExpression</class-interface>
      <method name="invoke" return-type="java.lang.Object">
        <parameters>
          <parameter>java.lang.Object[]</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <modified />
      <id>EL:JAVADOC:408</id>
      <description>if not enough arguments are provided</description>
      <package>jakarta.el</package>
      <class-interface>LambdaExpression</class-interface>
      <method name="invoke" return-type="java.lang.Object">
        <parameters>
          <parameter>java.lang.Object[]</parameter>
        </parameters>
        <throw>jakarta.el.ELException</throw>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <modified />
      <id>EL:JAVADOC:409</id>
      <description>Set the ELContext to use in evaluating the LambdaExpression. The ELContext must to be set prior to the invocation of the LambdaExpression, unless it is supplied with LambdaExpression#invoke.</description>
      <package>jakarta.el</package>
      <class-interface>LambdaExpression</class-interface>
      <method name="setELContext" return-type="void">
        <parameters>
          <parameter>jakarta.el.ELContext</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <modified />
      <id>EL:JAVADOC:410</id>
      <description>Construct a default ELContext for a stand-alone environment.</description>
      <package>jakarta.el</package>
      <class-interface>StandardELContext</class-interface>
      <method name="StandardELContext" return-type="StandardELContext">
        <parameters>
          <parameter>jakarta.el.ExpressionFactory</parameter>
        </parameters>
      </method>
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:411</id>
      <description>Returns the name of the method</description>
      <package>jakarta.el</package>
      <class-interface>MethodInfo</class-interface>
      <method name="getName" return-type="java.lang.String" />
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:412</id>
      <description>Returns the return type of the method</description>
      <package>jakarta.el</package>
      <class-interface>MethodInfo</class-interface>
      <method name="getReturnType" return-type="java.lang.Class" />
    </assertion>
    <assertion required="true" impl-spec="false" status="active" testable="true">
      <id>EL:JAVADOC:413</id>
      <description>Returns the parameter types of the method</description>
      <package>jakarta.el</package>
      <class-interface>MethodInfo</class-interface>
      <method name="getParamTypes" return-type="java.lang.Class[]" />
    </assertion>
  </assertions>
</javadoc>

