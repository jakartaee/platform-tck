<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE spec SYSTEM "https://raw.githubusercontent.com/eclipse-ee4j/jakartaee-tck/master/internal/docs/dtd/spec_assertions.dtd">
<!--

    Copyright (c) 2018 Oracle and/or its affiliates. All rights reserved.

    This program and the accompanying materials are made available under the
    terms of the Eclipse Public License v. 2.0, which is available at
    http://www.eclipse.org/legal/epl-2.0.

    This Source Code may also be made available under the following Secondary
    Licenses when the conditions for such availability set forth in the
    Eclipse Public License v. 2.0 are satisfied: GNU General Public License,
    version 2 with the GNU Classpath Exception, which is available at
    https://www.gnu.org/software/classpath/license.html.

    SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0

-->

<?xml-stylesheet type="text/xsl" href="https://raw.githubusercontent.com/eclipse-ee4j/jakartaee-tck/master/internal/docs/xsl/spec_assertions.xsl"?>
<spec>
	<next-available-id/>
	<previous-id/>
	<technology>PERSISTENCE</technology>
	<id>PERSISTENCE</id>
	<name>Java(TM) Persistence API</name>
	<version>1.0</version>
	<location-names>
		<chapters>
			<chapter id="2" name="Entities">
				<sections>
					<section id="1" name="Requirements on the Entity Class"/>
					<section id="1.1" name="Persistent Fields and Properties"/>
					<section id="1.2" name="Example"/>
					<section id="1.3" name="Entity Instance Creation"/>
					<section id="1.4" name="Primary Keys and Entity Identity"/>
					<section id="1.5" name="Embeddable Classes"/>
					<section id="1.6" name="Mapping Defaults for Non-Relationship Fields or Properties"/>
					<section id="1.7" name="entity Relationships"/>
					<section id="1.8" name="Relationship Mapping Defaults"/>
					<section id="1.8.1" name="One-to-One Bidirectional Relationships"/>
					<section id="1.8.2" name="Many-to-One/One-to-Many Bidirectional Relationships"/>
					<section id="1.8.3" name="UniDirectional Single-Valued Relationships"/>
					<section id="1.8.3.1" name="UniDirectional OneToOne Relationships"/>
					<section id="1.8.3.2" name="UniDirectional ManyToOne Relationships"/>
					<section id="1.8.4" name="Many-to-Many Bidirectional Relationships"/>
					<section id="1.8.5" name="UniDirectional Multi-Valued Relationships"/>
					<section id="1.8.5.1" name="UniDirectional OneToMany Relationships"/>
					<section id="1.8.5.2" name="UniDirectional ManyToMany Relationships"/>
					<section id="1.9" name="Inheritance"/>
					<section id="1.9.1" name="Abstract Entity Classes"/>
					<section id="1.9.2" name="Mapped SuperClasses"/>
					<section id="1.9.3" name="Non-Entity Classes in the Entity Inheritance Hierarchy"/>
					<section id="1.10" name="Inheritance Mapping Strategies"/>
					<section id="1.10.1" name="Single Table per Class Hierachy Strategy"/>
					<section id="1.10.2" name="Table per Class Strategy"/>
					<section id="1.10.3" name="Joined Subclass Strategy"/>
				</sections>
			</chapter>
			<chapter id="3" name="Entity Operations">
				<sections>
					<section id="1" name="EntityManager"/>
					<section id="1.1" name="EntityManager Interface"/>
					<section id="1.2" name="Examples of Use of EntityManager API"/>
					<section id="2" name="Entity Instance Life Cycle"/>
					<section id="2.1" name="Persisting an Entity Instance"/>
					<section id="2.2" name="Removal"/>
					<section id="2.3" name="Synchronization to the Database"/>
					<section id="2.4" name="Detached Entities"/>
					<section id="2.4.1" name="Merging Detached Entity State"/>
					<section id="2.4.2" name="Detached Entities and Lazy Loading"/>
					<section id="2.5" name="Managed Instances"/>
					<section id="3" name="Persistence Context"/>
					<section id="3.1" name="Transaction Commit"/>
					<section id="3.2" name="Transaction Rollback"/>
					<section id="4" name="Optimistic Locking and Concurrency"/>
					<section id="4.1" name="Optimistic Locking"/>
					<section id="4.2" name="Version Attributes"/>
					<section id="4.3" name="LockModes"/>
					<section id="4.4" name="OptimisticLockException"/>
					<section id="5" name="Entity Listeners and Callback Methods"/>
					<section id="5.1" name="Lifecycle Callback Methods "/>
					<section id="5.2" name="Semantics of the Life Cycle Callback Methods for Entities"/>
					<section id="5.3" name="Example"/>
					<section id="5.4" name="Multiple Lifecycle Callback Methods for an Entity Lifecycle Event"/>
					<section id="5.5" name="Example"/>
					<section id="5.6" name="Exceptions"/>
					<section id="5.7" name="Specification of Callback Listener Classes and Lifecycle Methods in the XML"/>
					<section id="5.8" name="Specification of Callback Listeners"/>
					<section id="5.9" name="Specification of the Binding of Entity Listener Classes to Entities"/>
					<section id="6" name="Query API"/>
					<section id="6.1" name="Query Interface"/>
					<section id="6.1.1" name="Example"/>
					<section id="6.2" name="Queries and FlushMode"/>
					<section id="6.3" name="Named Parameters"/>
					<section id="6.4" name="Named Queries"/>
					<section id="6.5" name="PolyMorphic Queries"/>
					<section id="6.6" name="SQL Queries"/>
					<section id="7" name="Summary of Exceptions"/>
				</sections>
			</chapter>
			<chapter id="4" name="Query Language">
				<sections>
					<section id="1" name="Overview"/>
					<section id="2" name="Statement Types "/>
					<section id="2.1" name="Select Statement "/>
					<section id="2.2" name="Update and Delete Statements "/>
					<section id="3" name="Abstract Schema Types and Query Domains"/>
					<section id="3.1" name="Naming"/>
					<section id="3.2" name="Example"/>
					<section id="4" name="The FROM Clause and Navigational Declarations"/>
					<section id="4.1" name="Identifiers"/>
					<section id="4.2" name="Identification Variables"/>
					<section id="4.3" name="Range Variable Declarations"/>
					<section id="4.4" name="Path Expressions"/>
					<section id="4.5" name="Joins"/>
					<section id="4.5.1" name="Inner Joins (Relationship Joins)"/>
					<section id="4.5.2" name="Left Outer Joins"/>
					<section id="4.5.3" name="Fetch Joins"/>
					<section id="4.6" name="Collection Member Declarations"/>
					<section id="4.7" name="FROM Clause and SQL"/>
					<section id="4.8" name="Polymorphism"/>
					<section id="5" name="WHERE Clause"/>
					<section id="6" name="Conditional Expressions"/>
					<section id="6.1" name="Literals"/>
					<section id="6.2" name="Identification Variables"/>
					<section id="6.3" name="Path Expressions"/>
					<section id="6.4" name="Input Parameters"/>
					<section id="6.4.1" name="Positional Parameters"/>
					<section id="6.4.2" name="Named Parameters"/>
					<section id="6.5" name="Conditional Expression Composition"/>
					<section id="6.6" name="Operators and Operator Precedence"/>
					<section id="6.7" name="Between Expressions"/>
					<section id="6.8" name="In Expressions"/>
					<section id="6.9" name="Like Expressions"/>
					<section id="6.10" name="Null Comparison Expression"/>
					<section id="6.11" name="Empty Collection Comparison Expressions"/>
					<section id="6.12" name="Collection Member Expressions"/>
					<section id="6.13" name="Exists Expressions"/>
					<section id="6.14" name="All or Any Expressions"/>
					<section id="6.15" name="Subqueries"/>
					<section id="6.16" name="Functional Expressions"/>
					<section id="6.16.1" name="String Functions"/>
					<section id="6.16.2" name="Arithmetic Functions"/>
					<section id="6.16.3" name="Datetime Functions"/>
					<section id="7" name="GROUP BY, HAVING Clause"/>
					<section id="8" name="SELECT Clause"/>
					<section id="8.1" name="Result Type of the SELECT Clause"/>
					<section id="8.2" name="Constructor Expressions in the SELECT Clause"/>
					<section id="8.3" name="Null Values in the Query Result"/>
					<section id="8.4" name="Aggregate Functions in the SELECT Clause"/>
					<section id="8.4.1" name="Examples"/>
					<section id="9" name="ORDER BY Clause"/>
					<section id="10" name="Bulk Update and Delete Operations"/>
					<section id="11" name="Null Values"/>
					<section id="12" name="Equality and Comparison Semantics"/>
					<section id="13" name="Examples"/>
					<section id="13.1" name="Simple Queries"/>
					<section id="13.2" name="Queries with Relationships"/>
					<section id="13.3" name="Queries Using Input Parameters"/>
					<section id="14" name="BNF"/>
				</sections>
			</chapter>
			<chapter id="5" name="Entity Managers and Persistence Contexts">
				<sections>
					<section id="1" name="Persistence Contexts"/>
					<section id="2" name="Obtaining the EntityManager"/>
					<section id="1.1" name="Container-managed Entity Managers"/>
					<section id="1.2" name="Application-managed Entity Managers"/>
					<section id="1.2.1" name="The EntityManagerFactory Interface"/>
					<section id="1.2.2" name="Control of the Application-Managed EntityManager Lifecycle"/>
					<section id="2" name="Controlling Transactions"/>
					<section id="2.1" name="JTA Entity Managers"/>
					<section id="2.2" name="Resource-local Entity Managers"/>
					<section id="2.2.1" name="The EntityTransaction Interface"/>
					<section id="3" name="Persistence Contexts"/>
					<section id="6" name="Container-managed Persistence Contexts"/>
					<section id="6.1" name="Container-managed Transaction-scoped Persistence Context"/>
					<section id="6.2" name="Container-managed Extended Persistence Context"/>
					<section id="6.2.1" name="Inheritance of Extended Persistence Context"/>
					<section id="6.3" name="Persistence  Context Propagation"/>
					<section id="6.3.1" name="Requirements for Persistence Context Propagation"/>
					<section id="6.4" name="Examples"/>
					<section id="6.4.1" name="Container-Managed Transaction-Scoped Persistence Context"/>
					<section id="6.4.2" name="Container-Managed Extended Persistence Context"/>
					<section id="7" name="Application-managed Persistence Contexts"/>
					<section id="7.1" name="Examples"/>
					<section id="7.1.1" name="Application-managed Persistence Context used in Stateless Session Bean"/>
					<section id="7.1.2" name="Application-managed Persistence Context used in Stateless Session Bean"/>
					<section id="7.1.3" name="Application-managed Persistence Context used in Stateful Session Bean"/>
					<section id="7.1.4" name="Application-managed Persistence Context with Resource Transaction"/>
					<section id="8" name="Requirements on the Container"/>
					<section id="8.1" name="Application-managed Persistence Contexts"/>
					<section id="8.2" name="Container Managed Persistence Contexts"/>
					<section id="9" name="Runtime Contracts Between the Container and Persistence Provider"/>
					<section id="9.1" name="Container Responsibilities"/>
					<section id="9.2" name="Provider Responsibilities"/>
				</sections>
			</chapter>
			<chapter id="6" name="Entity Packaging">
				<sections>
					<section id="1" name="Persistence Unit"/>
					<section id="2" name="Persistence Unit Packaging"/>
					<section id="2.1" name="persistence.xml file"/>
					<section id="2.1.1" name="name"/>
					<section id="2.1.2" name="transaction-type"/>
					<section id="2.1.3" name="description"/>
					<section id="2.1.4" name="provider"/>
					<section id="2.1.5" name="jta-data-source, non-jta-data-source"/>
					<section id="2.1.6" name="mapping-file, jar-file, class, exclude-unllisted-classes"/>
					<section id="2.1.7" name="properties"/>
					<section id="2.1.8" name="Examples"/>
					<section id="2.2" name="Persistence Unit Scope"/>
					<section id="3" name="persistence.xml Schema"/>
				</sections>
			</chapter>
			<chapter id="7" name="Container and Provider Contracts for Deployment and Bootstrapping">
				<sections>
					<section id="1" name="JavaEE Deployment"/>
					<section id="1.1" name="Responsibilities of the Container"/>
					<section id="1.2" name="Responsibilities of the Persistence Provider"/>
					<section id="1.3" name="javax.persistence.spi.PersistenceProvider"/>
					<section id="1.3.1" name="Persistence Unit Properties"/>
					<section id="1.4" name="javax.persistence.spi.PersistenceUnitInfo Inerface"/>
					<section id="2" name="Bootstrapping in Java SE Environments"/>
					<section id="1.5" name="javax.persistence.Persistence Class"/>
				</sections>
			</chapter>
			<chapter id="8" name="MetaData Annotations">
				<sections>
					<section id="1" name="Entity"/>
					<section id="2" name="Callback Annotations"/>
					<section id="3" name="Annotations for Queries"/>
					<section id="3.1" name="NamedQuery Annotation"/>
					<section id="3.2" name="NamedNativeQuery Annotation"/>
					<section id="1.1" name="Annotations for SQL Query Result Set Mappings"/>
					<section id="4" name="References to EntityManager and EntityManagerFactory"/>
					<section id="4.1" name="PersistenceContext Annotation"/>
					<section id="4.2" name="PersistenceUnit Annotation"/>
				</sections>
			</chapter>
			<chapter id="9" name="MetaData for Object/Relational Mapping">
				<sections>
					<section id="1" name="Annotations for Object/Relational Mapping"/>
					<section id="1.1" name="Table Annotation"/>
					<section id="1.2" name="SecondaryTable Annotation"/>
					<section id="1.3" name="SecondaryTables Annotation"/>
					<section id="1.4" name="UniqueConstraint Annotation"/>
					<section id="1.5" name="Column Annotation"/>
					<section id="1.6" name="JoinColumn Annotation"/>
					<section id="1.7" name="JoinColumns Annotation"/>
					<section id="1.8" name="Id Annotation"/>
					<section id="1.9" name="GeneratedValue Annotation"/>
					<section id="1.10" name="AttributeOverride Annotation"/>
					<section id="1.11" name="AttributeOverrides Annotation"/>
					<section id="1.12" name="AssociationOverride Annotation"/>
					<section id="1.13" name="AssociationOverrides Annotation"/>
					<section id="1.14" name="EmbeddedId Annotation"/>
					<section id="1.15" name="IdClass Annotation"/>
					<section id="1.16" name="Transient Annotation"/>
					<section id="1.17" name="Version Annotation"/>
					<section id="1.18" name="Basic Annotation"/>
					<section id="1.19" name="Lob Annotation"/>
					<section id="1.20" name="Temporal Annotation"/>
					<section id="1.21" name="Enumerated Annotation"/>
					<section id="1.22" name="ManyToOne Annotation"/>
					<section id="1.23" name="OneToOneAnnotation"/>
					<section id="1.24" name="OneToMany Annotation"/>
					<section id="1.25" name="JoinTable Annotation"/>
					<section id="1.26" name="ManyToMany Annotation"/>
					<section id="1.27" name="MapKey Annotation"/>
					<section id="1.28" name="OrderBy Annotation"/>
					<section id="1.29" name="Inheritance Annotation"/>
					<section id="1.30" name="DiscriminatorColumn Annotation"/>
					<section id="1.31" name="DiscriminatorValue Annotation"/>
					<section id="1.32" name="PrimaryKeyJoinColumn Annotation"/>
					<section id="1.33" name="PrimaryKeyColumns Annotation"/>
					<section id="1.34" name="Embeddable Annotation"/>
					<section id="1.35" name="Embedded Annotation"/>
					<section id="1.36" name="MappedSuperclass Annotation"/>
					<section id="1.37" name="SequenceGenerator Annotation"/>
					<section id="1.38" name="TableGenertor Annotation"/>
				</sections>
			</chapter>
			<chapter id="10" name="XML Descriptor">
				<sections>
					<section id="1" name="XML Overriding Rules"/>
					<section id="1.1" name="persistence-unit-defaults Subelements"/>
					<section id="1.1.1" name="schema"/>
					<section id="1.1.2" name="catalog"/>
					<section id="1.1.3" name="access"/>
					<section id="1.1.4" name="cascade-persist"/>
					<section id="1.1.5" name="entity-listeners"/>
					<section id="1.2" name="Other Subelements of the entity-mapping element"/>
					<section id="1.2.1" name="package"/>
					<section id="1.2.2" name="schema"/>
					<section id="1.2.3" name="catalog"/>
					<section id="1.2.4" name="access"/>
					<section id="1.2.5" name="sequence-generator"/>
					<section id="1.2.6" name="table-generator"/>
					<section id="1.2.7" name="named-query"/>
					<section id="1.2.8" name="named-native-query"/>
					<section id="1.2.9" name="sql-result-set-mapping"/>
					<section id="1.2.10" name="entity"/>
					<section id="1.2.11" name="mapped-superclass"/>
					<section id="1.2.12" name="embeddable"/>
					<section id="1.3" name="entity Subelements"/>
					<section id="1.3.1" name="table"/>
					<section id="1.3.2" name="secondary-table"/>
					<section id="1.1.1" name="primary-key-join-column"/>
					<section id="1.3.4" name="id-class"/>
					<section id="1.3.5" name="inheritance"/>
					<section id="1.3.6" name="discriminator"/>
					<section id="1.3.7" name="discriminator-column"/>
					<section id="1.3.8" name="sequence-generator"/>
					<section id="1.3.9" name="table-generator"/>
					<section id="1.3.10" name="attribute-override"/>
					<section id="1.3.11" name="association-override"/>
					<section id="1.3.12" name="named-query"/>
					<section id="1.3.13" name="named-native-query"/>
					<section id="1.3.14" name="sql-result-set-mapping"/>
					<section id="1.3.15" name="exclude-default-listeners"/>
					<section id="1.3.16" name="exclude-superclass-listeners"/>
					<section id="1.3.17" name="entity-listeners"/>
					<section id="1.3.18" name="pre-persist, post-persist, pre-remove, post-remove, pre-update, post-update"/>
					<section id="1.3.19" name="id"/>
					<section id="1.3.20" name="embedded-id"/>
					<section id="1.3.21" name="basic"/>
					<section id="1.3.22" name="version"/>
					<section id="1.3.23" name="many-to-one"/>
					<section id="1.3.24" name="one-to-many"/>
					<section id="1.3.25" name="one-to-one"/>
					<section id="1.3.26" name="many-to-many"/>
					<section id="1.3.27" name="embedded"/>
					<section id="1.3.28" name="transient"/>
					<section id="1.4" name="mapped-superclass Subelements"/>
					<section id="1.4.1" name="id-class"/>
					<section id="1.4.2" name="exclude-default-listeners"/>
					<section id="1.4.3" name="exclude-superclass-listeners"/>
					<section id="1.4.4" name="entity-listeners"/>
					<section id="1.4.5" name="pre-persist, post-persist, pre-remove, post-remove, pre-update, post-update"/>
					<section id="1.4.6" name="id"/>
					<section id="1.4.7" name="embedded-id"/>
					<section id="1.4.8" name="basic"/>
					<section id="1.4.9" name="version"/>
					<section id="1.4.10" name="many-to-one"/>
					<section id="1.4.11" name="one-to-many"/>
					<section id="1.4.12" name="one-to-one"/>
					<section id="1.4.13" name="many-to-many"/>
					<section id="1.4.14" name="embedded"/>
					<section id="1.4.15" name="transient"/>
					<section id="1.5" name="embeddable Subelements"/>
					<section id="1.5.1" name="basic"/>
					<section id="1.5.2" name="transient"/>
					<section id="2" name="XML Schema"/>
				</sections>
			</chapter>
		</chapters>
	</location-names>
	<assertions>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:500</id>
			<description>The entity class must:</description>
			<keywords>
				<keyword>application-role</keyword>
				<keyword>application-server-role</keyword>
			</keywords>
			<location chapter="2" section="1"/>
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:501</id>
					<description>be annotated with the Entity annotation</description>
					<keywords>
						<keyword>application-role</keyword>
						<keyword>application-server-role</keyword>
					</keywords>
					<location chapter="2" section="1"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:502</id>
					<description>be denoted in the deployment descriptor as an Entity</description>
					<keywords>
						<keyword>application-role</keyword>
						<keyword>application-server-role</keyword>
					</keywords>
					<location chapter="2" section="1"/>
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:503</id>
			<description>The entity must have a no-arg constructor.</description>
			<keywords>
				<keyword>application-role</keyword>
			</keywords>
			<location chapter="2" section="1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:504</id>
			<description>The entity may have other constructors as well.</description>
			<keywords>
				<keyword>application-role</keyword>
			</keywords>
			<location chapter="2" section="1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:505</id>
			<description>The no-arg constructor must be public or protected.</description>
			<keywords>
				<keyword>application-role</keyword>
			</keywords>
			<location chapter="2" section="1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:506</id>
			<description>If the entity is to be passed by value as a detached object (e.g., through a remote interface), it must implement the Serializable interface.</description>
			<keywords>
				<keyword>application-role</keyword>
			</keywords>
			<location chapter="2" section="1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:507</id>
			<description>The entity class must not be final. </description>
			<keywords>
				<keyword>application-role</keyword>
			</keywords>
			<location chapter="2" section="1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:508</id>
			<description>No methods or persistent instances of the entity class may be final.</description>
			<location chapter="2" section="1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:509</id>
			<description>Both abstract and concrete classes can be entities.</description>
			<location chapter="2" section="1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:510</id>
			<description>Entities may extend non-entity classes as well as entity classes and non-entity classes may extend entity classes.</description>
			<location chapter="2" section="1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:511</id>
			<description>Instance variables must not be accessed by clients of the entity.  The state of the entity is available to clients only through the entity's accessor methods or other business methods.</description>
			<keywords>
				<keyword>application-role</keyword>
				<keyword>application-server-role</keyword>
			</keywords>
			<location chapter="2" section="1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:512</id>
			<description>Instance variables must be private, protected, or package visibility.</description>
			<keywords>
				<keyword>application-role</keyword>
			</keywords>
			<location chapter="2" section="1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:513</id>
			<description>If the entity is field-based access, the persistence provider runtime accesses instance variables directly and all non-transient instance variables that are not annotated with the Transient annotation are persistent.</description>
			<location chapter="2" section="1.1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:514</id>
			<description>If the entity is property-based access, the persistence provider accesses persistent state via the property accessor methods and all properties not annotated with the Transient annotation are persistent.</description>
			<location chapter="2" section="1.1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:515</id>
			<description>The property accessor methods must be public or protected.</description>
			<keywords>
				<keyword>application-role</keyword>
			</keywords>
			<location chapter="2" section="1.1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:516</id>
			<description>It is required that the entity class follow the method conventions for a JavaBean when persistent properties are used.</description>
			<keywords>
				<keyword>application-role</keyword>
				<keyword>application-server-role</keyword>
			</keywords>
			<location chapter="2" section="1.1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:517</id>
			<description>Collection-valued peristent fields and properties must be defned in terms of the java.util.Collection or java.util.Set interfaces regardless of whether the entity class otherwise adheres to the JavaBeans conventions noted above.  </description>
			<keywords>
				<keyword>application-role</keyword>
				<keyword>application-server-role</keyword>
			</keywords>
			<location chapter="2" section="1.1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:518</id>
			<description> The following collection interfaces are supported:  java.util.Collection, java.util.set, java.util.List, java.util.Map</description>
			<keywords>
				<keyword>application-role</keyword>
				<keyword>application-server-role</keyword>
			</keywords>
			<location chapter="2" section="1.1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:519</id>
			<description>For collection-valued persistent properties, type T must be one of these Collection interface types in the method signatures above.  Generic variants of these Collection types may also
			be used.</description>
			<keywords>
				<keyword>application-role</keyword>
				<keyword>application-server-role</keyword>
			</keywords>
			<location chapter="2" section="1.1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:520</id>
			<description>In addition to returning and setting persistent state of the instance, the property accessor methods may contain other business logic as well, for example, to perform validation. THe persistence provider runtime executes this logic when property-based access is used.</description>
			<location chapter="2" section="1.1"/>
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:521</id>
					<description>Runtime exceptions thrown by property accessor methods will cause the current transaction to be rolled back.</description>
					<location chapter="2" section="1.1"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:522</id>
					<description>Exceptions thrown by such methos when used by the persistence runtime to load or store persistent state cause the persistence runtime to rollback the current transaction and to throw a PersistenceException that wraps the application exception.</description>
					<location chapter="2" section="1.1"/>
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:523</id>
			<description>Entity subclasses are permitted to override the property accessor methods of the entity.  However, portable applications must not override the object/relational mapping metadata that applies to the persistent fields or properties of entity superclasses.</description>
			<keywords>
				<keyword>application-role</keyword>
			</keywords>
			<location chapter="2" section="1.1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:524</id>
			<description>The persistent fields or properties of an entity may be one of the following types:</description>
			<keywords>
				<keyword>application-role</keyword>
				<keyword>application-server-role</keyword>
			</keywords>
			<location chapter="2" section="1.1"/>
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:525</id>
					<description>Java primitive types</description>
					<location chapter="2" section="1.1"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:526</id>
					<description>java.lang.String</description>
					<location chapter="2" section="1.1"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:527</id>
					<description>other Java serializable types (including wrappers of the primitive types, java.math.BigInteger, java.math.BigDecimal, java.util.Date,
					java.util.Calendar, java.sql.Date, java.sql.Time, java.sql.TimeStamp</description>
					<location chapter="2" section="1.1"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:528</id>
					<description>user-defined serializable types, byte[], Byte[], char[], and Character[]</description>
					<location chapter="2" section="1.1"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:529</id>
					<description>enums</description>
					<location chapter="2" section="1.1"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:530</id>
					<description>entity types</description>
					<location chapter="2" section="1.1"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:531</id>
					<description>collection of entity types</description>
					<location chapter="2" section="1.1"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:532</id>
					<description>embeddable classes</description>
					<location chapter="2" section="1.1"/>
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:533</id>
			<description>Every entity must have a primary key.</description>
			<keywords>
				<keyword>application-role</keyword>
			</keywords>
			<location chapter="2" section="1.4"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:534</id>
			<description>A simple primary key must correspond to a single persistent field or property of the entity class.</description>
			<keywords>
				<keyword>application-role</keyword>
				<keyword>application-server-role</keyword>
			</keywords>
			<location chapter="2" section="1.4"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:535</id>
			<description>A composite primary key must correspond to either a single persistent field or property or to a set of such fields or properties.</description>
			<keywords>
				<keyword>application-role</keyword>
				<keyword>application-server-role</keyword>
			</keywords>
			<location chapter="2" section="1.4"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:536</id>
			<description>The primary key must be one of the following types:</description>
			<keywords>
				<keyword>application-role</keyword>
				<keyword>application-server-role</keyword>
			</keywords>
			<location chapter="2" section="1.4"/>
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:537</id>
					<description>any Java primitive type</description>
					<location chapter="2" section="1.4"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:538</id>
					<description>any primitive wrapper type</description>
					<location chapter="2" section="1.4"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:539</id>
					<description>java.lang.String</description>
					<location chapter="2" section="1.4"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:540</id>
					<description>java.util.Date.  If java.util.Date is used as a primary key field or property,the temporal type should be specified as DATE.</description>
					<location chapter="2" section="1.4"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:541</id>
					<description>java.sql.Date</description>
					<location chapter="2" section="1.4"/>
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:542</id>
			<description>The access type (field- or property-based access) of a primary key class is determined by the access type of the entity for which it is the primary key.</description>
			<keywords>
				<keyword>application-role</keyword>
				<keyword>application-server-role</keyword>
			</keywords>
			<location chapter="2" section="1.4"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:543</id>
			<description>The following rules apply for composite primary keys:</description>
			<location chapter="2" section="1.4"/>
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:544</id>
					<description>The primary key class must be public and must have a public no-arg constructor.</description>
					<keywords>
						<keyword>application-role</keyword>
					</keywords>
					<location chapter="2" section="1.4"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:545</id>
					<description>The primary key class must be serializable.</description>
					<keywords>
						<keyword>application-role</keyword>
					</keywords>
					<location chapter="2" section="1.4"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:546</id>
					<description>If property-based access is used, the properties of the primary key class must be public or protected.</description>
					<keywords>
						<keyword>application-role</keyword>
					</keywords>
					<location chapter="2" section="1.4"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:547</id>
					<description>The composite primary key must define equals and hashCode methods.</description>
					<keywords>
						<keyword>application-role</keyword>
					</keywords>
					<location chapter="2" section="1.4"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:548</id>
					<description>A composite primary key must either be represented and mapped as an embeddable class (EmbeddedId annotation) or must be represented and mapped to multiple fields or properties of the entity class (IdClass annotation).</description>
					<keywords>
						<keyword>application-role</keyword>
					</keywords>
					<location chapter="2" section="1.4"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:549</id>
					<description>If the composite primary key class is mapped to multiple fields or properties of the entity class, then the names of the primary key fields or properties in the primary key class and those of the entity class must correspond and their types must be the same.</description>
					<keywords>
						<keyword>application-role</keyword>
					</keywords>
					<location chapter="2" section="1.4"/>
				</assertion>
				<assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="false">
					<id>PERSISTENCE:SPEC:550</id>
					<description>The application must not change the value of the primary key.  The behavior is undefined if this occurs.</description>
					<keywords>
						<keyword>application-role</keyword>
					</keywords>
					<location chapter="2" section="1.4"/>
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="false">
			<id>PERSISTENCE:SPEC:551</id>
			<description>Such embedded objects belong strictly to their owning entity and are not shareable across persistent entities.  Attempting to share an embedded object across entities has undefined semantics.</description>
			<location chapter="2" section="1.5"/>
		</assertion>
		<assertion required="false" impl-spec="false" defined-by="technology" status="active" testable="false">
			<id>PERSISTENCE:SPEC:552</id>
			<description>Collection of embedded objects are not supported in this release.</description>
			<location chapter="2" section="1.5"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:553</id>
			<description>Embeddable classes must adhere to the requirements as specified in section 2.1 for entities with the exception that embeddable classes are not annotated as Entity.</description>
			<keywords>
				<keyword>application-role</keyword>
				<keyword>application-server-role</keyword>
			</keywords>
			<location chapter="2" section="1.5"/>
		</assertion>
		<assertion required="false" impl-spec="false" defined-by="technology" status="active" testable="false">
			<id>PERSISTENCE:SPEC:554</id>
			<description>Unlike entities, embeddable classes do not support polymorphism and inheritance.</description>
			<location chapter="2" section="1.5"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:555</id>
			<description>If a persistent field or property other than a relationship property is not annotated with a mapping annotation, the the following default mappings rules are applied. </description>
			<location chapter="2" section="1.6"/>
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:556</id>
					<description>If the type of the field or property is one of the following, it is mapped as @Basic: Java primitive types, wrappers of primitive types, java.lang.String, java.math.BigInteger, java.math.BigDecimal, java.util.Date, java.util.Calendar,java.sql.Date, java.sql.Time, java.sql.TimeStamp, byte[], Byte[], char[], Character[], enums, any other types that implement Serializable.</description>
					<location chapter="2" section="1.6"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:557</id>
					<description>If the type is a class that is annotated with the @Embeddable annotation, it is mapped as @Embedded.</description>
					<location chapter="2" section="1.6"/>
				</assertion>
				<assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:560</id>
					<description>It is an error if no annotation is present and none of the above rules apply.</description>
					<keywords>
						<keyword>application-role</keyword>
						<keyword>application-server-role</keyword>
					</keywords>
					<location chapter="2" section="1.6"/>
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:561</id>
			<description>If there is an association between two entities, one of the following relationship modeling annotations must be applied to the corresponding property or instance variable of the referencing entity:</description>
			<keywords>
				<keyword>application-role</keyword>
				<keyword>application-server-role</keyword>
			</keywords>
			<location chapter="2" section="1.7"/>
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:562</id>
					<description>OneToOne</description>
					<location chapter="2" section="1.7"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:563</id>
					<description>OneToMany</description>
					<location chapter="2" section="1.7"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:564</id>
					<description>ManyToOne</description>
					<location chapter="2" section="1.7"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:565</id>
					<description>ManyToMany</description>
					<location chapter="2" section="1.7"/>
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:566</id>
			<description>For associations that do not specify the targe type (e.g., where Java generic types are not used for collections) it is necessary to also specify the entity that is the target of the relationship.</description>
			<keywords>
				<keyword>application-role</keyword>
				<keyword>application-server-role</keyword>
			</keywords>
			<location chapter="2" section="1.7"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:567</id>
			<description>A bidirectional relationship has both an owning side and an inverse side.</description>
			<location chapter="2" section="1.7"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:568</id>
			<description>A unidirectional relationship has only an owning side.</description>
			<location chapter="2" section="1.7"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:569</id>
			<description>The following rules apply to bidirectional relationships:</description>
			<location chapter="2" section="1.7"/>
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:570</id>
					<description>The inverse side of a bidirectional relationship must refer to its owning side by use of the mappedBy element of the OneToOne, OneToMany, or ManyToMany annotation.</description>
					<keywords>
						<keyword>application-role</keyword>
						<keyword>application-server-role</keyword>
					</keywords>
					<location chapter="2" section="1.7"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:571</id>
					<description>The mappedBy element designates the property or field in the entity that is the owner of the relationship.</description>
					<location chapter="2" section="1.7"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:572</id>
					<description>The many side of one-to-many/many-to-one bidirectional relationships must be the owning side, hence the mappedBy element cannot be specified on the ManyToOne annotation.</description>
					<keywords>
						<keyword>application-role</keyword>
						<keyword>application-server-role</keyword>
					</keywords>
					<location chapter="2" section="1.7"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:573</id>
					<description>For one-to-one bidirectional relationships, the owning side corresponds to the side that contains the corresponding foreign key.</description>
					<location chapter="2" section="1.7"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:574</id>
					<description>For many-to-many bidirectional relationships, either side may be the owning side.</description>
					<location chapter="2" section="1.7"/>
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:575</id>
			<description>The cascade=REMOVE specification should only be applied to associations that are specified as OneToOne or OneToMany.</description>
			<keywords>
				<keyword>application-role</keyword>
				<keyword>application-server-role</keyword>
			</keywords>
			<location chapter="2" section="1.7"/>
		</assertion>
		<assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:576</id>
			<description>Applications that apply cascade=REMOVE to other assocations [ManyToMany, ManyToOne] are not portable.</description>
			<keywords>
				<keyword>application-role</keyword>
				<keyword>application-server-role</keyword>
			</keywords>
			<location chapter="2" section="1.7"/>
		</assertion>
		<assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:577</id>
			<description>A foreign key mapping may be used for a unidirectional one-to-many mapping. Any such overriding must be consistent with the relationship modeling annotation that is specified.</description>
			<keywords>
				<keyword>application-role</keyword>
				<keyword>application-server-role</keyword>
			</keywords>
			<location chapter="2" section="1.7"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:578</id>
			<description>Bidirectional OneToOne Relationships</description>
			<location chapter="2" section="1.8.1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:579</id>
			<description>Bidirectional ManyToOne/OneToMany Relationships</description>
			<location chapter="2" section="1.8.2"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:580</id>
			<description>Unidirectional Single-Valued Relationships</description>
			<location chapter="2" section="1.8.3"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:581</id>
			<description>Unidirectional OneToOne Relationships</description>
			<location chapter="2" section="1.8.3.1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:582</id>
			<description>Unidirectional ManyToOne Relationships</description>
			<location chapter="2" section="1.8.3.2"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:583</id>
			<description>Bidirectional ManyToMany Relationships</description>
			<location chapter="2" section="1.8.4"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:584</id>
			<description>Unidirectional Multi-Valued Relationships</description>
			<location chapter="2" section="1.8.5"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:585</id>
			<description>Unidirectional OneToMany Relationships</description>
			<location chapter="2" section="1.8.5.1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:586</id>
			<description>Unidirectional ManyToMany Relationships</description>
			<location chapter="2" section="1.8.5.2"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:587</id>
			<description>When an entity is defined as a subclass of another entity, the primary keys of the entities must be of the same type.</description>
			<keywords>
				<keyword>application-role</keyword>
			</keywords>
			<location chapter="2" section="1.9"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:588</id>
			<description>An abstract entity class is annotated with the Entity annotation or denoted in the XML descriptor as an entity.</description>
			<location chapter="2" section="1.9.1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:588.1</id>
			<description>An abstract entity is mapped as an entity and can be the target of queries (which will operate over and/or retrieve instances of its concrete subclass).</description>
			<location chapter="2" section="1.9.1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:589</id>
			<description>An entity may have a non-entity superclass which may be either a concrete or abstract class.</description>
			<location chapter="2" section="1.9.2"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:590</id>
			<description>The state of a non-entity superclass is not persistent.</description>
			<location chapter="2" section="1.9.2"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:591</id>
			<description>Any state inherited from non-entity superclasses is non-persistent in an inheriting entity class.  This non-persistent state is not managed
			by the EntityManager, nor is it required to be retained across transactions.</description>
			<location chapter="2" section="1.9.2"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
			<id>PERSISTENCE:SPEC:592</id>
			<description>Non-entity classes cannot be passed as arguments to methods of the EntityManager or Query interfaces and cannot bear mapping information.</description>
			<location chapter="2" section="1.9.2"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:593</id>
			<description>An entity may have an mapped superclass, which provides persistent entity state and mapping information, but which is not an entity itself.</description>
			<location chapter="2" section="1.9.3"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
			<id>PERSISTENCE:SPEC:594</id>
			<description>A mapped superclass, unlike an entity, is not queryable and cannot be passed as an argument to EntityManager or Query operations.</description>
			<location chapter="2" section="1.9.3"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:595</id>
			<description>An mapped superclass cannot be the target of a persistent relationship.</description>
			<location chapter="2" section="1.9.3"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:596</id>
			<description>Both abstract or concrete classes may be specified as mapped superclasses.</description>
			<location chapter="2" section="1.9.3"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:597</id>
			<description>The MappedSuperclass annotation (or mapped-superclass XML descriptor element) is used to designate an mapped superclass.</description>
			<location chapter="2" section="1.9.3"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:598</id>
			<description>A class designated as an mapped superclass has no separate table defined for it.  Its mapping information is applied to entities that inherit from it.</description>
			<location chapter="2" section="1.9.3"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:599</id>
			<description>A classes designated as MappedSuperclass can be mapped in the same way as an entity except that the mapping will only apply to its subclesses since no table exists for the mapped superclass.  When applied to the subclasses the inherited mappings will apply in the context of the subclass tables.</description>
			<location chapter="2" section="1.9.3"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:600</id>
			<description>Mapping information may be overriden in such subclasses by using the AttributeOverride annotation or attribute-override XML element.</description>
			<location chapter="2" section="1.9.3"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:601</id>
			<description>All other entity mapping defaults apply equally to a class designated as MappedSuperclass.</description>
			<location chapter="2" section="1.9.3"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:602</id>
			<description>There are three basic strategies that are used when mapping a class or class hierarchy to a relational database schema:</description>
			<location chapter="2" section="1.10"/>
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:603</id>
					<description>Single Table per Class Hierarchy Strategy.  An implementation is required to support the single table per class hierachy inheritance mapping strategy.</description>
					<location chapter="2" section="1.10.1"/>
				</assertion>
				<assertion required="false" impl-spec="true" defined-by="technology" status="active" testable="false">
					<id>PERSISTENCE:SPEC:604</id>
					<description>Table Per Class Strategy - Optional in this release.</description>
					<location chapter="2" section="1.10.2"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:605</id>
					<description>Joined Subclass Strategy </description>
					<location chapter="2" section="1.10.3"/>
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:606</id>
			<description>The persist, merge, remove, flush, and refresh methods must be invoked within a transaction context when an entity
					manager with a transaction-scoped persistence context is used.  If there is no transaction context, the javax.persistence. TransactionRequiredException
					is thrown.</description>
			<location chapter="3" section="1.1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:607</id>
			<description>The find and getReference methods are not required to be invoked within a transaction context.  If an entity manager with transaction-
					scoped persistence context is in use, the resulting entities will be detached; if an entity manager with an extended persistence context is used,
					they will be managed.</description>
			<location chapter="3" section="1.1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:608</id>
			<description>The Query and EntityTransaction objects obtained from an entity manager are valid while that entity manager is open.</description>
			<location chapter="3" section="1.1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:609</id>
			<description>If the argument to the createQuery method is not a valid QL query string, the IllegalArgumentException may be thrown
					or the query execution will fail.</description>
			<location chapter="3" section="1.1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
			<id>PERSISTENCE:SPEC:610</id>
			<description>If a native query is not a valid query for the database in use or if the results set specification is incompatible with the result
					of the query, the query execution will fail and a PersistenceException will be thrown when the query is executed.  The PersistenceException
					should wrap the underlying database exception when possible.</description>
			<location chapter="3" section="1.1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:611</id>
			<description>Runtime exceptions thrown by the methods of the EntityManager interface will cause the current transaction to
					be rolled back.</description>
			<location chapter="3" section="1.1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:612</id>
			<description>The methods close, isOpen, joinTransaction and getTransaction are used to managed application-managed
					entity managers and their life cycle.</description>
			<location chapter="3" section="1.1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:613</id>
			<description>Entity Instance's Life Cycle:</description>
			<location chapter="3" section="2"/>
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:614</id>
					<description>A new entity instance has no persistent identity and is not yet associated with a persistence context.</description>
					<location chapter="3" section="2"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:615</id>
					<description>A managed entity instance is an instance with a persistent identity that is currently associated with a persistence context.</description>
					<location chapter="3" section="2"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:616</id>
					<description>A detached entity is an instance with a persistent identity that is not (or no longer) associated with a persistence context.</description>
					<location chapter="3" section="2"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:617</id>
					<description>A removed entity instance is an instance with a persistent identity associated with a persistence context that is scheduled for removal from the database.</description>
					<location chapter="3" section="2"/>
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:618</id>
			<description>The new entity instance becomes both managed and persistent by
			 invoking the persist method on it or by cascading the persist operation.   The semantics of the persist operation, applied to an entity X, are as follows:</description>
			<location chapter="3" section="2.1"/>
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:619</id>
					<description>If X is a new entity, it becomes managed.</description>
					<location chapter="3" section="2.1"/>
				</assertion>
				<assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:620</id>
					<description>The entity X will be entered into the database at or before transaction commit or as a result of the flush operation.</description>
					<location chapter="3" section="2.1"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:621</id>
					<description>If X is a preexisting managed entity, it is ignored by the persist operation.</description>
					<location chapter="3" section="2.1"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:622</id>
					<description>However, the persist operation is cascaded to entities referenced by X, if the relationship from X to these other entities is annotated with cascade=PERSIST annotation element.</description>
					<location chapter="3" section="2.1"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:623</id>
					<description>However, the persist operation is cascaded to entities referenced by X, if the relationship from X to these other entities is annotated with cascade=ALL annotation element.</description>
					<location chapter="3" section="2.1"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:624</id>
					<description>If X is a removed entity, it becomes managed.</description>
					<location chapter="3" section="2.1"/>
				</assertion>
				<assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:625</id>
					<description>If X is a detached object, an IllegalArgumentException will be thrown by the persist operation (or the transaction comit will fail).</description>
					<location chapter="3" section="2.1"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:626</id>
					<description>For all entities Y referenced by a relationship from X, if the relationship to Y has been annotated with the cascade element value cascade=PERSIST, the persist operation is applied to Y.</description>
					<location chapter="3" section="2.1"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:627</id>
					<description>For all entities Y referenced by a relationship from X, if the relationship to Y has been annotated with the cascade element value cascade=ALL, the persist operation is applied to Y.</description>
					<location chapter="3" section="2.1"/>
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:628</id>
			<description>A managed entity instance  becomes removed by invoking the
			 remove method on it or by cascading the remove operation.   The semantics of the remove operation, applied to an entity X, are as follows:</description>
			<location chapter="3" section="2.2"/>
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:629</id>
					<description>If X is a new entity, it is ignored by the remove operation.</description>
					<location chapter="3" section="2.2"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:630</id>
					<description>However, the remove operation is cascaded to entities referenced by X, if the relationship from X to these other entities is annotated with cascade=REMOVE annotation element.</description>
					<location chapter="3" section="2.2"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:631</id>
					<description>However, the remove operation is cascaded to entities referenced by X, if the relationship from X to these other entities is annotated with cascade=ALL annotation element.</description>
					<location chapter="3" section="2.2"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:632</id>
					<description>If X is a managed entity, the remove operation causes it to transition to the removed state.</description>
					<location chapter="3" section="2.2"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:633</id>
					<description>The remove operation is cascaded to entities referenced by X, if the relationship from X to these other entities is annotated with cascade=REMOVE annotation element.</description>
					<location chapter="3" section="2.2"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:634</id>
					<description>The remove operation is cascaded to entities referenced by X, if the relationship from X to these other entities is annotated with cascade=ALL annotation element.</description>
					<location chapter="3" section="2.2"/>
				</assertion>
				<assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:635</id>
					<description>If X is a detached entity, an IllegalArgumentException will be thrown by the remove operation (or the transaction commit will fail).</description>
					<location chapter="3" section="2.2"/>
				</assertion>
				<assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:636</id>
					<description>If X is a removed entity, it is ignored by the remove operation.</description>
					<location chapter="3" section="2.2"/>
				</assertion>
				<assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:637</id>
					<description>A removed entity X will be removed from the database at or before transaction commit or as a result of the flush operation.</description>
					<location chapter="3" section="2.2"/>
				</assertion>
				<assertion required="false" impl-spec="true" defined-by="technology" status="active" testable="false">
					<id>PERSISTENCE:SPEC:638</id>
					<description>Accessing an entity in the removed state is undefined.</description>
					<location chapter="3" section="2.2"/>
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:639</id>
			<description>The state of persistent entities is synchronized with the database at transaction commit.</description>
			<location chapter="3" section="2.3"/>
		</assertion>
		<assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="false">
			<id>PERSISTENCE:SPEC:640</id>
			<description>The persistence provider runtime is permitted to perform [database] synchronization at other times as well, for example, before query execution.</description>
			<location chapter="3" section="2.3"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:641</id>
			<description>The flush method can be used to force synchronization.  It applies to entities associated with a persistence context.  The semantics of the flush operation, applied to entity X are as follows:</description>
			<location chapter="3" section="2.3"/>
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:642</id>
					<description>If X is a managed entity, it is synchronized to the database.</description>
					<location chapter="3" section="2.3"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:643</id>
					<description>For all entities Y referenced by a relationship from X, if the relationship to Y has been annotated with the cascade element value cascade=PERSIST, the persist operation is applied to Y.</description>
					<location chapter="3" section="2.3"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:644</id>
					<description>For all entities Y referenced by a relationship from X, if the relationship to Y has been annotated with the cascade element value cascade=ALL, the persist operation is applied to Y.</description>
					<location chapter="3" section="2.3"/>
				</assertion>
				<assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:645</id>
					<description>For any new entity Y referenced by a relationship from X, where the relationship to Y has not been annotated with the cascade element cascade=PERSIST or cascade=ALL, an exception will be thrown by the flush operation or the transaction commit will fail.</description>
					<location chapter="3" section="2.3"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:646</id>
					<description>For any detached entity Y referenced by a relationship from X, where the relationship to Y has not been annotated with the cascade element value cascade=PERSIST or cascade=ALL, the semantics depend upon the ownership of the relationship:  If X owns the relationship, any changes to the relationship are synchronized with the database.</description>
					<location chapter="3" section="2.3"/>
				</assertion>
				<assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="false">
					<id>PERSISTENCE:SPEC:647</id>
					<description>For any detached entity Y referenced by a relationship from X, where the relationship to Y has not been annotated with the cascade element value cascade=PERSIST or cascade=ALL, the semantics depend upon the ownership of the relationship: If Y owns the relationships, the behavior is undefined.</description>
					<location chapter="3" section="2.3"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:648</id>
					<description>If X is a removed entity, it is removed from the database.</description>
					<location chapter="3" section="2.3"/>
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:649</id>
			<description>When the persistence context ends, managed entity instances associated with the context become detached.  
			The application may safely access their available state of available detached entity instances after the persistence context ends.  The available state includes:</description>
			<location chapter="3" section="2.4"/>
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:650</id>
					<description>Any persistent field or property not marked fetch=LAZY</description>
					<location chapter="3" section="2.4"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:651</id>
					<description>Any persistent field or property that was accessed by the application.</description>
					<location chapter="3" section="2.4"/>
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:652</id>
			<description>If the persistent field or property is an associationm, the state of an associated instance may only be safely accessed if the associated instance is available.
			The available instances include:</description>
			<location chapter="3" section="2.4"/>
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:653</id>
					<description>All entity instances retrieved using find().</description>
					<location chapter="3" section="2.4"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:654</id>
					<description>Any entity instances retrieved using a query or explictly requested in the FETCH JOIN clause.</description>
					<location chapter="3" section="2.4"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:655</id>
					<description>Any entity instance for which an instance variable holding non-primary-key persistent state was accessed by the application.</description>
					<location chapter="3" section="2.4"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:656</id>
					<description>Any entity instance that may be reached from another available instance by navigating associations marked fetch=EAGER.</description>
					<location chapter="3" section="2.4"/>
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:657</id>
			<description>A detached entity may also result by serializing an entity, or otherwise passing it by value (e.g., to a separate application tier,through a remote inteface, etc.) and the same rules apply.</description>
			<location chapter="3" section="2.4"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:658</id>
			<description>The merge operation allows for the propagation of state from detached entities onto persistent entities managed by the Entity Manager.  The semantics of the merge operation applied to an entity X are as follows:</description>
			<location chapter="3" section="2.4.1"/>
			<sub-assertions>
				<assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:659</id>
					<description>If X is a detached entity, it is copied onto pre-existing managed entity instance X1 of the same identity or a new managed copy of X is created.</description>
					<location chapter="3" section="2.4.1"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:660</id>
					<description>If X is a new entity instance, a new managed entity instance X1 is created and the state of X is copied into the new managed entity instance X1.</description>
					<location chapter="3" section="2.4.1"/>
				</assertion>
				<assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:661</id>
					<description>If X is a removed entity instance, an IllegalArgumentException will be thrown by the merge operation (or the transaction commit will fail).</description>
					<location chapter="3" section="2.4.1"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:662</id>
					<description>If X is a managed entity, it is ignored by the merge operation, however, the merge operation is cascaded to entities referenced by relationships from X if these relationships have been annotated with the cascade element value cascade=MERGE annotation.</description>
					<location chapter="3" section="2.4.1"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:663</id>
					<description>If X is a managed entity, it is ignored by the merge operation, however, the merge operation is cascaded to entities referenced by relationships from X if these relationships have been annotated with the cascade element value cascade=ALL annotation.</description>
					<location chapter="3" section="2.4.1"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:664</id>
					<description>For all entities Y referenced by relationships from X having the cascade element value cascade=MERGE, Y is merged recursively as Y1.  For all such Y referenced by X, X1 is set to reference Y1.</description>
					<location chapter="3" section="2.4.1"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:665</id>
					<description>For all entities Y referenced by relationships from X having the cascade element value cascade=ALL, Y is merged recursively as Y1.  For all such Y referenced by X, X1 is set to reference Y1.</description>
					<location chapter="3" section="2.4.1"/>
				</assertion>
				<assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:666</id>
					<description>Version colunms used by the entity should be checked by the persistence runtime implementation during the merge operation or at flush or commit time.</description>
					<location chapter="3" section="2.4.1"/>
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:667</id>
			<description>The contains method [used to determine whether an entity instance is in the managed state] returns true:</description>
			<location chapter="3" section="2.5"/>
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:668</id>
					<description>If the entity has been retrieved from the database and has not been removed or detached.</description>
					<location chapter="3" section="2.5"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:669</id>
					<description>If the entity instance is new and the persist method has been called on the entity.</description>
					<location chapter="3" section="2.5"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:670</id>
					<description>If the entity instance is new and  the persist operation has been cascaded to it.</description>
					<location chapter="3" section="2.5"/>
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:671</id>
			<description>The contains method [used to determine whether an entity instance is in the managed state] returns false:</description>
			<location chapter="3" section="2.5"/>
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:672</id>
					<description>If the instance is detached.</description>
					<location chapter="3" section="2.5"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:673</id>
					<description>If the remove method has been called on the entity.</description>
					<location chapter="3" section="2.5"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:674</id>
					<description>If the remove operation has been cascaded to it.</description>
					<location chapter="3" section="2.5"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:675</id>
					<description>If the entity instance is new and the persist method has not been called on the entity.</description>
					<location chapter="3" section="2.5"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:676</id>
					<description>If the entity instance is new and  the persist operation has not been cascaded to it.</description>
					<location chapter="3" section="2.5"/>
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:677</id>
			<description>Not that the effect of cascading persist or remove is immediately visible to the contains method, whereas, the actual
			insertion or deletion of the database representation for the entity may be deferred until the end of the transaction.</description>
			<location chapter="3" section="2.5"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:678</id>
			<description>The enum PersistenceContextType is used to define persistence context lifetime scope for container-managed entity managers.</description>
			<location chapter="3" section="3"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:679</id>
			<description>By default, a persistence context's lifecycle corresponds to the scope of a transaction (PersistenceContextType.TRANSACTION).</description>
			<location chapter="3" section="3"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:680</id>
			<description>When an extended persistence context is used, the extended persistence contexts exists from the time the EntityManager instance is created
			until it is closed.  This persistence context might span multiple transactions and non-transactional invocations of the EntityManager.</description>
			<location chapter="3" section="3"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:681</id>
			<description>An EntityManager with an extended persistence context maintains its references to the entity objects after a transaction has committed.
			Those objects remain managed by the EntityManager and they may be updated as managed objects between transactions.</description>
			<location chapter="3" section="3"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:682</id>
			<description>Navigation from a managed object in an extended persistence context results in one or more other managed objects regardless of
			whether a transaction is active.</description>
			<location chapter="3" section="3"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:683</id>
			<description>When an EntityManager with an extended persistence context is used, the persist, remove, merge and refresh operations
			may be called regardless of whether a transaction is active.  The effects of these operations will be committed to the database when the 
			extended persistence context is entlisted in a transaction and the transaction commits.</description>
			<location chapter="3" section="3"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:684</id>
			<description>The scope of the persistence context of an application-managed entity manager is extended.  It is the responsibility
			of the application to manage the lifecycle of the persistence context.</description>
			<location chapter="3" section="3"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:685</id>
			<description>The managed entities of a transaction-scoped persistence context become detached when the transaction commits.</description>
			<location chapter="3" section="3.1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:686</id>
			<description>The managed entities of an extended persistence context remain managed.</description>
			<location chapter="3" section="3.1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:687</id>
			<description>For both transaction-scoped and extended persistence contexts, transaction rollback causes all pre-existng managed instances and removed 
			instances to become detached.</description>
			<location chapter="3" section="3.2"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:688</id>
			<description>Optmistic Locking and Concurrency</description>
			<location chapter="3" section="4"/>
		</assertion>
		<assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:689</id>
			<description>Optimistic Locking</description>
			<location chapter="3" section="4.1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:690</id>
			<description>Version Attributes</description>
			<location chapter="3" section="4.2"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:691</id>
			<description>Lock Modes</description>
			<location chapter="3" section="4.3"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:692</id>
			<description>OptimisticLockException</description>
			<location chapter="3" section="4.4"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:693</id>
			<description>OptimisticLockException always causes the transaction to roll back.</description>
			<location chapter="3" section="4.4"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:694</id>
			<description>Lifecycle callback methods and entity listener classes are defined by means of metadata annotations or in the XML descriptor.</description>
			<location chapter="3" section="5"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:695</id>
			<description>When annotations are used, one or more entity listener classes are denoted using the EntityListeners annoation on the
			entity class or mapped superclass.</description>
			<location chapter="3" section="5"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:696</id>
			<description>If multiple entity listeners are defined, the order in wihch they are invoked is determined by the order in which they are specified
			in the EntityListeners annotation.</description>
			<location chapter="3" section="5"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:697</id>
			<description>The XML descriptor may be used as an alternative to specify the invocation order of the entity listeners or to override the order specified in metadata annotations..</description>
			<location chapter="3" section="5"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:698</id>
			<description>Any subset or combination of annotations may be specified on an entity class, mapped superclass, of listener class..</description>
			<keywords>
				<keyword>application-role</keyword>
			</keywords>
			<location chapter="3" section="5"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:699</id>
			<description>A single class may not have more than one lifecycle callback method for the same lifecycle event.  The same method may be used for multiple callback events.</description>
			<keywords>
				<keyword>application-role</keyword>
			</keywords>
			<location chapter="3" section="5"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:700</id>
			<description>Multple entity classes and mapped superclasses in an inheritance hierarchy may define listener classes and/or lifecycle callback methods directly on the class.</description>
			<keywords>
				<keyword>application-role</keyword>
			</keywords>
			<location chapter="3" section="5"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:701</id>
			<description>The entity listener class must have a public no-arg constructor.</description>
			<keywords>
				<keyword>application-role</keyword>
			</keywords>
			<location chapter="3" section="5"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:702</id>
			<description>The following rules apply to callbacks:</description>
			<location chapter="3" section="5"/>
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:703</id>
					<description>Callback methods may throw unchecked/runtime exceptions.</description>
					<keywords>
						<keyword>application-role</keyword>
					</keywords>
					<location chapter="3" section="5"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:704</id>
					<description>A runtime exception thrown by a callback method that executes within a transaction causes that transaction to be rolled back.</description>
					<location chapter="3" section="5"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:705</id>
					<description>Lifecycle callbacks can invoke JNDI, JDBC, JMS, and enterprise beans.</description>
					<keywords>
						<keyword>application-role</keyword>
						<keyword>application-server-role</keyword>
					</keywords>
					<location chapter="3" section="5"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
					<id>PERSISTENCE:SPEC:706</id>
					<description> In general, portable applications should not invoke EntityManager
					or Query operations, access other entity instances or modify relationships in a lifecycle callback method.</description>
					<location chapter="3" section="5"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:707</id>
					<description>When invoked from within a JavaEE environment, the callback listener for an entity share the enterprise
					naming context of the invoking component, and the entity callback methods are invoked in the transaction and
					security contexts of the calling component at the time at which the callback method is invoked.</description>
					<location chapter="3" section="5"/>
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:708</id>
			<description>The PrePersist and PreRemove callback methods are invoked for a given entity before the respective EntityManager persist and remove operation for that entity are executed
			These callbacks will also be invoked on entities to which these operations are cascaded.</description>
			<location chapter="3" section="5.2"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:709</id>
			<description>The PrePersist and PreRemove callbacks will always be invoked on all entities which these operations are cascaded.</description>
			<location chapter="3" section="5.2"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:710</id>
			<description>For entities which the merge operation has been applied and causes the creation of newly managed instaced, the PrePersist callback methods 
			will be invoked for the managed instance after the entity state has been copied to it.</description>
			<location chapter="3" section="5.2"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:711</id>
			<description>The PrePersist and PreRemove callbacks will always be invoked as part of the synchronous persist, merge, and remove operations..</description>
			<location chapter="3" section="5.2"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:712</id>
			<description>The PostPersist and PostRemove callback methods are invoked after the entity has been made persistent or removed.
				These callbacks will also be invoked on entities to which these operations are cascaded.</description>
			<location chapter="3" section="5.2"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:713</id>
			<description>The PostPersist and PostRemove methods will be invoked after the database insert and delete operations respectively. 
				</description>
			<location chapter="3" section="5.2"/>
		</assertion>
		<assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="false">
			<id>PERSISTENCE:SPEC:714</id>
			<description>These database operations may occur directly after the persist, merge, or remove operations have been invoked or they may occur directly
			after a flush operation has occurred (which may be at the end of the transaction).</description>
			<location chapter="3" section="5.2"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:715</id>
			<description>Generated primary key values are available in the PostPersist method.</description>
			<location chapter="3" section="5.2"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:716</id>
			<description>The PreUpdate and PostUpdate callbacks occur before and after the database update operations to entity data respectively.  </description>
			<location chapter="3" section="5.2"/>
		</assertion>
		<assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="false">
			<id>PERSISTENCE:SPEC:717</id>
			<description>These database operations may be at the time the entity state is updated or it may be at the time state is flushed to the database which may be at the end of a transaction.</description>
			<location chapter="3" section="5.2"/>
		</assertion>
		<assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="false">
			<id>PERSISTENCE:SPEC:718</id>
			<description>Note it is implementation-dependent as to whether PreUpdate and PostUpdate callbacks occur when an entity is created and subsequently modified in a single transaction or when an entity is modified and subsequently removed within a single transaction.  Portable applications should not rely on such behavior.</description>
			<location chapter="3" section="5.2"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:719</id>
			<description>The PostLoad method is invoked after an entity has been loaded into the current persistence context from the database.</description>
			<location chapter="3" section="5.2"/>
		</assertion>
		<assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:720</id>
			<description>This PostLoad method is invoked before a query result is returned or accessed or before an association is traversed.</description>
			<location chapter="3" section="5.2"/>
		</assertion>
		<assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="false">
			<id>PERSISTENCE:SPEC:721</id>
			<description>It is implementation-dependent as to whether callback methods are invoked before or after the cascading of the lifecycle events to
			related entities.   Applications should not depend on this ordering.</description>
			<location chapter="3" section="5.2"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:722</id>
			<description>Default listeners, if any, are invoked first, in the order specified in the XML descriptor.  Default listeners
					apply to all entities in the persistence unit, unless explicitly excluded by means of the ExcludeDefaultListeners annotation
					or exclude-default-listeners XML element.</description>
			<location chapter="3" section="5.4"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:723</id>
			<description>The lifecycle callback methods defined on the entity listener classes for an entity class or mapped superclass are invoked
					in the same order as the specification of the entity listener classes in the EntityListeners annotation.</description>
			<location chapter="3" section="5.4"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:724</id>
			<description>If multiple classes in an inheritance hierarchy - entity classes and/or mapped superclasses - define entity listeners
					the listeners defined for a superclass are invoked before the listeners and defined for its subclasses in this order.</description>
			<location chapter="3" section="5.4"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:725</id>
			<description>The ExcludeSuperclassListeners annotation or exclude-superclass-listeners XML element may be applied to an
					entity class or mapped super class to exclude the invocation of the listeners defined on the entity listener classes for the
					superclasses of the entity or maped supeclass.  The excluded listeners are excluded from the class to which the
					ExcludeSuperclassListeners annotation is specified and its subclasses.</description>
			<location chapter="3" section="5.4"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:726</id>
			<description>Excluded listeners may reintroduced on an entity class by listing them explicitly in the
					EntityListeners annotation or XML entity-listeners element.</description>
			<location chapter="3" section="5.4"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:727</id>
			<description>The ExcludeSuperclassListeners or exclude-superclass-listeners XML element does not cause the
					default entity listeners to be excluded from invocation.</description>
			<location chapter="3" section="5.4"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:728</id>
			<description>The elements of a query result whos SELECT clause consists of more than one value are of type Object[].</description>
			<location chapter="3" section="6"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:729</id>
			<description>An IllegalArgumentException is thrown if:</description>
			<location chapter="3" section="6"/>
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:730</id>
					<description>a parameter name is specified that does not correspond to a named parameter in the query string</description>
					<location chapter="3" section="6"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:731</id>
					<description>a positional value is specified that does not correspond to a positional parameter in the query string</description>
					<location chapter="3" section="6"/>
				</assertion>
				<assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:732</id>
					<description>If the type of the parameter is not valid for the query.  This exception may be thrown when the parameter is bound, or the execution of the query may fail.</description>
					<location chapter="3" section="6"/>
				</assertion>
				<assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:733</id>
					<description>This exception may be thrown when the parameter is bound, or the execution of the query may fail.</description>
					<location chapter="3" section="6"/>
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:734</id>
			<description>A named parameter is an identifier that is prefixed by the ":" symbol.</description>
			<location chapter="3" section="6.2"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:735</id>
			<description>By default, all queries are polymorphic.</description>
			<location chapter="3" section="6.4"/>
		</assertion>
		<assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:736</id>
			<description>The SQL query facility is intended to provide support for those cases where it is necessary to use the native SQL of the target database in use (and/or where Java Persistence QL cannot be used).  Native SQL queries are not expected to be portable across databases.</description>
			<keywords>
				<keyword>application-role</keyword>
			</keywords>
			<location chapter="3" section="6.5"/>
		</assertion>
		<assertion required="false" impl-spec="true" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:737</id>
			<description>The use of named parameters is not defined for native queries. Only positional parameter binding may be portably used.</description>
			<keywords>
				<keyword>application-role</keyword>
			</keywords>
			<location chapter="3" section="6.5"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:738</id>
			<description>Summary of Exceptions</description>
			<location chapter="3" section="7"/>
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:739</id>
					<description>PersistenceException</description>
					<location chapter="3" section="7"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:740</id>
					<description>TransactionRequiredException</description>
					<location chapter="3" section="7"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:741</id>
					<description>RollbackException</description>
					<location chapter="3" section="7"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:742</id>
					<description>EntityExistsException</description>
					<location chapter="3" section="7"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:743</id>
					<description>EntityNotFoundException</description>
					<location chapter="3" section="7"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:744</id>
					<description>NoResultException</description>
					<location chapter="3" section="7"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:745</id>
					<description>NonUniqueResultException</description>
					<location chapter="3" section="7"/>
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:746</id>
			<description>An query language statement may be either:</description>
			<location chapter="4" section="2"/>
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:746.1</id>
					<description>a select statement</description>
					<location chapter="4" section="2"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:746.2</id>
					<description>an update statement</description>
					<location chapter="4" section="2"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:746.3</id>
					<description>a delete statement</description>
					<location chapter="4" section="2"/>
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:750</id>
			<description>Any query language statement may be constructed dymically or may be statically defined in a metadata annotation or XML descriptor element.</description>
			<location chapter="4" section="2"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:751</id>
			<description>All query language statement types may have parameters.</description>
			<location chapter="4" section="2"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:752</id>
			<description>An query language select statement is a string which consists of the following clauses:</description>
			<location chapter="4" section="2.1"/>
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:753</id>
					<description>a SELECT clause, which determines the type of the objects or values to be selected.</description>
					<location chapter="4" section="2.1"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:754</id>
					<description>a FROM clause, which provides declaration that designate the domain to which the expressions specified in the other clauses of the query apply</description>
					<location chapter="4" section="2.1"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:755</id>
					<description>an optional WHERE clause, which may be used to restrict the results that are returned by the query</description>
					<location chapter="4" section="2.1"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:756</id>
					<description>an optional GROUP BY clause, which allows query results to be aggregated in terms of groups</description>
					<location chapter="4" section="2.1"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:757</id>
					<description>an optional HAVING clause, which allows filtering over aggregated groups</description>
					<location chapter="4" section="2.1"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:758</id>
					<description>an optional ORDER BY clause, which may be used to order the results that are returned by the query</description>
					<location chapter="4" section="2.1"/>
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:312</id>
			<description>A select statement must always have a SELECT and a FROM clause.</description>
			<keywords>
				<keyword>application-role</keyword>
				<keyword>application-server-role</keyword>
			</keywords>
			<location chapter="4" section="2.1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:759</id>
			<description>Update and delete statements provide bulk operations over sets of entities.  The update and delete clauses determine the type
					of the entities to be updated or deleted.  The WHERE clause may be used to restrict the scope of the update or delete operation.
					Compatibility Note:  Update and delete statements are not supported for EJB 2.1 entity beans with container-managed persistence.</description>
			<location chapter="4" section="2.2"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:760</id>
			<description>The abstract schema type of an entity is derived from the entity class and the metadata
			information provided by Java Language annotations or in the XML descriptor.</description>
			<location chapter="4" section="3"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:761</id>
			<description>The domain of a query consists of the abstract schema types of all entities that are defined in the same persistence unit.</description>
			<location chapter="4" section="3"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:762</id>
			<description>The abstract schema name is defined by the name element of the Entity annotation (or entity-name XML descriptor element), and
			defaults to the unqualified name of the entity class.</description>
			<location chapter="4" section="3.1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:317</id>
			<description>Identification variables designate instances of a particular entity abstract schema type.   The FROM clause can contain
			multiple identification variable declarations separated by a comma:</description>
			<location chapter="4" section="4"/>
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:317.1</id>
					<description>range_variable_declaration
					</description>
					<location chapter="4" section="4"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:317.2</id>
					<description>collection_member_declaration
					</description>
					<location chapter="4" section="4"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:317.3</id>
					<description>join_spec</description>
					<location chapter="4" section="4"/>
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:316</id>
			<description>Reserved identifiers are case insensitive.</description>
			<location chapter="4" section="4.1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:763</id>
			<description>Reserved identifiers must not be used as identification variables.</description>
			<location chapter="4" section="4.1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:764</id>
			<description>All identification variables must be declared in teh FROM clause.  Identification variables cannot be declared in other clauses.</description>
			<location chapter="4" section="4.2"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:318</id>
			<description>An identification variable must not be a reserved identifier or have the same name as any of the followng in the same persistence unit:</description>
			<keywords>
				<keyword>application-role</keyword>
				<keyword>application-server-role</keyword>
			</keywords>
			<location chapter="4" section="4.2"/>
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:318.3</id>
					<description>entity name (as defined by the Entity annotation or entity-name XML deployment descriptor element</description>
					<location chapter="4" section="4.2"/>
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:319</id>
			<description>Identification variables are case insensitive.</description>
			<location chapter="4" section="4.2"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:320</id>
			<description>In order to select values by comparing more than one instance of an entity abstract schema type, more than one identification variable ranging over the entity's abstract schema type is needed in the FROM clause.</description>
			<location chapter="4" section="4.3"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:322</id>
			<description>A single_valued_association_field is designated by the name of an association-field in a one-to-one or many-to-one relationship.  The type of a single_valued_association_field and thus a single_valued_association_path_expression is the abstract schema type of the related entity.</description>
			<location chapter="4" section="4.4"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:323</id>
			<description>A collection_valued_association_field is designated by the name of an association-field in a one-to-many or a many-to-many relationship. The type of a collection_valued_association_field is a collection of values of the abstract schema type of the related entity.</description>
			<location chapter="4" section="4.4"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
			<id>PERSISTENCE:SPEC:325</id>
			<description>A path expression that ends in a simple state-field, rather than an embedded class, is terminal and cannot be further composed.</description>
			<location chapter="4" section="4.4"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
			<id>PERSISTENCE:SPEC:326</id>
			<description>A path expression that leads to an association-field may be further composed.  Path expressions can be composed from other path expression if the original path expression evaluates to a single-valued type (not a collection) corresponding to an association-field.</description>
			<location chapter="4" section="4.4"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:328</id>
			<description>The evaluation of a path expression terminating in a state-field results in the abstract schema type corresponding to the Java type designed by the state-field.</description>
			<location chapter="4" section="4.4"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:329</id>
			<description>Path expression navigability is composed using "inner join" semantics.  That is, if the value of a non-terminal association-field in the path expression is null, the path is considered to have no value, and does not participate in the determination of the result.</description>
			<location chapter="4" section="4.4"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:765</id>
			<description>The syntax for single-valued path expressions and collection valued path expression is as follows:</description>
			<location chapter="4" section="4.4"/>
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:766</id>
					<description>single_valued_path_expression ::= state_field_path_expression | single_valued_association_path_expression</description>
					<location chapter="4" section="4.4"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:767</id>
					<description>state_field_path_expression ::= {identification_variable | single_valued_association_path_expression}.state_field</description>
					<location chapter="4" section="4.4"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:768</id>
					<description>single_valued_association_path_expression ::= identification_variable.{single_valued_association_field.}*single_valued_association_field</description>
					<location chapter="4" section="4.4"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:769</id>
					<description>collection_valued_path_expression ::= identification_variable.{single_valued_association_field.}*collection_valued_association_field</description>
					<location chapter="4" section="4.4"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:770</id>
					<description>state_field := simple_state_field | {embedded_class_state_field.}*simple_state_field</description>
					<location chapter="4" section="4.4"/>
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:771</id>
			<description>Navigation to a related entity results in a value of the related entity's abstract schema type.</description>
			<location chapter="4" section="4.4"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:772</id>
			<description>The evaluation of a path expression terminating in a state-field results in the abstract schema type corresponding to the Java type designated by the state-field.</description>
			<location chapter="4" section="4.4"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:773</id>
			<description>An inner join may be implicitly specified by the use of a cartesian product in the FROM clause and a join condition in the WHERE clause.</description>
			<location chapter="4" section="4.5"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:774</id>
			<description>The syntax for explicit join operations is as follows:</description>
			<location chapter="4" section="4.5"/>
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:775</id>
					<description>join ::= join_spec association_path_expression [AS] identification_variable</description>
					<location chapter="4" section="4.5"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:776</id>
					<description>fetch_join ::= join_spec FETCH association_path_expression</description>
					<location chapter="4" section="4.5"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:777</id>
					<description>association_path_expression ::= collection_valued_path_expression | single_valued_association_path_expression</description>
					<location chapter="4" section="4.5"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:778</id>
					<description>join ::= join_spec::=[LEFT [OUTER] | INNER] JOIN</description>
					<location chapter="4" section="4.5"/>
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:779</id>
			<description>The syntax for the inner join operation is:  [INNER] JOIN association_path_expression [AS] identification_variable</description>
			<location chapter="4" section="4.5.1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:780</id>
			<description>LEFT JOIN and LEFT OUTER JOIN are synonymous.  They enable retrieval of a set of entities where matching values in the join condition
					may be absent.  The syntax for a left outer join is:  LEFT [OUTER] JOIN association_path_expression [AS] identification_variable</description>
			<location chapter="4" section="4.5.2"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:781</id>
			<description>A FETCH JOIN enables the fetching of an association as a side effect of the execution of a query.  A FETCH JOIN is specified over an entity and its related entities.
					The syntax for a fetch join is:  fetch_join ::= [LEFT [OUTER] | INNER ] JOIN FETCH association_path_expression</description>
			<location chapter="4" section="4.5.3"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:782</id>
			<description>The association referenced by the right side of the FETCH JOIN clause must be an association that belongs to an entity that is returned
					as a result of the query.   It is not permitted to specify an identification variable for the entities referenced by the right side of the FETCH JOIN clause, and hence
					references to the implicitly fetched entities cannot appear elsewhere in the query.</description>
			<location chapter="4" section="4.5.3"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:321</id>
			<description>An identification variable of a collection member declaration is declared using a special operator, the reserved identifier IN.  The argument to the IN operator takes a collection valued path expression.</description>
			<location chapter="4" section="4.6"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:783</id>
			<description>The path expression evaluates to a collection type specified as a result of navigation to a collection-valued association-field of an entity abstract schena type.</description>
			<location chapter="4" section="4.6"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:784</id>
			<description>Java Persistence queries are automatically polymorphic.  The FROM clause of a query designates not only instances of the specific entity class(es) to which explictly refers but of subclasses as well.  The instances returned by a query include instances of the subclasses that satisfy the query criteria.</description>
			<location chapter="4" section="4.8"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:785</id>
			<description>The WHERE clause restricts the result set of a select statement or the scope of an update or delete operation.  
			A WHERE clause is defined as follows:  where_clause ::= WHERE conditional_expression</description>
			<location chapter="4" section="5"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:330</id>
			<description>A string literal is enclosed in single quotes.  A string literal that includes a single quote is represented by two single quotes. EJB-QL string literals are like Java String literals in that they use unicode character encoding. </description>
			<location chapter="4" section="6.1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:331</id>
			<description>An exact numeric literal is a numeric value without a decimal point.  Exact numeric literals support numbers in the range of Java long. </description>
			<location chapter="4" section="6.1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:332</id>
			<description>Although predefined reserved literals appear in upper case, they are case insensitive.</description>
			<location chapter="4" section="6.1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:333</id>
			<description>An approximate numeric literal is a value in scientific notation.  Approximate numeric literal support numbers in the range of Java double. </description>
			<location chapter="4" section="6.1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:334</id>
			<description>The boolean literals are TRUE and FALSE. </description>
			<location chapter="4" section="6.1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:786</id>
			<description>All identification variables used in the WHERE or HAVING clause of a SELECT or DELETE statement must be declared
			in the FROM clause. 
			</description>
			<location chapter="4" section="6.2"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:787</id>
			<description>The identification variables used in the WHERE clause of an UPDATE statement must  be declared in the UPDATE clause.
			</description>
			<location chapter="4" section="6.2"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:788</id>
			<description>It is illegal to use a collection_valued_path_expression within a WHERE or HAVING clause as part of a conditional
			expression except in an empty_collection_comparison_expression or collection_member_expression, or as an argument to the SIZE operator.
			</description>
			<location chapter="4" section="6.3"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:336</id>
			<description>If an input parameter is NULL, arithmetic operations involving the input
		 parameter will return an UNKNOWN value 
			</description>
			<location chapter="4" section="6.4"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:337</id>
			<description>If an input parameter is NULL, comparison operations involving the input parameter will return an UNKNOWN value.  NOTE:  Duplicate assertion to: PERSISTENCE:SPEC:342. Recheck tagged test code and remedy list accordingly. </description>
			<location chapter="4" section="6.4"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:338</id>
			<description>Input parameters are numbered starting from 1</description>
			<location chapter="4" section="6.4.1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:341</id>
			<description>An input parameter evaluates to the abstract schema type of the corresponding parameter defined in the signature of the finder or select method with which the query is associated.  It is the responsible of the Container to map the input parameter to the appropriate abstract schema type value.</description>
			<location chapter="4" section="6.4.1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:789</id>
			<description>A named parameter is an identifier that is prefixed by the ":" symbol.  It follows the rules for identifiers in Section 3.4.1.</description>
			<location chapter="4" section="6.4.2"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:342</id>
			<description>Note that if an input parameter is Null, comparison operations involving the input parameter will return an unknown value.</description>
			<location chapter="4" section="6.4"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:343</id>
			<description>Note that if an input parameter is Null, arithmetic operations involving the input parameter will return an unknown value.</description>
			<location chapter="4" section="6.4"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:344</id>
			<description>Arithmetic operations use numeric promotion.</description>
			<location chapter="4" section="6.5"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:345</id>
			<description>Conditional expressions are composed of other conditional expressions, comparison operators, logical operations, path expressions that evaluate to boolean values and boolean literals.</description>
			<location chapter="4" section="6.5"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:346</id>
			<description>Standard bracketing for ordering expression evaluation is supported.</description>
			<location chapter="4" section="6.5"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:347</id>
			<description>Arithmetic expressions can be used in comparison expressions.</description>
			<location chapter="4" section="6.5"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:348</id>
			<description>Operators and Operator Precedence.  The operators listed below in order of descreasing precedence.</description>
			<location chapter="4" section="6.6"/>
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:348.1</id>
					<description>Navigation Operator</description>
					<location chapter="4" section="6.6"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:348.2</id>
					<description>Arithmetic Operators (+,- unary - *,/ multiplication, division - +.- addition, substraction)</description>
					<location chapter="4" section="6.6"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:348.3</id>
					<description>Comparison Operators</description>
					<location chapter="4" section="6.6"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:348.4</id>
					<description>Logical Operators: NOT, AND, OR</description>
					<location chapter="4" section="6.6"/>
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:349</id>
			<description>The syntax for the use of the comparison operator [NOT] BETWEEN in a conditional expression is as follows: arithmetic_expression [NOT] BETWEEN arithmetic-expr AND arithmetic-expr</description>
			<location chapter="4" section="6.7"/>
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:349.1</id>
					<description>string_expression [NOT] BETWEEN string-expression AND string-expression</description>
					<location chapter="4" section="6.7"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:349.2</id>
					<description>datetime_expression [NOT] BETWEEN datetime-expression AND datetime-expression</description>
					<location chapter="4" section="6.7"/>
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:350</id>
			<description>The BETWEEN expression x BETWEEN y and z is semantically equivalent to: y less than = x AND x less than = z </description>
			<location chapter="4" section="6.7"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:351</id>
			<description>If the value of a state_field_path_expression in an IN or NOT IN expression is 
NULL or UNKNOWN, the value of the expression is UNKNOWN.
			</description>
			<location chapter="4" section="6.8"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:352</id>
			<description>The syntax for the use of the comparison operator IN in a conditional expression is as follows: state_field_path_expression [NOT] IN({literal | input parameter} [, {literal | input_parameter}]*} | subquery).  The state_field_path_expression must have a string or numeric value.</description>
			<keywords>
				<keyword>application-role</keyword>
				<keyword>application-server-role</keyword>
			</keywords>
			<location chapter="4" section="6.8"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:352.1</id>
			<description>The literal and/or input parameter values must be like the same abstract schema type of the  state_field_path_expression in type.</description>
			<keywords>
				<keyword>application-role</keyword>
				<keyword>application-server-role</keyword>
			</keywords>
			<location chapter="4" section="6.8"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:352.2</id>
			<description>The results of the subquery must be like the same abstract schema type of the state_field_path_expression in type.</description>
			<keywords>
				<keyword>application-role</keyword>
				<keyword>application-server-role</keyword>
			</keywords>
			<location chapter="4" section="6.8"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:353</id>
			<description>There must be at least one element in the comma separated list that defines the set of values for the IN expression.</description>
			<keywords>
				<keyword>application-role</keyword>
				<keyword>application-server-role</keyword>
			</keywords>
			<location chapter="4" section="6.8"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:354</id>
			<description>The expression o.country IN ('UK', 'US', 'France') is equivalent to the expression (o.country = 'UK') OR (o.country = 'US') OR (o.country = 'France')</description>
			<location chapter="4" section="6.8"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:355</id>
			<description>The expression o.country NOT IN ('UK', 'US', 'France') is equivalent to the expression NOT (o.country = 'UK') OR (o.country = 'US') OR (o.country = 'France')</description>
			<location chapter="4" section="6.8"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:356</id>
			<description>If the value of a single-valued path expression or pattern_value is NULL or UNKNOWN, the value of the
LIKE expression is UNKNOWN.
			</description>
			<location chapter="4" section="6.9"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:357</id>
			<description>If the escape_character is specified as a NULL, the value of the LIKE expression is iunknown.</description>
			<location chapter="4" section="6.9"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:358</id>
			<description>The syntax for the use of the comparison operator [NOT] LIKE in a conditional expression is as follows: state_field_path_expression [NOT] LIKE pattern-value [ESCAPE escape-character].   The state_field_path_expression must have a String value.  The pattern-value is a string
literal or a string-valued input parameter in which an underscore stands for any single character, a percent character stands for any sequence of characters and all other characters stand for themselves.  The  optional escape-character is a single character string literal or a character-valued input parameter (i.e., char or Character) and is used to escape the special meaning of the underscore and percent characters in pattern-value.
			</description>
			<location chapter="4" section="6.9"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:359</id>
			<description>The syntax for the use of the comparison operator IS [NOT] NULL in a conditional expression is as follows: single_valued_path_expression | input parameter IS [NOT] NULL. A null comparison expression tests whether or not the single valued path expression is a NULL value.</description>
			<location chapter="4" section="6.10"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
			<id>PERSISTENCE:SPEC:360</id>
			<description>The collection designated by the collection-valued path expression used in an empty collection comparison expression must not be used in the FROM clause for the declaration of an identification variable.</description>
			<location chapter="4" section="6.11"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:361</id>
			<description>The syntax for the use of the comparison operator IS  [NOT] EMPTY in an empty_collection_comparison_expression is as follows: collection_valued_path_expression IS [NOT] EMPTY This expression tests whether or not the collection designated by the collection-valued
path expression is empty (that is, it has no elements).
			</description>
			<location chapter="4" section="6.11"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:362</id>
			<description>If the value of the collection-valued path expression in an empty collection comparison expression is unknown, the value of the
empty comparison expression is unknown.
			</description>
			<location chapter="4" section="6.11"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:363</id>
			<description>The syntax for the use of the comparison operator MEMBER OF in a collection_member_expression is as follows: entity_expression [NOT] MEMBER [OF] collection_valued_path_expression.
			entity_expression::= 
			 This expression tests whether the designated value is a member of the collection designated by the collection-valued path expression.</description>
			<location chapter="4" section="6.12"/>
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:363.1</id>
					<description>single_valued_association_path_expression</description>
					<location chapter="4" section="6.12"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:363.2</id>
					<description>identification variable</description>
					<location chapter="4" section="6.12"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:361.1</id>
					<description>input_parameter</description>
					<location chapter="4" section="6.12"/>
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:364</id>
			<description>If the value of the collection-valued path expression or single-valued association-field path expression in the collection member expression is NULL, the value of the collection member expression is unknown.</description>
			<location chapter="4" section="6.12"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:365</id>
			<description>If the collection valued path expression designates an empty collection, the value of the the MEMBER OF expression is FALSE and the value of the NOT MEMBER OF expression is TRUE.</description>
			<location chapter="4" section="6.12"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:366</id>
			<description>If the value of the single-valued association-field path expression in the collection member expression is unknown, the value of the empty comparison expression is unknown.  If the collection valued path expressiuon designates an empty collection, the value of the expression is FALSE.</description>
			<location chapter="4" section="6.12"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:791</id>
			<description>An EXISTS expression is a predicate that is true only if the result of the subquery consists of one or more values and that is false otherwise.</description>
			<location chapter="4" section="6.13"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:792</id>
			<description>The syntax of an exists expression is: exists_expression::= [NOT] EXISTS (subquery)</description>
			<location chapter="4" section="6.13"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:793</id>
			<description>An ALL conditional expression is a predicate that is true if the comparison operation is true for all values in the result of the subquery, and that is otherwise false.  If the result of the subquery is empty, the ALL condition is true.</description>
			<location chapter="4" section="6.14"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:794</id>
			<description>An ANY conditional expression is a predicate that is true if the comparison operation is true for all values in the result of the subquery, and that is otherwise false.</description>
			<location chapter="4" section="6.14"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:795</id>
			<description>The keyword SOME is synonymous with ANY.</description>
			<location chapter="4" section="6.14"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:796</id>
			<description>If the result of the subquery is empty, the ANY or SOME condition is false.</description>
			<location chapter="4" section="6.14"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:797</id>
			<description>The comparison operators used with ALL or ANY conditional expressions are =, &lt;, &lt;=, &gt;, &gt;=, &lt;&gt;.  The result of the subquery must be like that of the other argument to the comparison operator in type.</description>
			<location chapter="4" section="6.14"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:798</id>
			<description>The syntax of an ALL or ANY expression is specified as follows:  all_or_any_expression ::= {ALL | ANY | SOME} (subquery)</description>
			<location chapter="4" section="6.14"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:799</id>
			<description>Subqueries may be used in the WHERE or HAVING clause.</description>
			<location chapter="4" section="6.15"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:800</id>
			<description>The syntax for subqueries is as follows.</description>
			<location chapter="4" section="6.15"/>
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:801</id>
					<description>subquery ::= simple_select_clause from_clause [where_clause] [groupby_clause] [having_clause]</description>
					<location chapter="4" section="6.15"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:802</id>
					<description>simple_select_clause ::= SELECT [DISTINCT] select_expression</description>
					<location chapter="4" section="6.15"/>
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:367</id>
			<description>If the value of any argument to a functional expression is NULL or UNKNOWN, the value of the functional expression is UNKNOWN.</description>
			<location chapter="4" section="6.16"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:369</id>
			<description>Java Persistence QL includes the following built-in String functions which may be used in the WHERE clause of a query.
			</description>
			<location chapter="4" section="6.16.1"/>
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:369.1</id>
					<description>CONCAT(string_expression, string_expression).  The CONCAT function returns  a string that is a concatenation of its arguments.</description>
					<location chapter="4" section="6.16.1"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:369.2</id>
					<description>SUBSTRING(string_expression, arithmetic expression, arithmetic-expression).  The second and third argument of the SUBSTRING denote the starting
					position and length of the substring to be returned.  These arguments are integers.  The firstd position of a string is denoted by 1.  The SUBSTRING function
					returns a string.</description>
					<location chapter="4" section="6.16.1"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:369.3</id>
					<description>LOCATE(string_expression, string_expression[,arithmetic_expression]).  The LOCATE function returns the position of a given string within a string
					starting the search at a specified position. (NOTE:  Not all databases support the use of the third argument to LOCATE; use of this argument may result in queries that
					are not portable.)
					</description>
					<location chapter="4" section="6.16"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:369.4</id>
					<description>LENGTH(string_expression).  The LENGTH function returns the length of the string in characters as an integer.</description>
					<location chapter="4" section="6.16.1"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:369.9</id>
					<description>TRIM([[trim_sepcification] [trim_character] FROM] string_expression).  trim_specification ::=[LEADING | TRAILING | BOTH]
					The TRIM function trims the specified character from a string.If the character to be trimmed is note specified, it is assumed to be space (or blank).
					The optional trim_character is a single-character string liuteral or character-valued input parameter (i.e. char or Character).  The TRIM function
					returns the trimmed string.(NOTE:  Not all databases support the use of the trim_character other than a space character; use of this argument may result in queries
					that are not portable.)
					</description>
					<location chapter="4" section="6.16.1"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:369.10</id>
					<description>LOWER(string_expression). The LOWER function converts a string to upper case.  LOWER returns a string.</description>
					<location chapter="4" section="6.16.1"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:369.11</id>
					<description>UPPER (string_expression).  The UPPER function converts a string to upper case.  UPPER returns a string.</description>
					<location chapter="4" section="6.16.1"/>
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:369</id>
			<description>Java Persistence QL includes the following built-in Arithmetic functions which may be used in the WHERE clause of a query:
			</description>
			<location chapter="4" section="6.16.2"/>
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:369.5</id>
					<description>ABS(arithmetic_expression).  The ABS function takes a nueric argument and returns a number (integer, float, double) of the same type as the argument to the function.</description>
					<location chapter="4" section="6.16.2"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:369.6</id>
					<description>SQRT(arithmetic_expression).  The SQRT function takes a nuneric argument and returns a double.</description>
					<location chapter="4" section="6.16.2"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:369.7</id>
					<description>MOD(arithmetic_expression, arithmetic_expression).  The MOD function takes two integer argumetns and returns an integer.</description>
					<location chapter="4" section="6.16.2"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:369.8</id>
					<description>SIZE(collection_valued_path_expression).  The SIZE function returns an integer value, the number of elements of the collection.  If the collection is empty, the
					SIZE function evaluates to zero.</description>
					<location chapter="4" section="6.16.2"/>
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:368</id>
			<description>Numeric arguments to these functions may correspond to the numeric Java object types as well as the primitive numeric types.</description>
			<location chapter="4" section="6.16.2"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:803</id>
			<description>The GROUP BY construct enables the aggregation of values according to a set of properties. The HAVING construct enables conditions to be specified that further restrict the query result.  Such conditions are restrictions upon the groups.</description>
			<location chapter="4" section="7"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:804</id>
			<description>The syntax of the GROUP BY and HAVING clauses is as follows:</description>
			<location chapter="4" section="7"/>
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:805</id>
					<description>groupby_clause ::= GROUP BY groupby_item[,groupby_item]*</description>
					<location chapter="4" section="7"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:806</id>
					<description>groupby_item ::= state_field_path_expression</description>
					<location chapter="4" section="7"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:807</id>
					<description>having_clause ::= HAVING conditional_expression</description>
					<location chapter="4" section="7"/>
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:808</id>
			<description>If the query contains both a WHERE clause and a GROUP BY clause, the effect is that of first applying the where clause, and then forming the groups and filtering them to the HAVING clause. The HAVING cluase causes those groups to be retained that satisfy the conditiona of the HAVING clause.</description>
			<location chapter="4" section="7"/>
		</assertion>
		<assertion required="false" impl-spec="true" defined-by="technology" status="active" testable="false">
			<id>PERSISTENCE:SPEC:809</id>
			<description>If there is no GROUP BY clause and the HAVING clause is used, the effect is that of treating the result fo the query as a single group. The use of HAVING in the absence of GROUP BY is not required to be supported by an implementataion of this specification.  Portable applications should not rely on HAVING without the use of GROUP BY.</description>
			<location chapter="4" section="7"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:810</id>
			<description>The requirements for the SELECT clause when GROUP BY is used follow those of SQL; namely, any property that appears in the SELECT clause (other than as an argument to an aggregate function) must also appear in the GROUP BY clause.  In forming groups. null values are treated as the same for grouping purposes.</description>
			<location chapter="4" section="7"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:811</id>
			<description>The SELECT clause denotes the query result.  More than one value may be returned from the SELECT clause of a query.</description>
			<location chapter="4" section="8"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:372</id>
			<description>The SELECT clause may contain one or more of the following elements:</description>
			<location chapter="4" section="8"/>
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:372.1</id>
					<description>a single range variable</description>
					<location chapter="4" section="8"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:372.2</id>
					<description>identification variable that ranges over an entity abstract schema type</description>
					<location chapter="4" section="8"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:372.3</id>
					<description>a single-valued path expression</description>
					<location chapter="4" section="8"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:372.4</id>
					<description>an aggregate select expression</description>
					<location chapter="4" section="8"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:372.5</id>
					<description>a constructor expression</description>
					<location chapter="4" section="8"/>
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:814</id>
			<description>The SELECT clause has the following syntax:</description>
			<location chapter="4" section="8"/>
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:815</id>
					<description>select_clause ::= SELECT [DISTINCT] select_expression[,select_expression]*</description>
					<location chapter="4" section="8"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:816</id>
					<description>select_expression ::= {single_valued_path_expression | aggregate_select_expression | identification_variable | OBJECT(identification variable) | constructor_expression</description>
					<location chapter="4" section="8"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:817</id>
					<description>constructor_expression ::= NEW constructor_name([single_valued_path_expression | aggregate_select_expression} [,{single_valued_patch_expression | aggregate_select_expression}]*)</description>
					<location chapter="4" section="8"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:818</id>
					<description>aggregate_select_expression ::= {AVG | MAX | MIN | SUM | COUNT}([DISTINCT] state_field_path_expression) | COUNT ([DISTINCT] identification_variable | single_valued_association_path_expression)</description>
					<location chapter="4" section="8"/>
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:373</id>
			<description>All standalone identification variables in the SELECT clause may optionally be qualified by the OBJECT operator.</description>
			<location chapter="4" section="8"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:374</id>
			<description>The DISTINCT keyword is used to specify that duplicate values must be eliminated from the query result.</description>
			<location chapter="4" section="8"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:371</id>
			<description>If the query is specified for a method whose result type is java.util.Set, but does not specify DISTINCT, the container must interpret the query as if SELECT DISTINCT had been specified.</description>
			<location chapter="4" section="8"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
			<id>PERSISTENCE:SPEC:413</id>
			<description> If the query is specified for a method whose return type is java.util.Collection, the collection of values returned by the Container may contain duplicates if DISTINCT is not specified in the SELECT clause.</description>
			<location chapter="4" section="8"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:406</id>
			<description>The type of the query result specified by the SELECT clause of a query is an entity abstract schema type, a state-field type, the result of an aggregate function, the result of a construction operation, or some sequence of these. 
			</description>
			<location chapter="4" section="8.1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:408</id>
			<description>The result of the SELECT clause is defined by the result types of the select_expressions contained in it.  When multiple select_expressions are used in the SELECT clause, the result of the query is of type Object[] and the elements in this result correspond in order to the order of their specification in the SELECT caluse and in type to the result types of each select_expressions.</description>
			<location chapter="4" section="8.1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:409</id>
			<description>The result type of the select_expression is a single_valued_path_expression that is a state_field_path_expression results in an object of the same type as the corresponding state field of the entity.  If the state field of the entity is a primitive type, the corresponding object type is returned.</description>
			<location chapter="4" section="8.1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:410</id>
			<description>The result type of the select_expression is a single_valued_path_expression that is a single_valued_association_path_expression results in an entity object of the type as the relationship field or the subtype of the relationship field of the entity as determined by the o/r mapping.</description>
			<location chapter="4" section="8.1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:394</id>
			<description>The result type of an identification_variable is type of the entity to which that identification variable corresponds or a subtype as determined by the o/r mapping.</description>
			<location chapter="4" section="8.1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:395</id>
			<description>The result type of a constructor_expression is the type of the class for which the constructor is defined.</description>
			<location chapter="4" section="8.1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:819</id>
			<description>A constructor expression may be used in the SELECT list to return a collection of Java instances.  The specified class is not required to be an entity or to be mapped to the database.</description>
			<location chapter="4" section="8.2"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:820</id>
			<description>If an entity name is specified in the SELECT NEW clause, the resulting entity instances are in the new state.</description>
			<location chapter="4" section="8.2"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:375</id>
			<description>If the result of an query corresponds to an association-field or state-field whose value is null, that null value is returned in the result of the query method.</description>
			<location chapter="4" section="8.3"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:376</id>
			<description>The IS NOT NULL construct can be used to eliminate the null from the result set of the query.</description>
			<location chapter="4" section="8.2"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:379</id>
			<description>Note, however, that state-field types in terms of Java numeric primitive types cannot produce NULL values in the query results.  An query that returns such a state-field type as a result type MUST NOT return a null value.</description>
			<location chapter="4" section="8.2"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:380</id>
			<description>The aggregate function AVG can be used in the SELECT clause of an query.</description>
			<location chapter="4" section="8.4"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:381</id>
			<description>The aggregate function MIN can be used in the SELECT clause of an query.</description>
			<location chapter="4" section="8.4"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:382</id>
			<description>The aggregate function MAX can be used in the SELECT clause of an query.</description>
			<location chapter="4" section="8.4"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:383</id>
			<description>The aggregate function SUM can be used in the SELECT clause of an query.</description>
			<location chapter="4" section="8.4"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:384</id>
			<description>The aggregate COUNT function can be used in the SELECT clause of an query.</description>
			<location chapter="4" section="8.4"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:389</id>
			<description>The path expression argument to COUNT may terminate in a state-field.</description>
			<location chapter="4" section="8.4"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:390</id>
			<description>The path expression argument to COUNT may terminate in a association-field.</description>
			<location chapter="4" section="8.4"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:391</id>
			<description>The argument to COUNT may be an identification variable.</description>
			<location chapter="4" section="8.4"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:821</id>
			<description>Arguments to the functions SUM and AVG must be numeric.</description>
			<location chapter="4" section="8.4"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:822</id>
			<description>Arguments to the functions MAX and MIN must correspond to orderable state-field types (i.e., numeric types,
			string types, character types, or date type).</description>
			<location chapter="4" section="8.4"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:823</id>
			<description>The Java type that is contained in the result of a query using an aggregate function is as follows [with 3.0 entities]:</description>
			<location chapter="4" section="8.4"/>
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:824</id>
					<description>COUNT returns long</description>
					<location chapter="4" section="8.4"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:825</id>
					<description>MAX, MIN return the type of the state-field to which they are applied</description>
					<location chapter="4" section="8.4"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:826</id>
					<description>AVG returns Double</description>
					<location chapter="4" section="8.4"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:827</id>
					<description>SUM returns Long when applied to state-fields of integral types (other than BigInteger); Double when applied to state-fields of
					floating-point types; BigInteger when applied to state-fields of type BigInteger, and BigDecimal when applied to state-fields of type BigDecimal.</description>
					<location chapter="4" section="8.4"/>
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:828</id>
			<description>If SUM, AVG, MAX, or MIN is used, and there are no values to which the aggreate function can be applied, the
					result of the aggregate function is NULL.</description>
			<location chapter="4" section="8.4"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:829</id>
			<description>If COUNT is used, and there are no values to which COUNT can be applied, the result of the aggregate function is 0.</description>
			<location chapter="4" section="8.4"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:392</id>
			<description>The argument to an aggregate function may be preceded by the keyword DISTINCT to specify that duplicate values are to be eliminated before
			the aggregate function is applied.  (NOTE:  It is legal to specify DISTINCT with MAX or MIN but it does not affect the result.)</description>
			<location chapter="4" section="8.4"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:393</id>
			<description>Null values are eliminated before the aggregate function is applied regardless whether the keyword DISTINCT is specified.</description>
			<location chapter="4" section="8.4"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:399</id>
			<description>When Order By clause is used, the SELECT clause of the query MUST be one of the following</description>
			<location chapter="4" section="9"/>
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:399.1</id>
					<description>a single_valued_association_path_expression. 
					For a single_valued_association_path_expression, each orderby_item MUST be an orderable state-field of the entity
			bean abstract schema type value returned by the SELECT clause
					</description>
					<location chapter="4" section="9"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:399.2</id>
					<description>an Identification Variable.
								For an identification variable, each orderby_item MUST be an orderable state-field of the entity
			bean abstract schema type value returned by the SELECT clause
					</description>
					<location chapter="4" section="9"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:399.3</id>
					<description>a state_field_path_expression. 
						For state_field_path_expression, the orderby_item MUST evaluate to the same state-field of the same entity bean abstract schema type as the state_field_path_expression in the SELECT clause.
					</description>
					<location chapter="4" section="9"/>
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:400</id>
			<description>If more than one orderby_item is specified, the left-to-right sequence of the
		orderby_item elements determines the precedence, whereby the leftmost orderby_item has the highest precedence.
			</description>
			<location chapter="4" section="9"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:401</id>
			<description>The keyword ASC specifies that ascending order is used.  DEFAULT.</description>
			<location chapter="4" section="9"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:402</id>
			<description>The keyword DESC specified that descending order is used.</description>
			<location chapter="4" section="9"/>
		</assertion>
		<assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:403</id>
			<description>SQL rules for ordering of NULLS apply: that is, all null values MUST appear before all non-null values in the ordering or all null values MUST appear before all non-null values in the ordering, but it is not specified which.</description>
			<location chapter="4" section="9"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:404</id>
			<description>The ordering of the query result is preserved in the result of the query method if the ORDER BY clause is used.</description>
			<location chapter="4" section="9"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:834</id>
			<description>Bulk update and delete operations apply to entities of a single entity class (together with its subclasses, if any).
			Only one entity abstract schema type may be specified in the FROM or UPDATE clause.</description>
			<location chapter="4" section="10"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:835</id>
			<description>A delete operation only applies to entities of the specified class and its subclasses.  It does not cascade to
			related entities.</description>
			<location chapter="4" section="10"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:836</id>
			<description>The syntax of these operations are as follows:</description>
			<location chapter="4" section="10"/>
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:837</id>
					<description>update_statement ::=update_clause[where_clause]</description>
					<location chapter="4" section="10"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:838</id>
					<description>update_clause ::=UPDATE abstract_schema_name[[AS] identification_variable] SET update_item {,update_item}*</description>
					<location chapter="4" section="10"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:839</id>
					<description>update_item ::=[identification_variable].state_field=new_value</description>
					<location chapter="4" section="10"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:840</id>
					<description>delete_statement ::=delete_clause [where_clause]</description>
					<location chapter="4" section="10"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:841</id>
					<description>delete_clause ::= DELETE FROM abstract_schema_name [[AS] identificationo_variable]</description>
					<location chapter="4" section="10"/>
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:415</id>
			<description>Two NULL values are not considered to be equal, the comparison yield an UNKNOWN value.</description>
			<location chapter="4" section="11"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:416</id>
			<description>Comparison operations with a NULL value always yield an UNKNOWN value.</description>
			<location chapter="4" section="11"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:417</id>
			<description>Comparison operations with an UNKNOWN value always yield an UNKNOWN value.</description>
			<location chapter="4" section="11"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:418</id>
			<description>Arithmetic operators with a NULL value always yield an UNKNOWN value.</description>
			<location chapter="4" section="11"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:419</id>
			<description>Arithmetic operators with an UNKNOWN value always yield an UNKNOWN value.</description>
			<location chapter="4" section="11"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:422</id>
			<description>The IS NOT NULL operators convert a NULL state-field into the respective TRUE or FALSE value.</description>
			<location chapter="4" section="11"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:423</id>
			<description>The IS NOT NULL operators convert a NULL single-valued-association-field into the respective TRUE or FALSE value.</description>
			<location chapter="4" section="11"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:424</id>
			<description>Boolean operators use three valued logic: Table 7:  Definition of the AND Operator</description>
			<location chapter="4" section="11"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:425</id>
			<description>Boolean operators use three valued logic: Table 8: Definition of the OR Operator</description>
			<location chapter="4" section="11"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:426</id>
			<description>Boolean operators use three valued logic: Table 9: Definition of the NOT Operator</description>
			<location chapter="4" section="11"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:427</id>
			<description>Two entities of the same abstract schema type are equal if and only if they have the same primary key value.</description>
			<location chapter="4" section="12"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:428</id>
			<description>Only equality/inequality comparisons over enums are required to be supported.</description>
			<location chapter="4" section="12"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:430</id>
			<description>Only the values of like types can be compared. There is one exception to this rule: it is valid to compare numeric values for which the rule of numeric promotion apply.  Conditional expression attempting to compare non-like type values are disallowed except for this numeric case.</description>
			<location chapter="4" section="12"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:842</id>
			<description>Both container-managed and application-managed entity managers and their persistence contexts are required to be supported in JavaEE web containers and EJB containers.</description>
			<location chapter="5" section="1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:843</id>
			<description>In Java SE and in Java EE application client containers, only application-managed entity managers are required to be supported.
			 [NOTE the use of JTA is not required to be supported in application client containers.]</description>
			<location chapter="5" section="1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:844</id>
			<description>A container-managed entity manager is obtained by the application through dependency injection or through JNDI lookup.</description>
			<location chapter="5" section="2"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:845</id>
			<description>The PersistenceContext annotation is used for entity manager injection.</description>
			<location chapter="5" section="2.1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:846</id>
			<description>The unitName element may optionally be specified to designate the persistence unit whose factory is used by the container.</description>
			<location chapter="5" section="2.1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:847</id>
			<description>The type element specifies whether a transaction-scoped or extended persistence context is to be used.</description>
			<location chapter="5" section="2.1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:848</id>
			<description>The EntityManagerFactory interface is used to create an application-managed entity manager and manage its lifecycle.</description>
			<location chapter="5" section="3"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
			<id>PERSISTENCE:SPEC:849</id>
			<description>More than one entity manager factory instance may be available simultaneously in the JVM.</description>
			<location chapter="5" section="3"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:850</id>
			<description>Within a JavaEE environment, an entity manager factory may be injected using the PersistenceUnit annotation or obtained through JNDI lookup.</description>
			<location chapter="5" section="3.1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
			<id>PERSISTENCE:SPEC:851</id>
			<description>Outside the JavaEE container environment, the javax.persistence.Persistence class is the bootstrap class that provides access to an entity
			manager factory.  The application creates an entity manager factory by called the createEntityManagerFactory method of the javax.persistence.Persistence class.</description>
			<location chapter="5" section="3.2"/>
			<comment>STANDALONE</comment>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:852</id>
			<description>The EntityManagerFactoryInterface is the interface used by the application to create a new application-managed entity
			manager or to get a provider-managed entity manager that is bound to the current JTA transaction context. </description>
			<location chapter="5" section="4"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
			<id>PERSISTENCE:SPEC:853</id>
			<description> When the application has finished using the entity manager factory, and/or at application shutdown, the application should close the entity manager factory.</description>
			<location chapter="5" section="4"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:854</id>
			<description>Any number of vendor-specific properties may be included in the map passed to createEntityManager.  Properties not recognized by a vendor must be ignored.</description>
			<location chapter="5" section="4"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:855</id>
			<description>An entity manager is defined to be of a given transaction type - JTA or resource-local - at the time its underlying entity manager factory is configured and created.</description>
			<location chapter="5" section="5"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:856</id>
			<description>Both JTA entity managers and resource-local entity managers are required to be supported in JavaEE web and EJB containers.</description>
			<location chapter="5" section="5"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
			<id>PERSISTENCE:SPEC:857</id>
			<description>In general, in JavaSE environments, only resource-local entity managers are supported.</description>
			<location chapter="5" section="5"/>
			<comment>STANDALONE</comment>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:858</id>
			<description>Container-managed entity managers must be a JTA entity manager.  JTA entity managers are only specified for use in JavaEE containers.</description>
			<location chapter="5" section="5"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:859</id>
			<description>Application-managed entity managers may either be JTA or resource-local entity managers.</description>
			<location chapter="5" section="5.1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:860</id>
			<description>An entity manager whose transactions are controlled by the application through the EntityTransaction API is a resource-local entity manager.  
			The EntityManager.getTransaction() method returns the EntityTransaction Interface.</description>
			<location chapter="5" section="5.2.1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:861</id>
			<description>When a container-managed entity manager is used, the lifecycle of the persistence context is always managed automatically, transparently to the application,
			and the persistence context is propagated with the JTA transaction.</description>
			<location chapter="5" section="6"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:862</id>
			<description>Container-managed Transaction-scoped Persistence Context:  A new persistence context begins when a container-managed entity manager is invoked in the scope
			of an active JTA transaction and there is no current persistence context already associated with the JTA transaction.  The persistence context is then associated with the
			current JTA transaction.</description>
			<location chapter="5" section="6.1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:863</id>
			<description>Container-managed Transaction-scoped Persistence Context: The persistent context ends when the associated JTA transaction completes and al entites that were
			managed by the EntityManager become detached.</description>
			<location chapter="5" section="6.1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:864</id>
			<description>Container-managed Transaction-scoped Persistence Context:  If the entity manager is invoked outside the scope of a transaction, a persistence context is
			created and destroyed to service the method call only and any entities loaded from the database will immediately become detached at the end of the method call.</description>
			<location chapter="5" section="6.1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:865</id>
			<description>Container-managed Extended Persistence Context:  An extended persistence context exists from the point at which the stateful session bean declares a dependency on an entity manager of type PersistenceContextType.EXTENDED is created and bound to the stateful session bean. </description>
			<location chapter="5" section="6.2"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:866</id>
			<description>Container-managed Extended Persistence Context:   The dependency on the extended persistence context is declared by means of the PersistenceContext annoation or the persistence-context-ref deployment descriptor element. </description>
			<location chapter="5" section="6.2"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:867</id>
			<description>Container-managed Extended Persistence Context can only be initiated within the scope of a stateful
			session bean.</description>
			<location chapter="5" section="6.2"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:868</id>
			<description>If a stateful session bean with an extended persistence context instantiates another stateful session bean with an
					extended persistence context, the extended persistence context is inherited by the second stateful session bean and bound to it, and this rule
					recursively applies - independently of whether transactions are active or not at the point of the creation of the stateful session beans. </description>
			<location chapter="5" section="6.2.1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:869</id>
			<description>IIf the persistence context has been inherited by any stateful session beans, the container does not close the
			persistence context until all such stateful session beans have been removed or otherwise destroyed.</description>
			<location chapter="5" section="6.2.1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:870</id>
			<description>The persistence context is propagated across the entity manager instances as the JTA transaction is propagated.  Propagation of
			persistence contexts only applies within a local environment.  Persistence contexts are not propagated to remote tiers.</description>
			<location chapter="5" section="6.3"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:871</id>
			<description>If a component  is called and there is no JTA transaction or the JTA transaction is not propagated, the
					persistence context is not propagated.</description>
			<location chapter="5" section="6.3.1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:872</id>
			<description>If an entity manager is invoked from within the component:</description>
			<location chapter="5" section="6.3.1"/>
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:873</id>
					<description>Invocation of an entity manager defined with PersistsenceContextType.TRANSACTION will result in use of a new
					persistence context.</description>
					<location chapter="5" section="6.3.1"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:874</id>
					<description>Invocation of an entity manager defined with the PersistenceContextType.EXTENDED will result in the use of the
					existing extended persistence context bound to that component.</description>
					<location chapter="5" section="6.3.1"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:875</id>
					<description>If the entity manager is invoked within a JTA transaction the persistence context will be boud to the JTA transaction.</description>
					<location chapter="5" section="6.3.1"/>
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:876</id>
			<description>If a component is called and the JTA transaction is propagated into that component:</description>
			<location chapter="5" section="6.3.1"/>
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:877</id>
					<description>If the component is a stateful session bean to which an extended persistence context has been bound
					and there is a different persistence context bound to the JTA transaction, an EJBException is thrown by the container.</description>
					<location chapter="5" section="6.3.1"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:878</id>
					<description>Otherwise, if there is a persistence context bound to the JTA transaction, that persistence context is propagated and used.</description>
					<location chapter="5" section="6.3.1"/>
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:879</id>
			<description>Application-managedPersistence Context:  When an applicatio-managed entity manager is used, the application interacts directly with the persistence provider's entity manager factory to
			manage the entity manager lifecycle and to obtain and destroy persistence contexts  All such application-managed persistence contexts are extended in scope and may span multiple transactions.</description>
			<location chapter="5" section="7"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:880</id>
			<description>The EntityManager close and isOpen methods are used to manage the lifecycle of an application-managed entity manager and its associated persistence context.</description>
			<location chapter="5" section="7"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:881</id>
			<description>The EntityManager.close() closes the entity manager to release its persistence context and any other resources. </description>
			<location chapter="5" section="7"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:882</id>
			<description>After calling close, the application must not invoke
			any further methods on the EntityManager instance except for getTransaction or IsOpen or the IllegalStateException will be thrown.</description>
			<location chapter="5" section="7"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:883</id>
			<description>If the close method is invoked when a transaction is active, the persistence context remains managed until the transaction completes.</description>
			<location chapter="5" section="7"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:884</id>
			<description>The EntityManager.isOpen() method will return true unless the entity manager has been closed.</description>
			<location chapter="5" section="4"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:885</id>
			<description>Application-managed Extended Persistence Context:  The extended persistence context exists from the point at which the entity manager hs been created
			using EntityManagerFactory.createEntityManager until the entity manager is closed by the means of EntityManager.close.  The extended persistence context obtained from the application-managed entity manager is a stand-alone persistence context - it is not propagated with the transaction.</description>
			<location chapter="5" section="7"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:886</id>
			<description>When a JTA application-managed entity manager is used, if the entity manager is created outside the scope of the current JTA transaction, it is the responsibility of the application to associate
			the entity manager with the transaction, if desired, by calling EntityManager.joinTransaction.</description>
			<location chapter="5" section="7"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:887</id>
			<description>Requirements on the Container</description>
			<location chapter="5" section="8"/>
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:888</id>
					<description>Application Managed Persistence Contexts</description>
					<location chapter="5" section="8.1"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:889</id>
					<description>Container Managed Persistence Contexts</description>
					<location chapter="5" section="8.2"/>
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:890</id>
			<description>
			Runtime Contracts between the Container and Persistence Provider</description>
			<location chapter="5" section="9"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:891</id>
			<description>Container Responsibilities</description>
			<location chapter="5" section="9.1"/>
		</assertion>
		<assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:892</id>
			<description>Provider Responsibilities</description>
			<location chapter="5" section="9.2"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:893</id>
			<description>Within JavaEE environments, an EJB-JAR, WAR, or EAR can define a persistence unit. Any number of persistence archives may be deployed within an EJB-JAR, WAR, or EAR.</description>
			<location chapter="6" section="2"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:894</id>
			<description>A persistence unit may be packaged:</description>
			<location chapter="6" section="2"/>
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:895</id>
					<description>within one or more jar files contained within a WAR</description>
					<location chapter="6" section="2"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:896</id>
					<description>one or more jar files contained within an EAR</description>
					<location chapter="6" section="2"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:897</id>
					<description>as a set of classes within an EJB-JAR file</description>
					<location chapter="6" section="2"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:898</id>
					<description>a set of classes in the WAR classes directory</description>
					<location chapter="6" section="2"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:899</id>
					<description>as a combination of these</description>
					<location chapter="6" section="2"/>
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:900</id>
			<description>A persistence unit is defined by a persistence.xml file.  The jar file or directory whose META-INF directory contains the persistence.xml is termed the root of the persistence unit.
			In Java EE, the root of a persistence unit may be one of the following:</description>
			<location chapter="6" section="2"/>
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:901</id>
					<description>an EJB-JAR file</description>
					<location chapter="6" section="2"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:902</id>
					<description>the WEB-INF classes directory of a WAR file [the root of the persistence unit - in this case - is the WEB-INF/classes directory; the
					persistence.xml file is therefore contained in the WEB-INF/classes/META-INF directory.</description>
					<location chapter="6" section="2"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:903</id>
					<description>a jar file in the WEB-INF/lib directory of a WAR file</description>
					<location chapter="6" section="2"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:904</id>
					<description>a jar file in the root of the EAR</description>
					<location chapter="6" section="2"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:905</id>
					<description>a jar file in the EAR lib directory</description>
					<location chapter="6" section="2"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:906</id>
					<description>an application client jar file</description>
					<location chapter="6" section="2"/>
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:907</id>
			<description>It is not required that na EJB-JAR or WAR containing a persistence unit be packaged in an EAR unless
					the persistence unit contains persistence classes in addition to those contained in the EJB-JAR or WAR.</description>
			<location chapter="6" section="2"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:908</id>
			<description>A persistence unit must have a name.</description>
			<location chapter="6" section="2"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:909</id>
			<description>Only one persistence unit of any given name may be defined:</description>
			<location chapter="6" section="2"/>
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:910</id>
					<description>within a single EJB-JAR file</description>
					<location chapter="6" section="2"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:911</id>
					<description>within a single WAR file</description>
					<location chapter="6" section="2"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:912</id>
					<description>within a single application client jar</description>
					<location chapter="6" section="2"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:913</id>
					<description>within an EAR in the EAR root</description>
					<location chapter="6" section="2"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:914</id>
					<description>within an EAR in the  lib directory</description>
					<location chapter="6" section="2"/>
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:915</id>
			<description>The persistence.xml file may be used to designate more thanone persistnece unit within the same scope.</description>
			<location chapter="6" section="2"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:916</id>
			<description>All persistence classes defined at the level of the Java EE EAR must be accessible to all other J2EE components in the application such
			 that if the same entity class is referenced by two different Java EE components (which may be using different persistence units),
			 the referenced class is the same identifical class.</description>
			<location chapter="6" section="2"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
			<id>PERSISTENCE:SPEC:917</id>
			<description>In Java SE environments, the metadata mapping files, jar files, and classes described in the following sections can be used.
			To insure portability of a Java SE application, it is necessary to explicitly list the managed persistence classes that are inclulded in the persistence unit.</description>
			<location chapter="6" section="2"/>
			<comment>STANDALONE</comment>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:918</id>
			<description>The persistence.xml file defines a persistence unit.  It may be used to specify managed persistence classes included in the 
			persistence unit, and the o/r mapping information for those classes, and other configuration information for the persistence unit
			and entity manager(s) and the entity manager factory for the persistence unit.  The persistence.xml file is located in the META-INF
			directory of the root of the persistence unit.  This information may be defined by containment or by reference.</description>
			<location chapter="6" section="2"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:919</id>
			<description>The o/r mapping information may take the form of:</description>
			<location chapter="6" section="2.1"/>
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:920</id>
					<description>annotations on the managed persistence classes included in the persistence unit</description>
					<location chapter="6" section="2.1"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:921</id>
					<description>one or more XML files contained in the root of the persistence unit</description>
					<location chapter="6" section="2.1"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:922</id>
					<description>one or more XML files outside the persistence archive on the classpath and referenced from the persistence.xml</description>
					<location chapter="6" section="2.1"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:923</id>
					<description>a combination of above</description>
					<location chapter="6" section="2.1"/>
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:924</id>
			<description>The managed persistence classes may either be:</description>
			<location chapter="6" section="2.1"/>
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:925</id>
					<description>contained within the persistence archive</description>
					<location chapter="6" section="2.1"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:926</id>
					<description>specified by reference that are accessible on the application classpath </description>
					<location chapter="6" section="2.1"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:927</id>
					<description>specified by come combination of above</description>
					<location chapter="6" section="2.1"/>
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:928</id>
			<description>The persistence element consists of one or more persistence-unit elements.</description>
			<location chapter="6" section="2.1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:929</id>
			<description>The persistence-unit element consists of the following sub-elements and attributes:</description>
			<location chapter="6" section="2.1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:930</id>
			<description>The name attribute is required; the other attributes and elements are optional.</description>
			<location chapter="6" section="2.1.1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:931</id>
			<description>The description element provides optional descriptive information about the persistence unit.</description>
			<location chapter="6" section="2.1.1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:932</id>
			<description>The name attribute defines the name for the persistence unit.  This name is used to identify the
			persistence unit referred to by the PersistenceContext and PersistenceUnit annotations and
			the programmatic API for creating EntityManagers and EntityManager Factories.</description>
			<location chapter="6" section="2.1.2"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
			<id>PERSISTENCE:SPEC:933</id>
			<description>The provider element specifies the name of the persistence provider's javax.persistence.spi.PersistenceProvider class. </description>
			<location chapter="6" section="2.1.3"/>
			<comment>STANDALONE</comment>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
			<id>PERSISTENCE:SPEC:934</id>
			<description>The provider element must be specified if a third-party provider implementation is used.</description>
			<location chapter="6" section="2.1.3"/>
			<comment>STANDALONE</comment>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
			<id>PERSISTENCE:SPEC:935</id>
			<description>In J2SE environments, the persistence provider must be specified [either by this means or vendor-specific-means].</description>
			<location chapter="6" section="2.1.3"/>
			<comment>STANDALONE</comment>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:936</id>
			<description>The transaction-type attribute is used to specify whether the entity managers provided by the entity
			manager factory for the persistence unit must be JTA entity managers or resource-local entity managers.</description>
			<location chapter="6" section="2.1.4"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:937</id>
			<description>The value of this element is JTA or RESOURCE_LOCAL.</description>
			<location chapter="6" section="2.1.4"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:938</id>
			<description>IIf this element is not specified, the default is JTA.</description>
			<location chapter="6" section="2.1.4"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:939</id>
			<description>In Java EE environments, the jta-data-source and non-jta-data-source elements is used to specify the global JNDI name of the JTA and/or non-JTA data source
			to be used by the persistence provider.</description>
			<location chapter="6" section="2.1.5"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:940</id>
			<description>If neither is specified, the deployer must specify a JTA datasource at deployment or a JTA data source must be provided by the container and
			a JTA EntityManagerFactory will be created to correspond to it.</description>
			<location chapter="6" section="2.1.5"/>
		</assertion>
		<assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="false">
			<id>PERSISTENCE:SPEC:941</id>
			<description>These elements name the data source in the local environment; the format of these names and the ability
			to specify the names are product specific.</description>
			<location chapter="6" section="2.1.5"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
			<id>PERSISTENCE:SPEC:942</id>
			<description>In Java SE environments, these elements may be used or the datasource information may be specified by other means -
			depending upon the requirements of the provider.</description>
			<location chapter="6" section="2.1.5"/>
			<comment>STANDALONE</comment>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:943</id>
			<description>The following classes must be implicitly or explicitly denoted as managed persistence classes to be included within a persistence unit:
			entity classes; embeddadble classes; mapped superclasses.</description>
			<location chapter="6" section="2.1.6"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:944</id>
			<description>The set of classes that are managed by a persistence unit is defined by using one or more of the following:</description>
			<location chapter="6" section="2.1.6"/>
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:945</id>
					<description>One or more o/r mapping XML file</description>
					<location chapter="6" section="2.1.6"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:946</id>
					<description>One or more jar files that will be searched for classes</description>
					<location chapter="6" section="2.1.6"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:947</id>
					<description>An explicit list of the classes</description>
					<location chapter="6" section="2.1.6"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:948</id>
					<description>The annotated managed persistence classes contained in the root of the persistence unit
					(unless the exclude-unlisted-classes element is specified)</description>
					<location chapter="6" section="2.1.6"/>
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:949</id>
			<description>An orm.xml file:</description>
			<location chapter="6" section="2.1.6"/>
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:950</id>
					<description>may be specified in the META-INF directory in the root of the persistence unit</description>
					<location chapter="6" section="2.1.6"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:951</id>
					<description>or in the META-INF directory of any jar file referenced by the persistence.xml</description>
					<location chapter="6" section="2.1.6"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:952</id>
					<description>and/or one or more mapping files may be referenced by the mapping-file elements of the persistence-unit element [of the persistence.xml file]</description>
					<location chapter="6" section="2.1.6"/>
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:953</id>
			<description>If a mapping file is specified, the classes and mapping information specified in the mapping file will be used.</description>
			<location chapter="6" section="2.1.6"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:954</id>
			<description>If multiple mapping files are specified (possibly including an orm.xml file), the resulting mappings are obtained by combining the mappings from all the files</description>
			<location chapter="6" section="2.1.6"/>
		</assertion>
		<assertion required="false" impl-spec="true" defined-by="technology" status="active" testable="false">
			<id>PERSISTENCE:SPEC:955</id>
			<description>The result is undefined if multiple mappings referenced within a single persistence unit contain overlapping mapping information for any given class.</description>
			<location chapter="6" section="2.1.6"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
			<id>PERSISTENCE:SPEC:956</id>
			<description>The o/r mapping information contained in any mapping file referenced within the persistence unit must be disjoint at the class level from o/r mapping information contained in any other such mappings.</description>
			<location chapter="6" section="2.1.6"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:957</id>
			<description>One or more jar files may be specified using the jar-file elements instead of, or in addition to the mapping files specified in the mapping-files elements.
			 If specified, these JAR files will be searched for managed persistence classes and any mapping
			metadata annotations found on them will be processed or they will be mapped using the mapping annotation defaults defined by this specification.
			Such JAR files are specified relative to the root of the persistence unit.</description>
			<location chapter="6" section="2.1.6"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:958</id>
			<description>A list of named managed persistence classes may also be specified instead of, or in addition to, the JAR files and mapping files.  Any mapping
			metadata annotations found on them will be processed or they will be mapped using the mapping annotation defaults defined by this specification.</description>
			<location chapter="6" section="2.1.6"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:959</id>
			<description>The class element is used to list a managed persistence class.</description>
			<location chapter="6" section="2.1.6"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
			<id>PERSISTENCE:SPEC:960</id>
			<description>A list of all named managed persistence classes must be specified in Java SE environments to insure portability.  Portable
			JavaSE applications should not rely on the other mechanisms described here to specify the managed persistence classes of a
			persistence unit.  Persistence providers my also require that the set of entity classes and classes that are to be managed
			must be fully enumerated in each of the persistence.xml files in Java SE environments.</description>
			<location chapter="6" section="2.1.6"/>
			<comment>STANDALONE</comment>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:961</id>
			<description>All classes contained in the persistence unit are also searched for annotated managed persistence classes and any mapping metadata annotations found
			on them will be processed, or they will be mapped using the mapping annotation defaults.</description>
			<location chapter="6" section="2.1.6"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:962</id>
			<description>If it is not intended that the annoted persistence classes contained in the root of the persistence unit be included in the persistence unit,
			the exclude-unlisted-classes should be used. </description>
			<location chapter="6" section="2.1.6"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:963</id>
			<description>The exclude-unlisted-classes element is not intended for use in Java SE environments.</description>
			<location chapter="6" section="2.1.6"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:964</id>
			<description>The resulting set of entities managed by the persistence unit is the union of these four sources with the mapping metadata annotations (or annotation defaults)
			for any given class being overridden by the XML mapping information file if there are both annotations as well as XML mappings for that class.</description>
			<location chapter="6" section="2.1.6"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
			<id>PERSISTENCE:SPEC:966</id>
			<description>All classes and/or jars that are named as part of a persistence unit must be on the classpath; referencing them from the persistence.xml does not cause them
			to be placed on the classpath.</description>
			<location chapter="6" section="2.1.6"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
			<id>PERSISTENCE:SPEC:967</id>
			<description>All classes must be on the classpath to ensure that entity managers from different persistence units that map the same class will be accessing the same identical class.</description>
			<location chapter="6" section="2.1.6"/>
		</assertion>
		<assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="false">
			<id>PERSISTENCE:SPEC:968</id>
			<description>The properties element is used to specify vendor-specific properties that apply to the persistence unit and its entity manager factory configurations.</description>
			<location chapter="6" section="2.1.7"/>
		</assertion>
		<assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:969</id>
			<description>If a persistence provider does not recognize properties (other than those defined by this specification), the provider must ignore those properties.</description>
			<location chapter="6" section="2.1.7"/>
		</assertion>
		<assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:970</id>
			<description>An EJB-JAR, WAR, application client or EAR can define a persistence unit.  The visibility of the persistence unit is determined by its point of definition.</description>
			<location chapter="6" section="2.2"/>
		</assertion>
		<assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:971</id>
			<description>A persistence unit that is defined at the level of an EJB-JAR, WAR, or application client jar is scoped to that EJB-JAR, WAR, or application-client jar
			respectively.  It is visible to the components defined in that jar or war, but is not visible as a persistence  unit to other parts of the application.</description>
			<location chapter="6" section="2.2"/>
		</assertion>
		<assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:972</id>
			<description>A persistence unit that is to be visible to the application as whole must be defined at EAR level (in EAR root or in the lib directory).</description>
			<location chapter="6" section="2.2"/>
		</assertion>
		<assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:973</id>
			<description>A persistence unit is defined at the level of the EAR is generally visible to all components of the application.  However, if a persistence unit of the same name is defiend by an EJB-JAR, WAR or 
			application client jar file within the EAR, the persistence unit of that name defined at the EAR level will not be visible to the components defined by that EJB-JAR, WAR, or 
			application jar file.</description>
			<location chapter="6" section="2.2"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:974</id>
			<description>Each persistence unit deployed into a Java EE container consists of a single persistence.xml file, any number
			of mapping files and any number of classes.</description>
			<location chapter="7" section="1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:975</id>
			<description>At deployment time the container is responsible for scanning locations specified in 6.2 and discovering the persistence.xml files and  processing them.</description>
			<location chapter="7" section="1.1"/>
		</assertion>
		<assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:976</id>
			<description>When the container finds a persistence.xml file, it processes the persistence unit definitions that it contains.  Provider or data source information not specified in the persistence.xml file must be provided 
			at deployment or defaulted by the container.</description>
			<location chapter="7" section="1.1"/>
		</assertion>
		<assertion required="false" impl-spec="true" defined-by="technology" status="active" testable="false">
			<id>PERSISTENCE:SPEC:977</id>
			<description>The container may optionally add its own container-specific properties to be passed to the provider when creating the entity manager factory for the persistence unit.</description>
			<location chapter="7" section="1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
			<id>PERSISTENCE:SPEC:978</id>
			<description>When a persistence unit is redeployed the container must call the createContainerEntityManagerFactory method again, with the required PersistenceUnitInfo metadata, to indicate the redeployment.</description>
			<location chapter="7" section="1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:979</id>
			<description>The persistence provider must implement the PersistenceProvider SPI and be able to process the metadata that is passed to it at the time createContainerEntityManagerFactory method is called.</description>
			<location chapter="7" section="1.2"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:980</id>
			<description>An instance of EntityManagerFactory is created and the metadata for the named EntityManager is associated with the factory.  The factory is then returned to the container.</description>
			<location chapter="7" section="1.2"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:981</id>
			<description>The interface javax.persistence.spi.PersistenceProvider is implemented by the persistence provider.</description>
			<location chapter="7" section="1.3"/>
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:982</id>
					<description>It is invoked by the container in Java EE environments.</description>
					<location chapter="7" section="1.3"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
					<id>PERSISTENCE:SPEC:983</id>
					<description>It is invoked by the javax.persistence.Persistence class in Java SE environments.</description>
					<location chapter="7" section="1.3"/>
					<comment>STANDALONE</comment>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
					<id>PERSISTENCE:SPEC:984</id>
					<description>It is not intended to be used by the application.</description>
					<location chapter="7" section="1.3"/>
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
			<id>PERSISTENCE:SPEC:985</id>
			<description>The PersistenceProvider class must have a public no-arg constructor.</description>
			<location chapter="7" section="1.3"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
			<id>PERSISTENCE:SPEC:986</id>
			<description>Persistence unit properties may be passed to persistence providers in the Map parameter of the createEntityManagerFactory(String, Map) method.
			These properties correspond to the elements of the persistence.xml file.  When any of these properties are specified in the Map parameter, their
			values override the values of the corresponding elements in the persistence.xml file for the named persistene unit. They also override any defaults
			that the provider may have applied.</description>
			<location chapter="7" section="1..3.1"/>
			<comment>STANDALONE</comment>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
			<id>PERSISTENCE:SPEC:987</id>
			<description>The properties listed below are defined by this specification.</description>
			<location chapter="7" section="1.3.1"/>
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
					<id>PERSISTENCE:SPEC:988</id>
					<description>javax.persistence.provider - corresponds to the provider element in the persistence.xml</description>
					<location chapter="7" section="1.3.1"/>
					<comment>STANDALONE</comment>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
					<id>PERSISTENCE:SPEC:989</id>
					<description>javax.persistence.transactionType - corresponds to the transaction-type attribute of the persistence-unit element in the persistence.xml</description>
					<location chapter="7" section="1.3.1"/>
					<comment>STANDALONE</comment>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
					<id>PERSISTENCE:SPEC:990</id>
					<description>javax.persistence.jtaDataSource - corresponds to the jta-data-source element in the persistence.xml</description>
					<location chapter="7" section="1.3.1"/>
					<comment>STANDALONE</comment>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
					<id>PERSISTENCE:SPEC:991</id>
					<description>javax.persistence.nonJtaDataSource - corresponds to the jnon-ta-data-source element in the persistence.xml</description>
					<location chapter="7" section="1.3.1"/>
					<comment>STANDALONE</comment>
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:992</id>
			<description>BootStrapping in Java SE Environments</description>
			<location chapter="7" section="2"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:993</id>
			<description>Entity Annotation</description>
			<location chapter="8" section="1"/>
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:994</id>
					<description>The name annotation element defaults to the unqualified name of the entity class.</description>
					<location chapter="8" section="1"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:995</id>
					<description>This name [annotation element] is used to refer to the entity in queries. The name must not be a reserved literal in the query.</description>
					<keywords>
						<keyword>application-role</keyword>
						<keyword>application-server-role</keyword>
					</keywords>
					<location chapter="8" section="1"/>
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:997</id>
			<description>Callback Annotations</description>
			<location chapter="8" section="2"/>
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:998</id>
					<description>The EntityListener annotation specifies the callback listener class to be used for an entity.</description>
					<location chapter="8" section="2"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:999</id>
					<description>The callback annotations [see Persistence JavaDoc assertion list] are used to specify callbackmethods for the corresponding lifecycle events.  These annotations may be applied to methods on the entity class or methods of the EntityListener class.</description>
					<keywords>
						<keyword>application-role</keyword>
						<keyword>application-server-role</keyword>
					</keywords>
					<location chapter="8" section="2"/>
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1004</id>
			<description>The NamedQuery annotation is used to specify a named query.  The name element is used to refer to the query when using the EntityManager methods that create query objects.</description>
			<location chapter="8" section="3.2"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1005</id>
			<description>The NamedNativeQuery annotation is used to specify a native SQL query.  The name element is used to refer to the query when using the EntityManager methods that create query objects.</description>
			<location chapter="8" section="3.2"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1006</id>
			<description>The [NamedNativeQuery] resultClass element refers to the class of the result.</description>
			<location chapter="8" section="3.2"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1007</id>
			<description>The value of the [NamedNativeQuery] resultSetMapping element is the name of a SQLResultSetMapping as defined in the metadata.</description>
			<location chapter="8" section="3.2"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1008</id>
			<description>Annotations for SQL Query Result Set Mappings</description>
			<location chapter="8" section="3.4"/>
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:1009</id>
					<description>The SqlResultSetMapping is used to specify the mapping of the result of a native SQL query.</description>
					<location chapter="8" section="3.4"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:1010</id>
					<description>The name element is the name given to the result set mapping and used to refer to it in the methods of the Query API.</description>
					<location chapter="8" section="3.4"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:1011</id>
					<description>The entities and columns elements are used to specify the mapping to entities and to scalar values respectively.</description>
					<location chapter="8" section="3.4"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:1012</id>
					<description>The entityClass element specified the class of the result.</description>
					<location chapter="8" section="3.4"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:1013</id>
					<description>The discriminatorColumn element is used to specify the column name (or alias) of the column in the SELECT list that is used to determine the type of the entity instance.</description>
					<location chapter="8" section="3.4"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:1014</id>
					<description>The fields element is used to map the columns specified in the SELECT list of the query to the properies or fields of the entity class.</description>
					<location chapter="8" section="3.4"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:1015</id>
					<description>The name element [of FieldResult] is the name of the persistent field or property of the class.</description>
					<location chapter="8" section="3.4"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:1016</id>
					<description>The column element [of FieldResult] is the column name (or alias) as specified in the SELECT list.</description>
					<location chapter="8" section="3.4"/>
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1018</id>
			<description>References to EntityManager and EntityManagerFactory</description>
			<location chapter="8" section="4"/>
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:1019</id>
					<description>The PersistenceContext annotation is used to express a dependency on an EntityManager persistence context.</description>
					<location chapter="8" section="4"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:1020</id>
					<description>The [PersistenceContext] name element refers to the name by which the EntityManager is to be known in the environment referencing context and is not needed when dependency injection is used.</description>
					<location chapter="8" section="4"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:1021</id>
					<description>The [PersistenceContext] unitName element refers to the name of the persistence unit.  It must be specified if there is more than one persistence unit.</description>
					<location chapter="8" section="4"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:1022</id>
					<description>The [PersistenceContext] type element specifies whether a transaction-scoped or extended persistence context is to be used.</description>
					<location chapter="8" section="4"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:1023</id>
					<description>The PersistenceUnit annotation is used to express a dependency on an EntityManagerFactory.</description>
					<location chapter="8" section="4"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:1024</id>
					<description>The [PersistenceUnit] name element refers to the name by which the EntityManagerFactory is to be known in the environment referencing context and is not needed when dependency injection is used.</description>
					<location chapter="8" section="4"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:1025</id>
					<description>The [PersistenceUnit unitName element refers to the name of the persistence unit.  It must be specified if there is more thatn one persistence unit.</description>
					<location chapter="8" section="4"/>
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1026</id>
			<description>The implementation of this specification must assume the application logic to be dependent upon the object/relational mapping expressed in metadata.</description>
			<location chapter="9" section="1"/>
		</assertion>
		<assertion required="false" impl-spec="true" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1027</id>
			<description>It is permitted, but not required, that DDL generation be supported by an implementation of this specification.  The annotation elements that specify such DDL are intended as hints to the implementation for DDL generation.  Use of such hings is not portable.</description>
			<location chapter="9" section="1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1028</id>
			<description>The Table annotation specifies the primary table for the annotated entity.</description>
			<location chapter="9" section="1.1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1028.1</id>
			<description>If no Table annotation is specified for an entity, all of the default values defined by the Table annotation will apply to the entity.</description>
			<location chapter="9" section="1.1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1029</id>
			<description>Specifying one or more secondary tables indicates that the entity data is stored across multiple tables. </description>
			<location chapter="9" section="1.2"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1030</id>
			<description>If no SecondaryTable is specified, it is assumed that all properties of the entity are mapped to the primary table.</description>
			<location chapter="9" section="1.2"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1031</id>
			<description>If no join column is specified, the join columns are assumed to reference the primary key columns of the primary table and have the same names as the referenced columns.</description>
			<location chapter="9" section="1.2"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1032</id>
			<description>If there is a single secondary table, the join column or columns may be specified outside the SecondaryTable annotation.</description>
			<location chapter="9" section="1.2"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1033</id>
			<description>If there are multiple secondary tables and the join columns are not uniformly named, then the nested JoinColumn annotation will be required.</description>
			<location chapter="9" section="1.2"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1034</id>
			<description>Note that the secondaryTable element of the JoinColumn annotation will be ignored whtn the JoinColumn element is used to join a primary table to a secondary table.</description>
			<location chapter="9" section="1.2"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1035</id>
			<description>An entity may have multiple secondary tables.  In this case, they must be enclosed within a SecondaryTables annotation. A SecondaryTables annotation takes an array of SecondaryTable annotations as its single annotation element.</description>
			<location chapter="9" section="1.3"/>
		</assertion>
		<assertion required="false" impl-spec="true" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1036</id>
			<description>The UniqueConstraint annotation is used to specify that a unique constraint should be included in the generated DDL for a primary or secondary table.  It is only specified as a nested annotation within the Table or SecondaryTable annotation.</description>
			<location chapter="9" section="1.4"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1037</id>
			<description>Column annotation is used to specify a mapped column for a persistent property or field. </description>
			<location chapter="9" section="1.5"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1037.1</id>
			<description> If a Column annotation is not specified, or the name annotation element is missing, the column name defaults to the persistent property or field name.</description>
			<location chapter="9" section="1.5"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1038</id>
			<description>The JoinColumn annotation is used to specify a mapped column for joining an entity association or a secondary table.</description>
			<location chapter="9" section="1.6"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1039</id>
			<description>The name annotation element defines the name of the foreign key column.</description>
			<location chapter="9" section="1.6"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1040</id>
			<description>If the referencedColumnName element is missing, the foreign key is assumed to refer to the primary key of the referenced table.</description>
			<location chapter="9" section="1.6"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1041</id>
			<description>If the name annotation element is missing, or if no JoinColumn annotation is specified, the join columns are assumed to have the same names as the primary key columns of the referenced table.</description>
			<location chapter="9" section="1.6"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1042</id>
			<description>If no JoinColumn annotation is specified, a single join column is assumed.</description>
			<location chapter="9" section="1.6"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1043</id>
			<description>If there is a single join column, then:</description>
			<location chapter="9" section="1.6"/>
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:1044</id>
					<description>If the name annotation element is missing, the join column name is formed as the concatenation of the following:  the name of the referencing relationship property or field of the referencing entity; "_"; the name of the referenced primary key column.</description>
					<location chapter="9" section="1.6"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:1045</id>
					<description>If the referencedColumnName element is missing, the foreign key is assumed to refer t the primary key of the referenced table.</description>
					<location chapter="9" section="1.6"/>
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="false" impl-spec="true" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1046</id>
			<description>If there is more than one join column, a JoinColumn annotation myust be specified for each join column.  Both the name and referencedColumnName elements must be specified in each such JoinColumn annotation.</description>
			<keywords>
				<keyword>application-role</keyword>
			</keywords>
			<location chapter="9" section="1.6"/>
		</assertion>
		<assertion required="false" impl-spec="true" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1047</id>
			<description>Support for referenced columns that are not the primary key of the referenced table is optional in this release, but will be required in the next.</description>
			<keywords>
				<keyword>application-role</keyword>
			</keywords>
			<location chapter="9" section="1.6"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1048</id>
			<description>Composite keys are supported via the JoinColumns annotation.  This allows grouping a number of JoinColumn specifications for the same relationship or table association.</description>
			<location chapter="9" section="1.7"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1049</id>
			<description>The Id annotation specifies the primary key property or field of an entity.  The Id annotatoin may be applied in an entity or mapped superclass.</description>
			<location chapter="9" section="1.8"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1050</id>
			<description>By default, the mapped column for the primary key of the entity is assumed to be the primary key of the primary table.  If no Column annotation is specified, the primary key column name is assumed to be the name of the identifier property or field.</description>
			<location chapter="9" section="1.8"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1051</id>
			<description>The types of the primary key generation are defined by the GenerationType enum.</description>
			<location chapter="9" section="1.9"/>
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:1052</id>
					<description>The TABLE generator type value indicates that the persistence provider must assign primary keys for the entity using an underlying database table to ensure uniqueness.</description>
					<location chapter="9" section="1.9"/>
				</assertion>
				<assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:1053</id>
					<description>The SEQUENCE and IDENTITY values specify the use of a database sequence or identity column, respectively.</description>
					<location chapter="9" section="1.9"/>
				</assertion>
				<assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:1055</id>
					<description>AUTO indicates that the persistence provider should pick an appropriate strategy for the particular database.</description>
					<location chapter="9" section="1.9"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:1057</id>
					<description>The GeneratedValue annotation provides for the specification of generation strategies for the value of primary keys.   The GeneratedValue annotation may be applied
			to a primary key property or field of an entity or mapped superclass in conjunction with the Id annotation. </description>
					<location chapter="9" section="1.9"/>
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1059</id>
			<description>The AttributeOverride annotation is used to override mappings of a Basic property or field or Id property or field.</description>
			<location chapter="9" section="1.10"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1060</id>
			<description>Columns in the overrides apply to the current primary table for the class that contains the annotation.</description>
			<location chapter="9" section="1.10"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1061</id>
			<description>The AttributeOverride  annotation may be used on an entity that extends a mapped superclass or on an embeddable class.</description>
			<location chapter="9" section="1.10"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1062</id>
			<description>The mappings of multiple properties or fields may be overridden.  The AttributesOverrides annotation is used for this purpose.</description>
			<location chapter="9" section="1.11"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1062.0</id>
			<description>The AssociationOverride annotation is used to override a many-to-one or one-to-one mapping of property or field for an entity relationship.</description>
			<location chapter="9" section="1.11"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1062.1</id>
			<description>If the AssociationOverride annotation is not specified, the join column is mapped the same as in the original mapping. The joinColumns element refers to the table for the class that contains the annotation.</description>
			<location chapter="9" section="1.11"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1063</id>
			<description>The EmbeddedId annotation is used to denote a composite primary key that is an embeddable class.  It may be applied to a persistent field or property of the entity class.</description>
			<location chapter="9" section="1.14"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1064</id>
			<description>There should only be one EmbeddedId annotation and no Id annotation when the EmbeddedId annotation is used.</description>
			<location chapter="9" section="1.14"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1065</id>
			<description>The IdClass annotation is used to denote a composite primary key.  It is applied to the entity class.  The composite primary key class corresponds to multiple fields or properties of the entity class and the names of the primary key fields or properties in the primary key class and those of the entity class must correspond and their types must be the same.</description>
			<location chapter="9" section="1.15"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1066</id>
			<description>The Id annotation must also be applied to the corresponding fields or properties of the entity.</description>
			<location chapter="9" section="1.15"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1067</id>
			<description>The Transient annotation is used to annotate a property or field of the entity class.  It specifies the property or field is not persistent.</description>
			<location chapter="9" section="1.16"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1068</id>
			<description>The Version annotation is a marker annotation that keeps track of the version property (optimistic lock value) of an entity class.  This is used to ensure integrity when reattaching and for overall optimistic concurrency control.</description>
			<location chapter="9" section="1.17"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1069</id>
			<description>The Basic annotation is the simplest type of mapping to a database column. </description>
			<location chapter="9" section="1.18"/>
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:1070</id>
					<description>The Basic annotation can optionally be applied to any persistent property or instance variable of the following type: Java primitive types</description>
					<location chapter="9" section="1.18"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:1071</id>
					<description>The Basic annotation can optionally be applied to any persistent property or instance variable of the following type: java.lang.String</description>
					<location chapter="9" section="1.18"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:1072</id>
					<description>The Basic annotation can optionally be applied to any persistent property or instance variable of the following types: wrappers of the primitive types</description>
					<location chapter="9" section="1.18"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:1073</id>
					<description>The Basic annotation can optionally be applied to any persistent property or instance variable of the following type: byte[]</description>
					<location chapter="9" section="1.18"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:1074</id>
					<description>The Basic annotation can optionally be applied to any persistent property or instance variable of the following type: Byte[]</description>
					<location chapter="9" section="1.18"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:1075</id>
					<description>The Basic annotation can optionally be applied to any persistent property or instance variable of the following type: char[]</description>
					<location chapter="9" section="1.18"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:1076</id>
					<description>The Basic annotation can optionally be applied to any persistent property or instance variable of the following type: Character[]</description>
					<location chapter="9" section="1.18"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:1077</id>
					<description>The Basic annotation can optionally be applied to any persistent property or instance variable of the following type: java.math.BigInteger</description>
					<location chapter="9" section="1.18"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:1078</id>
					<description>The Basic annotation can optionally be applied to any persistent property or instance variable of the following type: java.math.BigDecimal</description>
					<location chapter="9" section="1.18"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:1079</id>
					<description>The Basic annotation can optionally be applied to any persistent property or instance variable of the following type: java.util.Date</description>
					<location chapter="9" section="1.18"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:1080</id>
					<description>The Basic annotation can optionally be applied to any persistent property or instance variable of the following type: java.util.Calendar</description>
					<location chapter="9" section="1.18"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:1081</id>
					<description>The Basic annotation can optionally be applied to any persistent property or instance variable of the following type: java.sql.Date</description>
					<location chapter="9" section="1.18"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:1082</id>
					<description>The Basic annotation can optionally be applied to any persistent property or instance variable of the following type: java.sql.Time</description>
					<location chapter="9" section="1.18"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:1083</id>
					<description>The Basic annotation can optionally be applied to any persistent property or instance variable of the following type: java.sql.TimeStamp</description>
					<location chapter="9" section="1.18"/>
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1084</id>
			<description>The [FetchType] LAZY strategy is a hint to the persistence provider runtime that data should be fetched lazily when it is first accessed.</description>
			<location chapter="9" section="1.18"/>
		</assertion>
		<assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1085</id>
			<description>The implementation is permitted to eagerly fetch data for which the LAZY strategy hint hasd been specified.</description>
			<location chapter="9" section="1.18"/>
		</assertion>
		<assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1086</id>
			<description>For Basic properties, lazy fetching might only be available for properties which are always accessed via the get/set pair.</description>
			<location chapter="9" section="1.18"/>
		</assertion>
		<assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="false">
			<id>PERSISTENCE:SPEC:1087</id>
			<description>The optional element can be used a a hint as to whether the value of the field or property may be null. </description>
			<location chapter="9" section="1.18"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1088</id>
			<description>[The optional element] is disregarded for primitive types, which are considered non-optional. </description>
			<location chapter="9" section="1.18"/>
		</assertion>
		<assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1089</id>
			<description>A Lob annotation specifies that a persistent property or field should be persisted as a large object to a database-supported large object type.</description>
			<location chapter="9" section="1.19"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1090.0</id>
			<description>The Temporal annotation must be specified for persistent fields or properties of type java.util.Date and java.util.Calendar.  It may only be specified for fields or properties of those types.</description>
			<location chapter="9" section="1.20"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1090.1</id>
			<description>The Enumerated annotation specifies that a persistent property or field should be persisted as enumerated type.</description>
			<location chapter="9" section="1.21"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1090.2</id>
			<description>An enum can be mapped as either string or integer.  The EnumType enum defines the mapping for enumerated types.</description>
			<location chapter="9" section="1.21"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1090.3</id>
			<description>If the enumerated type is not specified or the Enumerated annotation is not used, the enumerated type is assumed to be ORDINAL.</description>
			<location chapter="9" section="1.21"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1090</id>
			<description>The ManyToOne annotation defines a single-valued association to another entity class that has a many-to-one multiplicity.  It is not normally necessary to specify the name of the associated target entity explicitly since it can usually be inferred from the type of the object being referenced.</description>
			<location chapter="9" section="1.22"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1091</id>
			<description>The cascade set will cause the specified cascadable operations to be propagated to the associated entity.</description>
			<location chapter="9" section="1.22"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1092</id>
			<description>Multiple operations may be included in the [cascade] set.</description>
			<location chapter="9" section="1.22"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1093</id>
			<description>The value cascade=ALL is equivalent to cascade={PERSIST, MERGE, REMOVE, REFRESH}.</description>
			<location chapter="9" section="1.22"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1094</id>
			<description>The OneToOne annotation defines a single-valued association to another entity class that ha s a one-to-one multiplicity.  It is not normally necessary to specify the name of the associated target entity explicitly since it can usually b e inferred from the type of the object being referenced.</description>
			<location chapter="9" section="1.23"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1095</id>
			<description>The OneToMany annotation defines a many-valued association with one-to-many multiplicity. If the Collection is defined using generics to specify the element type then the associated target entity type need not be specified.  If a regular Collection or Set is used then the target entity of the class must be included.</description>
			<location chapter="9" section="1.24"/>
		</assertion>
		<assertion required="false" impl-spec="true" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1096</id>
			<description>Unidirectional one-to-many relationships may be implemented using one-to-many foreign key mappings, however, such support is not required in this release.  Applications that want to use a foreign key mapping strategy for one-to-many relationships should make these relationships bidirectional to ensure portability.</description>
			<keywords>
				<keyword>application-role</keyword>
			</keywords>
			<location chapter="9" section="1.24"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1097</id>
			<description>A JoinTable annotation s used in the mapping of associations.  A JoinTable annotation is specified on the owning side of a many-to-many association, or in a uni-directional one-to-many association. The JoinTable annotation is missing, the default values of the annotation elements apply.  The name of the JoinTable is assumed to be the tables names of the associated primary tables concatenated together (owning side first) using an underscore.</description>
			<location chapter="9" section="1.25"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1098</id>
			<description>The ManyToMany annotation defines a many-valued association with many-to-many multiplicity. If the Collection is defined using generics to specify the element type then the associated target entity type need not be specified.  If a regular Collection or Set is used then the target entity of the class must be included.</description>
			<location chapter="9" section="1.26"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1099</id>
			<description>Every many-to-many association has two sides, the owning side and the non-owning or inverse side.  The association table is specified on the owning side.</description>
			<location chapter="9" section="1.26"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable=" true">
			<id>PERSISTENCE:SPEC:1100</id>
			<description>The MapKey annotation is used to specify the map key for associations of type java.util.Map.</description>
			<location chapter="9" section="1.27"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable=" true">
			<id>PERSISTENCE:SPEC:1101</id>
			<description>The name element [of the MapKey annotation] designates the name of the persistent field or property of the associated entity that is used as the map key.
						If name is not specified, by default the primary key is used as the map key.</description>
			<location chapter="9" section="1.27"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable=" true">
			<id>PERSISTENCE:SPEC:1102</id>
			<description>If the primary key is a composite primary key and is mapped as IdClass, an instance of the primary key class is used as the key.</description>
			<location chapter="9" section="1.27"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable=" true">
			<id>PERSISTENCE:SPEC:1103</id>
			<description>The OrderyBy annnotation specifies the ordering of the elements of a collection valued associate at the point when the association is retrieved.</description>
			<location chapter="9" section="1.28"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1104</id>
			<description>The syntax of the ordering element is as follows:</description>
			<location chapter="9" section="1.28"/>
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:1105</id>
					<description>ORDER BY orderby_list</description>
					<location chapter="9" section="1.28"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:1106</id>
					<description>orderby_list::=orderby_item[,orderby_item]*</description>
					<location chapter="9" section="1.28"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
					<id>PERSISTENCE:SPEC:1107</id>
					<description>orderby_item::=property_or_field_name[ASC|DESC]</description>
					<location chapter="9" section="1.28"/>
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable=" true">
			<id>PERSISTENCE:SPEC:1108</id>
			<description>If ASC or DESC is not specified, ASC (ascending order) is assumed.</description>
			<location chapter="9" section="1.28"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable=" true">
			<id>PERSISTENCE:SPEC:1109</id>
			<description>The property or field name must correspond to that of a persistent property or field of the associated class.</description>
			<location chapter="9" section="1.28"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable=" true">
			<id>PERSISTENCE:SPEC:1110</id>
			<description>The properties or fields used in the ordering must correspond to columns for which comparison operators are supported.</description>
			<location chapter="9" section="1.28"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable=" true">
			<id>PERSISTENCE:SPEC:1111</id>
			<description>The OrderyBy annnotation specifies the ordering of the elements of a collection valued associate at the point when the association is retrieved.</description>
			<location chapter="9" section="1.28"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1112</id>
			<description>The Inheritance annotation defines the inheritance strategy to be used for an entity class hierarchy.  The three inheritance mapping strategies are:</description>
			<location chapter="9" section="1.29"/>
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable=" true">
					<id>PERSISTENCE:SPEC:1113</id>
					<description>Single Table per Class Hierarchy</description>
					<location chapter="9" section="1.29"/>
				</assertion>
				<assertion required="false" impl-spec="true" defined-by="technology" status="active" testable=" true">
					<id>PERSISTENCE:SPEC:1114</id>
					<description>Table per Class [NOTE: Support for TABLE_PER_CLASS mapping strategy is optional in this release but will be required in the next.]</description>
					<location chapter="9" section="1.29"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable=" true">
					<id>PERSISTENCE:SPEC:1115</id>
					<description>Joined Subclass</description>
					<location chapter="9" section="1.29"/>
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1116</id>
			<description>For the SINGLE_TABLE mapping strategy, the persistence provider will use a discriminator column.  The supported discriminator types are defined by the DiscriminatorType enum:  STRING, CHAR, INTEGER.</description>
			<location chapter="9" section="1.29"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1118</id>
			<description>The strategy and discriminatorType are only specified once per class hierarchy (in the root class), while the discriminatorValue should be specified for each class in the hierarchy.</description>
			<location chapter="9" section="1.30"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1119</id>
			<description>If no inheritance type is specified for a class hierarchy, the single table per class hierarchy strategy is used.</description>
			<location chapter="9" section="1.29"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1126</id>
			<description>The DiscriminatorColumn annotation is used to define the discriminator column for SINGLE_TABLE and JOINED inheritance mapping strategies.</description>
			<location chapter="9" section="1.30"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1126.1</id>
			<description>The DiscriminatorColumn annotation can be specified on an entity class (including on an abstract entity class).</description>
			<location chapter="9" section="1.30"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1126.2</id>
			<description>If the DiscriminatorColumn annotation is missing, and a discriminator column is required, the name of the discriminator column defaults to "DTYPE" and the discriminator type to STRING.</description>
			<location chapter="9" section="1.30"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1126.3</id>
			<description>The DiscriminatorValue annotation is used to specify the value of the discriminator column for entities of the given type.  The DiscriminatorValue annotation can only be specified on a concrete entity class.  If the DiscriminatorValue annotation is not specified and a discriminator column is used, a provider-specific function will be used to generate a value representing the entity type.</description>
			<location chapter="9" section="1.31"/>
		</assertion>
		<assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1126.4</id>
			<description>If the DiscriminatorValue annotation is not specified and a discriminator column is used, a provider-specific function will be used to generate a value representing the entity type.</description>
			<location chapter="9" section="1.31"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1120</id>
			<description>The PrimaryKeyJoinColumn annotation specifies the primary key columns that are used as a foreign key to join to another table.</description>
			<location chapter="9" section="1.32"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1121</id>
			<description>The PrimaryKeyJoinColumn annotated is used:</description>
			<location chapter="9" section="1.32"/>
			<sub-assertions>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable=" true">
					<id>PERSISTENCE:SPEC:1122</id>
					<description>to join the primary table of an entity subclass in the JOINED mapping strategy to the primary table of its superclass</description>
					<location chapter="9" section="1.32"/>
				</assertion>
				<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable=" true">
					<id>PERSISTENCE:SPEC:1123</id>
					<description>in a OneToOne mapping in which the primary key of the referencing entity is used as a foreign key to the referenced entity.</description>
					<location chapter="9" section="1.32"/>
				</assertion>
			</sub-assertions>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1124</id>
			<description>If no PrimaryKeyJoinColumn annotation is specified, the foreign key columns are assumed to have the same names as the primary key columns of the primary table of the superclass.</description>
			<location chapter="9" section="1.32"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1125</id>
			<description>Composite keys are supported via the PrimaryKeyJoinColumns annotation.</description>
			<location chapter="9" section="1.33"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1127</id>
			<description>The Embeddable annotation is used to mark an object that is stored as an intrinisic part of an owning entity and shares the identify of that entity.</description>
			<location chapter="9" section="1.34"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1128</id>
			<description>Each of the persistent properties or fields of the embedded object is mapped to the database table.  Only Basic, Column, Serialized, and Lob mapping annotations may be used to map embedded object.</description>
			<location chapter="9" section="1.34"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1129</id>
			<description>The Embedded annotation may be used in an entity class when it is using a shared embeddable class.  The entity may override the column mappings declared within the embeddable class to apply to its own entity table.</description>
			<location chapter="9" section="1.35"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1130</id>
			<description>The MappedSuperclass annotation designates an embedded superclass  A class designated as an embedded superclass has no separate table defined for it.  Its mapping
			informationis applied to the entities that inherit from it.</description>
			<location chapter="9" section="1.36"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1131</id>
			<description>A class designated as MappedSuperclass can be mapped in the same way as an entity except that the mappings will apply only to its subcllesses since not table exits for the embedded superclass.</description>
			<location chapter="9" section="1.36"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1132</id>
			<description>When applied to the subclasses the inherited mappings will apply in the context of the subclass tables.</description>
			<location chapter="9" section="1.36"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1133</id>
			<description>Mapping information may be overridden in such subclasses by using the AttributreOverride annotation.</description>
			<location chapter="9" section="1.36"/>
		</assertion>
		<assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="false">
			<id>PERSISTENCE:SPEC:1134</id>
			<description>The SequenceGenerator annotation defines a primary key or id generator which may be referenced by name when annotation the id attribute.</description>
			<location chapter="9" section="1.37"/>
		</assertion>
		<assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="false">
			<id>PERSISTENCE:SPEC:1135</id>
			<description>A generator may be defined at either the package, class, method, or field level.  The level at which it is defined will depend upon the desired visibility and sharing of the generator.  No scoping or visibility rules are actually enforced.  However, it is good practice to define the generator at the level for which it will be used.</description>
			<location chapter="9" section="1.37"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1136</id>
			<description>The TableGenerator annotation defines a primary key or id generator which may be referenced by name when annotation the id attribute.</description>
			<location chapter="9" section="1.38"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1137</id>
			<description>A generator may be defined at either the package, class, method, or field level.  The level 
at which it is defined will depend upon the desired visibility and sharing of the generator.  No scoping or visibility rules are actually enforce
d.  However, it is good practice to define the generator at the level for which it will be used.</description>
			<location chapter="9" section="1.38"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1138</id>
			<description>XML Overriding Rules</description>
			<location chapter="10" section="1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1139</id>
			<description>persistent-unit-defaults Subelements</description>
			<location chapter="10" section="1.1"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1140</id>
			<description>Other Subelements of the entity-mapping element</description>
			<location chapter="10" section="1.2"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1141</id>
			<description>Entity Subelements</description>
			<location chapter="10" section="1.3"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1142</id>
			<description>mapped-superclass Subelements</description>
			<location chapter="10" section="1.4"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1143</id>
			<description>Embeddable Subelements</description>
			<location chapter="10" section="1.5"/>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>PERSISTENCE:SPEC:1144</id>
			<description>XML Schema</description>
			<location chapter="10" section="2"/>
		</assertion>
	</assertions>
</spec>

