<?xml version="1.0" encoding="UTF-8"?>
<!--

    Copyright (c) 2018, 2020 Oracle and/or its affiliates. All rights reserved.

    This program and the accompanying materials are made available under the
    terms of the Eclipse Public License v. 2.0, which is available at
    http://www.eclipse.org/legal/epl-2.0.

    This Source Code may also be made available under the following Secondary
    Licenses when the conditions for such availability set forth in the
    Eclipse Public License v. 2.0 are satisfied: GNU General Public License,
    version 2 with the GNU Classpath Exception, which is available at
    https://www.gnu.org/software/classpath/license.html.

    SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0

-->

<spec>
    <next-available-id>312</next-available-id>
    <previous-id>311</previous-id>
    <technology>Servlet</technology>
    <id>Servlet</id>
    <name>Jakarta Servlet</name>
    <version>5.0</version>
    <location-names>
        <chapters>
            <chapter id="1" name="Overview">
                <sections>
                    <section id="1" name="What is a Servlet?"/>
                    <section id="2" name="What is a Servlet Container"/>
                    <section id="3" name="An Example"/>
                    <section id="4" name="Comparing Servlets with Other Technologies"/>
                    <section id="5" name="Relationship to Java 2, Platform Enterprise Edition"/>
                    <section id="6" name="Compatibility with Java Servlet Specification Version 2.5"/>
                    <section id="6.1" name="Processing annotations"/>
                </sections>
            </chapter>
            <chapter id="2" name="The Servlet Interface">
                <sections>
                    <section id="1" name="Request Handling Methods"/>
                    <section id="1.1" name="HTTP Specific Request Handling Methods"/>
                    <section id="1.2" name="Additional Methods"/>
                    <section id="1.3" name="Conditional GET Support"/>
                    <section id="2" name="Number of Instances"/>
                    <section id="2.1" name="Note About Single Thread Model"/>
                    <section id="3" name="Servlet Life Cycle"/>
                    <section id="3.1" name="Loading and Instantiation"/>
                    <section id="3.2" name="Initialization"/>
                    <section id="3.2.1" name="Error Conditions on Initialization"/>
                    <section id="3.2.2" name="Tool Consideration"/>
                    <section id="3.3" name="Request Handling"/>
                    <section id="3.3.1" name="Multithreading Issues"/>
                    <section id="3.3.2" name="Exceptions During Request Handling"/>
                    <section id="3.3.3" name="Asynchronous processing"/>
                    <section id="3.3.4" name="Thread Safety"/>
                    <section id="3.3.5" name="Upgrade Processing"/>
                    <section id="3.4" name="End of Service"/>
                </sections>
            </chapter>
            <chapter id="3" name="The Request">
                <sections>
                    <section id="1" name="HTTP Protocol Parameters"/>
                    <section id="1.1" name="When Parameters Are Available"/>
                    <section id="2" name="File upload"/>
                    <section id="3" name="Attributes"/>
                    <section id="4" name="Headers"/>
                    <section id="5" name="Request Path Elements"/>
                    <section id="6" name="Path Translation Methods"/>
                    <section id="7" name="Non Blocking IO"/>
                    <section id="8" name="Cookies"/>
                    <section id="9" name="SSL Attributes"/>
                    <section id="10" name="Internationalization"/>
                    <section id="11" name="Request data encoding"/>
                    <section id="12" name="Lifetime of the Request Object"/>
                </sections>
            </chapter>
            <chapter id="4" name="Servlet Context">
                <sections>
                    <section id="1" name="Introduction to the ServletContext Interface"/>
                    <section id="2" name="Scope of a ServletContext Interface"/>
                    <section id="3" name="Initialization Parameters"/>
                    <section id="4" name="Configuration methods"/>
                    <section id="4.1" name="Programmatically adding and configuring Servlets"/>
                    <section id="4.1.1" name="addServlet(String servletName, String className)"/>
                    <section id="4.1.2" name="addServlet(String servletName, Servlet servlet)"/>
                    <section id="4.1.3" name="addServlet(String servletName, Class &lt;? extends Servlet&gt; servletClass)" />
                    <section id="4.1.4" name="&lt;T extends Servlet&gt; T createServlet(Class&lt;T&gt; clazz) "/>
                    <section id="4.1.5" name="ServletRegistration getServletRegistration(String servletName)"/>
                    <section id="4.1.6" name="Map&lt;String, &lt;? extends ServletRegistration&gt; getServletRegistrations()"/>
                    <section id="4.2" name="Programmatically adding and configuring Filters"/>
                    <section id="4.2.1" name="addFilter(String filterName, String className)"/>
                    <section id="4.2.2" name="addFilter(String filterName, Filter filter)"/>
                    <section id="4.2.3" name="addFilter(String filterName, Class &lt;? extends Filter&gt; filterClass)"/>
                    <section id="4.2.4" name="&lt;T extends Filter&gt; T createFilter(Class&lt;T&gt; clazz)"/>
                    <section id="4.2.5" name="FilterRegistration getFilterRegistration(String filterName)"/>
                    <section id="4.2.6" name="Map&lt;String, &lt;? extends FilterRegistration&gt; getServletRegistrations()"/>
                    <section id="4.3" name="Programmatically adding and configuring Listeners"/>
                    <section id="4.3.1" name="void addListener(String className)"/>
                    <section id="4.3.2" name="&lt;T extends EventListener&gt; void addListener(T t)"/>
                    <section id="4.3.3" name="void addListener(Class &lt;? extends EventListener&gt; listenerClass)"/>
                    <section id="4.3.4" name="&lt;T extends EventListener&gt; void createListener(Class&lt;T&gt; clazz)"/>
                    <section id="4.3.5" name="Annotation processing requirements for programmatically added Servlets, Filters and Listeners"/>
                    <section id="5" name="Context Attributes"/>
                    <section id="5.1" name="Context Attributes in a Distributed Container"/>
                    <section id="6" name="Resources"/>
                    <section id="7" name="Multiple Hosts and Servlet Contexts"/>
                    <section id="8" name="Reloading Considerations"/>
                    <section id="8.1" name="Temporary Working Directories"/>
                </sections>
            </chapter>
            <chapter id="5" name="The Response">
                <sections>
                    <section id="1" name="Buffering"/>
                    <section id="2" name="Headers"/>
                    <section id="3" name="Non Blocking IO"/>
                    <section id="4" name="Convenience Methods"/>
                    <section id="5" name="Internationalization"/>
                    <section id="6" name="Closure of Response Object"/>
                    <section id="7" name="Lifetime of the Response Object"/>
                </sections>
            </chapter>
            <chapter id="6" name="Filtering">
                <sections>
                    <section id="1" name="What is a filter?"/>
                    <section id="1.1" name="Examples of Filtering Components"/>
                    <section id="2" name="Main Concepts"/>
                    <section id="2.1" name="Filter Lifecycle"/>
                    <section id="2.2" name="Wrapping Requests and Responses"/>
                    <section id="2.3" name="Filter Environment"/>
                    <section id="2.4" name="Configuration of Filters in a Web Application"/>
                    <section id="2.5" name="Filters and the RequestDispatcher"/>
                </sections>
            </chapter>
            <chapter id="7" name="Sessions">
                <sections>
                    <section id="1" name="Session Tracking Mechanisms"/>
                    <section id="1.1" name="Cookies"/>
                    <section id="1.2" name="SSL Sessions"/>
                    <section id="1.3" name="URL Rewriting"/>
                    <section id="1.4" name="Session Integrity"/>
                    <section id="2" name="Creating a Session"/>
                    <section id="3" name="Session Scope"/>
                    <section id="4" name="Binding Attributes into a Session"/>
                    <section id="5" name="Session Timeouts"/>
                    <section id="6" name="Last Accessed Times"/>
                    <section id="7" name="Important Session Semantics"/>
                    <section id="7.1" name="Threading Issues"/>
                    <section id="7.2" name="Distributed Environments"/>
                    <section id="7.3" name="Client Semantics"/>
                </sections>
            </chapter>
            <chapter id="8" name="Annotations and pluggability">
                <sections>
                    <section id="1" name="Annotations and pluggability"/>
                    <section id="1.1" name="@WebServlet"/>
                    <section id="1.2" name="@WebFilter"/>
                    <section id="1.3" name="@WebInitParam"/>
                    <section id="1.4" name="@WebListener"/>
                    <section id="1.5" name="@MultipartConfig"/>
                    <section id="1.6" name="Other annotations/conventions"/>
                    <section id="2" name="Pluggability"/>
                    <section id="2.1" name="Modularity of web.xml"/>
                    <section id="2.2" name="Ordering of web.xml and web-fragment.xml"/>
                    <section id="2.3" name="Assembling the descriptor from web.xml, web-fragment.xml and annotations"/>
                    <section id="2.4" name="Shared libraries / runtimes pluggability"/>
                    <section id="3" name="JSP container pluggability"/>
                    <section id="4" name="Processing annotations and fragments"/>
                </sections>
            </chapter>
            <chapter id="9" name="Dispatching Requests">
                <sections>
                    <section id="1" name="Obtaining a RequestDispatcher"/>
                    <section id="1.1" name="Query Strings in Request Dispatcher Paths"/>
                    <section id="2" name="Using a Request Dispatcher"/>
                    <section id="3" name="The Include Method"/>
                    <section id="3.1" name="Included Request Parameters"/>
                    <section id="4" name="The Forward Method"/>
                    <section id="4.1" name="Query String"/>
                    <section id="4.2" name="Forwarded Request Parameters"/>
                    <section id="5" name="Error Handling"/>
                    <section id="6" name="Obtaining an AsyncContext"/>
                    <section id="7" name="The Dispatch Method"/>
                    <section id="7.1" name="Query String"/>
                    <section id="7.2" name="Dispatched Request Parameters"/>
                </sections>
            </chapter>
            <chapter id="10" name="Web Applications">
                <sections>
                    <section id="1" name="Web Applications Within Web Servers"/>
                    <section id="2" name="Relationship to ServletContext"/>
                    <section id="3" name="Elements of a Web Application"/>
                    <section id="4" name="Deployment Hierarchies"/>
                    <section id="5" name="Directory Structure"/>
                    <section id="5.1" name="Example of Application Directory Structure"/>
                    <section id="6" name="Web Application Archive File"/>
                    <section id="7" name="Web Application Deployment Descriptor"/>
                    <section id="7.1" name="Dependencies on Extensions"/>
                    <section id="7.2" name="Web Application Classloader"/>
                    <section id="8" name="Replacing a Web Application"/>
                    <section id="9" name="Error Handling"/>
                    <section id="9.1" name="Request Attributes"/>
                    <section id="9.2" name="Error Pages"/>
                    <section id="9.3" name="Error Filters"/>
                    <section id="10" name="Welcome Files"/>
                    <section id="11" name="Web Application Environment"/>
                    <section id="12" name="Web Applicaation Deployment"/>
                    <section id="13" name="Inclusion of a web.xml Deployment Descriptor"/>
                </sections>
            </chapter>
            <chapter id="11" name="Application Lifecycle Events">
                <sections>
                    <section id="1" name="Introduction"/>
                    <section id="2" name="Event Listeners"/>
                    <section id="2.1" name="Event Types and Listener Interfaces"/>
                    <section id="2.2" name="An Example of Listener Use"/>
                    <section id="3" name="Listener Class Configuration"/>
                    <section id="3.1" name="Provision of Listener Classes"/>
                    <section id="3.2" name="Deployment Declarations"/>
                    <section id="3.3" name="Listener Registration"/>
                    <section id="3.4" name="Notification At Shutdown"/>
                    <section id="4" name="Deployment Descriptor Example"/>
                    <section id="5" name="Listener Instances and Threading"/>
                    <section id="6" name="Listener Exceptions"/>
                    <section id="7" name="Distributed Containers"/>
                    <section id="8" name="Session Events"/>
                </sections>
            </chapter>
            <chapter id="12" name="Mapping Requests to Servlets">
                <sections>
                    <section id="1" name="Use of URL Paths"/>
                    <section id="2" name="Specification of Mappings"/>
                    <section id="2.1" name="Implicit Mappings"/>
                    <section id="2.2" name="Example Mapping Set"/>
                </sections>
            </chapter>
            <chapter id="13" name="Security">
                <sections>
                    <section id="1" name="Introduction"/>
                    <section id="2" name="Declarative Security"/>
                    <section id="3" name="Programmatic Security"/>
                    <section id="4" name="Programmatic Access Control Annotations"/>
                    <section id="4.1" name="@ServletSecurity Annotation"/>
                    <section id="4.1.1" name="Examples"/>
                    <section id="4.1.2" name="Mapping @ServletSecurity to security-constraint"/>
                    <section id="4.1.3" name="Mapping @HttpConstraint and @HttpMethodConstraint to XML"/>
                    <section id="4.2" name="setServletSecurity of ServletRegistration.Dynamic"/>
                    <section id="5" name="Roles"/>
                    <section id="6" name="Authentication"/>
                    <section id="6.1" name="HTTP Basic Authentication"/>
                    <section id="6.2" name="HTTP Digest Authentication"/>
                    <section id="6.3" name="Form Based Authentication"/>
                    <section id="6.3.1" name="Login Form Notes"/>
                    <section id="6.4" name="HTTPS Client Authentication"/>
                    <section id="6.5" name="Additional Container Authentication Mechanisms"/>
                    <section id="7" name="Server Tracking of Authentication Information"/>
                    <section id="8" name="Specifying Security Constraints"/>
                    <section id="8.1" name="Combining Overlapping Constraints"/>
                    <section id="8.2" name="Example"/>
                    <section id="8.3" name="Processing Requests"/>
                    <section id="8.4" name="Uncovered HTTP Protocol Methods"/>
                    <section id="9" name="Default Policies"/>
                    <section id="10" name="Login and Logout"/>
                </sections>
            </chapter>
            <chapter id="14" name="Deployment Descriptor">
                <sections>
                    <section id="1" name="Deployment Descriptor Elements"/>
                    <section id="2" name="Rules for Processing the Deployment Descriptor"/>
                    <section id="3" name="Deployment Descriptor"/>
                    <section id="4" name="Deployment Descriptor Diagram"/>
                    <section id="5" name="Examples"/>
                    <section id="5.1" name="A Basic Example"/>
                    <section id="5.2" name="An Example of Security"/>
                </sections>
            </chapter>
            <chapter id="15" name="Requirements related to other Specifications">
                <sections>
                    <section id="1" name="Sessions"/>
                    <section id="2" name="Web Applications"/>
                    <section id="2.1" name="Web Application Class Loader"/>
                    <section id="2.2" name="Web Application Environment"/>
                    <section id="2.3" name="JNDI Name for Web Module Context Root URL"/>
                    <section id="3" name="Security"/>
                    <section id="3.1" name="Propagation of Security Identity in Jakarta Enterprise Beans Calls"/>
                    <section id="3.2" name="Container Authorization Requirements"/>
                    <section id="3.3" name="Container Authentication Requirements"/>
                    <section id="4" name="Deployment"/>
                    <section id="4.1" name="Deployment Descriptor Elements"/>
                    <section id="4.2" name="Packaging and Deployment of JAX-WS Components"/>
                    <section id="4.3" name="Rules for Processing the Deployment Descriptor"/>
                    <section id="5" name="Annotations and Resource Injection"/>
                    <section id="5.1" name="@DeclaredRoles"/>
                    <section id="5.2" name="@EJB Annotation"/>
                    <section id="5.3" name="@EJBs Annotation"/>
                    <section id="5.4" name="@Resource Annotation"/>
                    <section id="5.5" name="@PersistenceContext Annotation"/>
                    <section id="5.6" name="@PersistenceContexts Annotation"/>
                    <section id="5.7" name="@PersistenceUnit Annotation"/>
                    <section id="5.8" name="@PersistenceUnits Annotation"/>
                    <section id="5.9" name="@PostConstruct Annotation"/>
                    <section id="5.10" name="@PreDestroy Annotation"/>
                    <section id="5.11" name="@Resources Annotation"/>
                    <section id="5.12" name="@RunAs Annotation"/>
                    <section id="5.13" name="@WebServiceRef Annotation"/>
                    <section id="5.14" name="@WebServiceRefs Annotation"/>
                    <section id="5.15" name="Managed Beans and JSR 299 requirements"/>
                </sections>
            </chapter>
            <chapter id="A" name="Change Log">
                <sections>
                    <section id="1" name="Changes since Servlet 3.0"/>
                    <section id="2" name="Changes since Servlet 3.0 Proposed Final Draft"/>
                    <section id="3" name="Changes since Servlet 3.0 Public Review"/>
                    <section id="4" name="Changes since Servlet 3.0 EDR"/>
                    <section id="5" name="Changes since Servlet 2.5 MR6"/>
                    <section id="6" name="Changes since Servlet 2.5 MR5"/>
                    <section id="6.1" name="Clarify SRV 8.4 The Forward Method"/>
                    <section id="6.2" name="Update Deployment descriptor http-method values allowed"/>
                    <section id="6.3" name="Clarify SRV 7.7.1 Threading Issues"/>
                    <section id="7" name="Changes since Servlet 2.5 MR2"/>
                    <section id="7.1" name="Updated Annotation Requirements for Jakarta EE containers"/>
                    <section id="7.2" name="Updated Java Enterprise Edition Requirements"/>
                    <section id="7.3" name="Clarified HttpServletRequest.getRequestURL()"/>
                    <section id="7.4" name="Removal of IllegalStateException from HttpSession.getId()"/>
                    <section id="7.5" name="ServletContext.getContextPath()"/>
                    <section id="7.6" name="Requirement for web.xml in web applications"/>
                    <section id="8" name="Changes Since Servlet 2.4"/>
                    <section id="8.1" name="Session Clarification"/>
                    <section id="8.2" name="Filter All Dispatches"/>
                    <section id="8.3" name="Multiple Occurrences of Servlet Mappings"/>
                    <section id="8.4" name="Multiple Occurrences Filter Mappings"/>
                    <section id="8.5" name="Support Alternative HTTP Methods with Authorization Constraints"/>
                    <section id="8.6" name="Minimum Java SE Requirement"/>
                    <section id="8.7" name="Annotations and Resource Injection"/>
                    <section id="8.8" name="SRV.9.9 (Error Handling) Requirement Removed"/>
                    <section id="8.9" name="HttpServletRequest.isRequestedSessionIdValid() Clarification"/>
                    <section id="8.10" name="SRV.5.5 (Closure of Response Object) Clarification"/>
                    <section id="8.11" name="ServletRequest.setCharacterEncoding() Clarified"/>
                    <section id="8.12" name="Java Enterprise Edition Requirements"/>
                    <section id="8.13" name="Servlet 2.4 MR Change Log Updates Added"/>
                    <section id="8.14" name="Synchronized Access Session Object Clarified"/>
                    <section id="9" name="Changes Since Servlet 2.3"/>
                </sections>
            </chapter>
        </chapters>
    </location-names>
    <assertions>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:1</id>
            <description>All servlet containers must support HTTP/1.0 and HTTP/1.1 protocols</description>
            <location chapter="1" section="2"/>
            <comment>Not going to put the container through the paces of full support, but we should be able to issue an OPTIONS request to the container using HTTP/1.1 and HTTP/1.0 should be accepted within a request.  NOTE:  All tests will probably now use HTTP/1.1.</comment>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>Servlet:SPEC:2</id>
            <description>Java SE 7 is the minimum version of the underlying Java platform with which containers must be built.</description>
            <location chapter="1" section="2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:269</id>
            <description>In Servlet 2.5, metadata-complete only affected the scanning of annotations at
            deployment time. The notion of web-fragments did not exist in servlet 2.5. However
                in servlet 3.0 and later, metadata-complete affects scanning of all annotations that
                specify deployment information and web-fragments at deployment time. The
                version of the descriptor MUST not affect which annotations you scan for in a web
                application. An implementation of a particular version of the specification MUST
                scan for all annotations supported in that configuration, unless metadata-complete
                is specified.
            </description>
            <location chapter="1" section="6.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:3</id>
            <description>A servlet hosted in a non-distributed environment, the servlet container must use only one instance per servlet declaration.</description>
            <location chapter="2" section="2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>Servlet:SPEC:4</id>
            <description>A servlet deployed as part of an application marked in the deployment descriptor as distributable, a container may have only one instance per servlet declaration per virtual machine (VM).</description>
            <location chapter="2" section="2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:5</id>
            <description>The life cycle of a servlet is expressed in the API by the 'init', 'service', and 'destroy' methods of the jakarta.servlet.Servlet interface that all servlets must implement directly, or indirectly through the GenericServlet or HttpServlet abstract classes.</description>
            <location chapter="2" section="3"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:6</id>
            <description>The servlet container is responsible for loading and instantiating servlets.  </description>
            <location chapter="2" section="3.1"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
                    <id>Servlet:SPEC:6.1</id>
                    <description>When the servlet engine is started, needed servlet classes must be located by the servlet container using normal Java class loading facilities.</description>
                    <location chapter="2" section="3.1"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:7</id>
            <description>After the servlet object is instantiated, the container must initialize the servlet before it can handle requests from clients by calling the init method of the Server interface with a unique (per servlet declaration) object implementing the ServerConfig interface.</description>
            <location chapter="2" section="3.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:8</id>
            <description>The servlet container must not call the destroy method on a Servlet that threw an Exception during the initialization process.</description>
            <location chapter="2" section="3.2.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>Servlet:SPEC:9</id>
            <description>A servlet throwing an UnavailableException that indicates a minimum time of unavailability, the container must wait for the period of time specified to pass before creating and initializing a new servlet instance.</description>
            <location chapter="2" section="3.2.1"/>
            <comment>Not testable as there is no information about expected response from container in such cases.</comment>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="deprecated" testable="true">
            <id>Servlet:SPEC:10</id>
            <description>For servlets not implementing the SingleThreadModel interface, if the service method (or methods such as doGet or doPost which are dispatched to the service method of the HttpServlet abstract class) has been defined with the synchronized keyword, the servlet container must serialize request through it.</description>
            <location chapter="2" section="3.3.1"/>
            <comment>Revisit -- wording seems incorrect.</comment>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:11</id>
            <description>If a permanent unavailability is indicated by the UnavailableException, the servlet container must remove the servlet from service, call its destroy method, and release the servlet instance.</description>
            <location chapter="2" section="3.3.2"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:11.1</id>
                    <description>Any requests refused by the container by the cause, must be returned with a SC_NOT_FOUND(404) response.</description>
                    <location chapter="2" section="3.3.2"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:270</id>
            <description>public ServletRequest getRequest() - returns the request that was used to
                initialize the AsyncContext by calling one of the startAsync methods. Calling
                getRequest when complete or any of the dispatch methods has been
                previously called in the asynchronous cycle will result in an IllegalStateException.
            </description>
            <location chapter="2" section="3.3.3"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:271</id>
            <description>public ServletResponse getResponse() - returns the response that was used
                to initialize the AsyncContext by calling one of the startAsync methods.
                Calling getResponse when complete or any of the dispatch methods has
                been previously called in the asynchronous cycle will result in an
                IllegalStateException.
            </description>
            <location chapter="2" section="3.3.3"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:272</id>
            <description>The servlet container provides an HTTP upgrade mechanism. However the servlet
                container itself does not have knowledge about the upgraded protocol. The protocol
                processing is encapsulated in the  HttpUpgradeHandler.
                Data reading or writing between the servlet container and the HttpUpgradeHandler is in byte streams..
            </description>
            <location chapter="2" section="3.3.5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:273</id>
            <description>When an upgrade request is received, the servlet can invoke the
                HttpServletRequest.upgrade method, which starts the upgrade process.
                This method instantiates the given HttpUpgradeHandler class.
                The returned HttpUpgradeHandler instance may be further customized. The application
                prepares and sends an appropriate response to the client. After exiting the service
                method of the servlet, the servlet container completes the processing of all filters and
                marks the connection to be handled by the HttpUpgradeHandler. It then calls
                the HttpUpgradeHandler's init method, passing a WebConnection to allow the protocol handler
                access to the data streams.
            </description>
            <location chapter="2" section="3.3.5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:274</id>
            <description>The servlet filters only process the initial HTTP request and response. They are not
                involved in subsequent communications. In other words, they are not invoked once
                the request has been upgraded.
            </description>
            <location chapter="2" section="3.3.5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:275</id>
            <description>The HttpUpgradeHandler may use non blocking IO to consume and produce messages. </description>
            <location chapter="2" section="3.3.5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:299</id>
            <description>When the upgrade processing is done, HttpUpgradeHandler.destroy will be invoked.</description>
            <location chapter="2" section="3.3.5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>Servlet:SPEC:12</id>
            <description>When the servlet container determines that a Servlet should be removed from service, it must call the destroy method of the Servlet interface to allow the servlet to release any resources it is using and save any persistent state.</description>
            <location chapter="2" section="3.4"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
                    <id>Servlet:SPEC:12.1</id>
                    <description>Before the container calls the destroy method, it must allow any threads that are currently running in the service method of the servlet to complete execution, or exceed a server defined time limit.</description>
                    <location chapter="2" section="3.4"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
                    <id>Servlet:SPEC:12.2</id>
                    <description>Once the destroy method is called on a servlet instance, the container must not route other requests to that instance of the Servlet.</description>
                    <location chapter="2" section="3.4"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
                    <id>Servlet:SPEC:12.3</id>
                    <description>After the destroy method completes, the servlet container must release the servlet instance so that it is eligible for garbage collection.</description>
                    <location chapter="2" section="3.4"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:20</id>
            <description>Data from the query string and the post body are aggregated into the request
                parameter set. Query string data is presented before post body data.
            </description>
            <location chapter="3" section="1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:21</id>
            <description>Path parameters that are a part of a GET request (as defined by HTTP 1.1) are not exposed by these APIs.
                They must be parsed from the String values returned by the getRequestURI method or the getPathInfo method.
            </description>
            <location chapter="3" section="1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:22</id>
            <description>The following conditions must be met before post form data will be populated to the parameter set:</description>
            <location chapter="3" section="1.1"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:22.1</id>
                    <description>The request is an HTTP or HTTPS request</description>
                    <location chapter="3" section="1.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:22.2</id>
                    <description>The HTTP method is POST</description>
                    <location chapter="3" section="1.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:22.3</id>
                    <description>The content type is application/x-www-form-urlencoded</description>
                    <location chapter="3" section="1.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:22.4</id>
                    <description>The servlet has made an initial call to any of the getParameter family of methods on the request object.</description>
                    <location chapter="3" section="1.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:22.5</id>
                    <description>If the conditions are not met, and the post form data is not included in the parameter
                        set, the post data must still be available to the servlet via the request object's input stream.
                    </description>
                    <location chapter="3" section="1.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:22.6</id>
                    <description>If the conditions are met, post form data will no longer be available for
                        reading directly from the request object?s input stream.
                    </description>
                    <location chapter="3" section="1.1"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:276</id>
            <description>Servlet container allows files to be uploaded when data is sent as multipart/form-data.</description>
            <location chapter="3" section="2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:277</id>
            <description>The servlet container provides multipart/form-data processing if any one of the following conditions is met.</description>
            <location chapter="3" section="2"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:277.1</id>
                    <description>The servlet handling the request is annotated with the @MultipartConfig
                        as defined in Section 8.1.5, "@MultipartConfig" on page8-68.
                    </description>
                    <location chapter="3" section="2"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:277.2</id>
                    <description>Deployment descriptors contain a multipart-config element for the servlet handling the request.</description>
                    <location chapter="3" section="2"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:278</id>
            <description>How data in a request of type multipart/form-data is made available depends on
                whether the servlet container provides multipart/form-data processing:
            </description>
            <location chapter="3" section="2"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:278.1</id>
                    <description>If the servlet container provides multipart/form-data processing,
                        the data is made available through the following methods in HttpServletRequest:
                    </description>
                    <location chapter="3" section="2"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:278.1.1</id>
                    <description>public Collection &lt;Part&gt; getParts()
                    </description>
                    <location chapter="3" section="2"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:278.1.2</id>
                    <description>public Part getPart(String name)</description>
                    <location chapter="3" section="2"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:278.1.3</id>
                    <description>Each part provides access to the headers, content type related with it
                        and the content via the Part.getInputStream method.
                    </description>
                    <location chapter="3" section="2"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:278.1.4</id>
                    <description>For parts with form-data as the Content-Disposition, but without a filename,
                        the string value of the part will also be available through the getParameter and
                        getParameterValues methods on HttpServletRequest, using the name of the part.
                    </description>
                    <location chapter="3" section="2"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:278.2</id>
                    <description>If the servlet container does not provide the multi-part/form-data processing,
                        the data will be available through the HttpServletReuqest.getInputStream.
                    </description>
                    <location chapter="3" section="2"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:23</id>
            <description>(Servlet Path)This path starts with a '/' character except in the case
                where the request is matched with the '/*'  or "" pattern, in which case it is an
                empty string.
            </description>
            <location chapter="3" section="5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:24</id>
            <description>(Servlet Path)The path section that directly corresponds to the mapping which
                activated this request. This path starts with a '/' character except...
            </description>
            <location chapter="3" section="5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:25</id>
            <description>The part of the request path that is not part of the Context Path or the
                Servlet Path. It is either null if there is no extra path, or is a string with a leading
                '/'.
            </description>
            <location chapter="3" section="5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:279</id>
            <description>It is important to note that, except for URL encoding differences between the request
                URI and the path parts, the following equation is always true:
                requestURI = contextPath + servletPath + pathInfo
            </description>
            <location chapter="3" section="5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:280</id>
            <description>In situations where the servlet container cannot determine a valid file path for these
                methods, such as when the Web application is executed from an archive, on a remote
                file system not accessible locally, or in a database, these methods must return null.
            </description>
            <location chapter="3" section="6"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:281</id>
            <description>Resources inside the META-INF/resources directory of JAR file must be considered
                only if the container has unpacked them from their containing JAR file when a call to
                getRealPath() is made, and in this case MUST return the unpacked location.
            </description>
            <location chapter="3" section="6"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:282</id>
            <description>The ReadListener provides the following callback methods for non blocking IO -
            </description>
            <location chapter="3" section="7"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:282.1</id>
                    <description>ReadListener.onDataAvailable(). The onDataAvailable method is invoked on the
                        ReadListener when data is available to read from the incoming request
                        stream. The container will invoke the method. This method will be invoked
                        once for every set of data available.
                    </description>
                    <location chapter="3" section="7"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:282.2</id>
                    <description>ReadListener.onAllDataRead(). The onAllDataRead method is invoked when you have
                        finished reading all the data for the ServletRequest for which the listener was registered.
                    </description>
                    <location chapter="3" section="7"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:282.3</id>
                    <description>ReadListener.onError(Throwable t). The onError method is invoked if there is any error or
                        exception that occurs while processing the request.
                    </description>
                    <location chapter="3" section="7"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:282.5</id>
                    <description>boolean ServletInputStream.isFinished(). The isFinished method returns true when all the
                        data for the request associated with the ServletInputStream has been read.
                        Otherwise it returns false.
                    </description>
                    <location chapter="3" section="7"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:282.6</id>
                    <description>boolean ServletInputStream.isReady(). The isReady method returns true if data can be read
                        without blocking. If no data can be read without blocking it returns false. If
                        isReady returns false it is illegal to call the read method and an
                        IllegalStateException MUST be thrown.
                    </description>
                    <location chapter="3" section="7"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:282.7</id>
                    <description>void ServletInputStream.setReadListener(ReadListener listener). Sets the ReadListener
                        defined above to get invoked to read data in a non-blocking fashion. Once the
                        listener is associated for the given ServletInputStream, the container invokes
                        the methods on the ReadListener when data is available to read, all the data
                        has been read or if there was an error processing the request. Registering a
                        ReadListener will start non-blocking IO. It is illegal to switch to the traditional
                        blocking IO at that point and an IllegalStateException MUST be thrown.
                        A subsequent call to setReadListener in the scope of the current request is
                        illegal and an IllegalStateException MUST be thrown..
                    </description>
                    <location chapter="3" section="7"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
            <id>Servlet:SPEC:26</id>
            <description>If a request has been transmitted over a secure protocol, such as HTTPS, this
                information must be exposed via the isSecure method of the ServletRequest
                interface. The Web container must expose the following attributes to the servlet
                programmer:
            </description>
            <location chapter="3" section="9"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                    <id>Servlet:SPEC:26.1</id>
                    <description>attribute: cipher suite - attribute name: jakarta.servlet.request.cipher_suite - Java type: String </description>
                    <location chapter="3" section="9"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                    <id>Servlet:SPEC:26.2</id>
                    <description>attribute: bit size of the algorithm - attribute name: jakarta.servlet.request.key_size - Java type: Integer</description>
                    <location chapter="3" section="9"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                    <id>Servlet:SPEC:26.4</id>
                    <description>attribute: SSL session id - attribute name: jakarta.servlet.request.ssl_session_id - Java type: String</description>
                    <location chapter="3" section="9"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                    <id>Servlet:SPEC:26.3</id>
                    <description>If there is an SSL certificate associated with the request, it must be exposed by the
                        servlet container to the servlet programmer as an array of objects of type
                        java.security.cert.X509Certificate and accessible via a ServletRequest
                        attribute of jakarta.servlet.request.X509Certificate.
                    </description>
                    <location chapter="3" section="9"/>
                    <sub-assertions>
                        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                            <id>Servlet:SPEC:26.3.1</id>
                            <description>The order of this array (associated with the jakarta.servlet.request.X509Certificate request attribute)
                                is being defined as being in ascending order of trust.
                                The first certificate in the chain is the one set by the client,
                                the next is the one used to authenticate first, and so on.
                            </description>
                            <location chapter="3" section="9"/>
                        </assertion>
                    </sub-assertions>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:27</id>
            <description>The default encoding of a request the container uses to create the request reader
                and parse POST data must be "ISO-8859-1", if none has been specified by the client request.
            </description>
            <location chapter="3" section="11"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:28</id>
            <description>Calling the (setCharacterEncoding(String enc)) method after once data has been read will not affect the encoding.</description>
            <location chapter="3" section="11"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>Servlet:SPEC:29</id>
            <description>Each request object is valid only within the scope of a servlet's service method, or
                within the scope of a filter's doFilter method, unless the asynchronous processing
                is enabled for the component and the startAsync method is invoked on the request object.
            </description>
            <location chapter="3" section="12"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:283</id>
            <description>In the case where asynchronous processing occurs, the request object remains
                valid until complete is invoked on the AsyncContext.
            </description>
            <location chapter="3" section="12"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:305</id>
            <description>In case of upgrade, the above is still true.
            </description>
            <location chapter="3" section="12"/>
        </assertion>
      <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:13</id>
            <description>There is only one instance object of the ServletContext interface
                associated with each web application deployed into a container.
            </description>
            <location chapter="4" section="2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>Servlet:SPEC:14</id>
            <description>In cases where the container is distributed over many virtual machines,
                a Web application will have an instance of the ServletContext for each JVM.
            </description>
            <location chapter="4" section="2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>Servlet:SPEC:15</id>
            <description>A default ServletContext must be made available to servlets not deployed as a web application.</description>
            <location chapter="4" section="2"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
                    <id>Servlet:SPEC:15.1</id>
                    <description>In a distributed container, the default ServletContext is non-distributable and must only exist in one VM.</description>
                    <location chapter="4" section="2"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>Servlet:SPEC:16</id>
            <description>Any attribute bound into a context is available to any other servlet
                that is part of the same web application.
            </description>
            <location chapter="4" section="5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>Servlet:SPEC:17</id>
            <description>Web servers may support multiple logical hosts sharing one IP address on a server.
                This capability is sometimes referred to as "virtual hosting".
                In this case, each logical host must have its own servlet context or set of servlet contexts.
                Servlet contexts can not be shared across virtual hosts.
            </description>
            <location chapter="4" section="7"/>
        </assertion>
        <assertion required="false" impl-spec="true" defined-by="technology" status="active" testable="false">
            <id>Servlet:SPEC:18</id>
            <description>Although a Container Provider implementation of a class reloading scheme
                for ease of development is not required, any such implementation must ensure that all servlets,
                and classes that they may use, are loaded in the scope of a single class loader.
            </description>
            <location chapter="4" section="8"/>
            <sub-assertions>
                <assertion required="false" impl-spec="true" defined-by="technology" status="active" testable="false">
                    <id>Servlet:SPEC:18.1</id>
                    <description>The full semantics of notification to session binding listeners
                        should be supported by containers for use in the monitoring of session termination
                        upon class reloading.
                    </description>
                    <location chapter="4" section="8"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:19</id>
            <description>Servlet containers must provide a private temporary directory for each servlet context.</description>
            <location chapter="4" section="8.1"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:19.1</id>
                    <description>(The container must) make it available via the jakarta.servlet.context.tempdir context attribute.
                        The objects associated with the attribute must be of type java.io.File.
                    </description>
                    <location chapter="4" section="8.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:19.2</id>
                    <description>Servlet containers are required to ensure that the contents of the temporary directory
                        of one servlet context is not visible to the servlet contexts of other Web applications
                        running on the servlet container.
                    </description>
                    <location chapter="4" section="8.1"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="false" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>Servlet:SPEC:30</id>
            <description>A servlet container is allowed, but not required,
                to buffer output going to the client for efficiency purposes.
            </description>
            <location chapter="5" section="1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:31</id>
            <description>If a response has been committed and the reset or resetBuffer methods have been called,
                an IllegalStateException must be thrown. The response and its associated buffer will be unchanged.
            </description>
            <location chapter="5" section="1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:32</id>
            <description>When using a buffer, the container must immediately flush the contents of a filled buffer
                to the client.  If this is the first data sent to the client, the response is considered to be committed.
            </description>
            <location chapter="5" section="1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:33</id>
            <description>To be successfully transmitted back to the client, headers must be set before the response is committed.
                Headers set after the response is committed will be ignored by the servlet container.
            </description>
            <location chapter="5" section="2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:34</id>
            <description>Servlet containers must not set a default content type when the servlet programmer does not set the type.</description>
            <location chapter="5" section="2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:183</id>
            <description>The setHeader method sets a header with a given name and value.
                A previous header is replaced by the new header.
                Where a set of header values exist for the name,
                the values are cleared and replaced with the new value.
            </description>
            <location chapter="5" section="2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:300</id>
            <description>Non-blocking IO only works with async request processing in Servlets and Filters
                as defined in Section 2.3.3.3, "Asynchronous processing" on page 2-10,
                and upgrade processing (as defined in Section 2.3.3.5, ?Upgrade Processing? on page 2-20).
            </description>
            <location chapter="5" section="3"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:306</id>
            <description>Otherwise, an IllegalStateException must be thrown when ServletInputStream.setReadListener
                or ServletOutputStream.setWriteListener is invoked.
            </description>
            <location chapter="5" section="3"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:35</id>
            <description>If a partial URL is given and, for whatever reason, cannot be converted into a valid URL,
                then this method(sendRedirect) must throw an IllegalArgumentException.
            </description>
            <location chapter="5" section="4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:36</id>
            <description>These methods(sendError) will have the side effect of committing the response,
                if it has not already been committed, and terminating it. No further output to the client should
                be made by the servlet after these methods are called.
            </description>
            <location chapter="5" section="4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:37</id>
            <description>These methods(sendRedirect) will have the side effect of commiting the response,
                if it has not already been committed, and terminating it. No further output to the client should
                be made by the servlet after these methods are called.
            </description>
            <location chapter="5" section="4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:38</id>
            <description>If data has been written to the response buffer, but not returned to the client (i.e., the response is not committed), the data in the response buffer must be cleared and replaced with the data set by sendRedirect.</description>
            <location chapter="5" section="4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:39</id>
            <description>If data has been written to the response buffer,
                but not returned to the client(i.e., the response is not committed),
                the data in the response buffer must be cleared and replaced with the data set by sendError.
            </description>
            <location chapter="5" section="4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:40</id>
            <description>If data is written to the response after sendRedirect has been called,
                the data is ignored.
            </description>
            <location chapter="5" section="4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:41</id>
            <description>If data is written to the response after sendError has been called,
                the data is ignored.
            </description>
            <location chapter="5" section="4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:284</id>
            <description>When a response is closed, the container must immediately flush all remaining
                content in the response buffer to the client.
            </description>
            <location chapter="5" section="6"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:42</id>
            <description>The following events indicate that the servlet has satisfied the request
                and that the response object is to be closed:
            </description>
            <location chapter="5" section="6"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
                    <id>Servlet:SPEC:42.1</id>
                    <description>The termination of the service method of the servlet.</description>
                    <location chapter="5" section="6"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:42.2</id>
                    <description>The amount of content specified in the setContentLength
                        or setContentLengthLong method of the response
                        has been greater than zero and has been written to the response.
                    </description>
                    <location chapter="5" section="6"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:42.3</id>
                    <description>The sendError method is called.</description>
                    <location chapter="5" section="6"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:42.4</id>
                    <description>The sendRedirect method is called.</description>
                    <location chapter="5" section="6"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:42.5</id>
                    <description>The complete method on AsyncContext is called.</description>
                    <location chapter="5" section="6"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>Servlet:SPEC:43</id>
            <description>Each response object is valid only within the scope of a servlet's service method,
                or within the scope of a filter's doFilter method, unless the associated request object
                has asynchronous processing enabled for the component.
            </description>
            <location chapter="5" section="7"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>Servlet:SPEC:285</id>
            <description>If asynchronous processing on the associated request is started,
                then the request object remains valid until complete method on AsyncContext is called.
            </description>
            <location chapter="5" section="7"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>Servlet:SPEC:44</id>
            <description>After deployment of a web application,
                and before a request causes the container to access a web resource,
                The container must locate the list of filters that must be applied to the Web resource as described below.
            </description>
            <location chapter="6" section="2.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:45</id>
            <description>The container must ensure that it has instantiated a filter of the appropriate class
                for each filter in the list, and called its init(FilterConfig config) method.
            </description>
            <location chapter="6" section="2.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>Servlet:SPEC:286</id>
            <description>The filter may throw an exception to indicate that it cannot function properly.
            </description>
            <location chapter="6" section="2.1"/>
        </assertion>
        <assertion required="false" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>Servlet:SPEC:46</id>
            <description>If the exception thrown by a Filter is of type UnavailableException,
                the container may examine the isPermanent attribute of the exception
                and may choose to retry the filter at some later time.
            </description>
            <location chapter="6" section="2.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>Servlet:SPEC:47</id>
            <description>Only one instance per &lt;filter&gt; declaration in
                the deployment descriptor is instantiated per JVM of the container.
                The container provides the filter config as declared in the filter's deployment descriptor,
                the reference to the ServletContext for the Web application, and the set of initialization parameters.
            </description>
            <location chapter="6" section="2.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:48</id>
            <description>When the container receives an incoming request it takes the first filter instance
                in the list and calls its doFilter method, passing in the ServletRequest and ServletResponse,
                and a reference to the FilterChain object it will use.
            </description>
            <location chapter="6" section="2.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>Servlet:SPEC:287</id>
            <description>The doFilter method of a filter will typically be implemented following this
                or some subset of the following pattern:
            </description>
            <location chapter="6" section="2.1"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:287.1</id>
                    <description>The method examines the request's headers.</description>
                    <location chapter="6" section="2.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:287.2</id>
                    <description>The method may wrap the request object with a customized implementation of
                        ServletRequest or HttpServletRequest in order to modify request headers or data.
                    </description>
                    <location chapter="6" section="2.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:287.3</id>
                    <description>The method may wrap the response object passed in to its doFilter method with a
                        customized implementation of ServletResponse or HttpServletResponse to
                        modify response headers or data.
                    </description>
                    <location chapter="6" section="2.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:287.4</id>
                    <description>The filter may invoke the next entity in the filter chain. The next entity may be
                        another filter, or if the filter making the invocation is the last filter configured in the
                        deployment descriptor for this chain, the next entity is the target Web resource. The
                        invocation of the next entity is effected by calling the doFilter method on the
                        FilterChain object, and passing in the request and response with which it was
                        called or passing in wrapped versions it may have created.
                    </description>
                    <location chapter="6" section="2.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:50</id>
                    <description>The filter chain's implementation of the doFilter method, provided by the
                        container, must locate the next entity in the filter chain and invoke its doFilter
                        method, passing in the appropriate request and response objects.
                    </description>
                    <location chapter="6" section="2.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:287.5</id>
                    <description>Alternatively, the filter chain can block the request by not making the call
                        to invoke the next entity, leaving the filter responsible for filling out the response object.
                    </description>
                    <location chapter="6" section="2.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:287.6</id>
                    <description>The service method is required to run in the same thread as all filters
                        that apply to the servlet.
                    </description>
                    <location chapter="6" section="2.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:287.7</id>
                    <description>After invocation of the next filter in the chain, the filter may examine response
                        headers.
                    </description>
                    <location chapter="6" section="2.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:287.8</id>
                    <description>Alternatively, the filter may have thrown an exception to indicate an error in
                        processing. If the filter throws an UnavailableException during its doFilter
                        processing, the container must not attempt continued processing down the filter
                        chain. It may choose to retry the whole chain at a later time if the exception is not
                        marked permanent.
                    </description>
                    <location chapter="6" section="2.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:287.9</id>
                    <description>When the last filter in the chain has been invoked, the next entity accessed is the
                        target servlet or resource at the end of the chain.
                    </description>
                    <location chapter="6" section="2.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
                    <id>Servlet:SPEC:49</id>
                    <description>Before a filter instance can be removed from service by the container,
                        the container must first call the destroy method on the filter to enable the filter
                        to release any resources and perform other cleanup operations.
                    </description>
                    <location chapter="6" section="2.1"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:288</id>
            <description>When a filter invokes the doFilter method on the container's filter
                chain implementation, the container must ensure that the request and response
                object that it passes to the next entity in the filter chain, or to the target web resource
                if the filter was the last in the chain, is the same object that was passed into the
                doFilter method by the calling filter.
            </description>
            <location chapter="6" section="2.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:51</id>
            <description>The same requirement of wrapper object identity applies to the calls from a servlet
                or a filter to RequestDispatcher.forward or RequestDispatcher.include, when
                the caller wraps the request or response objects. In this case, the request and
                response objects seen by the called servlet must be the same wrapper objects that
                were passed in by the calling servlet or filter.
            </description>
            <location chapter="6" section="2.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:52</id>
            <description>The order the container uses in building the chain of filters to be applied for
                a particular request URI is as follows:
            </description>
            <location chapter="6" section="2.4"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:52.1</id>
                    <description>the &lt;url-pattern&gt; matching filter-mappings in the same order
                        that these elements appear in the deployment descriptor.
                    </description>
                    <location chapter="6" section="2.4"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:52.2</id>
                    <description>The &lt;servlet-name&gt; matching filter-mappings in the same order
                        that these elements appear in the deployment descriptor.
                    </description>
                    <location chapter="6" section="2.4"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="false" impl-spec="true" defined-by="technology" status="active" testable="false">
            <id>Servlet:SPEC:53</id>
            <description>It is expected that high performance Web containers will cache filter chains
                so that they do not need to compute them on a per-request basis.
            </description>
            <location chapter="6" section="2.4"/>
        </assertion>
        <assertion required="false" impl-spec="true" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:302</id>
            <description>By using the new &lt;dispatcher&gt; element in the deployment descriptor,
                the developer can indicate for a filter-mapping whether he would like the filter
                to be applied to requests when:
            </description>
            <location chapter="6" section="2.5"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:54</id>
                    <description>The request comes directly from the client.
                        This is indicated by a &lt;dispatcher&gt; element with value REQUEST,
                    </description>
                    <location chapter="6" section="2.5"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:58</id>
                    <description>The request comes directly from the client.
                        This is indicated by the absence of any &lt;dispatcher&gt; elements.
                    </description>
                    <location chapter="6" section="2.5"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:55</id>
                    <description>The request is being processed under a request dispatcher representing
                        the Web component matching the &lt;url-pattern&gt; or &lt;servlet-name&gt; using a forward() call.
                        This is indicated by a &lt;distpatcher&gt; element with value FORWARD.
                    </description>
                    <location chapter="6" section="2.5"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:56</id>
                    <description>The request is being processed under a request dispatcher representing
                        the Web component matching the  &lt;url-pattern&gt; or &lt;servlet-name&gt; using an include() call.
                        This is indicated by a &lt;distpatcher&gt; element with value INCLUDE.
                    </description>
                    <location chapter="6" section="2.5"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:57</id>
                    <description>The request is being processed with the error page mechanism
                        specified in ?Error Handling? on page 106 to an error resource matching
                        the &lt;url-pattern&gt;. This is indicated by a &lt;dispatcher&gt; element
                        with the value ERROR.
                    </description>
                    <location chapter="6" section="2.5"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:301</id>
                    <description>The request is being processed with the async context dispatch mechanism
                        specified in ?Asynchronous processing? on page 10 to a web component using a dispatch call.
                        This is indicated by a &lt;dispatcher&gt; element with the value ASYNC.
                    </description>
                    <location chapter="6" section="2.5"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:59</id>
                    <description>(The container must be able to support) any combination of 1, 2, 3, 4 or 5 above.</description>
                    <location chapter="6" section="2.5"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:202</id>
            <description>Session tracking through HTTP cookies is the most used session tracking mechanism
                and is required to be supported by all servlet containers.
            </description>
            <location chapter="7" section="1.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:303</id>
            <description>The container sends a cookie to the client.
                The client will then return the cookie on each subsequent request to the server,
                unambiguously associating the request with a session.
                The name of the session tracking cookie must be JSESSIONID.
            </description>
            <location chapter="7" section="1.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>Servlet:SPEC:60</id>
            <description>When a client will not accept a cookie, URL rewriting may be used by the server
                as the basis for session tracking. URL rewriting involves adding data, a session ID,
                to the URL path that is interpreted by the container to associate the request with a session.
            </description>
            <location chapter="7" section="1.3"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:60.2</id>
                    <description> The session ID must be encoded as a path parameter in the URL string.</description>
                    <location chapter="7" section="1.3"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:60.1</id>
                    <description>The name of the parameter must be 'jsessionid'.</description>
                    <location chapter="7" section="1.3"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>Servlet:SPEC:61</id>
            <description>Web container must be able to support HTTP session tracking
                while servicing HTTP request from clients that do no support the use of cookies.
            </description>
            <location chapter="7" section="1.4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:62</id>
            <description>A session is considered 'new' if either of the following are true:</description>
            <location chapter="7" section="2"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:62.1</id>
                    <description>The client does not yet know about the session.</description>
                    <location chapter="7" section="2"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:62.2</id>
                    <description>The client chooses not to join a session.</description>
                    <location chapter="7" section="2"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:63</id>
            <description>HttpSession objects must be scoped at the application (or servlet context) level.</description>
            <location chapter="7" section="3"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:63.1</id>
                    <description>The underlying mechanism, such as the cookies used to establish the session,
                        including the attributes in that object, must never be shared between context by the container.
                    </description>
                    <location chapter="7" section="3"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:63.2</id>
                    <description>Additionally, sessions of a context must be resumable by requests into
                        that context regardless of whether their associated context was being accessed
                        directly or as the target of a request dispatch at the time the sessions were created.
                    </description>
                    <location chapter="7" section="3"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>Servlet:SPEC:64</id>
            <description>The valueBound method must be called before the object is made available vai the getAttribute method of the HttpSession interface.</description>
            <location chapter="7" section="4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>Servlet:SPEC:65</id>
            <description>The valueUnbound method must be called after the object is no longer available via the getAttribute method of the HttpSession interface.</description>
            <location chapter="7" section="4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:66</id>
            <description>The default timeout period for sessions is defined by the servlet container and can be obtained via the getMaxInactiveInterval method of the HttpSession interface.</description>
            <location chapter="7" section="5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:67</id>
            <description>Invalidation will not take effect until all servlets using that session have exited the service method.</description>
            <location chapter="7" section="5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:203</id>
            <description>The getLastAccessedTime method of the HttpSession interface allows a servlet to determine the last time the session was accessed before the current request. The session is considered to be accessed when a request that is part of the session is first handled by the servlet container.</description>
            <location chapter="7" section="6"/>
        </assertion>
        <assertion required="false" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>Servlet:SPEC:68</id>
            <description>Within an application marked as distributable, all request that are part of a session must be handled by one virtual machine at a time.</description>
            <location chapter="7" section="7.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>Servlet:SPEC:69</id>
            <description>The container must be able to handle all objects placed into instances of the HttpSession class using the setAttribute or putValue methods appropriately, with the following restrictions:</description>
            <location chapter="7" section="7.2"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
                    <id>Servlet:SPEC:69.1</id>
                    <description>The container must accept objects that implement the Serializable interface.</description>
                    <location chapter="7" section="7.2"/>
                </assertion>
                <assertion required="false" impl-spec="false" defined-by="technology" status="active" testable="false">
                    <id>Servlet:SPEC:69.2</id>
                    <description>The container may choose to support storage of other designated objects in the HttpSession, such as references to Enterprise JavaBean components and transactions.</description>
                    <location chapter="7" section="7.2"/>
                </assertion>
                <assertion required="false" impl-spec="true" defined-by="technology" status="active" testable="false">
                    <id>Servlet:SPEC:69.3</id>
                    <description>Migration of sessions will be handled by container-specific facilities.</description>
                    <location chapter="7" section="7.2"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>Servlet:SPEC:70</id>
            <description>The distributed servlet container must throw an IllegalArgumentException for objects where the container cannot support the mechanism necessary for migration of the session storing them.</description>
            <location chapter="7" section="7.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>Servlet:SPEC:71</id>
            <description>The distributed servlet container must support the mechanism necessary for migrating objects that implement Serializable.</description>
            <location chapter="7" section="7.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="false">
            <id>Servlet:SPEC:72</id>
            <description>Distributed servlet containers must support the mechanism necessary for migrating objects that implements Serializable.</description>
            <location chapter="7" section="7.2"/>
        </assertion>
        <assertion required="false" impl-spec="true" defined-by="technology" status="active" testable="false">
            <id>Servlet:SPEC:73</id>
            <description>If distributed contains persist or migrate sessions to provide quality of service features, they are not restricted to using the native JVM Serialization mechanism for serializing HttpSessions and their attributes.</description>
            <location chapter="7" section="7.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>Servlet:SPEC:74</id>
            <description>Containers must notify any session attributes implementing the HttpSessionActivationListener during migration of a session.  They must notify listeners of passivation prior to serialization of a session, and of activation after deserialization of a session</description>
            <location chapter="7" section="7.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:307</id>
            <description>In a web application, classes using annotations will have their annotations processed
                only if they are located in the WEB-INF/classes directory, or if they are packaged
                in a jar file located in WEB-INF/lib within the application.
            </description>
            <location chapter="8" section="1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:308</id>
            <description>The web application deployment descriptor contains a new ?metadata-complete?
                attribute on the web-app element. The ?metadata-complete? attribute defines
                whether the web descriptor is complete, or whether the class files of the jar file
                should be examined for annotations and web fragments at deployment time. If
                ?metadata-complete? is set to "true", the deployment tool MUST ignore any
                servlet annotations that specify deployment information present in the class files of
                the application and web fragments. If the metadata-complete attribute is not
                specified or is set to "false", the deployment tool must examine the class files of the
                application for annotations, and scan for web fragments.
            </description>
            <location chapter="8" section="1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:221</id>
            <description>This annotation(@WebServlet) is used to define a Servlet component in a web application. </description>
            <location chapter="8" section="1.1"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:221.1</id>
                    <description>This annotation is specified on a class and contains metadata about the Servlet being declared. </description>
                    <location chapter="8" section="1.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:221.2</id>
                    <description>The urlPatterns or the value attribute on the annotation MUST be present. </description>
                    <location chapter="8" section="1.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:221.3</id>
                    <description>All other attributes are optional with default settings (see javadocs for more details). </description>
                    <location chapter="8" section="1.1"/>
                </assertion>
                <assertion required="false" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:221.4</id>
                    <description>It is recommended to use value when the only attribute on the annotation is the url pattern and to use the urlPatterns attribute when the other attributes are also used. </description>
                    <location chapter="8" section="1.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
                    <id>Servlet:SPEC:221.5</id>
                    <description>It is illegal to have both value and urlPatterns attribute used together on the same annotation. </description>
                    <location chapter="8" section="1.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:221.6</id>
                    <description>The default name of the Servlet if not specified is the fully qualified class name.</description>
                    <location chapter="8" section="1.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:221.7</id>
                    <description>The annotated servlet MUST specify at least one url pattern to be deployed. </description>
                    <location chapter="8" section="1.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:221.8</id>
                    <description>If the same servlet class is declared in the deployment descriptor under a different name,
                        a new instance of the servlet MUST be instantiated.
                    </description>
                    <location chapter="8" section="1.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:221.9</id>
                    <description>If the same servlet class is added to the ServletContext via the programmatic API
                        defined in Section 4.4.1, "Programmatically adding and configuring Servlets" on page 4-35,
                        the attribute values declared via the @WebServlet annotation MUST be ignored and
                        a new instance of the servlet with the name specified MUST be created.
                    </description>
                    <location chapter="8" section="1.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:221.10</id>
                    <description>Classes annotated with @WebServlet class MUST extend the jakarta.servlet.http.HttpServlet class.</description>
                    <location chapter="8" section="1.1"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:222</id>
            <description>This annotation(@MultipartConfig), when specified on a Servlet, indicates that the request it expects is of type mime/multipart. The HttpServletRequest object of the corresponding servlet MUST make available the mime attachments via the getParts and getPart methods to iterate over the various mime attachments. </description>
            <location chapter="8" section="1.5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:223</id>
            <description>The location attribute of the jakarta.servlet.annotation.MultipartConfig and the &lt;location&gt; element of the &lt;multipart-config&gt; is interpreted as an absolut path and defaults to the value of the jakarta.servlet.context.tempdir. </description>
            <location chapter="8" section="1.5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:224</id>
            <description>If a relative path is specified(in &lt;location&gt;), it will be relative to the tempdir location.</description>
            <location chapter="8" section="1.5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:225</id>
            <description>The test for absolute path vs relative path (in &lt;location&gt;) MUST be done via java.io.File.isAbsolute. </description>
            <location chapter="8" section="1.5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:226</id>
            <description>Using the annotations(@WebServlet, @WebFilter, @WebInitParam, @WebListener, @MultipartConfig)
                defined above makes the use of web.xml optional.
            </description>
            <location chapter="8" section="2.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:227</id>
            <description>However for overriding either the default values or the values set via annotations,
                the deployment descriptor is used.
            </description>
            <location chapter="8" section="2.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:228</id>
            <description>As before, if the metadata-complete element is set to true in the web.xml
                descriptor,  annotations that specify deployment information present
                in the class files and web-fragments bundled in jars will not be processed.
                It implies that all the metadata for the application is specified
                via the web.xml descriptor.
            </description>
            <location chapter="8" section="2.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:229</id>
            <description>A plain old jar file in the WEB-INF/lib directory with no web-fragment.xml is also considered a fragment. Any annotations specified in it will be processed according to the rules defined in 8.2.3. The container will pick up and use the configuration as per the rules defined below. </description>
            <location chapter="8" section="2.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:230</id>
            <description>A web-fragment.xml may have a top level &lt;name&gt; element of type javaee:java-identifierType.
                There can only be one &lt;name&gt; element in a web-fragment.xml. If a &lt;name&gt; element is present,
                it must be considered for the ordering of artifacts (unless the duplicate name exception applies, as described below).
            </description>
            <location chapter="8" section="2.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:231</id>
            <description>There can only be one &lt;absolute-ordering&gt; element in a web.xml.</description>
            <location chapter="8" section="2.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:232</id>
            <description>The web.xml and WEB-INF/classes MUST be processed before any of the web-fragments
                listed in the absolute-ordering element.
            </description>
            <location chapter="8" section="2.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:233</id>
            <description>Any &lt;name&gt; element direct children of the &lt;absolute-ordering&gt;
                MUST be interpreted as indicating the absolute ordering in which those named web-fragments,
                which may or may not be present, must be processed.
            </description>
            <location chapter="8" section="2.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:234</id>
            <description>The &lt;absolute-ordering&gt; element may contain zero or one &lt;others /&gt; element. </description>
            <location chapter="8" section="2.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:235</id>
            <description>If the &lt;absolute-ordering&gt; element does not contain an &lt;others/&gt;
                element, any web-fragment not specifically mentioned within &lt;name /&gt; elements
                MUST be ignored.
            </description>
            <location chapter="8" section="2.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:236</id>
            <description>Excluded jars are not scanned for annotated servlets, filters or listeners. </description>
            <location chapter="8" section="2.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:237</id>
            <description>However, if a servlet, filter or listener from an excluded jar is listed in web.xml
                or a non-excluded web-fragment.xml, then it's annotations will apply unless otherwise
                excluded by metadata-complete.
            </description>
            <location chapter="8" section="2.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
            <id>Servlet:SPEC:238</id>
            <description>ServletContextListeners discovered in TLD files of excluded jars are not
                able to configure filters and servlets using the programmatic APIs.
                Any attempt to do so will result in an IllegalStateException.
            </description>
            <location chapter="8" section="2.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:239</id>
            <description>If a discovered ServletContainerInitializer is loaded from an excluded jar,
                it will be ignored. Irrespective of the setting of metadata-complete,
                jars excluded by &lt;absolute-ordering&gt; elements are not scanned
                for classes to be handled by any ServletContainerInitializer.
            </description>
            <location chapter="8" section="2.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:240</id>
            <description>Duplicate name exception: if, when traversing the children of &lt;absolute-ordering&gt;, multiple children with the same &lt;name&gt; element are encountered, only the first such occurrence must be considered. </description>
            <location chapter="8" section="2.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:241</id>
            <description>There can only be one &lt;ordering&gt; element in a web-fragment.xml.</description>
            <location chapter="8" section="2.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:242</id>
            <description>A web-fragment.xml may have an &lt;ordering&gt; element. If so, this element must contain zero or one &lt;before&gt; element and zero or one &lt;after&gt; element. </description>
            <location chapter="8" section="2.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:243</id>
            <description>Duplicate name exception: if, when traversing the web-fragments, multiple members with the same &lt;name&gt; element are encountered, the application must log an informative error message including information to help fix the problem, and must fail to deploy. For example, one way to fix this problem is for the user to use absolute ordering, in which case relative ordering is ignored. </description>
            <location chapter="8" section="2.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:244</id>
            <description>&lt;before&gt; means the document must be ordered before the document with the name matching what is specified within the nested &lt;name&gt; element. </description>
            <location chapter="8" section="2.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:245</id>
            <description>&lt;after&gt; means the document must be ordered after the document with the name matching what is specified within the nested &lt;name&gt; element.</description>
            <location chapter="8" section="2.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:246</id>
            <description>There is a special element &lt;others/&gt; which may be included zero or one time within the &lt;before&gt; or &lt;after&gt; element, or zero or one time directly within the &lt;absolute-ordering&gt; element. The
                <others/> element must be handled as follows.
            </description>
            <location chapter="8" section="2.2"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:246.1</id>
                    <description>If the &lt;before&gt; element contains a nested
                        <others/>, the document will be moved to the beginning of the list of sorted documents. If there are multiple documents stating &lt;before&gt;
                        <others/>, they will all be at the beginning of the list of sorted documents, but the ordering within the group of such documents is unspecified.
                    </description>
                    <location chapter="8" section="2.2"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:246.2</id>
                    <description>If the &lt;after&gt; element contains a nested
                        <others/>, the document will be moved to the end of the list of sorted documents. If there are multiple documents requiring &lt;after&gt;
                        <others/>, they will all be at the end of the list of sorted documents, but the ordering within the group of such documents is unspecified.
                    </description>
                    <location chapter="8" section="2.2"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:246.3</id>
                    <description>Within a &lt;before&gt; or &lt;after&gt; element, if an
                        <others/> element is present, but is not the only &lt;name&gt; element within its parent element, the other elements within that parent must be considered in the ordering process.
                    </description>
                    <location chapter="8" section="2.2"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:246.4</id>
                    <description>If the
                        <others/> element appears directly within the &lt;absolute-ordering&gt; element, the runtime must ensure that any web-fragments not explicitly named in the &lt;absolute-ordering&gt; section are included at that point in the processing order. `
                    </description>
                    <location chapter="8" section="2.2"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:247</id>
            <description>If a web-fragment.xml file does not have an &lt;ordering&gt; or the web.xml does not have an &lt;absolute-ordering&gt; element the artifacts are assumed to not have any ordering dependency. </description>
            <location chapter="8" section="2.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>Servlet:SPEC:248</id>
            <description>If the runtime discovers circular references, an informative message must be logged, and the application must fail to deploy. Again, one course of action the user may take is to use absolute ordering in the web.xml.  </description>
            <location chapter="8" section="2.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>Servlet:SPEC:249</id>
            <description>If the order in which the listeners, servlets, filters are invoked is important to an
                application then a deployment descriptor must be used.
            </description>
            <location chapter="8" section="2.3"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:250</id>
            <description>when using annotations to define the listeners, servlets and filters, the order in which they are invoked is unspecified.</description>
            <location chapter="8" section="2.3"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:251</id>
            <description>The order for listeners, servlets, filters if relevant must be specified in either the web-fragment.xml or the web.xml. </description>
            <location chapter="8" section="2.3"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:252</id>
            <description> The ordering will be based on the order in which they are defined in the descriptor and on the absolute-ordering element in the web.xml or an ordering element in the web-fragment.xml, if present.</description>
            <location chapter="8" section="2.3"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:253</id>
            <description> Filters that match a request are chained in the order in which they are declared in the web.xml. </description>
            <location chapter="8" section="2.3"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:254</id>
            <description> Servlets are initialized either lazily at request processing time or eagerly during deployment. In the latter case, they are initialized in the order indicated by their load-on-startup elements.  </description>
            <location chapter="8" section="2.3"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:255</id>
            <description>The listeners are invoked in the order in which they are declared 
                in the web.xml as specified below:
            </description>
            <location chapter="8" section="2.3"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:255.1</id>
                    <description> Implementations of jakarta.servlet.ServletContextListener are invoked at their contextInitialized method in the order in which they have been declared, and at their contextDestroyed method in reverse order. </description>
                    <location chapter="8" section="2.3"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:255.2</id>
                    <description> Implementations of jakarta.servlet.ServletRequestListener are invoked at their requestInitialized method in the order in which they have been declared, and at their requestDestroyed method in reverse order. </description>
                    <location chapter="8" section="2.3"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:255.3</id>
                    <description> Implementations of jakarta.servlet.http.HttpSessionListener are invoked at their sessionCreated method in the order in which they have been declared, and at their sessionDestroyed method in reverse order. </description>
                    <location chapter="8" section="2.3"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:255.4</id>
                    <description>The methods of implementation of 
                        jakarta.servlet.ServletContextAttributeListener,
                        jakarta.servlet.ServletRequestAttributeListener and 
                        jakarta.servlet.HttpSessionAttributeListener are invoked in 
                        the order in which they are declared when corresponding events are fired.
                    </description>
                    <location chapter="8" section="2.3"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:256</id>
            <description>If a servlet is disabled using the enabled element introduced in the web.xml then the servlet will not be available at the url-pattern specified for the servlet. </description>
            <location chapter="8" section="2.3"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:257</id>
            <description>The web.xml of the web application has the highest precedence when resolving conflicts between the web.xml, web-fragment.xml and annotations. </description>
            <location chapter="8" section="2.3"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:258</id>
            <description>If metadata-complete is not specified in the descriptors, or is set to false in the deployment descriptor, then the effective metadata for the application is derived by combining the metadata present in the annotations and the descriptors. The rules for merging are specified below -</description>
            <location chapter="8" section="2.3"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:258.1</id>
                    <description>Configuration settings in web fragments are used to augment those specified in the main web.xml in such a way as if they had been specified in the same web.xml. </description>
                    <location chapter="8" section="2.3"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:258.2</id>
                    <description>The order in which configuration settings of web fragments are added to those in the main web.xml is as specified above in Section 8.2.2, Ordering of web.xml and web-fragment.xml on page 8-66 </description>
                    <location chapter="8" section="2.3"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:258.3</id>
                    <description>The metadata-complete attribute when set to true in the main web.xml, is considered complete and scanning of annotations and fragments will not occur at deployment time. The absolute-ordering and ordering elements will be ignored if present. When set to true on a fragment, the metadata-complete attribute applies only to scanning of annotations in that particular jar.</description>
                    <location chapter="8" section="2.3"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:258.4</id>
                    <description>Web fragments are merged into the main web.xml unless the metadata-complete is set to true. The merging takes place after annotation processing on the corresponding fragment.</description>
                    <location chapter="8" section="2.3"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:258.5</id>
                    <description>The following are considered configuration conflicts when augmenting a web.xml with web fragments: </description>
                    <location chapter="8" section="2.3"/>
                    <sub-assertions>
                        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                            <id>Servlet:SPEC:258.5.1</id>
                            <description>Multiple &lt;init-param&gt; elements with the same &lt;param-name&gt; but different &lt;param-value&gt; </description>
                            <location chapter="8" section="2.3"/>
                        </assertion>
                        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                            <id>Servlet:SPEC:258.5.2</id>
                            <description>Multiple &lt;mime-mapping&gt; elements with the same &lt;extension&gt; but different &lt;mime-type&gt; </description>
                            <location chapter="8" section="2.3"/>
                        </assertion>
                    </sub-assertions>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:258.6</id>
                    <description>The above configuration conflicts are resolved as follows</description>
                    <location chapter="8" section="2.3"/>
                    <sub-assertions>
                        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                            <id>Servlet:SPEC:258.6.1</id>
                            <description>Configuration conflicts between the main web.xml and a web fragment are resolved such that the configuration in the web.xml takes precedence.  </description>
                            <location chapter="8" section="2.3"/>
                        </assertion>
                        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
                            <id>Servlet:SPEC:258.6.2</id>
                            <description>Configuration conflicts between two web fragments, where the element at the center of the conflict is not present in the main web.xml, will result in an error. An informative message must be logged, and the application must fail to deploy</description>
                            <location chapter="8" section="2.3"/>
                        </assertion>
                    </sub-assertions>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:258.7</id>
                    <description>After the above conflicts have been resolved, these additional rules are applied:</description>
                    <location chapter="8" section="2.3"/>
                    <sub-assertions>
                        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                            <id>Servlet:SPEC:258.7.1</id>
                            <description>Elements that may be declared any number of times are additive across the web-fragments in the resulting web.xml. For example, &lt;context-param&gt; elements with different &lt;param-name&gt; are additive.</description>
                            <location chapter="8" section="2.3"/>
                        </assertion>
                        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                            <id>Servlet:SPEC:258.7.2</id>
                            <description>Elements that may be declared any number of times, if specified in the web.xml overrides the values specified in the web-fragments with the same name.</description>
                            <location chapter="8" section="2.3"/>
                        </assertion>
                        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                            <id>Servlet:SPEC:258.7.3</id>
                            <description>If an element with a minimum occurrence of zero, and a maximum occurrence of one, is present in a web fragment, and missing in the main web.xml, the main web.xml inherits the setting from the web fragment. If the element is present in both the main web.xml and the web fragment, the configuration setting in the main web.xml takes precedence. For example, if both the main web.xml and a web fragment declare the same servlet, and the servlet declaration in the web fragment specifies a &lt;load-on-startup&gt; element, whereas the one in the main web.xml does not, then the &lt;load-on-startup&gt; element from the web fragment will be used in the merged web.xml. </description>
                            <location chapter="8" section="2.3"/>
                        </assertion>
                        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
                            <id>Servlet:SPEC:258.7.4</id>
                            <description>It is considered an error if an element with a minimum occurrence of zero, and a maximum occurrence of one, is specified differently in two web fragments, while absent from the main web.xml. For example, if two web fragments declare the same servlet, but with different &lt;load-on-startup&gt; elements, and the same servlet is also declared in the main web.xml, but without any &lt;load-on-startup&gt;, then an error must be reported. </description>
                            <location chapter="8" section="2.3"/>
                        </assertion>
                        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                            <id>Servlet:SPEC:258.7.5</id>
                            <description>&lt;welcome-file&gt; declarations are additive. </description>
                            <location chapter="8" section="2.3"/>
                        </assertion>
                        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                            <id>Servlet:SPEC:258.7.6</id>
                            <description>&lt;servlet-mapping&gt; elements with the same &lt;servlet-name&gt; are additive across web-fragments. &lt;servlet-mapping&gt; specified in the web.xml overrides values specified in the web-fragments with the same &lt;servlet-name&gt;. </description>
                            <location chapter="8" section="2.3"/>
                        </assertion>
                        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                            <id>Servlet:SPEC:258.7.7</id>
                            <description>&lt;filter-mapping&gt; elements with the same &lt;filter-name&gt; are add itive across web-fragments. &lt;filter-mapping&gt; specified in the web.xml overrides values specified in the web-fragments with the same &lt;filter-name&gt;.</description>
                            <location chapter="8" section="2.3"/>
                        </assertion>
                        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                            <id>Servlet:SPEC:258.7.8</id>
                            <description> Multiple &lt;listener&gt; elements with the same &lt;listener-class&gt; are treated as a single &lt;listener&gt; declaration </description>
                            <location chapter="8" section="2.3"/>
                        </assertion>
                        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                            <id>Servlet:SPEC:258.7.9</id>
                            <description>The web.xml resulting from the merge is considered &lt;distributable&gt; only if all its web fragments are marked as &lt;distributable&gt; as well. </description>
                            <location chapter="8" section="2.3"/>
                        </assertion>
                        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                            <id>Servlet:SPEC:258.7.10</id>
                            <description>The top-level &lt;icon&gt; and it's children elements, &lt;display-name>&gt;, and &lt;description&gt; elements of a web fragment are ignored.</description>
                            <location chapter="8" section="2.3"/>
                        </assertion>
                        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                            <id>Servlet:SPEC:258.7.11</id>
                            <description>jsp-property-group is additive. It is recommended that jsp-config element use the url-pattern as opposed to extension mappings when bundling static resources in the META-INF/resources directory of a jar file. Further more JSP resources for a fragment should be in a sub-directory same as the fragment name, if there exists one. This helps prevent a web-fragment's jsp-property-group from affecting the JSPs in the main docroot of the application and the jsp-property-group from affecting the JSPs in a fragment's META-INF/resources directory.</description>
                            <location chapter="8" section="2.3"/>
                        </assertion>
                    </sub-assertions>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                    <id>Servlet:SPEC:258.8</id>
                    <description> For all the resource reference elements (env-entry, ejb-ref, ejb-local-ref, service-ref, resource-ref, resource-env-ref, message-destination-ref, persistence-context-ref and persistence-unit-ref) the following rules apply:</description>
                    <location chapter="8" section="2.3"/>
                    <sub-assertions>
                        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                            <id>Servlet:SPEC:258.8.1</id>
                            <description> If any resource reference element is present in a web fragment, and is missing in the main web.xml, the main web.xml inherits the value from the web fragment. If the element is present in both the main web.xml and the web fragment, with the same name, the web.xml takes precedence. None of the child elements from the fragment are merged into the main web.xml except for the injection-target as specified below. For example, if both the main web.xml and a web fragment declare a &lt;resource-ref&gt; with the same &lt;resource-ref-name&gt;, the &lt;resource-ref&gt; from the web.xml will be used without any child elements being merged from the fragment except &lt;injection-target&gt; as described below. </description>
                            <location chapter="8" section="2.3"/>
                        </assertion>
                        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                            <id>Servlet:SPEC:258.8.2</id>
                            <description> If a resource reference element is specified in two fragments, while absent from the main web.xml, and all the attributes and child elements of the resource reference element are identical, the resource reference will be merged  into the main web.xml. It is considered an error if a resource reference element has the same name specified in two fragments, while absent from the main web.xml and the attributes and child elements are not identical in the two fragments. An error must be reported and the application MUST fail to deploy. For example, if two web fragments declare a &lt;resource-ref&gt; with the same &lt;resource-ref-name&gt; element but the type in one is specified as javax.sql.DataSource while the type in the other is that of a JavaMail resource, it is an error and the application will fail to deploy </description>
                            <location chapter="8" section="2.3"/>
                        </assertion>
                        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                            <id>Servlet:SPEC:258.8.3</id>
                            <description>For resource reference element with the same name &lt;injection-target&gt; elements from the fragments will be merged into the main web.xml. </description>
                            <location chapter="8" section="2.3"/>
                        </assertion>
                    </sub-assertions>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                    <id>Servlet:SPEC:258.9</id>
                    <description>In addition to the merging rules for web-fragment.xml defined above, the following rules apply when using the resource reference annotations (@Resource, @Resources, @EJB, @EJBs, @WebServiceRef, @WebServiceRefs, @PersistenceContext, @PersistenceContexts,@PersistenceUnit, and @PersistenceUnits)</description>
                    <location chapter="8" section="2.3"/>
                    <sub-assertions>
                        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                            <id>Servlet:SPEC:258.9.1</id>
                            <description>If a resource reference annotation is applied on a class, it is equivalent to defining a resource, however it is not equivalent to defining an injection-target. The rules above apply for injection-target element in this case.</description>
                            <location chapter="8" section="2.3"/>
                        </assertion>
                        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                            <id>Servlet:SPEC:258.9.2</id>
                            <description>If a resource reference annotation is used on a field it is equivalent to defining the injection-target element in the web.xml. However if there is no injection-target element in the descriptor then the injection-target from the fragments will still be merged into the web.xml as defined above. </description>
                            <location chapter="8" section="2.3"/>
                        </assertion>
                        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                            <id>Servlet:SPEC:258.9.3</id>
                            <description>If on the other hand there is an injection-target in the main web.xml and there is a resource reference annotation with the same resource name, then it is considered an override for the resource reference annotation. In this case since there is an injection-target specified in the descriptor, the rules defined above would apply in addition to overriding the value for the resource reference annotation. </description>
                            <location chapter="8" section="2.3"/>
                        </assertion>
                    </sub-assertions>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                    <id>Servlet:SPEC:258.10</id>
                    <description> If a data-source element is specified in two fragments, while absent from the main web.xml, and all the attributes and child elements of the data-source element are identical, the data-source will be merged  into the main web.xml. It is considered an error if a data-source element has the same name specified in two fragments, while absent from the main web.xml and the attributes and child elements are not identical in the two fragments. In such a case an error must be reported and the application MUST fail to deploy. </description>
                    <location chapter="8" section="2.3"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:258.11</id>
                    <description>If the main web.xml does not have any &lt;post-construct&gt; element specified and web-fragments have specified &lt;post-construct&gt; then the &lt;post-construct&gt; elements from the fragments will be merged into the main web.xml. However if in the main web.xml at least one &lt;post-construct&gt; element is specified then the &lt;post-construct&gt; elements from the fragment will not be merged. It is the responsibility of the author of the web.xml to make sure that the &lt;post-construct&gt; list is complete.</description>
                    <location chapter="8" section="2.3"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:258.12</id>
                    <description>If the main web.xml does not have any &lt;pre-destroy&gt; element specified and web-fragments have specified &lt;pre-destroy&gt; then the &lt;pre-destroy&gt; elements from the fragments will be merged into the main web.xml. However if in the main web.xml at least one &lt;pre-destroy&gt; element is specified then the &lt;pre-destroy&gt; elements from the fragment will not be merged. It is the responsibility of the author of the web.xml to make sure that the &lt;pre-destroy&gt; list is complete.</description>
                    <location chapter="8" section="2.3"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:258.13</id>
                    <description>After processing the web-fragment.xml, annotations from the corresponding fragment are processed to complete the effective metadata for the fragment before processing the next fragment. The following rules are used for processing annotations:</description>
                    <location chapter="8" section="2.3"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:258.14</id>
                    <description>Any metadata specified via an annotation that isn't already present in the descriptor will be used to augment the effective descriptor. </description>
                    <location chapter="8" section="2.3"/>
                    <sub-assertions>
                        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                            <id>Servlet:SPEC:258.14.1</id>
                            <description> Configuration specified in the main web.xml or a web fragment takes precedence over the configuration specified via annotations. </description>
                            <location chapter="8" section="2.3"/>
                        </assertion>
                        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                            <id>Servlet:SPEC:258.14.2</id>
                            <description>For a servlet defined via the @WebServlet annotation, to override values via the descriptor, the name of the servlet in the descriptor MUST match the name of the servlet specified via the annotation (explicitly specified or the default name, if one is not specified via the annotation).  </description>
                            <location chapter="8" section="2.3"/>
                        </assertion>
                        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                            <id>Servlet:SPEC:258.14.3</id>
                            <description> Init params for servlets and filters defined via annotations, will be overridden in the descriptor if the name of the init param exactly matches the name specified via the annotation. Init params are additive between the annotations and descriptors. </description>
                            <location chapter="8" section="2.3"/>
                        </assertion>
                        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                            <id>Servlet:SPEC:258.14.4</id>
                            <description> url-patterns, when specified in a descriptor for a given servlet name overrides the url patterns specified via the annotation.</description>
                            <location chapter="8" section="2.3"/>
                        </assertion>
                        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                            <id>Servlet:SPEC:258.14.5</id>
                            <description> For a filter defined via the @WebFilter annotation, to override values via the descriptor, the name of the filter in the descriptor MUST match the name of the filter specified via the annotation (explicitly specified or the default name, if one is not specified via the annotation). </description>
                            <location chapter="8" section="2.3"/>
                        </assertion>
                        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                            <id>Servlet:SPEC:258.14.6</id>
                            <description> url-patterns to which a filter is applied, when specified in a descriptor for a given filter name overrides the url patterns specified via the annotation. </description>
                            <location chapter="8" section="2.3"/>
                        </assertion>
                        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                            <id>Servlet:SPEC:258.14.7</id>
                            <description>DispatcherTypes to which a filter applies, when specified in a descriptor for a given filter name overrides the DispatcherTypes specified via the annotation. </description>
                            <location chapter="8" section="2.3"/>
                        </assertion>
                    </sub-assertions>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
            <id>Servlet:SPEC:259</id>
            <description>In addition to supporting fragments and use of annotations one of the requirements is
                that not only we be able to plug-in things that are bundled in the WEB-INF/lib
                but also plugin shared copies of frameworks - including being able to plug-in
                to the web container things like JAX-WS, JAX-RS and JSF that build on top of the web container.
                The ServletContainerInitializer allows handling such a use case as described below.
            </description>
            <location chapter="8" section="2.4"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                    <id>Servlet:SPEC:259.1</id>
                    <description>The ServletContainerInitializer class is looked up via the jar services API.
                        For each application, an instance of the ServletContainerInitializer is created
                        by the container at application startup time.
                        The framework providing an implementation of the ServletContainerInitializer MUST bundle
                        in the META-INF/services directory of the jar file a file called
                        jakarta.servlet.ServletContainerInitializer, as per the jar services API,
                        that points to the implementation class of the ServletContainerInitializer.
                    </description>
                    <location chapter="8" section="2.4"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                    <id>Servlet:SPEC:259.2</id>
                    <description>In addition to the ServletContainerInitializer we also have an annotation - HandlesTypes.
                        The HandlesTypes annotation on the implementation of the ServletContainerInitializer is used
                        to express interest in classes that may have anotations (type, method or field level annotations)
                        specified in the value of the HandlesTypes or if it extends / implements one those classes
                        anywhere in the class' super types.
                        The HandlesTypes annotation is applied irrespective of the setting of metadata-complete.
                        The container uses the HandlesTypes annotation to determine when to invoke the initializer's
                        onStartup method.
                        When examining the classes of an application to see if they match any of the criteria
                        specified by the HandlesTypes annotation of a ServletContainerInitializer,
                        the container may run into class loading problems if one or more of the application's
                        optional JAR files are missing.
                        Since the container is not in a position to decide whether these types of class
                        loading failures will prevent the application from working correctly,
                        it must ignore them, while at the same time providing a configuration option that would log them.
                    </description>
                    <location chapter="8" section="2.4"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                    <id>Servlet:SPEC:259.3</id>
                    <description>If an implementation of ServletContainerInitializer does not have the @HandlesTypes annotation,
                        or if there are no matches to any of the HandlesType specified,
                        then it will get invoked once for every application with null as the value of the Set.
                        This will allow for the initializer to determine based on the resources available
                        in the application whether it needs to initialize a servet / filter or not.
                    </description>
                    <location chapter="8" section="2.4"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                    <id>Servlet:SPEC:259.4</id>
                    <description>The onStartup method of the ServletContainerInitializer will be invoked when the application is coming up before any of the listener's events are fired. </description>
                    <location chapter="8" section="2.4"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                    <id>Servlet:SPEC:259.5</id>
                    <description>The ServletContainerInitializer's onStartup method get's a Set of Classes that either extend / implement the classes that the initializer expressed interest in or if it is annotated with any of the classes specified via the @HandlesTypes annotation. </description>
                    <location chapter="8" section="2.4"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                    <id>Servlet:SPEC:259.6</id>
                    <description>The framework jar file can also be bundled in WEB-INF/lib directory of the war file.
                        If the ServletContainerInitializer is bundled in a JAR file inside the WEB-INF/lib 
                        directory of an application, it's onStartup method will be invoked only once 
                        during the startup of the bundling application. If, on the other hand, the ServletContainerInitialzer is bundled
                        in a JAR file outside of the WEB-INF/lib directory, but still discoverable
                        by the runtime's service provider lookup mechanism,
                        it's onStartup method will be invoked every time an application is started.
                    </description>
                    <location chapter="8" section="2.4"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                    <id>Servlet:SPEC:259.7</id>
                    <description>Implementations of the ServletContainerInitializer interface will be discovered by the runtime's service lookup mechanism or a container specific mechanism that is semantically equivalent to it. In either case, ServletContainerInitializer services from web fragment JAR files that are excluded from an absolute ordering MUST be ignored, and the order in which these services are discovered MUST follow the application's class loading delegation model.</description>
                    <location chapter="8" section="2.4"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
            <id>Servlet:SPEC:260</id>
            <description>The ServletContainerInitializer and programmatic registration features make it possible to provide a clear separation of responsibilities between the Servlet and JSP containers, by making the Servlet container responsible for parsing only web.xml and web-fragment.xml resources, and delegating the parsing of Tag Library Descriptor (TLD) resources to the JSP container. `</description>
            <location chapter="8" section="3"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
            <id>Servlet:SPEC:261</id>
            <description>Previously, a web container had to scan TLD resources for any listener declarations.  With Servlet 3.0, this responsibility may be delegated to the JSP container. A JSP container that is embedded in a Servlet 3.0 compliant Servlet container may provide its own ServletContainerInitializer implementation, search the ServletContext passed to its onStartup method for any TLD resources, scan those resources for listener declarations, and register the corresponding listeners with the ServletContext.  </description>
            <location chapter="8" section="3"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
            <id>Servlet:SPEC:262</id>
            <description>In addition, prior to Servlet 3.0, a JSP container used to have to scan an application's deployment descriptor for any jsp-config related configuration. With Servlet 3.0, the Servlet container must make available, via the ServletContext.getJspConfigDescriptor method, any jsp-config related configuration from the application's web.xml and web-fragment.xml deployment descriptors. </description>
            <location chapter="8" section="3"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
            <id>Servlet:SPEC:263</id>
            <description>Any ServletContextListeners that were discovered in a TLD and registered programmatically are limited in the functionality they provide. Any attempt to call a ServletContext API method on them that was added in Servlet 3.0 will result in an UnsupportedOperationException. </description>
            <location chapter="8" section="3"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
            <id>Servlet:SPEC:264</id>
            <description>In addition, a Servlet 3.0 compliant Servlet container must provide a ServletContext attribute with name jakarta.servlet.context.orderedLibs, whose value (of type java.util.List&lt;java.lang.String&gt;) contains the list of names of JAR files in the WEB-INF/lib directory of the application represented by the ServletContext, ordered by their web fragment names (with possible exclusions if fragment JAR files have been excluded from absolute-ordering), or null if the application does not specify any absolute or relative ordering. </description>
            <location chapter="8" section="3"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:265</id>
            <description>Web applications can include both annotations and the web.xml / web-fragment.xml deployment descriptors. </description>
            <location chapter="8" section="4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:266</id>
            <description>. If there is no deployment descriptor, or there is one but does not have the metadata-complete set to true, web.xml, web-fragment.xml and annotations if used in the application must be processed.</description>
            <location chapter="8" section="4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:267</id>
            <description>The following table (Table 8-1) describes whether or not to process annotations and web.xml fragments. </description>
            <location chapter="8" section="4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>Servlet:SPEC:75</id>
            <description>The Container provider must ensure that the dispatch of the request to a target servlet
                occurs in the same thread of the same VM as the original request.
            </description>
            <location chapter="9" section="2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:192</id>
            <description>The include method of the RequestDispatcher interface may be called at any time. The target servlet of the include method has access to all aspects of the request object, but its use of the response object is more limited.</description>
            <location chapter="9" section="3"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:192.1</id>
                    <description>It can only write information to the ServletOutputStream or Writer of the response object</description>
                    <location chapter="9" section="3"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:192.2</id>
                    <description>commit a response by writing content past the end of the response buffer</description>
                    <location chapter="9" section="3"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:192.3</id>
                    <description>commit a response by explicitly calling the flushBuffer method of the ServletResponse interface.</description>
                    <location chapter="9" section="3"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:192.4</id>
                    <description>It cannot set headers or call any method that affects the headers of the response, with the exception of the HttpServletRequest. getSession() and HttpServletRequest.getSession(boolean) methods. Any attempt to set the headers must be ignored, and any call to HttpServletRequest. getSession() or HttpServletRequest.getSession( boolean) that would require adding a Cookie response header must throw an IllegalStateException if the response has been committed.</description>
                    <location chapter="9" section="3"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:76</id>
            <description>Except for servlets obtained by using the getNamedDispatcher method, a servlet being used from within an include has access to the path by which it was invoked.  The following request attributes are set:</description>
            <location chapter="9" section="3.1"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:76.1</id>
                    <description>'jakarta.servlet.include.request_uri' which is the URI by which it was invoked.</description>
                    <location chapter="9" section="3.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:76.2</id>
                    <description>'jakarta.servlet.include.context_path' which is the context path portion of the request URI by which it was invoked.</description>
                    <location chapter="9" section="3.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:76.3</id>
                    <description>'jakarta.servlet.include.servlet_path' the servlet-path portion of the request URI by which it was invoked.</description>
                    <location chapter="9" section="3.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:76.4</id>
                    <description>'jakarta.servlet.include.path_info' the path-info portion of the request URI by which it was invoked.</description>
                    <location chapter="9" section="3.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:76.5</id>
                    <description>'jakarta.servlet.include.query_string' the query string portion of the request URI by which it was invoked.</description>
                    <location chapter="9" section="3.1"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:77</id>
            <description>If output data exists in the response buffer that has not been committed, the content must be cleared before the target's service method is called.</description>
            <location chapter="9" section="4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:78</id>
            <description>The path elements of the request object exposed to the target servlet must reflect the path used to obtain the RequestDispatcher.</description>
            <location chapter="9" section="4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>Servlet:SPEC:79</id>
            <description>If the RequestDispatcher was obtained through getNamedDispatcher the path elements of the request object must reflect those of the original request.</description>
            <location chapter="9" section="4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:80</id>
            <description>Before the forward method of the RequestDispatcher interface returns without exception,
                the response content must be sent and committed, and closed by the servlet container,
                unless the request was put into the asynchronous mode
            </description>
            <location chapter="9" section="4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="deprecated" testable="true">
            <id>Servlet:SPEC:81</id>
            <description>The request dispatching mechanism is responsible for aggregating query string parameters when forwarding or including requests.</description>
            <location chapter="9" section="4.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:180</id>
            <description>Except for servlets obtained by using the getNamedDispatcher method, a servlet that has been invoked by another servlet using the forward method of RequestDispatcher has access to the path of the original request. The values of these attributes must be equal to the return values of the HttpServletRequest methods getRequestURI, getContextPath, getServletPath, getPathInfo, getQueryString respectively, invoked on the request object passed to the first servlet object in the call chain that received the request from the client. These attributes are accessible from the forwarded servlet via the getAttribute method on the request object. Note that these attributes must always reflect the information in the original request even under the situation that multiple forwards and subsequent includes are called. If the forwarded servlet was obtained by using the getNamedDispatcher method, these attributes must not be set.</description>
            <location chapter="9" section="4.2"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:180.1</id>
                    <description>jakarta.servlet.forward.request_uri</description>
                    <location chapter="9" section="4.2"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:180.2</id>
                    <description>jakarta.servlet.forward.context_path</description>
                    <location chapter="9" section="4.2"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:180.3</id>
                    <description>jakarta.servlet.forward.servlet_path</description>
                    <location chapter="9" section="4.2"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:180.4</id>
                    <description>jakarta.servlet.forward.path_info</description>
                    <location chapter="9" section="4.2"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:180.5</id>
                    <description>jakarta.servlet.forward.query_string</description>
                    <location chapter="9" section="4.2"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:181</id>
            <description>If the forwarded servlet was obtained by using the getNamedDispatcher method, these attributes must not be set.</description>
            <location chapter="9" section="4.2"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:181.1</id>
                    <description>jakarta.servlet.forward.request_uri</description>
                    <location chapter="9" section="4.2"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:181.2</id>
                    <description>jakarta.servlet.forward.context_path</description>
                    <location chapter="9" section="4.2"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:181.3</id>
                    <description>jakarta.servlet.forward.servlet_path</description>
                    <location chapter="9" section="4.2"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:181.4</id>
                    <description>jakarta.servlet.forward.path_info</description>
                    <location chapter="9" section="4.2"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:181.5</id>
                    <description>jakarta.servlet.forward.query_string</description>
                    <location chapter="9" section="4.2"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>Servlet:SPEC:82</id>
            <description>If the servlet that is the target of a request dispatcher throws a runtime exception or a checked exception of type ServletException or IOException, it may be propagated to the calling servlet.</description>
            <location chapter="9" section="5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:83</id>
            <description>All other exceptions (not a runtime, ServletException, or IOException) should be wrapped as ServletExceptions with the root cause the original exception before propagation.</description>
            <location chapter="9" section="5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>Servlet:SPEC:84</id>
            <description>An instance of a web application, by default, must run on one VM at any one time.</description>
            <location chapter="10" section="1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>Servlet:SPEC:85</id>
            <description>An application marked as distributable must obey a more restrictive set of rules than is required of a normal web application (the rules are set through out this list.)</description>
            <location chapter="10" section="1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>Servlet:SPEC:86</id>
            <description>The servlet container must enforce a one to one correspondence between a web application and a ServletContext.  A ServletContext object provides a servlet with its view of the application.</description>
            <location chapter="10" section="2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>Servlet:SPEC:87</id>
            <description>Since the context path of an application determines the URL namespace of the context of the web application, web containers must reject web application defining a context path could cause potential conflicts in this URL namespace.</description>
            <location chapter="10" section="5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>Servlet:SPEC:88</id>
            <description>Since request are matched to resources case sensitively, this determination of potential context path namespace conflicts must be performed case sensitively as well.</description>
            <location chapter="10" section="5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:89</id>
            <description>The WEB-INF node (or directory) of a web application is not part of the public document tree of the application.  Any requests to access the resources in /WEB-INF directory must be returned with a SC_NOT_FOUND(404) response.</description>
            <location chapter="10" section="5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:90</id>
            <description>The contents of /WEB-INF are visible to Servlets through the use of ServletContext.getResource or ServletContext.getSourceAsStream.</description>
            <location chapter="10" section="5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:91</id>
            <description>The web applcation classloader must load classes from the WEB-INF/ classes directory first, and then from the library JARs in the WEB-INF directory.</description>
            <location chapter="10" section="5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:92</id>
            <description>When web applications are packaged in a WAR file (Web ARchive file), a META-INF directory will be present which contains information useful to Java Archive tools.</description>
            <location chapter="10" section="6"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:92.1</id>
                    <description>Any requests to the META-INF directory of a packaged web application will be returned with a SC_NOT_FOUND(404) response.</description>
                    <location chapter="10" section="6"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:92.2</id>
                    <description>The content of the META-INF directory of a packaged web application is accessible to servlets using the getResource and getResourceAsStream methods of the ServletContext.</description>
                    <location chapter="10" section="6"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="false">
            <id>Servlet:SPEC:93</id>
            <description>Jakarta EE technology-compliant containers are required to provide a mechanism by which a deployer can learn what JAR files containing resources and code are available for the Web application.</description>
            <location chapter="10" section="7.1"/>
        </assertion>
        <assertion required="false" impl-spec="true" defined-by="technology" status="active" testable="false">
            <id>Servlet:SPEC:97</id>
            <description>Containers should provide a convenient procedure for editing and configuring library files or extensions.</description>
            <location chapter="10" section="7.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>Servlet:SPEC:94</id>
            <description>During deployment of the Web application, the Web container must make the correct versions of the extensions available to the application following the rules defined by the Optional Package Versioning mechanism (https://docs.oracle.com/javase/8/docs/technotes/guides/extensions/extensions.html).</description>
            <location chapter="10" section="7.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>Servlet:SPEC:95</id>
            <description>Web containers must also be able to recognize declared dependencies expressed in the manifest entry of any of the library JARs under the WEB-INF/lib entry in a WAR.</description>
            <location chapter="10" section="7.1"/>
        </assertion>
        <assertion required="false" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>Servlet:SPEC:96</id>
            <description>If a web container is not able to satisfy the dependencies declared via manifest files, it should reject the application with an informative error message.</description>
            <location chapter="10" section="7.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:98</id>
            <description>The classloader that a container uses to load a servlet in a WAR must allow the developer to load any resources contained in library JARs within the WAR following normal Java SE semantics using getResource.</description>
            <location chapter="10" section="7.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:99</id>
            <description>As described in the Jakarta EE license agreement, servlet containers that are not part of a Jakarta EE product should not allow the application to override Java SE platform classes, such as those in the java.* and javax.* namespaces, that Java SE does not allow to be modified.</description>
            <location chapter="10" section="7.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:99.1</id>
            <description>Also, servlet containers that are part of a Jakarta EE product should not allow the application to override Java SE or Jakarta EE platform classes, such as those in the java.* and javax.* namespaces, that either Java SE or Jakarta EE do not allow to be modified.</description>
            <location chapter="10" section="7.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:99.2</id>
            <description>The class loader that a container uses to load a servlet in a WAR must allow the developer to load any resources contained in library JARs within the WAR following normal Java SE semantics using getResource.</description>
            <location chapter="10" section="7.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:99.3</id>
            <description>It is recommended also that the application class loader be implemented so that classes and resources packaged within the WAR are loaded in preference to classes and resources residing in container-wide library JARs.</description>
            <location chapter="10" section="7.2"/>
        </assertion>
        <assertion required="false" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>Servlet:SPEC:100</id>
            <description>It is recommended that the loader not allow servlets in the WAR access to the web container's implementation classes.</description>
            <location chapter="10" section="7.2"/>
        </assertion>
        <assertion required="false" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>Servlet:SPEC:101</id>
            <description>It is recommended also that the application classloader be implemented so that classes and resources packaged  within the WAR are loaded in preference to classes and resources residing in container-wide library JARs.</description>
            <location chapter="10" section="7.2"/>
        </assertion>
        <assertion required="false" impl-spec="true" defined-by="technology" status="active" testable="false">
            <id>Servlet:SPEC:102</id>
            <description>A server should be able to replace an application with a new version without restarting the container.  When an application is replaced, the container should provide a robust method for preserving session data within that application.</description>
            <location chapter="10" section="8"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:103</id>
            <description>A web application must be able to specify that when errors occur other resources in the application are used to provide the content body of the error response.</description>
            <location chapter="10" section="9.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:104</id>
            <description>If the location of the error handler is a servlet or JSP page, then:</description>
            <location chapter="10" section="9.1"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:104.1</id>
                    <description>The original unwrapped request and response objects created by the container are passed to the servlet or JSP page.</description>
                    <location chapter="10" section="9.1"/>
                    <comment>Seems to contradict the section on request dispatching</comment>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="removed" testable="true">
                    <id>Servlet:SPEC:104.2</id>
                    <description>The response setStatus method is disabled and ignored if called.</description>
                    <location chapter="10" section="9.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:104.3</id>
                    <description>The request path and attributes are set as if a RequestDispatcher.forward to the error resource has been performed.</description>
                    <location chapter="10" section="9.1"/>
                    <sub-assertions>
                        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                            <id>Servlet:SPEC:104.3.1</id>
                            <description>The request attribute 'jakarta.servlet.error.status_code' of type 'java.lang.Integer' will be set containing the HTTP status code of the error condition.</description>
                            <location chapter="10" section="9.1"/>
                        </assertion>
                        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                            <id>Servlet:SPEC:104.3.2</id>
                            <description>The request attribute 'jakarta.servlet.error.exception_type' of type 'java.lang.Class' will be set if the error page was invoked due to an uncaught exception.</description>
                            <location chapter="10" section="9.1"/>
                        </assertion>
                        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                            <id>Servlet:SPEC:104.3.3</id>
                            <description>The request attribute 'jakarta.servlet.error.message' of type 'java.lang.String' will be set if the error page was invoked due to an uncaught exception.</description>
                            <location chapter="10" section="9.1"/>
                        </assertion>
                        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                            <id>Servlet:SPEC:104.3.4</id>
                            <description>The 'jakarta.servlet.error.exception' attribute of type 'java.lang.Throwable' will be set if the error page was invoked due to an uncaught exception.</description>
                            <location chapter="10" section="9.1"/>
                        </assertion>
                        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                            <id>Servlet:SPEC:104.3.5</id>
                            <description>The 'jakarta.servlet.error.request_uri' attribute of type 'java.lang.String' will contain the URI of the offending resource.</description>
                            <location chapter="10" section="9.1"/>
                        </assertion>
                        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                            <id>Servlet:SPEC:104.3.6</id>
                            <description>The 'jakarta.servlet.error.servlet_name' attribute of type 'java.lang.String' will contain the logical name of the servlet in which the error occurred.</description>
                            <location chapter="10" section="9.1"/>
                        </assertion>
                    </sub-assertions>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:105</id>
            <description>If the sendError method is called on the response, the container consults the list of error page declarations for the web application that use the status-code syntax and attempts a match.  If there is a match, the container returns the resource as indicated by the location entry.</description>
            <location chapter="10" section="9.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:106</id>
            <description>In the case where the container is matching error pages based on the exception-type element, a match results in the container returning the resource indicated in the location entry.  The closest match in the class hierarchy wins.</description>
            <location chapter="10" section="9.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:107</id>
            <description>If no error-page declaration containing an exception-type fits using the class-hierarchy match, and the exception throws is a ServletException or subclass thereof the container extraces the wrapped exception, as defined by the ServletException.getRootCause method and a second pass is made of the error page declarations, again attempting the match against the error page declearations,  but using the wrapped exception.</description>
            <location chapter="10" section="9.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>Servlet:SPEC:108</id>
            <description>Error-page declarations using the exception-type element in the deployment descriptor must be unique up to the class name of the exception type.</description>
            <location chapter="10" section="9.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:109</id>
            <description>Error page declarations using the status-code elements must be unique in the deployment descriptor up to the status-code.</description>
            <location chapter="10" section="9.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:311</id>
            <description>
               If an error-page element in the deployment descriptor does not contain 
               an exception-type or an error-code element, the error page is a default 
               error page.
            </description>
            <location chapter="10" section="9.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:110</id>
            <description>The error page mechanism does not intervene when errors occur when invoked using the RequestDispatcher or Filter.doFilter method.  In this way, a filter or servlet using the RequestDispatcher has the opportunity to handle errors generated.</description>
            <location chapter="10" section="9.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:111</id>
            <description>If a servlet generates an error that is not handled by the error page mechanism as described above, the container must ensure to send a response with status 500.</description>
            <location chapter="10" section="9.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:112</id>
            <description>The default servlet and container will use the sendError method to send 4xx and 5xx responses so that the error mechanism may be invoked.</description>
            <location chapter="10" section="9.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:113</id>
            <description>The default servlet and container will use the setStatus method to send 2xx and 3xx responses to bypass the error mechanism</description>
            <location chapter="10" section="9.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:114</id>
            <description>If a web container receives a valid partial request, the web container must examine the welcome files list, which is an ordered list of partial URLs, with no leading or trailing slash, and append the each welcome file to the partial URI in the order it was defined to find a match.  The web container must send the request to the first resource in the WAR that matches.</description>
            <location chapter="10" section="10"/>
        </assertion>
        <assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="false">
            <id>Servlet:SPEC:115</id>
            <description>If no welcome file match is found, the container may handle the request as it sees fit.</description>
            <location chapter="10" section="10"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
            <id>Servlet:SPEC:116</id>
            <description>Jakarta EE compliant servlet containers are required to support the following elements of the web deployment descriptor for specifying information allowing a servlet to obtain references to resources and enterprise beans. The deployment elements that contain this information are:</description>
            <location chapter="10" section="11"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                    <id>Servlet:SPEC:116.1</id>
                    <description>env-entry</description>
                    <location chapter="10" section="11"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                    <id>Servlet:SPEC:116.2</id>
                    <description>ejb-ref</description>
                    <location chapter="10" section="11"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                    <id>Servlet:SPEC:116.3</id>
                    <description>ejb-local-ref</description>
                    <location chapter="10" section="11"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                    <id>Servlet:SPEC:116.4</id>
                    <description>resource-env-ref</description>
                    <location chapter="10" section="11"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                    <id>Servlet:SPEC:116.5</id>
                    <description>resource-ref</description>
                    <location chapter="10" section="11"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="false" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>Servlet:SPEC:117</id>
            <description>If the standalone container does not support these lookup facilities, the container should provide a warning upon deployment of an application that has dependencies on such resources.</description>
            <location chapter="10" section="11"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
            <id>Servlet:SPEC:118</id>
            <description>Servlet containers that are part of a Jakarta EE technology compliant implementation must support lookups of such objects and calls made to those objects when performed on a thread managed by the servlet container.</description>
            <location chapter="10" section="11"/>
        </assertion>
        <assertion required="false" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>Servlet:SPEC:119</id>
            <description>Such servlet containers should support this lookup behavior when performed on threads created by the developer, but are not required to do so.</description>
            <location chapter="10" section="11"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:182</id>
            <description>&lt;![CDATA[When a web application is deployed into a container, the following steps must be performed, in this order, before the web application begins processing client requests.
                1. Instantiate an instance of each event listener identified by a &lt;listener&gt; element in the deployment descriptor.
                2. For instantiated listener instances that implement ServletContextListener, call the contextInitialized() method.
                3. Instantiate an instance of each filter identified by a &lt;filter>&gt; element in the deployment descriptor and call each filter instances init() method.
                4. Instantiate an instance of each servlet identified by a &lt;servlet&gt; element that includes a &lt;load-on-startup&gt; element in the order defined by the load-onstartup element values, and call each servlet instances init() method.]]&gt;
            </description>
            <location chapter="10" section="12"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
            <id>Servlet:SPEC:201</id>
            <description>A web application is NOT required to contain a web.xml if it does NOT contain any Servlet,
                Filter, or Listener components. In other words an application containing only static files
                or JSP pages does not require a web.xml to be present.
            </description>
            <location chapter="10" section="13"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>Servlet:SPEC:120</id>
            <description>Each listener class specified in the deployment descriptor must have a public constructor taking no arguments.</description>
            <location chapter="11" section="3.1"/>
            <comment>Untestable as there is no way to really validate this.</comment>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="removed" testable="true">
            <id>Servlet:SPEC:121</id>
            <description>Listeners will be invoked in the order that they are defined in the deployment descriptor.</description>
            <location chapter="11" section="3.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>Servlet:SPEC:122</id>
            <description>The Web container creates an instance of each listener class and registers it
                for event notifications prior to the processing of the first request by the application
            </description>
            <location chapter="11" section="3.3"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:123</id>
            <description>The Web container registers the listener instances according to the interfaces
                they implement and the order in which they appear in the deployment descriptor.
            </description>
            <location chapter="11" section="3.3"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:124</id>
            <description>During Web application execution, listeners corresponding to given events are
                invoked in the order of their registration.
            </description>
            <location chapter="11" section="3.3"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>Servlet:SPEC:125</id>
            <description>On application shutdown, listeners are notified in reverse order to their declarations with notifications to session listeners preceeding notifications to context listeners.  Session listeners must be notified of session invalidations prior to context listeners being notified of application shutdown.</description>
            <location chapter="11" section="3.4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:126</id>
            <description>The container is required to complete instantiation of the listener classes in a web application prior to the start of execution of the first request into the application.</description>
            <location chapter="11" section="5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>Servlet:SPEC:127</id>
            <description>The container must maintain a reference to each listener instance until the last request is serviced for the web application.</description>
            <location chapter="11" section="5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:128</id>
            <description>The container must allow unhandled exceptions to be handled by the error page mechanism described in Section SRV.9.9, "Error Handling". If there is no error page specified for those exceptions, the container must ensure to send a response back with status 500. In this case no more listeners under that event are called.</description>
            <location chapter="11" section="6"/>
        </assertion>
        <assertion required="false" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>Servlet:SPEC:129</id>
            <description>In cases where it is not possible to handle an Exception in application code (ex. an Exception occuring during initialization of a ContextListener), the container may response to all subsequent requests with an HTTP status code of 500 to indicate application error.</description>
            <location chapter="11" section="6"/>
        </assertion>
        <assertion required="false" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>Servlet:SPEC:130</id>
            <description>In distributed web containers, HttpSession instances are scoped to the particular VM services session requests, and the ServletContext object is scoped to the web container's VM.</description>
            <location chapter="11" section="7"/>
        </assertion>
        <assertion required="false" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>Servlet:SPEC:131</id>
            <description>Distributed containers are not required to propogate either servlet context events or HttpSession events to other VMs.</description>
            <location chapter="11" section="7"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>Servlet:SPEC:132</id>
            <description>Listener class instances are scoped to one per deployment descriptor declaration per Java virtual machine.</description>
            <location chapter="11" section="7"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:133</id>
            <description>Upon receipt of a client request, the Web container determines the Web application to which to forward it.  The Web application selected must have the longest context path that matches the start of the request URL.  The matched part of the URL is the context path when mapping to servlets.</description>
            <location chapter="12" section="1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:134</id>
            <description>The Web container next must locate the servlet to process the request using the path mapping procedure described below. The path used for mapping to a servlet is the request URL from the request object minus the context path and the path parameters. The URL path mapping rules below are used in order. The first successful match is used with no further matches attempted</description>
            <location chapter="12" section="1"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:134.1</id>
                    <description>The container will try to find an exact match of the path of the request to the path of the servlet.  A successful match selects the servlet.</description>
                    <location chapter="12" section="1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:134.2</id>
                    <description>The container will recursively try to match the longest path-prefix: This is done by stepping down the path tree a directory at a time, using the '/' character as a path separator.  The longest match determines the servlet selected.</description>
                    <location chapter="12" section="1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:134.3</id>
                    <description>If the last segment in the URL path contains an extension (e.g. .jsp), the servlet container will try to match a servlet that handles requests for the extension.  An extension is defined as the part of the last segment after the last '.' character.</description>
                    <location chapter="12" section="1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:134.4</id>
                    <description>If neither the previous three rules result in a servlet match, the container will attempt to serve content appropriate for the resource requested.  If a "default" servlet is defined for the applications, it will be used.</description>
                    <location chapter="12" section="1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:134.5</id>
                    <description>The container must use case-sensitive string comparisons for matching.</description>
                    <location chapter="12" section="1"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:220</id>
            <description>In the Web application deployment descriptor, the following syntax is used to define mappings</description>
            <location chapter="12" section="2"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:220.1</id>
                    <description>A string beginning with a / character and ending with a /* suffix is used for path mapping.</description>
                    <location chapter="12" section="2"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:220.2</id>
                    <description>A string beginning with a *. prefix is used as an extension mapping.</description>
                    <location chapter="12" section="2"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:220.3</id>
                    <description>The empty string ("") is a special URL pattern that exactly maps to the application's context root, i.e., requests of the form http://host:port/&lt;contextroot&gt;/. In this case the path info is / and the servlet path and context path is empty string "".</description>
                    <location chapter="12" section="2"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:220.4</id>
                    <description>A string containing only the character / indicates the "default" servlet of the application. In this case the servlet path is the request URI minus the context path and the path info is null.</description>
                    <location chapter="12" section="2"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:220.5</id>
                    <description>All other strings are used for exact matches only.</description>
                    <location chapter="12" section="2"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:220.6</id>
                    <description>
                         If the effective web.xml (after merging information from fragments 
                         and annotations) contains any url-patterns that are mapped to 
                         multiple servlets then the deployment must fail.
                    </description>
                    <location chapter="12" section="2"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
            <id>Servlet:SPEC:135</id>
            <description>If the container has an internal JSP container, the *.jsp extension is mapped to it, allowing JSP pages to be executed on demand.</description>
            <location chapter="12" section="2.1"/>
        </assertion>
        <assertion required="false" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>Servlet:SPEC:136</id>
            <description>A servlet container is allowed to make other implicit mappings as long as explicit mappings take precedence.</description>
            <location chapter="12" section="2.1"/>
            <comment>Could be testable.  Define a mapping for .do or whatever and make sure that the expected content is always returned...might be considered a weak test.</comment>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
            <id>Servlet:SPEC:137</id>
            <description>Declarative security constraints are not applied when a servlet uses the RequestDispatcher to invoke a static resource or servlet using a forward or an include.</description>
            <location chapter="13" section="2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
            <id>Servlet:SPEC:138</id>
            <description>The isUserInRole method uses the security-role-ref element when determining the return value of the call.   If no security-role-ref element matching a security-role element has been declared, the container must default to checking the role-name element against the list of security-role elements for the web applications.</description>
            <location chapter="13" section="3"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
            <id>Servlet:SPEC:290</id>
            <description> Servlet containers MUST support the use of the @ServletSecurity
                annotation on classes (and subclasses thereof) that implement
                the jakarta.servlet.Servlet interface.
            </description>
            <location chapter="13" section="4.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
            <id>Servlet:SPEC:291</id>
            <description> The @HttpConstraint annotation is used within the @ServletSecurity
                annotation to represent the security constraint to be applied to all
                HTTP protocol methods for which a corresponding @HttpMethodConstraint
                does NOT occur within the @ServletSecurity annotation.
            </description>
            <location chapter="13" section="4.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="false">
            <id>Servlet:SPEC:292</id>
            <description> At most one instance of the @ServletSecurity annotation may occur
                on a Servlet implementation class, and the @ServletSecurity annotation
                MUST NOT be specified on (that is, targeted to) a Java method.
            </description>
            <location chapter="13" section="4.1"/>
            <comment>This is not testable because the spec is unclear about
                what should happen when this is violated.
            </comment>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
            <id>Servlet:SPEC:293</id>
            <description> When one or more @HttpMethodConstraint annotations are defined within
                a @ServletSecurity annotation, each @HttpMethodConstraint defines the
                security-constraint that applies to the HTTP protocol method identified
                within the @HttpMethodConstraint. The encompassing @ServletSecurity
                annotation defines the security-constraint that applies to all HTTP
                protocol methods other than those for which a corresponding
                @HttpMethodConstraint is defined within the @ServletSecurity annotation.
            </description>
            <location chapter="13" section="4.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
            <id>Servlet:SPEC:294</id>
            <description> When a security-constraint in the portable deployment descriptor
                includes a url-pattern that is an exact match for a pattern mapped
                to a class annotated with @ServletSecurity, the annotation must
                have no effect on the constraints enforced by the Servlet container
                on the pattern.
            </description>
            <location chapter="13" section="4.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
            <id>Servlet:SPEC:295</id>
            <description> When metadata-complete=true is defined for a portable deployment
                descriptor, the @ServletSecurity annotation does not apply to any
                of the url-patterns mapped to (any servlet mapped to) the annotated
                class in the deployment descriptor.
            </description>
            <location chapter="13" section="4.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
            <id>Servlet:SPEC:296</id>
            <description> The enforcement by Servlet containers, of the @ServletSecurity
                annotation must be equivalent in effect to enforcement, by the
                container, of the security-constraint elements resulting from
                the mapping defined in this section.
            </description>
            <location chapter="13" section="4.1.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
            <id>Servlet:SPEC:297</id>
            <description> The @ServletSecurity annotation is used to define one
                method-independent @HttpConstraint followed by a list of zero
                or more @HttpMethodConstraint specifications. The method-independent
                constraint is applied to all HTTP methods for which no HTTP
                method-specific constraint has been defined.
            </description>
            <location chapter="13" section="4.1.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
            <id>Servlet:SPEC:298</id>
            <description> When no @HttpMethodConstraint elements are included, a
                @ServletSecurity annotation corresponds to a single
                security-constraint element containing a web-resource-collection
                that contains no http-method elements, and thus pertains to all
                HTTP methods.
            </description>
            <location chapter="13" section="4.1.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
            <id>Servlet:SPEC:139</id>
            <description>A servlet container enforces declarative or programmatic security for the principal associated with an incoming request based on the security attributes of the principal.  This may happen in either of the following ways:</description>
            <location chapter="13" section="5"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                    <id>Servlet:SPEC:139.1</id>
                    <description>A deployer has mapped a security role to a user group in the operational environment.  The user group to which the calling principal belongs is retrieved from its security attributes.  The principal is in the security role only if the principals user group matches the user group to which the security role has been mapped by the deployer.</description>
                    <location chapter="13" section="5"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                    <id>Servlet:SPEC:139.2</id>
                    <description>A deployer has mapped a security role to a principal name in a security policy domain.  In this case, the principal name of the calling principal is retrieved from its security attributes.  The principal is in the security role only if the principal name is the same as a principal name to which the security role was mapped.</description>
                    <location chapter="13" section="5"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
            <id>Servlet:SPEC:140</id>
            <description>HTTP Basic Authentication is required to be supported by servlet containers.</description>
            <location chapter="13" section="6.1"/>
        </assertion>
        <assertion required="false" impl-spec="false" defined-by="platform" status="active" testable="false">
            <id>Servlet:SPEC:141</id>
            <description>HTTP Digest Authentication is not a required authentication mechanism for servlet containers.</description>
            <location chapter="13" section="6.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="false">
            <id>Servlet:SPEC:142</id>
            <description>Form based authentication allows the customization of the login screen.</description>
            <location chapter="13" section="6.3"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                    <id>Servlet:SPEC:142.1</id>
                    <description>The login form used for form based authentication must contain fields for entering a username and a password.  These fields must be j_username and j_password, respectively.</description>
                    <location chapter="13" section="6.3"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                    <id>Servlet:SPEC:142.2</id>
                    <description>The login form used by the container can be specified within the deployment descriptor.</description>
                    <location chapter="13" section="6.3"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                    <id>Servlet:SPEC:142.3</id>
                    <description>An error page can be specified in the deployment descriptor which will be returned on failed form based authentication attempts.</description>
                    <location chapter="13" section="6.3"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="false">
                    <id>Servlet:SPEC:142.4</id>
                    <description>The authentication process for form based login:</description>
                    <location chapter="13" section="6.3"/>
                    <sub-assertions>
                        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                            <id>Servlet:SPEC:142.4.1</id>
                            <description>The login form associated with the security constraint is sent to the client and the URL path triggering the authentication is stored by the container.</description>
                            <location chapter="13" section="6.3"/>
                        </assertion>
                        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                            <id>Servlet:SPEC:142.4.2</id>
                            <description>The container attempts to authenticate the user using the information from the form.</description>
                            <location chapter="13" section="6.3"/>
                        </assertion>
                        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                            <id>Servlet:SPEC:142.4.3</id>
                            <description>If authentication fails, the error page is returned using either a forward or a redirect, and the status code of the response is set to 200.</description>
                            <location chapter="13" section="6.3"/>
                        </assertion>
                        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                            <id>Servlet:SPEC:142.4.4</id>
                            <description>If authentication succeeds, the authenticated user's principal is check to see if it is in an authroized role for accessing the resource.</description>
                            <location chapter="13" section="3.1"/>
                        </assertion>
                        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                            <id>Servlet:SPEC:142.4.5</id>
                            <description>If the user is authorized, the client is redirected to the resource using the stored URL path.</description>
                            <location chapter="13" section="3.1"/>
                        </assertion>
                    </sub-assertions>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                    <id>Servlet:SPEC:142.5</id>
                    <description>The action of the login form must always be j_security_check.</description>
                    <location chapter="13" section="6.3.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                    <id>Servlet:SPEC:142.6</id>
                    <description>If the form based login is invoked because of an HTTP request, the original request parameters must be preserved by the container for use if on successful authentication, it redirects the call to the requested resource.</description>
                    <location chapter="13" section="6.3.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                    <id>Servlet:SPEC:142.7</id>
                    <description>If the user is authenticated using form login and has created an HTTP session, the timeout or invalidation of that session leads to the user being logged out in the sense that subsequent requests must cause the user to be re-authenticated.</description>
                    <location chapter="13" section="6.3.1"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="false" impl-spec="false" defined-by="platform" status="active" testable="false">
            <id>Servlet:SPEC:143</id>
            <description>Servlet containers that are not Jakarta EE technology compliant are not required to support HTTPS protocol/authentication.</description>
            <location chapter="13" section="6.4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="false">
            <id>Servlet:SPEC:144</id>
            <description>Servlet containers are required to track authentication information at the container level rather than at the web application level.</description>
            <location chapter="13" section="7"/>
        </assertion>
        <assertion required="true" impl-spec="true" defined-by="platform" status="active" testable="false">
            <id>Servlet:SPEC:145</id>
            <description>A security identity, or principal, must always be provided for use in a call to an enterprise bean.</description>
            <location chapter="15" section="3.1"/>
        </assertion>
        <assertion required="true" impl-spec="true" defined-by="platform" status="active" testable="false">
            <id>Servlet:SPEC:146</id>
            <description>The default mode in calls to enterprise beans from web applications is for the security identity of a web user to be propagated to the Jakarta Enterprise Beans container.</description>
            <location chapter="15" section="3.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="false">
            <id>Servlet:SPEC:147</id>
            <description>If a container supports calls to Jakarta Enterprise Beans' containers are required to support access to web resources by clients that have not authenticated themselves to the container through the use of the run-as element of the deployment descriptor.  The container will use this identity when propagating the call from the web layer to the Jakarta Enterprise Beans layer.</description>
            <location chapter="15" section="3.1"/>
            <sub-assertions>
                <assertion required="true" impl-spec="true" defined-by="platform" status="active" testable="false">
                    <id>Servlet:SPEC:147.1</id>
                    <description>The security role propagated through the run-as element must be a security role defined in the deployment descriptor of the web application.</description>
                    <location chapter="15" section="3.1"/>
                </assertion>
                <assertion required="true" impl-spec="true" defined-by="platform" status="active" testable="false">
                    <id>Servlet:SPEC:147.2</id>
                    <description>
                         When a run-as role is specified for a Servlet, the Servlet container 
                         must propagate a principal mapped to the role as the security 
                         identity in any call from the Servlet to a Jakarta Enterprise Bean, including calls 
                         originating from the Servlets init and destroy methods. 
                    </description>
                    <location chapter="15" section="3.1"/>
                </assertion>

            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="false">
            <id>Servlet:SPEC:148</id>
            <description>Web containers running as part of a Jakarta EE platform, the use of run-as elements must be supported both for calls to Jakarta Enterprise Beans components within the same Jakarta EE application, and for calls to Jakarta Enterprise Beans components deployed in other Jakarta EE applications.</description>
            <location chapter="15" section="3.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
            <id>Servlet:SPEC:149</id>
            <description>If a request is issued against a set of protected resources the user who made the request must be a member of at least one of the named roles to be permitted to perform the contrained requests.</description>
            <location chapter="13" section="8"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
            <id>Servlet:SPEC:150</id>
            <description>The special role name "*" is a shorthand for all role names defined in the deployment descriptor.</description>
            <location chapter="13" section="8"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
            <id>Servlet:SPEC:151</id>
            <description>An auth constraint that names no roles indicates that access ot the contrained resources must not be permitted under any circumstances.</description>
            <location chapter="13" section="8"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="false">
            <id>Servlet:SPEC:152</id>
            <description>A user data constraint establishes a requirement that the constrained requests be received over a protected transport layer connection.</description>
            <location chapter="13" section="8"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="false">
                    <id>Servlet:SPEC:152.1</id>
                    <description>A transport guarantee of INTEGRAL is used to establish a requirement for content integrity.</description>
                    <location chapter="13" section="8"/>
                    <comment>Not testable.  Schema states that in most cases this would be SSL, but it's not a hard requirement.</comment>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="false">
                    <id>Servlet:SPEC:152.2</id>
                    <description>A transport guarantee of CONFIDENTIAL is used to establish a requirement for confidentiality.</description>
                    <location chapter="13" section="8"/>
                    <comment>Not testable.  Schema states that in most cases this would be SSL, but it's not a hard requirement.</comment>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                    <id>Servlet:SPEC:152.3</id>
                    <description>A transport guarantee of NONE indicates that the container must accept the constrained requests when received on any connection including unprotected ones.</description>
                    <location chapter="13" section="8"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
            <id>Servlet:SPEC:153</id>
            <description>If no auth-constraing applies to a request, the container must accept the request without requiring user authentication.</description>
            <location chapter="13" section="8"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
            <id>Servlet:SPEC:154</id>
            <description>When a url-pattern and http-method pair occurs in multiple security constraints, the applicable constraints (on the pattern and the method) are defined by combining the individual constraints.</description>
            <location chapter="13" section="8.1"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                    <id>Servlet:SPEC:154.1</id>
                    <description>A security constraint that does not contain an auth constraint shall combine with auth constraints that name or imply roles to allow unauthenticated access.</description>
                    <location chapter="13" section="8.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                    <id>Servlet:SPEC:154.2</id>
                    <description>The special case of an auth constraint that names no roles shall combine with any other constraints to override their affects and cause access to be precluded.</description>
                    <location chapter="13" section="8.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="false">
                    <id>Servlet:SPEC:154.3</id>
                    <description>The combination of user-data constraints that apply to a common usr-pattern and http-method shall yield the union of connection types accepted by the individual constraints as acceptable connection types.</description>
                    <location chapter="13" section="8.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                    <id>Servlet:SPEC:154.4</id>
                    <description>A security constraint that does not contain a user-data constraint shall combine with other user-data constraints to cause the unprotected connection type to be an accepted connection type.</description>
                    <location chapter="13" section="8.1"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
            <id>Servlet:SPEC:155</id>
            <description>When a Servlet container receives a request, it shall use the url pattern matching algorithm to select the constraints, if any, defined that is the best match to the request URI</description>
            <location chapter="13" section="8.3"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
            <id>Servlet:SPEC:156</id>
            <description>If no security contraint can be matched between the defined contraints and the request URI, the container will accept the request.</description>
            <location chapter="13" section="8.3"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
            <id>Servlet:SPEC:157</id>
            <description>If a constraint match is found based on the request URI, the container shall determine if the HTTP method of the request is constrained, if it's not, then the constrained request will be accepted.</description>
            <location chapter="13" section="8.3"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
            <id>Servlet:SPEC:158</id>
            <description>If the HTTP method is contrained, then the method used for the request must match what is acceptable for the constraint in order for the request to be accepted.</description>
            <location chapter="13" section="8.3"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
            <id>Servlet:SPEC:159</id>
            <description>If the characteristics of the connection on which the request was received must satisfy at least one of the supported connection types defined by the constraints.  If this rule is not satisfied, the container shall reject the request and redirect it to the HTTPS port.</description>
            <location chapter="13" section="8.3"/>
            <sub-assertions>
                <assertion required="false" impl-spec="false" defined-by="platform" status="active" testable="false">
                    <id>Servlet:SPEC:159.1</id>
                    <description>As an optimization, a container should reject the connection request if it doesn't match the constrained connection types and return a 403 (SC_FORBIDDEN) status code if it knows that access will ultimately be precluded (by an auth constraint naming with no roles).</description>
                    <location chapter="13" section="8.3"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
            <id>Servlet:SPEC:160</id>
            <description>If a constraint naming defined no roles, any attempted requests will result in a 403 (SC_FORBIDDEN).</description>
            <location chapter="13" section="8.3"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
            <id>Servlet:SPEC:161</id>
            <description>If access is restricted to permitted roles and the request has not been authenticated, the request shall be rejected as unauthorized and a 401 (SC_UNAUTHORIZED) status code shall be returned to cause authentication.</description>
            <location chapter="13" section="8.3"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
            <id>Servlet:SPEC:162</id>
            <description>If access is restricted to permitted roles and the authentication identity of the request is not a member of any of these roles, the request shall be rejected as forbidden and a 403 (SC_FORBIDDEN) status code shall be returned to the user.</description>
            <location chapter="13" section="8.3"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
            <id>Servlet:SPEC:309</id>
            <description>
                When the deny-uncovered-http-methods flag is set in the web.xml of an application, the container 
                must deny any HTTP protocol method when it is used with a request URL for which the HTTP method 
                is uncovered at the combined security constraint that applies to the url-pattern that is the best 
                match for the request URL.  The denied request shall be rejected as forbidden and a 403 (SC_FORBIDDEN) 
                status code shall be returned.
            </description>
            <location chapter="13" section="8.4.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
            <id>Servlet:SPEC:310</id>
            <description>
                When an applications security configuration contains no uncovered methods, the 
                deny-uncovered-http-methods flag must have no effect on the effective security 
                configuration of the application.                
            </description>
            <location chapter="13" section="8.4.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
            <id>Servlet:SPEC:163</id>
            <description>If a developer creates a session while a user is not authenticated, and the container then authenticates the user, the session visible to developer code after login must be the same session object that was created prior to login occurring so that there is no loss of session information.</description>
            <location chapter="13" section="10"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="platform" status="removed" testable="true">
            <id>Servlet:SPEC:164</id>
            <description>For all authentication methods in both non-single signon and single signon containers, logout is caused by one of the following situations:</description>
            <location chapter="13" section="10"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="platform" status="removed" testable="true">
                    <id>Servlet:SPEC:164.1</id>
                    <description>Invalidation of the session.  If this occurs, getUserPrincipal will return a null value.</description>
                    <location chapter="13" section="10"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="platform" status="removed" testable="true">
                    <id>Servlet:SPEC:164.2</id>
                    <description>Session timeouts.  If this occurs, getUserPrincipal will return a null value.</description>
                    <location chapter="13" section="10"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="platform" status="removed" testable="true">
                    <id>Servlet:SPEC:164.3</id>
                    <description>An explicit call to HttpSession.invalidateAll.  If this occurs, getUserPrincipal will return a null value.</description>
                    <location chapter="13" section="10"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="platform" status="removed" testable="true">
                    <id>Servlet:SPEC:164.4</id>
                    <description>An explicit call to HttpSession.logout.If this occurs, getUserPrincipal will return a null value.</description>
                    <location chapter="13" section="10"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="false">
            <id>Servlet:SPEC:165</id>
            <description>For non-single signon containers, a session invalidating has no effect on login state or session state in other web applications.</description>
            <location chapter="13" section="10"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="false">
            <id>Servlet:SPEC:166</id>
            <description>For single signon containers, logout causes all other active sessions associated with the current user to be invalidated.</description>
            <location chapter="13" section="10"/>
        </assertion>
        <assertion required="false" impl-spec="false" defined-by="platform" status="removed" testable="false">
            <id>Servlet:SPEC:167</id>
            <description>Invalidation or timeout of an individual session causes the termination of that session, but does not cause a logout unless it is the last session for this user, which means that a container is allowed to start a new session for one or more web applications without re-authenticating the user.</description>
            <location chapter="13" section="10"/>
        </assertion>
        <assertion required="false" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>Servlet:SPEC:168</id>
            <description>Servlet 2.5 web containers may use schema to validate the structure of a deployment descriptor.</description>
            <location chapter="14" section="2"/>
        </assertion>
        <assertion required="true" impl-spec="true" defined-by="technology" status="removed" testable="false">
            <id>Servlet:SPEC:169</id>
            <description>The deployment-extension element provides the ability to inject application or framework specific configuration information directly into the deployment descriptor.</description>
            <location chapter="14" section="1"/>
            <sub-assertions>
                <assertion required="false" impl-spec="false" defined-by="technology" status="removed" testable="false">
                    <id>Servlet:SPEC:169.1</id>
                    <description>If a container uses schema to validate a deployment descriptor, any new content injected into deployment-extension elements as described below will not be validated by the web container.</description>
                    <location chapter="14" section="1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="removed" testable="false">
                    <id>Servlet:SPEC:169.2</id>
                    <description>Deployment extensions are only valid within the top level web-app element or within servlet elements.</description>
                    <location chapter="14" section="1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="removed" testable="false">
                    <id>Servlet:SPEC:169.3</id>
                    <description>Servlet 2.5 containers are required to raise an exception if they do not recognize an extension within a deployment descriptor where the mustUnderstand attribute is 'true'.</description>
                    <location chapter="14" section="1.1"/>
                </assertion>
                <assertion required="false" impl-spec="false" defined-by="technology" status="removed" testable="false">
                    <id>Servlet:SPEC:169.4</id>
                    <description>Servlet 2.5 containers are not required to attempt to process extended deployment information where the nustUnderstand attribute is set to 'false'.</description>
                    <location chapter="14" section="1.1"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
            <id>Servlet:SPEC:170</id>
            <description>Security information which may appear in the deployment descriptor is not required to be supported unless the servlet container is part of an implementation of the Jakarta EE specification.</description>
            <location chapter="14" section="1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
            <id>Servlet:SPEC:193</id>
            <description>The following additional elements exist in the Web application deployment descriptor to meet the requirements of Web containers that are JSP pages enabledor part of a Jakarta EE application server. They are not required to be supported by containers wishing to support only the servlet specification:</description>
            <location chapter="15" section="4.1"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                    <id>Servlet:SPEC:171</id>
                    <description>jsp-config</description>
                    <location chapter="15" section="4.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                    <id>Servlet:SPEC:172</id>
                    <description>Syntax for looking up JNDI objects(env-entry, ejb-ref, ejb-local-ref, resource-ref, resource-env-ref)</description>
                    <location chapter="15" section="4.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                    <id>Servlet:SPEC:193.1</id>
                    <description>Syntax for specifying the message destination (message-destination, message-destination-ref)</description>
                    <location chapter="15" section="4.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                    <id>Servlet:SPEC:193.2</id>
                    <description>Reference to a Web service (service-ref)</description>
                    <location chapter="15" section="4.1"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="removed" testable="true">
            <id>Servlet:SPEC:174</id>
            <description>Web containers must remove all leading and trailing
                whitespace, which is defined as "S(whitespace)" in XML 1.0 (http://www.w3.org/TR/2000/WD-xml-
                2e-20000814), for the element content of the text nodes of a deployment descriptor.
            </description>
            <location chapter="14" section="2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:175</id>
            <description>The containers and tools that are
                part of Jakarta EE technology-compliant implementation are required to validate
                deployment descriptor against the XML schema for structural correctness.
            </description>
            <location chapter="14" section="2"/>
        </assertion>
        <assertion required="false" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:176</id>
            <description>It is recommended that Web containers and tools that
                manipulate Web applications provide a level of semantic checking. For example, it
                should be checked that a role referenced in a security constraint has the same
                name as one of the security roles defined in the deployment descriptor.
            </description>
            <location chapter="14" section="2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:10176</id>
            <description>The sub elements under web-app can be in an arbitrary
                order.
            </description>
            <location chapter="14" section="2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>Servlet:SPEC:11276</id>
            <description>The multiplicity
                of the elements distributable, session-config, welcome-file-list, jspconfig,
                login-config, and locale-encoding-mapping-list is "0 or more."
            </description>
            <location chapter="14" section="2"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
                    <id>Servlet:SPEC:11276.1</id>
                    <description>Containers must inform the developer
                        with a descriptive error message when the deployment descriptor contains
                        more than one element of session-config, jsp-config, and login-config.
                    </description>
                    <location chapter="14" section="2"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
                    <id>Servlet:SPEC:11276.2</id>
                    <description>The deployment descriptor instance
                        file must not contain multiple elements of session-config,
                        jsp-config, and login-config.
                    </description>
                    <location chapter="14" section="3"/>
                    <comment>From schema.</comment>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:11276.3</id>
                    <description>The container must concatenate the items
                        in welcome-file-list and locale-encoding-mapping-list when there are multiple occurrences.
                    </description>
                    <location chapter="14" section="2"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:11276.4</id>
                    <description>The multiple
                        occurrence of distributable must be treated exactly in the same way as the
                        single occurrence of distributable.
                    </description>
                    <location chapter="14" section="2"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>Servlet:SPEC:11276</id>
            <description>URI paths specified in the deployment descriptor are
                assumed to be in URLdecoded form.
            </description>
            <location chapter="14" section="2"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
                    <id>Servlet:SPEC:11276.1</id>
                    <description>The containers must inform the developer
                        with a descriptive error message when URL contains CR(#xD) or LF(#xA).
                    </description>
                    <location chapter="14" section="2"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>Servlet:SPEC:11276.2</id>
                    <description>The containers must
                        preserve all other characters including whitespace in URL.
                    </description>
                    <location chapter="14" section="2"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="false" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:177</id>
            <description>Containers must attempt to canonicalize paths in present in the deployment descriptor.</description>
            <location chapter="14" section="2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>Servlet:SPEC:178</id>
            <description>Paths beginning or resolving to paths that begin with ".." are not valid paths in the deployment descriptor.</description>
            <location chapter="14" section="3"/>
            <comment>Not testable as behavior of container is not defined.</comment>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>Servlet:SPEC:179</id>
            <description>Elements whose valus is an enumerated type must be treated in a case sensitive manner.</description>
            <location chapter="14" section="3"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="removed" testable="true">
            <id>Servlet:SPEC:214</id>
            <description>
                Servlet containers are required to support the use of these annotations
                within classes that extend the jakarta.servlet.http.HttpServlet abstract
                class.
            </description>
            <location chapter="14" section="4"/>
            <comment>
                "these annotations" are the 4 security annotations of:
                @RolesAllowed, @DenyAll, @PermitAll, and @TransportProtected
            </comment>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="removed" testable="true">
            <id>Servlet:SPEC:215</id>
            <description>
                When specified on a class target, these annotations apply to all requests
                processed by the public service method of the HttpServlet implementation class.
            </description>
            <location chapter="14" section="4"/>
            <comment>
                "these annotations" are the 4 security annotations of:
                @RolesAllowed, @DenyAll, @PermitAll, and @TransportProtected
            </comment>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="removed" testable="true">
            <id>Servlet:SPEC:216</id>
            <description>
                When an annotation is specified at both the class and method level, the method
                targeted annotation overrides that on the class (for the method).
            </description>
            <location chapter="14" section="4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="removed" testable="true">
            <id>Servlet:SPEC:217</id>
            <description>
                When the metadata-complete attribute is set in the portable deployment
                descriptor, the annotations described in this section have no effect on
                the access control policy enforced by the container on behalf of the
                corresponding web module or web fragment.
            </description>
            <location chapter="14" section="4"/>
            <comment>
                "the annotations" are the 4 security annotations of:
                @RolesAllowed, @DenyAll, @PermitAll, and @TransportProtected
            </comment>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="removed" testable="true">
            <id>Servlet:SPEC:218</id>
            <description>
                When a security-constraint in the portable deployment descriptor
                includes a url-pattern that matches a request URL, the security
                annotations described in this section have no effect on the access
                policy that applies to the request URL.
            </description>
            <location chapter="14" section="4"/>
            <comment>
                "the security annotations" are the 4 security annotations of:
                @RolesAllowed, @DenyAll, @PermitAll, and @TransportProtected
            </comment>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="removed" testable="true">
            <id>Servlet:SPEC:219</id>
            <description>
                When none of these annotations have been assigned to the class and method
                targets corresponding to a request, the access policy that is applied to
                the request is established by the applicable security constraints, if any,
                in the corresponding portable deployment descriptor.
            </description>
            <location chapter="14" section="4"/>
            <comment>
                "these annotations" are the 4 security annotations of:
                @RolesAllowed, @DenyAll, @PermitAll, and @TransportProtected
            </comment>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="false">
            <id>Servlet:SPEC:184</id>
            <description>Jakarta EE technology-compliant containers are required to provide a mechanism by which a deployer can learn about what jar file containing resources and code are available for the Web application.</description>
            <location chapter="15" section="2"/>
        </assertion>
        <assertion required="false" impl-spec="true" defined-by="platform" status="active" testable="false">
            <id>Servlet:SPEC:185</id>
            <description>Containers should provide a convenient procedure for editing and configuring library files or extensions.</description>
            <location chapter="15" section="2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
            <id>Servlet:SPEC:186</id>
            <description>Servlet containers that are part of a Jakarta EE product should not
                allow the application to override Java SE or Jakarta EE platform classes,
                such as those in the java.* and javax.* namespaces,
                that either Java SE or Jakarta EE do not allow to be modified.
            </description>
            <location chapter="15" section="2.1"/>
        </assertion>
        <assertion required="true" impl-spec="true" defined-by="platform" status="active" testable="true">
            <id>Servlet:SPEC:187</id>
            <description>A security identity, or principal, must always be provided for use in a call to an enterprise bean.</description>
            <location chapter="15" section="3.1"/>
        </assertion>
        <assertion required="true" impl-spec="true" defined-by="platform" status="active" testable="true">
            <id>Servlet:SPEC:188</id>
            <description>The default mode in calls to enterprise beans from web applications is
                for the security identity of a web user to be propagated to the Jakarta Enterprise Beans container.
            </description>
            <location chapter="15" section="3.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
            <id>Servlet:SPEC:189</id>
            <description>web containers are required to allow web users that are not known to the web container
                or to the Jakarta Enterprise Beans container to make calls:
            </description>
            <location chapter="15" section="3.1"/>
            <sub-assertions>
                <assertion required="true" impl-spec="true" defined-by="platform" status="active" testable="true">
                    <id>Servlet:SPEC:189.1</id>
                    <description>Web containers are required to support access to web resources by clients
                        that have not authenticated themselves to the container.
                        This is the common mode of access to web resources on the Internet.
                    </description>
                    <location chapter="15" section="3.1"/>
                </assertion>
                <assertion required="true" impl-spec="true" defined-by="platform" status="active" testable="false">
                    <id>Servlet:SPEC:189.2</id>
                    <description>Application code may be the sole processor of signon and
                        customization of data based on caller identity.
                    </description>
                    <location chapter="15" section="3.1"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
            <id>Servlet:SPEC:190</id>
            <description>a web application deployment descriptor may specify a run-as element.
                When a run-as role is specified for a Servlet, the Servlet container must
                propagate a principal mapped to the role as the security identity in any call from the
                Servlet to a Jakarta Enterprise Bean, including calls originating from the Servlet's init and destroy
                methods. The security role name must be one of the security role names defined for
                the web application.
            </description>
            <location chapter="15" section="3.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
            <id>Servlet:SPEC:191</id>
            <description>For web containers running as part of a Jakarta EE platform,
                the use of run-as elements must be supported both for calls to Jakarta Enterprise Beans components within the same Jakarta EE application,
                and for calls to Jakarta Enterprise Beans components deployed in other Jakarta EE applications.
            </description>
            <location chapter="15" section="3.1"/>
        </assertion>
        <assertion required="false" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:194</id>
            <description>Web containers may choose to support running components written to implement a Web service endpoint
                as defined by the JAX-RPC and/or JAX-WS specifications.
            </description>
            <location chapter="15" section="4.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
            <id>Servlet:SPEC:173</id>
            <description>Web containers embedded in a JavaEE conformant implementation are required to support JAX-RPC and JAX-WS web service components.</description>
            <location chapter="15" section="4.2"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                    <id>Servlet:SPEC:173.1</id>
                    <description>JSR-109 [http://jcp.org/jsr/detail/109.jsp] defines the model for packaging a Web service interface
                        with its associated WSDL description and associated classes.
                    </description>
                    <location chapter="15" section="4.2"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                    <id>Servlet:SPEC:173.2</id>
                    <description>It(JSR-109) defines a mechanism for JAX-WS and JAX-RPC enabled Web containers to link to a component that implements this Web service.</description>
                    <location chapter="15" section="4.2"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                    <id>Servlet:SPEC:173.3</id>
                    <description>JAX-WS and JAX-RPC enabled Web containers must support the developer
                        in using the Web deployment descriptor
                        to define the following information for the endpoint implementation component,
                        using the same syntax as for HTTP Servlet components using the servlet element.
                        The child elements are are used to specify endpoint information in the following way:
                    </description>
                    <location chapter="15" section="4.2"/>
                    <sub-assertions>
                        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                            <id>Servlet:SPEC:173.3.1</id>
                            <description>the servlet-name element defines a logical name which may be used
                                to locate this endpoint description among the other Web components in the WAR
                            </description>
                            <location chapter="15" section="4.2"/>
                        </assertion>
                        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                            <id>Servlet:SPEC:173.3.2</id>
                            <description>the servlet-class element provides the fully qualified Java class name of this endpoint implementation</description>
                            <location chapter="15" section="4.2"/>
                        </assertion>
                        <assertion required="false" impl-spec="false" defined-by="platform" status="active" testable="true">
                            <id>Servlet:SPEC:173.3.3</id>
                            <description>the description element(s) may be used to describe the component and may be displayed in a tool</description>
                            <location chapter="15" section="4.2"/>
                        </assertion>
                        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                            <id>Servlet:SPEC:173.3.4</id>
                            <description>the load-on-startup element specifies the order in which the component is initialized relative to other Web components in the Web container</description>
                            <location chapter="15" section="4.2"/>
                        </assertion>
                        <assertion required="false" impl-spec="false" defined-by="platform" status="active" testable="true">
                            <id>Servlet:SPEC:173.3.5</id>
                            <description>the security-role-ref element may be used to test whether the authenticated user is in a logical security role</description>
                            <location chapter="15" section="4.2"/>
                        </assertion>
                        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                            <id>Servlet:SPEC:173.3.6</id>
                            <description>the run-as element may be used to override the identity propagated to Jakarta Enterprise Beans called by this component</description>
                            <location chapter="15" section="4.2"/>
                        </assertion>
                    </sub-assertions>
                </assertion>
                <assertion required="false" impl-spec="false" defined-by="platform" status="active" testable="true">
                    <id>Servlet:SPEC:173.4</id>
                    <description>Any servlet initialization parameters defined by the developer for this Web component may be ignored by the container.</description>
                    <location chapter="15" section="4.2"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                    <id>Servlet:SPEC:173.5</id>
                    <description>JAX-WS and JAXRPC enabled Web component inherits the traditional Web component
                        mechanisms for defining the following information:
                    </description>
                    <location chapter="15" section="4.2"/>
                    <sub-assertions>
                        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                            <id>Servlet:SPEC:173.5.1</id>
                            <description>mapping of the component to the Web container's URL namespace using the servlet mapping technique</description>
                            <location chapter="15" section="4.2"/>
                        </assertion>
                        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                            <id>Servlet:SPEC:173.5.2</id>
                            <description>authorization constraints on Web components using security constraints</description>
                            <location chapter="15" section="4.2"/>
                        </assertion>
                        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                            <id>Servlet:SPEC:173.5.3</id>
                            <description>the ability to use servlet filters to provide low-level byte stream support for manipulating JAX-WS and/or JAX-RPC messages using the filter mapping technique</description>
                            <location chapter="15" section="4.2"/>
                        </assertion>
                        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                            <id>Servlet:SPEC:173.5.4</id>
                            <description>the timeout characteristics of any HTTP sessions that are associated with the component</description>
                            <location chapter="15" section="4.2"/>
                        </assertion>
                        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                            <id>Servlet:SPEC:173.5.5</id>
                            <description>links to Jakarta EE objects stored in the JNDI namespace</description>
                            <location chapter="15" section="4.2"/>
                        </assertion>
                    </sub-assertions>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
            <id>Servlet:SPEC:195</id>
            <description>Annotations must be supported on the following container managed classes
                that implement the following interfaces and are declared in the web application deployment descriptor
                or using the annotations defined in Section8.1, ?Annotations
                and pluggability? on page8-65 or added programmatically.
            </description>
            <location chapter="15" section="5"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                    <id>Servlet:SPEC:195.1</id>
                    <description>jakarta.servlet.Servlet</description>
                    <location chapter="15" section="5"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                    <id>Servlet:SPEC:195.2</id>
                    <description>jakarta.servlet.Filter</description>
                    <location chapter="15" section="5"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                    <id>Servlet:SPEC:195.3</id>
                    <description>jakarta.servlet.ServletContextListener</description>
                    <location chapter="15" section="5"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                    <id>Servlet:SPEC:195.4</id>
                    <description>jakarta.servlet.ServletContextAttributeListener</description>
                    <location chapter="15" section="5"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                    <id>Servlet:SPEC:195.5</id>
                    <description>jakarta.servlet.ServletRequestListener</description>
                    <location chapter="15" section="5"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                    <id>Servlet:SPEC:195.6</id>
                    <description>jakarta.servlet.ServletRequestAttributeListener</description>
                    <location chapter="15" section="5"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                    <id>Servlet:SPEC:195.7</id>
                    <description>jakarta.servlet.http.HttpSessionListener</description>
                    <location chapter="15" section="5"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                    <id>Servlet:SPEC:195.8</id>
                    <description>jakarta.servlet.http.HttpSessionAttributeListener</description>
                    <location chapter="15" section="5"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                    <id>Servlet:SPEC:195.10</id>
                    <description>jakarta.servlet.http.HttpSessionIdListener</description>
                    <location chapter="15" section="5"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                    <id>Servlet:SPEC:195.9</id>
                    <description>jakarta.servlet.AsyncListener</description>
                    <location chapter="15" section="5"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
            <id>Servlet:SPEC:196</id>
            <description>References must be injected prior to any lifecycle methods being called and
                the component instance being made available the the application.
            </description>
            <location chapter="15" section="5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
            <id>Servlet:SPEC:197</id>
            <description>In a web application, classes using resource injection will have their annotations processed only
                if they are located in the WEB-INF/classes directory, or if they are packaged in a jar file located in WEB-INF/lib.
            </description>
            <location chapter="15" section="5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
            <id>Servlet:SPEC:198</id>
            <description>The web application deployment descriptor contains a metadata-complete attribute on the web-app element.
                The metadata-complete attribute defines whether the web descriptor is complete,
                or whether other sources of metadata used by the deployment process should be considered.
                Metadata may come from the web.xml file, web-fragment.xml files,
                annotations on class files in WEB-INF/classes, and
                annotations on classes in jar files in the WEB-INF/lib directory.
                If metadata-complete is set to "true", the deployment tool only examines the web.xml file and
                must ignore annotations such as @WebServlet, @WebFilter, and @WebListener
                present in the class files of the application, and must also ignore any web-fragment.xml
                descriptor packaged in a jar file in WEB-INF/lib.
                If the metadata-complete attribute is not specified or is set to "false",
                the deployment tool must examine the class files and web-fragment.xml files for metadata,
                as previously specified.
            </description>
            <location chapter="15" section="5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
            <id>Servlet:SPEC:289</id>
            <description>The web-fragment.xml also contains the metadata-complete attribute on the web-
                fragment element. The attribute defines whether the web-fragment.xml descriptor
                is complete for the given fragment, or whether it should scan for annotations in the
                classes in the associated jar file. If metadata-complete is set to "true" the
                deployment tool only examines the web-fragment.xml and must ignore annotations
                such as @WebServlet, @WebFilter and @WebListener present in the class files of the
                fragment. If metadata-complete is not specified or is set to "false" the deployment
                tool must examine the class files for metadata.
            </description>
            <location chapter="15" section="5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
            <id>Servlet:SPEC:199</id>
            <description>Following are the annotations that are required by a Jakarta EE technology compliant web container.</description>
            <location chapter="15" section="5"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                    <id>Servlet:SPEC:199.1</id>
                    <description>The @Resource annotation is used to declare a reference to a resource such as
                        a data source, Java Messaging Service (JMS) destination, or environment entry.
                        This annotation is equivalent to declaring a resource-ref, message-destinationref
                        or env-ref, or resource-env-ref element in the deployment descriptor.
                        @Resource annotation is specified on a class, method or field.
                        The container is responsible injecting references to resources declared by
                        the @Resource annotation and mapping it to the proper JNDI resources.
                    </description>
                    <location chapter="15" section="5.4"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                    <id>Servlet:SPEC:199.2</id>
                    <description>@Resources annotation acts as a container for multiple @Resource annotations
                        because the Java MetaData specification does not allow for multiple annotations
                        with the same name on the same annotation target.
                    </description>
                    <location chapter="15" section="5.11"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="platform" status="removed" testable="true">
                    <id>Servlet:SPEC:199.3</id>
                    <description>InjectionComplete annotation is declared on a method which will be called after the resources injections have been completed and before any lifecycle methods on a component are called. This allows application code to do post create processing if necessary.</description>
                    <location chapter="15" section="5.3"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                    <id>Servlet:SPEC:199.4</id>
                    <description>Jakarta Enterprise Beans 4.0 components may be referenced from a web component using the @EJB annotation.
                        The @EJB annotation provides the equivalent functionality of declaring the ejb-ref
                        or ejb-local-ref elements in the deployment descriptor.
                        Fields that have a corresponding @EJB annotation are injected with the a reference to the corresponding Jakarta Enterprise Beans component.
                    </description>
                    <location chapter="15" section="5.2"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                    <id>Servlet:SPEC:199.5</id>
                    <description>The @WebServiceRef annotation provides a reference to a web service in a web component
                        in same way as a resource-ref element would in the deployment descriptor.
                    </description>
                    <location chapter="15" section="5.13"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                    <id>Servlet:SPEC:199.6</id>
                    <description>@DeclareRoles: This annotation is used to define the security roles that comprise the security model
                        of the application. This annotation is specified on a class, and if it is used to define
                        roles that could be tested (i.e., by calling isUserInRole) from within the methods of
                        the annotated class. Roles that are implicitly declared as a result of their use in a
                        @RolesAllowed need not be explicitly declared using the @DeclareRoles annotaion.
                        The @DeclareRoles annotation may only be defined in classes implementing the
                        jakarta.servlet.Servlet interface or a subclass thereof.
                    </description>
                    <location chapter="15" section="5.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                    <id>Servlet:SPEC:199.7</id>
                    <description>The @RunAs annotation is equivalent to the run-as element in the deployment descriptor.
                        The @RunAs annotation may only be defined in classes implementing the jakarta.servlet.Servlet interface
                        or a subclass thereof.
                    </description>
                    <location chapter="15" section="5.12"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                    <id>Servlet:SPEC:199.8</id>
                    <description>The @EJBs annotation allows more than one @EJB annotations to be declared on a single resource.</description>
                    <location chapter="15" section="5.3"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                    <id>Servlet:SPEC:199.9</id>
                    <description>This annotation(@PersistenceContext) specifies the container managed entity manager
                        for referenced persistence units.
                    </description>
                    <location chapter="15" section="5.5"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                    <id>Servlet:SPEC:199.10</id>
                    <description>The PersistenceContexts annotation allows more than one @PersistenceContext
                        to be declared on a resource.
                    </description>
                    <location chapter="15" section="5.6"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                    <id>Servlet:SPEC:199.11</id>
                    <description>The @PersistenceUnit annotation provides Enterprise Java Beans components
                        declared in a servlet a reference to a entity manager factory. The entity manager
                        factory is bound to a separate persistence.xml configuration file as described in
                        section 5.10 of the Jakarta Enterprise Beans 4.0 specification.
                    </description>
                    <location chapter="15" section="5.7"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                    <id>Servlet:SPEC:199.12</id>
                    <description>This annotation(@PersistenceUnits) allows for more than one @PersistentUnit annotations to be
                        declared on a resource.
                    </description>
                    <location chapter="15" section="5.8"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                    <id>Servlet:SPEC:199.13</id>
                    <description>The @PostConstruct annotation is declared on a method that does not take any
                        arguments, and must not throw any checked exceptions. The return value must be
                        void. The method MUST be called after the resources injections have been completed
                        and before any lifecycle methods on the component are called.
                    </description>
                    <location chapter="15" section="5.9"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                    <id>Servlet:SPEC:304</id>
                    <description>TThe @PostConstruct annnotation MUST be supported by all classes that support
                        dependency injection and called even if the class does not request any resources to be injected.
                        If the method throws an unchecked exception the class MUST not be put into service
                        and no method on that instance can be called.
                    </description>
                    <location chapter="15" section="5.9"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="platform" status="active" testable="true">
                    <id>Servlet:SPEC:199.14</id>
                    <description>The @PreDestroy annotation is declared on a method of a container managed
                        component. The method is called prior to component being removed by the
                        container. The method annotated with @PreDestroy must return void and must not throw a
                        checked exception. The method may be public, protected, package private or private.
                        The method must not be static however it may be final.
                    </description>
                    <location chapter="15" section="5.10"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:204</id>
            <description>sessions of a context must be resumable by requests into
                that context regardless of whether their associated context was being
                accessed directly or as the target of a request dispatch at the time
                the sessions were created.
            </description>
            <location chapter="A" section="7.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:205</id>
            <description>(The target servlet of the include method) cannot set
                headers or call any method that affects the headers of the response,
                with the exception of the HttpServletRequest.getSession() and
                HttpServletRequest.getSession(boolean) methods.
                Any attempt to set the headers must be ignored,
                and any call to HttpServletRequest.getSession() or
                HttpServletRequest.getSession(boolean) that would require adding a
                Cookie response header must throw an IllegalStateException
                if the response has been committed.
            </description>
            <location chapter="A" section="8.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:206</id>
            <description>clarify a way to map a filter to all servlet dispatches
                ... uses the special servlet name '*'.
            </description>
            <location chapter="A" section="8.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:207</id>
            <description>(Servlet 2.5) Previous versions of the servlet schema allows only a single url-pattern or servlet name per servlet mapping. For servlets mapped to multiple URLs this results in needless repetition of whole mapping clauses. The deployment descriptor servlet-mappingType was updated to...
            </description>
            <location chapter="A" section="8.3"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:208</id>
            <description>(Servlet 2.5)Previous versions of the servlet schema allows only a single url-pattern in a filter mapping. For filters mapped to multiple URLs this results in needless repetition of whole mapping clauses. The deployment descriptor schema the filter-mappingType was updated to... This change allows multiple patterns and servlet names to be defined in a single mapping</description>
            <location chapter="A" section="8.4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:209</id>
            <description>The http-method elements now need to be a token
                as described in HTTP 1.1 specification section 2.2.
            </description>
            <location chapter="A" section="8.5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:210</id>
            <description>If the location of the error handler is a servlet or a JSP page: [...]
                The response setStatus method is disabled and ignored if called.
            </description>
            <location chapter="A" section="8.8"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:211</id>
            <description>The API clarification better describes what happens
                when a client did not specify a session id.
                The API documentation in Section SRV.16.1.3,  HttpServletRequest
                was updated to specify when false is returned:
                Returns false if the client did not specify any session ID.
            </description>
            <location chapter="A" section="8.9"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:212</id>
            <description>Section SRV.5.5,  Closure of Response Object was updated
                to the following: "The amount of content specified in the
                setContentLength method of the response has been greater than zero
                and has been written to the response".
                the response's content length is set to 0 via
                response.setHeader("Content-Length", "0")
                and any subsequently setHeader() calls are ignored.
            </description>
            <location chapter="A" section="8.10"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>Servlet:SPEC:213</id>
            <description>The API in Section SRV.15.2.16,  ServletRequest
                was updated to described the behavior if the method is called
                after the getReader() was called. If the getReader() is called
                there will be no effect.
            </description>
            <location chapter="A" section="8.11"/>
        </assertion>
    </assertions>
</spec>
