<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE javadoc SYSTEM "https://raw.githubusercontent.com/eclipse-ee4j/jakartaee-tck/master/internal/docs/dtd/javadoc_assertions.dtd">
<!--

    Copyright (c) 2018, 2020 Oracle and/or its affiliates. All rights reserved.

    This program and the accompanying materials are made available under the
    terms of the Eclipse Public License v. 2.0, which is available at
    http://www.eclipse.org/legal/epl-2.0.

    This Source Code may also be made available under the following Secondary
    Licenses when the conditions for such availability set forth in the
    Eclipse Public License v. 2.0 are satisfied: GNU General Public License,
    version 2 with the GNU Classpath Exception, which is available at
    https://www.gnu.org/software/classpath/license.html.

    SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0

-->

<javadoc>
  <next-available-id>1453</next-available-id>
  <previous-id>1451</previous-id>
  <technology>JMS</technology>
  <id>JMS</id>
  <name>Java Message System</name>
  <version>2.0</version>
  <assertions>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1</id>
      <description>Constructs a TransactionRolledBackException with the specified reason and error code.</description>
      <package>jakarta.jms</package>
      <class-interface>TransactionRolledBackException</class-interface>
      <method name="TransactionRolledBackException" return-type="TransactionRolledBackException">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:2</id>
      <description>Constructs a TransactionRolledBackException with the specified reason. The error code defaults to null.</description>
      <package>jakarta.jms</package>
      <class-interface>TransactionRolledBackException</class-interface>
      <method name="TransactionRolledBackException" return-type="TransactionRolledBackException">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:3</id>
      <description>Constructs a TransactionInProgressException with the specified reason and error code.</description>
      <package>jakarta.jms</package>
      <class-interface>TransactionInProgressException</class-interface>
      <method name="TransactionInProgressException" return-type="TransactionInProgressException">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:4</id>
      <description>Constructs a TransactionInProgressException with the specified reason. The error code defaults to null.</description>
      <package>jakarta.jms</package>
      <class-interface>TransactionInProgressException</class-interface>
      <method name="TransactionInProgressException" return-type="TransactionInProgressException">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:5</id>
      <description>Constructor for the TopicRequestor class. This implementation assumes the session parameter to be non-transacted, with a delivery mode of either AUTO_ACKNOWLEDGE or DUPS_OK_ACKNOWLEDGE.</description>
      <package>jakarta.jms</package>
      <class-interface>TopicRequestor</class-interface>
      <method name="TopicRequestor" return-type="TopicRequestor">
        <parameters>
          <parameter>jakarta.jms.TopicSession</parameter>
          <parameter>jakarta.jms.Topic</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:6</id>
      <description>Sends a request and waits for a reply. The temporary topic is used for the JMSReplyTo destination; the first reply is returned, and any following replies are discarded.</description>
      <package>jakarta.jms</package>
      <class-interface>TopicRequestor</class-interface>
      <method name="request" return-type="jakarta.jms.Message">
        <parameters>
          <parameter>jakarta.jms.Message</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:7</id>
      <description>if the JMS provider fails to complete the request due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>TopicRequestor</class-interface>
      <method name="request" return-type="jakarta.jms.Message">
        <parameters>
          <parameter>jakarta.jms.Message</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:8</id>
      <description>Closes the TopicRequestor and its session. Since a provider may allocate some resources on behalf of a TopicRequestor outside the Java virtual machine, clients should close them when they are not needed. Relying on garbage collection to eventually reclaim these resources may not be timely enough. Note that this method closes the TopicSession object passed to the TopicRequestor constructor.</description>
      <package>jakarta.jms</package>
      <class-interface>TopicRequestor</class-interface>
      <method name="close" return-type="void"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:9</id>
      <description>if the JMS provider fails to close the TopicRequestor due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>TopicRequestor</class-interface>
      <method name="close" return-type="void">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:10</id>
      <description>Constructs a ResourceAllocationException with the specified reason and error code.</description>
      <package>jakarta.jms</package>
      <class-interface>ResourceAllocationException</class-interface>
      <method name="ResourceAllocationException" return-type="ResourceAllocationException">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:11</id>
      <description>Constructs a ResourceAllocationException with the specified reason. The error code defaults to null.</description>
      <package>jakarta.jms</package>
      <class-interface>ResourceAllocationException</class-interface>
      <method name="ResourceAllocationException" return-type="ResourceAllocationException">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:12</id>
      <description>Constructor for the QueueRequestor class. This implementation assumes the session parameter to be non-transacted, with a delivery mode of either AUTO_ACKNOWLEDGE or DUPS_OK_ACKNOWLEDGE.</description>
      <package>jakarta.jms</package>
      <class-interface>QueueRequestor</class-interface>
      <method name="QueueRequestor" return-type="QueueRequestor">
        <parameters>
          <parameter>jakarta.jms.QueueSession</parameter>
          <parameter>jakarta.jms.Queue</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:13</id>
      <description>Sends a request and waits for a reply. The temporary queue is used for the JMSReplyTo destination, and only one reply per request is expected.</description>
      <package>jakarta.jms</package>
      <class-interface>QueueRequestor</class-interface>
      <method name="request" return-type="jakarta.jms.Message">
        <parameters>
          <parameter>jakarta.jms.Message</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:14</id>
      <description>if the JMS provider fails to complete the request due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>QueueRequestor</class-interface>
      <method name="request" return-type="jakarta.jms.Message">
        <parameters>
          <parameter>jakarta.jms.Message</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:15</id>
      <description>Closes the QueueRequestor and its session. Since a provider may allocate some resources on behalf of a QueueRequestor outside the Java virtual machine, clients should close them when they are not needed. Relying on garbage collection to eventually reclaim these resources may not be timely enough. Note that this method closes the QueueSession object passed to the QueueRequestor constructor.</description>
      <package>jakarta.jms</package>
      <class-interface>QueueRequestor</class-interface>
      <method name="close" return-type="void"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:16</id>
      <description>if the JMS provider fails to close the QueueRequestor due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>QueueRequestor</class-interface>
      <method name="close" return-type="void">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:17</id>
      <description>Constructs a MessageNotWriteableException with the specified reason and error code.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageNotWriteableException</class-interface>
      <method name="MessageNotWriteableException" return-type="MessageNotWriteableException">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:18</id>
      <description>Constructs a MessageNotWriteableException with the specified reason. The error code defaults to null.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageNotWriteableException</class-interface>
      <method name="MessageNotWriteableException" return-type="MessageNotWriteableException">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:19</id>
      <description>Constructs a MessageNotReadableException with the specified reason and error code.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageNotReadableException</class-interface>
      <method name="MessageNotReadableException" return-type="MessageNotReadableException">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:20</id>
      <description>Constructs a MessageNotReadableException with the specified reason. The error code defaults to null.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageNotReadableException</class-interface>
      <method name="MessageNotReadableException" return-type="MessageNotReadableException">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:21</id>
      <description>Constructs a MessageFormatException with the specified reason and error code.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageFormatException</class-interface>
      <method name="MessageFormatException" return-type="MessageFormatException">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:22</id>
      <description>Constructs a MessageFormatException with the specified reason. The error code defaults to null.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageFormatException</class-interface>
      <method name="MessageFormatException" return-type="MessageFormatException">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:23</id>
      <description>Constructs a MessageEOFException with the specified reason and error code.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageEOFException</class-interface>
      <method name="MessageEOFException" return-type="MessageEOFException">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:24</id>
      <description>Constructs a MessageEOFException with the specified reason. The error code defaults to null.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageEOFException</class-interface>
      <method name="MessageEOFException" return-type="MessageEOFException">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:25</id>
      <description>Constructs a JMSSecurityException with the specified reason and error code.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSSecurityException</class-interface>
      <method name="JMSSecurityException" return-type="JMSSecurityException">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:26</id>
      <description>Constructs a JMSSecurityException with the specified reason. The error code defaults to null.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSSecurityException</class-interface>
      <method name="JMSSecurityException" return-type="JMSSecurityException">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:27</id>
      <description>Constructs a JMSException with the specified reason and error code.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSException</class-interface>
      <method name="JMSException" return-type="JMSException">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:28</id>
      <description>Constructs a JMSException with the specified reason and with the error code defaulting to null.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSException</class-interface>
      <method name="JMSException" return-type="JMSException">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:29</id>
      <description>Gets the vendor-specific error code.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSException</class-interface>
      <method name="getErrorCode" return-type="java.lang.String"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:30</id>
      <description>Gets the exception linked to this one.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSException</class-interface>
      <method name="getLinkedException" return-type="java.lang.Exception"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:31</id>
      <description>Adds a linked Exception.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSException</class-interface>
      <method name="setLinkedException" return-type="void">
        <parameters>
          <parameter>java.lang.Exception</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:32</id>
      <description>Constructs an InvalidSelectorException with the specified reason and error code.</description>
      <package>jakarta.jms</package>
      <class-interface>InvalidSelectorException</class-interface>
      <method name="InvalidSelectorException" return-type="InvalidSelectorException">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:33</id>
      <description>Constructs an InvalidSelectorException with the specified reason. The error code defaults to null.</description>
      <package>jakarta.jms</package>
      <class-interface>InvalidSelectorException</class-interface>
      <method name="InvalidSelectorException" return-type="InvalidSelectorException">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:34</id>
      <description>Constructs an InvalidDestinationException with the specified reason and error code.</description>
      <package>jakarta.jms</package>
      <class-interface>InvalidDestinationException</class-interface>
      <method name="InvalidDestinationException" return-type="InvalidDestinationException">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:35</id>
      <description>Constructs an InvalidDestinationException with the specified reason. The error code defaults to null.</description>
      <package>jakarta.jms</package>
      <class-interface>InvalidDestinationException</class-interface>
      <method name="InvalidDestinationException" return-type="InvalidDestinationException">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:36</id>
      <description>Constructs an InvalidClientIDException with the specified reason and error code.</description>
      <package>jakarta.jms</package>
      <class-interface>InvalidClientIDException</class-interface>
      <method name="InvalidClientIDException" return-type="InvalidClientIDException">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:37</id>
      <description>Constructs an InvalidClientIDException with the specified reason. The error code defaults to null.</description>
      <package>jakarta.jms</package>
      <class-interface>InvalidClientIDException</class-interface>
      <method name="InvalidClientIDException" return-type="InvalidClientIDException">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:38</id>
      <description>Constructs an IllegalStateException with the specified reason and error code.</description>
      <package>jakarta.jms</package>
      <class-interface>IllegalStateException</class-interface>
      <method name="IllegalStateException" return-type="IllegalStateException">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:39</id>
      <description>Constructs an IllegalStateException with the specified reason. The error code defaults to null.</description>
      <package>jakarta.jms</package>
      <class-interface>IllegalStateException</class-interface>
      <method name="IllegalStateException" return-type="IllegalStateException">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:40</id>
      <description>Gets the topic session associated with this XATopicSession.</description>
      <package>jakarta.jms</package>
      <class-interface>XATopicSession</class-interface>
      <method name="getTopicSession" return-type="jakarta.jms.TopicSession"/>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:41</id>
      <description>if an internal error occurs.</description>
      <package>jakarta.jms</package>
      <class-interface>XATopicSession</class-interface>
      <method name="getTopicSession" return-type="jakarta.jms.TopicSession">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:42</id>
      <description>Creates an XA topic connection with the default user identity. The connection is created in stopped mode. No messages will be delivered until the Connection.start method is explicitly called.</description>
      <package>jakarta.jms</package>
      <class-interface>XATopicConnectionFactory</class-interface>
      <method name="createXATopicConnection" return-type="jakarta.jms.XATopicConnection"/>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:43</id>
      <description>if the JMS provider fails to create an XA topic connection due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>XATopicConnectionFactory</class-interface>
      <method name="createXATopicConnection" return-type="jakarta.jms.XATopicConnection">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:44</id>
      <description>Creates an XA topic connection with the specified user identity. The connection is created in stopped mode. No messages will be delivered until the Connection.start method is explicitly called.</description>
      <package>jakarta.jms</package>
      <class-interface>XATopicConnectionFactory</class-interface>
      <method name="createXATopicConnection" return-type="jakarta.jms.XATopicConnection">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:45</id>
      <description>if the JMS provider fails to create an XA topic connection due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>XATopicConnectionFactory</class-interface>
      <method name="createXATopicConnection" return-type="jakarta.jms.XATopicConnection">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:46</id>
      <description>Creates an XATopicSession object.</description>
      <package>jakarta.jms</package>
      <class-interface>XATopicConnection</class-interface>
      <method name="createXATopicSession" return-type="jakarta.jms.XATopicSession"/>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:47</id>
      <description>if the XATopicConnection object fails to create an XATopicSession due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>XATopicConnection</class-interface>
      <method name="createXATopicSession" return-type="jakarta.jms.XATopicSession">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:48</id>
      <description>Creates a TopicSession object.</description>
      <package>jakarta.jms</package>
      <class-interface>XATopicConnection</class-interface>
      <method name="createTopicSession" return-type="jakarta.jms.TopicSession">
        <parameters>
          <parameter>boolean</parameter>
          <parameter>int</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:49</id>
      <description>if the XATopicConnection object fails to create a TopicSession due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>XATopicConnection</class-interface>
      <method name="createTopicSession" return-type="jakarta.jms.TopicSession">
        <parameters>
          <parameter>boolean</parameter>
          <parameter>int</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:50</id>
      <description>Gets the session associated with this XASession.</description>
      <package>jakarta.jms</package>
      <class-interface>XASession</class-interface>
      <method name="getSession" return-type="jakarta.jms.Session"/>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:51</id>
      <description>if an internal error occurs.</description>
      <package>jakarta.jms</package>
      <class-interface>XASession</class-interface>
      <method name="getSession" return-type="jakarta.jms.Session">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:52</id>
      <description>Returns an XA resource to the caller.</description>
      <package>jakarta.jms</package>
      <class-interface>XASession</class-interface>
      <method name="getXAResource" return-type="javax.transaction.xa.XAResource"/>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:53</id>
      <description>Indicates whether the session is in transacted mode.</description>
      <package>jakarta.jms</package>
      <class-interface>XASession</class-interface>
      <method name="getTransacted" return-type="boolean"/>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:54</id>
      <description>if the JMS provider fails to return the transaction mode due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>XASession</class-interface>
      <method name="getTransacted" return-type="boolean">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:55</id>
      <description>Throws a TransactionInProgressException, since it should not be called for an XASession object.</description>
      <package>jakarta.jms</package>
      <class-interface>XASession</class-interface>
      <method name="commit" return-type="void"/>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:57</id>
      <description>Throws a TransactionInProgressException, since it should not be called for an XASession object.</description>
      <package>jakarta.jms</package>
      <class-interface>XASession</class-interface>
      <method name="rollback" return-type="void"/>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:59</id>
      <description>Gets the queue session associated with this XAQueueSession.</description>
      <package>jakarta.jms</package>
      <class-interface>XAQueueSession</class-interface>
      <method name="getQueueSession" return-type="jakarta.jms.QueueSession"/>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:60</id>
      <description>if an internal error occurs.</description>
      <package>jakarta.jms</package>
      <class-interface>XAQueueSession</class-interface>
      <method name="getQueueSession" return-type="jakarta.jms.QueueSession">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:61</id>
      <description>Creates an XA queue connection with the default user identity. The connection is created in stopped mode. No messages will be delivered until the Connection.start method is explicitly called.</description>
      <package>jakarta.jms</package>
      <class-interface>XAQueueConnectionFactory</class-interface>
      <method name="createXAQueueConnection" return-type="jakarta.jms.XAQueueConnection"/>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:62</id>
      <description>if the JMS provider fails to create an XA queue connection due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>XAQueueConnectionFactory</class-interface>
      <method name="createXAQueueConnection" return-type="jakarta.jms.XAQueueConnection">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:63</id>
      <description>Creates an XA queue connection with the specified user identity. The connection is created in stopped mode. No messages will be delivered until the Connection.start method is explicitly called.</description>
      <package>jakarta.jms</package>
      <class-interface>XAQueueConnectionFactory</class-interface>
      <method name="createXAQueueConnection" return-type="jakarta.jms.XAQueueConnection">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:64</id>
      <description>if the JMS provider fails to create an XA queue connection due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>XAQueueConnectionFactory</class-interface>
      <method name="createXAQueueConnection" return-type="jakarta.jms.XAQueueConnection">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:65</id>
      <description>Creates an XAQueueSession object.</description>
      <package>jakarta.jms</package>
      <class-interface>XAQueueConnection</class-interface>
      <method name="createXAQueueSession" return-type="jakarta.jms.XAQueueSession"/>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:66</id>
      <description>if the XAQueueConnection object fails to create an XAQueueSession due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>XAQueueConnection</class-interface>
      <method name="createXAQueueSession" return-type="jakarta.jms.XAQueueSession">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:67</id>
      <description>Creates a QueueSession object.</description>
      <package>jakarta.jms</package>
      <class-interface>XAQueueConnection</class-interface>
      <method name="createQueueSession" return-type="jakarta.jms.QueueSession">
        <parameters>
          <parameter>boolean</parameter>
          <parameter>int</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:68</id>
      <description>if the XAQueueConnection object fails to create a QueueSession due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>XAQueueConnection</class-interface>
      <method name="createQueueSession" return-type="jakarta.jms.QueueSession">
        <parameters>
          <parameter>boolean</parameter>
          <parameter>int</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:69</id>
      <description>Creates an XAConnection with the default user identity. The connection is created in stopped mode. No messages will be delivered until the Connection.start method is explicitly called.</description>
      <package>jakarta.jms</package>
      <class-interface>XAConnectionFactory</class-interface>
      <method name="createXAConnection" return-type="jakarta.jms.XAConnection"/>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:70</id>
      <description>if the JMS provider fails to create an XA connection due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>XAConnectionFactory</class-interface>
      <method name="createXAConnection" return-type="jakarta.jms.XAConnection">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:71</id>
      <description>Creates an XAConnection with the specified user identity. The connection is created in stopped mode. No messages will be delivered until the Connection.start method is explicitly called.</description>
      <package>jakarta.jms</package>
      <class-interface>XAConnectionFactory</class-interface>
      <method name="createXAConnection" return-type="jakarta.jms.XAConnection">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:72</id>
      <description>if the JMS provider fails to create an XA connection due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>XAConnectionFactory</class-interface>
      <method name="createXAConnection" return-type="jakarta.jms.XAConnection">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:73</id>
      <description>Creates an XASession object.</description>
      <package>jakarta.jms</package>
      <class-interface>XAConnection</class-interface>
      <method name="createXASession" return-type="jakarta.jms.XASession"/>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:74</id>
      <description>if the XAConnection object fails to create an XASession due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>XAConnection</class-interface>
      <method name="createXASession" return-type="jakarta.jms.XASession">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:75</id>
      <description>Creates an Session object.</description>
      <package>jakarta.jms</package>
      <class-interface>XAConnection</class-interface>
      <method name="createSession" return-type="jakarta.jms.Session">
        <parameters>
          <parameter>boolean</parameter>
          <parameter>int</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:76</id>
      <description>if the XAConnection object fails to create a Session due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>XAConnection</class-interface>
      <method name="createSession" return-type="jakarta.jms.Session">
        <parameters>
          <parameter>boolean</parameter>
          <parameter>int</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:77</id>
      <description>Gets the Topic associated with this subscriber.</description>
      <package>jakarta.jms</package>
      <class-interface>TopicSubscriber</class-interface>
      <method name="getTopic" return-type="jakarta.jms.Topic"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:78</id>
      <description>if the JMS provider fails to get the topic for this topic subscriber due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>TopicSubscriber</class-interface>
      <method name="getTopic" return-type="jakarta.jms.Topic">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:79</id>
      <description>Gets the NoLocal attribute for this subscriber. The default value for this attribute is false.</description>
      <package>jakarta.jms</package>
      <class-interface>TopicSubscriber</class-interface>
      <method name="getNoLocal" return-type="boolean"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:80</id>
      <description>if the JMS provider fails to get the NoLocal attribute for this topic subscriber due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>TopicSubscriber</class-interface>
      <method name="getNoLocal" return-type="boolean">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:81</id>
      <description>Creates a topic identity given a Topic name. This facility is provided for the rare cases where clients need to dynamically manipulate topic identity. This allows the creation of a topic identity with a provider-specific name. Clients that depend on this ability are not portable. Note that this method is not for creating the physical topic. The physical creation of topics is an administrative task and is not to be initiated by the JMS API. The one exception is the creation of temporary topics, which is accomplished with the createTemporaryTopic method.</description>
      <package>jakarta.jms</package>
      <class-interface>TopicSession</class-interface>
      <method name="createTopic" return-type="jakarta.jms.Topic">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:82</id>
      <description>if the session fails to create a topic due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>TopicSession</class-interface>
      <method name="createTopic" return-type="jakarta.jms.Topic">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:83</id>
      <description>Creates a nondurable subscriber to the specified topic. A client uses a TopicSubscriber object to receive messages that have been published to a topic. Regular TopicSubscriber objects are not durable. They receive only messages that are published while they are active. In some cases, a connection may both publish and subscribe to a topic. The subscriber NoLocal attribute allows a subscriber to inhibit the delivery of messages published by its own connection. The default value for this attribute is false.</description>
      <package>jakarta.jms</package>
      <class-interface>TopicSession</class-interface>
      <method name="createSubscriber" return-type="jakarta.jms.TopicSubscriber">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:84</id>
      <description>if the session fails to create a subscriber due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>TopicSession</class-interface>
      <method name="createSubscriber" return-type="jakarta.jms.TopicSubscriber">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:85</id>
      <description>Creates a nondurable subscriber to the specified topic, using a message selector or specifying whether messages published by its own connection should be delivered to it. A client uses a TopicSubscriber object to receive messages that have been published to a topic. Regular TopicSubscriber objects are not durable. They receive only messages that are published while they are active. Messages filtered out by a subscriber's message selector will never be delivered to the subscriber. From the subscriber's perspective, they do not exist. In some cases, a connection may both publish and subscribe to a topic. The subscriber NoLocal attribute allows a subscriber to inhibit the delivery of messages published by its own connection. The default value for this attribute is false.</description>
      <package>jakarta.jms</package>
      <class-interface>TopicSession</class-interface>
      <method name="createSubscriber" return-type="jakarta.jms.TopicSubscriber">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>boolean</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:86</id>
      <description>if the session fails to create a subscriber due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>TopicSession</class-interface>
      <method name="createSubscriber" return-type="jakarta.jms.TopicSubscriber">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>boolean</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:87</id>
      <description>Creates an unshared durable subscription on the specified topic (if one does not already exist) and creates a consumer on that durable subscription. This method creates the durable subscription without a message selector and with a noLocal value of false. A durable subscription is used by an application which needs to receive all the messages published on a topic, including the ones published when there is no active consumer associated with it. The JMS provider retains a record of this durable subscription and ensures that all messages from the topic's publishers are retained until they are delivered to, and acknowledged by, a consumer on this durable subscription or until they have expired. A durable subscription will continue to accumulate messages until it is deleted using the unsubscribe method. This method may only be used with non-shared durable subscriptions. Any durable subscription created using this method will be non-shared. This means that only one active (i.e. not closed) consumer on the subscription may exist at a time. The term "consumer" here means a TopicSubscriber, MessageConsumer or JMSConsumer object in any client. An unshared durable subscription is identified by a name specified by the client and by the client identifier, which must be set. An application which subsequently wishes to create a consumer on that non-shared durable subscription must use the same client identifier. If an unshared durable subscription already exists with the same name and client identifier and the same topic and message selector, and there is no consumer already active (i.e. not closed) on the durable subscription, and no consumed messages from that subscription are still part of a pending transaction or are not yet acknowledged in the session, then this method creates a TopicSubscriber on the existing durable subscription. If an unshared durable subscription already exists with the same name and client identifier, and there is a consumer already active (i.e. not closed) on the durable subscription, or consumed messages from that subscription are still part of a pending transaction or are not yet acknowledged in the session, then a JMSException will be thrown. If an unshared durable subscription already exists with the same name and client identifier but a different topic, message selector or noLocal value has been specified, and there is no consumer already active (i.e. not closed) on the durable subscription, and no consumed messages from that subscription are still part of a pending transaction or are not yet acknowledged in the session, then the durable subscription will be deleted and a new one created. A shared durable subscription and an unshared durable subscription may not have the same name and client identifier. If a shared durable subscription already exists with the same name and client identifier then a JMSException is thrown. There is no restriction on durable subscriptions and shared non-durable subscriptions having the same name and clientId. Such subscriptions would be completely separate. This method is identical to the corresponding createDurableConsumer method except that it returns a TopicSubscriber rather than a MessageConsumer to represent the consumer.</description>
      <package>jakarta.jms</package>
      <class-interface>TopicSession</class-interface>
      <method name="createDurableSubscriber" return-type="jakarta.jms.TopicSubscriber">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:88</id>
      <description>if the session fails to create the non-shared durable subscription and TopicSubscriber due to some internal error if the client identifier is unset if an unshared durable subscription already exists with the same name and client identifier, and there is a consumer already active if a shared durable subscription already exists with the same name and client identifier</description>
      <package>jakarta.jms</package>
      <class-interface>TopicSession</class-interface>
      <method name="createDurableSubscriber" return-type="jakarta.jms.TopicSubscriber">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:89</id>
      <description>Creates an unshared durable subscription on the specified topic (if one does not already exist), specifying a message selector and the noLocal parameter, and creates a consumer on that durable subscription. A durable subscription is used by an application which needs to receive all the messages published on a topic, including the ones published when there is no active consumer associated with it. The JMS provider retains a record of this durable subscription and ensures that all messages from the topic's publishers are retained until they are delivered to, and acknowledged by, a consumer on this durable subscription or until they have expired. A durable subscription will continue to accumulate messages until it is deleted using the unsubscribe method. This method may only be used with non-shared durable subscriptions. Any durable subscription created using this method will be non-shared. This means that only one active (i.e. not closed) consumer on the subscription may exist at a time. The term "consumer" here means a TopicSubscriber, MessageConsumer or JMSConsumer object in any client. An unshared durable subscription is identified by a name specified by the client and by the client identifier, which must be set. An application which subsequently wishes to create a consumer on that non-shared durable subscription must use the same client identifier. If an unshared durable subscription already exists with the same name and client identifier and the same topic and message selector, and there is no consumer already active (i.e. not closed) on the durable subscription, and no consumed messages from that subscription are still part of a pending transaction or are not yet acknowledged in the session, then this method creates a TopicSubscriber on the existing durable subscription. If an unshared durable subscription already exists with the same name and client identifier, and there is a consumer already active (i.e. not closed) on the durable subscription, or consumed messages from that subscription are still part of a pending transaction or are not yet acknowledged in the session, then a JMSException will be thrown. If an unshared durable subscription already exists with the same name and client identifier but a different topic, message selector or noLocal value has been specified, and there is no consumer already active (i.e. not closed) on the durable subscription, and no consumed messages from that subscription are still part of a pending transaction or are not yet acknowledged in the session, then the durable subscription will be deleted and a new one created. A shared durable subscription and an unshared durable subscription may not have the same name and client identifier. If a shared durable subscription already exists with the same name and client identifier then a JMSException is thrown. If noLocal is set to true then any messages published to the topic using this session's connection, or any other connection with the same client identifier, will not be added to the durable subscription. There is no restriction on durable subscriptions and shared non-durable subscriptions having the same name and clientId. Such subscriptions would be completely separate. This method is identical to the corresponding createDurableConsumer method except that it returns a TopicSubscriber rather than a MessageConsumer to represent the consumer.</description>
      <package>jakarta.jms</package>
      <class-interface>TopicSession</class-interface>
      <method name="createDurableSubscriber" return-type="jakarta.jms.TopicSubscriber">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>boolean</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:90</id>
      <description>if the session fails to create the non-shared durable subscription and TopicSubscriber due to some internal error if the client identifier is unset if an unshared durable subscription already exists with the same name and client identifier, and there is a consumer already active if a shared durable subscription already exists with the same name and client identifier</description>
      <package>jakarta.jms</package>
      <class-interface>TopicSession</class-interface>
      <method name="createDurableSubscriber" return-type="jakarta.jms.TopicSubscriber">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>boolean</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:91</id>
      <description>Creates a publisher for the specified topic. A client uses a TopicPublisher object to publish messages on a topic. Each time a client creates a TopicPublisher on a topic, it defines a new sequence of messages that have no ordering relationship with the messages it has previously sent.</description>
      <package>jakarta.jms</package>
      <class-interface>TopicSession</class-interface>
      <method name="createPublisher" return-type="jakarta.jms.TopicPublisher">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:92</id>
      <description>if the session fails to create a publisher due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>TopicSession</class-interface>
      <method name="createPublisher" return-type="jakarta.jms.TopicPublisher">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:93</id>
      <description>Creates a TemporaryTopic object. Its lifetime will be that of the TopicConnection unless it is deleted earlier.</description>
      <package>jakarta.jms</package>
      <class-interface>TopicSession</class-interface>
      <method name="createTemporaryTopic" return-type="jakarta.jms.TemporaryTopic"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:94</id>
      <description>if the session fails to create a temporary topic due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>TopicSession</class-interface>
      <method name="createTemporaryTopic" return-type="jakarta.jms.TemporaryTopic">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:95</id>
      <description>Unsubscribes a durable subscription that has been created by a client. This method deletes the state being maintained on behalf of the subscriber by its provider. It is erroneous for a client to delete a durable subscription while there is an active TopicSubscriber for the subscription, or while a consumed message is part of a pending transaction or has not been acknowledged in the session.</description>
      <package>jakarta.jms</package>
      <class-interface>TopicSession</class-interface>
      <method name="unsubscribe" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:96</id>
      <description>if the session fails to unsubscribe to the durable subscription due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>TopicSession</class-interface>
      <method name="unsubscribe" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:97</id>
      <description>Gets the topic associated with this TopicPublisher.</description>
      <package>jakarta.jms</package>
      <class-interface>TopicPublisher</class-interface>
      <method name="getTopic" return-type="jakarta.jms.Topic"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:98</id>
      <description>if the JMS provider fails to get the topic for this TopicPublisher due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>TopicPublisher</class-interface>
      <method name="getTopic" return-type="jakarta.jms.Topic">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:99</id>
      <description>Publishes a message to the topic. Uses the TopicPublisher's default delivery mode, priority, and time to live.</description>
      <package>jakarta.jms</package>
      <class-interface>TopicPublisher</class-interface>
      <method name="publish" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Message</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:100</id>
      <description>if the JMS provider fails to publish the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>TopicPublisher</class-interface>
      <method name="publish" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Message</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:101</id>
      <description>Publishes a message to the topic, specifying delivery mode, priority, and time to live.</description>
      <package>jakarta.jms</package>
      <class-interface>TopicPublisher</class-interface>
      <method name="publish" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Message</parameter>
          <parameter>int</parameter>
          <parameter>int</parameter>
          <parameter>long</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:102</id>
      <description>if the JMS provider fails to publish the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>TopicPublisher</class-interface>
      <method name="publish" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Message</parameter>
          <parameter>int</parameter>
          <parameter>int</parameter>
          <parameter>long</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:103</id>
      <description>Publishes a message to a topic for an unidentified message producer. Uses the TopicPublisher's default delivery mode, priority, and time to live. Typically, a message producer is assigned a topic at creation time; however, the JMS API also supports unidentified message producers, which require that the topic be supplied every time a message is published.</description>
      <package>jakarta.jms</package>
      <class-interface>TopicPublisher</class-interface>
      <method name="publish" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>jakarta.jms.Message</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:104</id>
      <description>if the JMS provider fails to publish the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>TopicPublisher</class-interface>
      <method name="publish" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>jakarta.jms.Message</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:105</id>
      <description>Publishes a message to a topic for an unidentified message producer, specifying delivery mode, priority and time to live. Typically, a message producer is assigned a topic at creation time; however, the JMS API also supports unidentified message producers, which require that the topic be supplied every time a message is published.</description>
      <package>jakarta.jms</package>
      <class-interface>TopicPublisher</class-interface>
      <method name="publish" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>jakarta.jms.Message</parameter>
          <parameter>int</parameter>
          <parameter>int</parameter>
          <parameter>long</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:106</id>
      <description>if the JMS provider fails to publish the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>TopicPublisher</class-interface>
      <method name="publish" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>jakarta.jms.Message</parameter>
          <parameter>int</parameter>
          <parameter>int</parameter>
          <parameter>long</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:107</id>
      <description>Creates a topic connection with the default user identity. The connection is created in stopped mode. No messages will be delivered until the Connection.start method is explicitly called.</description>
      <package>jakarta.jms</package>
      <class-interface>TopicConnectionFactory</class-interface>
      <method name="createTopicConnection" return-type="jakarta.jms.TopicConnection"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:108</id>
      <description>if the JMS provider fails to create a topic connection due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>TopicConnectionFactory</class-interface>
      <method name="createTopicConnection" return-type="jakarta.jms.TopicConnection">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:109</id>
      <description>Creates a topic connection with the specified user identity. The connection is created in stopped mode. No messages will be delivered until the Connection.start method is explicitly called.</description>
      <package>jakarta.jms</package>
      <class-interface>TopicConnectionFactory</class-interface>
      <method name="createTopicConnection" return-type="jakarta.jms.TopicConnection">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:110</id>
      <description>if the JMS provider fails to create a topic connection due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>TopicConnectionFactory</class-interface>
      <method name="createTopicConnection" return-type="jakarta.jms.TopicConnection">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:111</id>
      <description>Creates a TopicSession object.</description>
      <package>jakarta.jms</package>
      <class-interface>TopicConnection</class-interface>
      <method name="createTopicSession" return-type="jakarta.jms.TopicSession">
        <parameters>
          <parameter>boolean</parameter>
          <parameter>int</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:112</id>
      <description>if the TopicConnection object fails to create a session due to some internal error or lack of support for the specific transaction and acknowledgement mode.</description>
      <package>jakarta.jms</package>
      <class-interface>TopicConnection</class-interface>
      <method name="createTopicSession" return-type="jakarta.jms.TopicSession">
        <parameters>
          <parameter>boolean</parameter>
          <parameter>int</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:113</id>
      <description>Creates a connection consumer for this connection (optional operation). This is an expert facility not used by regular JMS clients.</description>
      <package>jakarta.jms</package>
      <class-interface>TopicConnection</class-interface>
      <method name="createConnectionConsumer" return-type="jakarta.jms.ConnectionConsumer">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>jakarta.jms.ServerSessionPool</parameter>
          <parameter>int</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:114</id>
      <description>if the TopicConnection object fails to create a connection consumer due to some internal error or invalid arguments for sessionPool and messageSelector.</description>
      <package>jakarta.jms</package>
      <class-interface>TopicConnection</class-interface>
      <method name="createConnectionConsumer" return-type="jakarta.jms.ConnectionConsumer">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>jakarta.jms.ServerSessionPool</parameter>
          <parameter>int</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:115</id>
      <description>Create a durable connection consumer for this connection (optional operation). This is an expert facility not used by regular JMS clients.</description>
      <package>jakarta.jms</package>
      <class-interface>TopicConnection</class-interface>
      <method name="createDurableConnectionConsumer" return-type="jakarta.jms.ConnectionConsumer">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>jakarta.jms.ServerSessionPool</parameter>
          <parameter>int</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:116</id>
      <description>if the TopicConnection object fails to create a connection consumer due to some internal error or invalid arguments for sessionPool and messageSelector.</description>
      <package>jakarta.jms</package>
      <class-interface>TopicConnection</class-interface>
      <method name="createDurableConnectionConsumer" return-type="jakarta.jms.ConnectionConsumer">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>jakarta.jms.ServerSessionPool</parameter>
          <parameter>int</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:117</id>
      <description>Gets the name of this topic. Clients that depend upon the name are not portable.</description>
      <package>jakarta.jms</package>
      <class-interface>Topic</class-interface>
      <method name="getTopicName" return-type="java.lang.String"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:118</id>
      <description>if the JMS provider implementation of Topic fails to return the topic name due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Topic</class-interface>
      <method name="getTopicName" return-type="java.lang.String">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:119</id>
      <description>Returns a string representation of this object.</description>
      <package>jakarta.jms</package>
      <class-interface>Topic</class-interface>
      <method name="toString" return-type="java.lang.String"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:120</id>
      <description>Sets the string containing this message's data.</description>
      <package>jakarta.jms</package>
      <class-interface>TextMessage</class-interface>
      <method name="setText" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:121</id>
      <description>if the JMS provider fails to set the text due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>TextMessage</class-interface>
      <method name="setText" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:122</id>
      <description>Gets the string containing this message's data. The default value is null.</description>
      <package>jakarta.jms</package>
      <class-interface>TextMessage</class-interface>
      <method name="getText" return-type="java.lang.String"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:123</id>
      <description>if the JMS provider fails to get the text due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>TextMessage</class-interface>
      <method name="getText" return-type="java.lang.String">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:124</id>
      <description>Deletes this temporary topic. If there are existing subscribers still using it, a JMSException will be thrown.</description>
      <package>jakarta.jms</package>
      <class-interface>TemporaryTopic</class-interface>
      <method name="delete" return-type="void"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:125</id>
      <description>if the JMS provider fails to delete the temporary topic due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>TemporaryTopic</class-interface>
      <method name="delete" return-type="void">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:126</id>
      <description>Deletes this temporary queue. If there are existing receivers still using it, a JMSException will be thrown.</description>
      <package>jakarta.jms</package>
      <class-interface>TemporaryQueue</class-interface>
      <method name="delete" return-type="void"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:127</id>
      <description>if the JMS provider fails to delete the temporary queue due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>TemporaryQueue</class-interface>
      <method name="delete" return-type="void">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:128</id>
      <description>Reads a boolean from the stream message.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="readBoolean" return-type="boolean"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:129</id>
      <description>if the JMS provider fails to read the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="readBoolean" return-type="boolean">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:130</id>
      <description>Reads a byte value from the stream message.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="readByte" return-type="byte"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:131</id>
      <description>if the JMS provider fails to read the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="readByte" return-type="byte">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:132</id>
      <description>Reads a 16-bit integer from the stream message.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="readShort" return-type="short"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:133</id>
      <description>if the JMS provider fails to read the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="readShort" return-type="short">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:134</id>
      <description>Reads a Unicode character value from the stream message.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="readChar" return-type="char"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:135</id>
      <description>if the JMS provider fails to read the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="readChar" return-type="char">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:136</id>
      <description>Reads a 32-bit integer from the stream message.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="readInt" return-type="int"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:137</id>
      <description>if the JMS provider fails to read the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="readInt" return-type="int">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:138</id>
      <description>Reads a 64-bit integer from the stream message.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="readLong" return-type="long"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:139</id>
      <description>if the JMS provider fails to read the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="readLong" return-type="long">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:140</id>
      <description>Reads a float from the stream message.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="readFloat" return-type="float"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:141</id>
      <description>if the JMS provider fails to read the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="readFloat" return-type="float">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:142</id>
      <description>Reads a double from the stream message.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="readDouble" return-type="double"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:143</id>
      <description>if the JMS provider fails to read the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="readDouble" return-type="double">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:144</id>
      <description>Reads a String from the stream message.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="readString" return-type="java.lang.String"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:145</id>
      <description>if the JMS provider fails to read the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="readString" return-type="java.lang.String">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:146</id>
      <description>Reads a byte array field from the stream message into the specified byte[] object (the read buffer). To read the field value, readBytes should be successively called until it returns a value less than the length of the read buffer. The value of the bytes in the buffer following the last byte read is undefined. If readBytes returns a value equal to the length of the buffer, a subsequent readBytes call must be made. If there are no more bytes to be read, this call returns -1. If the byte array field value is null, readBytes returns -1. If the byte array field value is empty, readBytes returns 0. Once the first readBytes call on a byte[] field value has been made, the full value of the field must be read before it is valid to read the next field. An attempt to read the next field before that has been done will throw a MessageFormatException. To read the byte field value into a new byte[] object, use the readObject method.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="readBytes" return-type="int">
        <parameters>
          <parameter>byte[]</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:147</id>
      <description>if the JMS provider fails to read the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="readBytes" return-type="int">
        <parameters>
          <parameter>byte[]</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:148</id>
      <description>Reads an object from the stream message. This method can be used to return, in objectified format, an object in the Java programming language ("Java object") that has been written to the stream with the equivalent writeObject method call, or its equivalent primitive writetype method. Note that byte values are returned as byte[], not Byte[]. An attempt to call readObject to read a byte field value into a new byte[] object before the full value of the byte field has been read will throw a MessageFormatException.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="readObject" return-type="java.lang.Object"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:149</id>
      <description>if the JMS provider fails to read the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="readObject" return-type="java.lang.Object">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:150</id>
      <description>Writes a boolean to the stream message. The value true is written as the value (byte)1; the value false is written as the value (byte)0.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="writeBoolean" return-type="void">
        <parameters>
          <parameter>boolean</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:151</id>
      <description>if the JMS provider fails to write the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="writeBoolean" return-type="void">
        <parameters>
          <parameter>boolean</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:152</id>
      <description>Writes a byte to the stream message.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="writeByte" return-type="void">
        <parameters>
          <parameter>byte</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:153</id>
      <description>if the JMS provider fails to write the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="writeByte" return-type="void">
        <parameters>
          <parameter>byte</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:154</id>
      <description>Writes a short to the stream message.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="writeShort" return-type="void">
        <parameters>
          <parameter>short</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:155</id>
      <description>if the JMS provider fails to write the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="writeShort" return-type="void">
        <parameters>
          <parameter>short</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:156</id>
      <description>Writes a char to the stream message.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="writeChar" return-type="void">
        <parameters>
          <parameter>char</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:157</id>
      <description>if the JMS provider fails to write the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="writeChar" return-type="void">
        <parameters>
          <parameter>char</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:158</id>
      <description>Writes an int to the stream message.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="writeInt" return-type="void">
        <parameters>
          <parameter>int</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:159</id>
      <description>if the JMS provider fails to write the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="writeInt" return-type="void">
        <parameters>
          <parameter>int</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:160</id>
      <description>Writes a long to the stream message.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="writeLong" return-type="void">
        <parameters>
          <parameter>long</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:161</id>
      <description>if the JMS provider fails to write the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="writeLong" return-type="void">
        <parameters>
          <parameter>long</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:162</id>
      <description>Writes a float to the stream message.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="writeFloat" return-type="void">
        <parameters>
          <parameter>float</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:163</id>
      <description>if the JMS provider fails to write the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="writeFloat" return-type="void">
        <parameters>
          <parameter>float</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:164</id>
      <description>Writes a double to the stream message.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="writeDouble" return-type="void">
        <parameters>
          <parameter>double</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:165</id>
      <description>if the JMS provider fails to write the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="writeDouble" return-type="void">
        <parameters>
          <parameter>double</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:166</id>
      <description>Writes a String to the stream message.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="writeString" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:167</id>
      <description>if the JMS provider fails to write the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="writeString" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:168</id>
      <description>Writes a byte array field to the stream message. The byte array value is written to the message as a byte array field. Consecutively written byte array fields are treated as two distinct fields when the fields are read.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="writeBytes" return-type="void">
        <parameters>
          <parameter>byte[]</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:169</id>
      <description>if the JMS provider fails to write the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="writeBytes" return-type="void">
        <parameters>
          <parameter>byte[]</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:170</id>
      <description>Writes a portion of a byte array as a byte array field to the stream message. The a portion of the byte array value is written to the message as a byte array field. Consecutively written byte array fields are treated as two distinct fields when the fields are read.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="writeBytes" return-type="void">
        <parameters>
          <parameter>byte[]</parameter>
          <parameter>int</parameter>
          <parameter>int</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:171</id>
      <description>if the JMS provider fails to write the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="writeBytes" return-type="void">
        <parameters>
          <parameter>byte[]</parameter>
          <parameter>int</parameter>
          <parameter>int</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:172</id>
      <description>Writes an object to the stream message. This method works only for the objectified primitive object types (Integer, Double, Long ...), String objects, and byte arrays.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="writeObject" return-type="void">
        <parameters>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:173</id>
      <description>if the JMS provider fails to write the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="writeObject" return-type="void">
        <parameters>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:174</id>
      <description>Puts the message body in read-only mode and repositions the stream to the beginning.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="reset" return-type="void"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:175</id>
      <description>if the JMS provider fails to reset the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="reset" return-type="void">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:176</id>
      <description>Return a server session from the pool.</description>
      <package>jakarta.jms</package>
      <class-interface>ServerSessionPool</class-interface>
      <method name="getServerSession" return-type="jakarta.jms.ServerSession"/>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:177</id>
      <description>if an application server fails to return a ServerSession out of its server session pool.</description>
      <package>jakarta.jms</package>
      <class-interface>ServerSessionPool</class-interface>
      <method name="getServerSession" return-type="jakarta.jms.ServerSession">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:178</id>
      <description>Return the ServerSession's Session. This must be a Session created by the same Connection that will be dispatching messages to it. The provider will assign one or more messages to the Session and then call start on the ServerSession.</description>
      <package>jakarta.jms</package>
      <class-interface>ServerSession</class-interface>
      <method name="getSession" return-type="jakarta.jms.Session"/>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:179</id>
      <description>if the JMS provider fails to get the associated session for this ServerSession due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>ServerSession</class-interface>
      <method name="getSession" return-type="jakarta.jms.Session">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:180</id>
      <description>Cause the Session's run method to be called to process messages that were just assigned to it.</description>
      <package>jakarta.jms</package>
      <class-interface>ServerSession</class-interface>
      <method name="start" return-type="void"/>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:181</id>
      <description>if the JMS provider fails to start the server session to process messages due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>ServerSession</class-interface>
      <method name="start" return-type="void">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:182</id>
      <description>Creates a queue identity given a Queue name. This facility is provided for the rare cases where clients need to dynamically manipulate queue identity. It allows the creation of a queue identity with a provider-specific name. Clients that depend on this ability are not portable. Note that this method is not for creating the physical queue. The physical creation of queues is an administrative task and is not to be initiated by the JMS API. The one exception is the creation of temporary queues, which is accomplished with the createTemporaryQueue method.</description>
      <package>jakarta.jms</package>
      <class-interface>QueueSession</class-interface>
      <method name="createQueue" return-type="jakarta.jms.Queue">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:183</id>
      <description>if the session fails to create a queue due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>QueueSession</class-interface>
      <method name="createQueue" return-type="jakarta.jms.Queue">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:184</id>
      <description>Creates a QueueReceiver object to receive messages from the specified queue.</description>
      <package>jakarta.jms</package>
      <class-interface>QueueSession</class-interface>
      <method name="createReceiver" return-type="jakarta.jms.QueueReceiver">
        <parameters>
          <parameter>jakarta.jms.Queue</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:185</id>
      <description>if the session fails to create a receiver due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>QueueSession</class-interface>
      <method name="createReceiver" return-type="jakarta.jms.QueueReceiver">
        <parameters>
          <parameter>jakarta.jms.Queue</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:186</id>
      <description>Creates a QueueReceiver object to receive messages from the specified queue using a message selector.</description>
      <package>jakarta.jms</package>
      <class-interface>QueueSession</class-interface>
      <method name="createReceiver" return-type="jakarta.jms.QueueReceiver">
        <parameters>
          <parameter>jakarta.jms.Queue</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:187</id>
      <description>if the session fails to create a receiver due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>QueueSession</class-interface>
      <method name="createReceiver" return-type="jakarta.jms.QueueReceiver">
        <parameters>
          <parameter>jakarta.jms.Queue</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:188</id>
      <description>Creates a QueueSender object to send messages to the specified queue.</description>
      <package>jakarta.jms</package>
      <class-interface>QueueSession</class-interface>
      <method name="createSender" return-type="jakarta.jms.QueueSender">
        <parameters>
          <parameter>jakarta.jms.Queue</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:189</id>
      <description>if the session fails to create a sender due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>QueueSession</class-interface>
      <method name="createSender" return-type="jakarta.jms.QueueSender">
        <parameters>
          <parameter>jakarta.jms.Queue</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:190</id>
      <description>Creates a QueueBrowser object to peek at the messages on the specified queue.</description>
      <package>jakarta.jms</package>
      <class-interface>QueueSession</class-interface>
      <method name="createBrowser" return-type="jakarta.jms.QueueBrowser">
        <parameters>
          <parameter>jakarta.jms.Queue</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:191</id>
      <description>if the session fails to create a browser due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>QueueSession</class-interface>
      <method name="createBrowser" return-type="jakarta.jms.QueueBrowser">
        <parameters>
          <parameter>jakarta.jms.Queue</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:192</id>
      <description>Creates a QueueBrowser object to peek at the messages on the specified queue using a message selector.</description>
      <package>jakarta.jms</package>
      <class-interface>QueueSession</class-interface>
      <method name="createBrowser" return-type="jakarta.jms.QueueBrowser">
        <parameters>
          <parameter>jakarta.jms.Queue</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:193</id>
      <description>if the session fails to create a browser due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>QueueSession</class-interface>
      <method name="createBrowser" return-type="jakarta.jms.QueueBrowser">
        <parameters>
          <parameter>jakarta.jms.Queue</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:194</id>
      <description>Creates a TemporaryQueue object. Its lifetime will be that of the QueueConnection unless it is deleted earlier.</description>
      <package>jakarta.jms</package>
      <class-interface>QueueSession</class-interface>
      <method name="createTemporaryQueue" return-type="jakarta.jms.TemporaryQueue"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:195</id>
      <description>if the session fails to create a temporary queue due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>QueueSession</class-interface>
      <method name="createTemporaryQueue" return-type="jakarta.jms.TemporaryQueue">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:196</id>
      <description>Gets the queue associated with this QueueSender.</description>
      <package>jakarta.jms</package>
      <class-interface>QueueSender</class-interface>
      <method name="getQueue" return-type="jakarta.jms.Queue"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:197</id>
      <description>if the JMS provider fails to get the queue for this QueueSender due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>QueueSender</class-interface>
      <method name="getQueue" return-type="jakarta.jms.Queue">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:198</id>
      <description>Sends a message to the queue. Uses the QueueSender's default delivery mode, priority, and time to live.</description>
      <package>jakarta.jms</package>
      <class-interface>QueueSender</class-interface>
      <method name="send" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Message</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:199</id>
      <description>if the JMS provider fails to send the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>QueueSender</class-interface>
      <method name="send" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Message</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:200</id>
      <description>Sends a message to the queue, specifying delivery mode, priority, and time to live.</description>
      <package>jakarta.jms</package>
      <class-interface>QueueSender</class-interface>
      <method name="send" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Message</parameter>
          <parameter>int</parameter>
          <parameter>int</parameter>
          <parameter>long</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:201</id>
      <description>if the JMS provider fails to send the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>QueueSender</class-interface>
      <method name="send" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Message</parameter>
          <parameter>int</parameter>
          <parameter>int</parameter>
          <parameter>long</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:202</id>
      <description>Sends a message to a queue for an unidentified message producer. Uses the QueueSender's default delivery mode, priority, and time to live. Typically, a message producer is assigned a queue at creation time; however, the JMS API also supports unidentified message producers, which require that the queue be supplied every time a message is sent.</description>
      <package>jakarta.jms</package>
      <class-interface>QueueSender</class-interface>
      <method name="send" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Queue</parameter>
          <parameter>jakarta.jms.Message</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:203</id>
      <description>if the JMS provider fails to send the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>QueueSender</class-interface>
      <method name="send" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Queue</parameter>
          <parameter>jakarta.jms.Message</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:204</id>
      <description>Sends a message to a queue for an unidentified message producer, specifying delivery mode, priority and time to live. Typically, a message producer is assigned a queue at creation time; however, the JMS API also supports unidentified message producers, which require that the queue be supplied every time a message is sent.</description>
      <package>jakarta.jms</package>
      <class-interface>QueueSender</class-interface>
      <method name="send" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Queue</parameter>
          <parameter>jakarta.jms.Message</parameter>
          <parameter>int</parameter>
          <parameter>int</parameter>
          <parameter>long</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:205</id>
      <description>if the JMS provider fails to send the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>QueueSender</class-interface>
      <method name="send" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Queue</parameter>
          <parameter>jakarta.jms.Message</parameter>
          <parameter>int</parameter>
          <parameter>int</parameter>
          <parameter>long</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:209</id>
      <description>Creates a BytesMessage object. A BytesMessage object is used to send a message containing a stream of uninterpreted bytes. The message object returned may be sent using any Session or JMSContext. It is not restricted to being sent using the JMSContext used to create it. The message object returned may be optimised for use with the JMS provider used to create it. However it can be sent using any JMS provider, not just the JMS provider used to create it.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createBytesMessage" return-type="jakarta.jms.BytesMessage"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:210</id>
      <description>if the JMS provider fails to create this message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createBytesMessage" return-type="jakarta.jms.BytesMessage">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:211</id>
      <description>Creates a MapMessage object. A MapMessage object is used to send a self-defining set of name-value pairs, where names are String objects and values are primitive values in the Java programming language. The message object returned may be sent using any Session or JMSContext. It is not restricted to being sent using the JMSContext used to create it. The message object returned may be optimised for use with the JMS provider used to create it. However it can be sent using any JMS provider, not just the JMS provider used to create it.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createMapMessage" return-type="jakarta.jms.MapMessage"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:212</id>
      <description>if the JMS provider fails to create this message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createMapMessage" return-type="jakarta.jms.MapMessage">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:213</id>
      <description>Creates a Message object. The Message interface is the root interface of all JMS messages. A Message object holds all the standard message header information. It can be sent when a message containing only header information is sufficient. The message object returned may be sent using any Session or JMSContext. It is not restricted to being sent using the JMSContext used to create it. The message object returned may be optimised for use with the JMS provider used to create it. However it can be sent using any JMS provider, not just the JMS provider used to create it.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createMessage" return-type="jakarta.jms.Message"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:214</id>
      <description>if the JMS provider fails to create this message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createMessage" return-type="jakarta.jms.Message">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:215</id>
      <description>Creates an ObjectMessage object. An ObjectMessage object is used to send a message that contains a serializable Java object. The message object returned may be sent using any Session or JMSContext. It is not restricted to being sent using the JMSContext used to create it. The message object returned may be optimised for use with the JMS provider used to create it. However it can be sent using any JMS provider, not just the JMS provider used to create it.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createObjectMessage" return-type="jakarta.jms.ObjectMessage"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:216</id>
      <description>if the JMS provider fails to create this message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createObjectMessage" return-type="jakarta.jms.ObjectMessage">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:217</id>
      <description>Creates an initialized ObjectMessage object. An ObjectMessage object is used to send a message that contains a serializable Java object. The message object returned may be sent using any Session or JMSContext. It is not restricted to being sent using the JMSContext used to create it. The message object returned may be optimised for use with the JMS provider used to create it. However it can be sent using any JMS provider, not just the JMS provider used to create it.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createObjectMessage" return-type="jakarta.jms.ObjectMessage">
        <parameters>
          <parameter>java.io.Serializable</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:218</id>
      <description>if the JMS provider fails to create this message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createObjectMessage" return-type="jakarta.jms.ObjectMessage">
        <parameters>
          <parameter>java.io.Serializable</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:219</id>
      <description>Creates a StreamMessage object. A StreamMessage object is used to send a self-defining stream of primitive values in the Java programming language. The message object returned may be sent using any Session or JMSContext. It is not restricted to being sent using the JMSContext used to create it. The message object returned may be optimised for use with the JMS provider used to create it. However it can be sent using any JMS provider, not just the JMS provider used to create it.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createStreamMessage" return-type="jakarta.jms.StreamMessage"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:220</id>
      <description>if the JMS provider fails to create this message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createStreamMessage" return-type="jakarta.jms.StreamMessage">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:221</id>
      <description>Creates a TextMessage object. A TextMessage object is used to send a message containing a String object. The message object returned may be sent using any Session or JMSContext. It is not restricted to being sent using the JMSContext used to create it. The message object returned may be optimised for use with the JMS provider used to create it. However it can be sent using any JMS provider, not just the JMS provider used to create it.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createTextMessage" return-type="jakarta.jms.TextMessage"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:222</id>
      <description>if the JMS provider fails to create this message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createTextMessage" return-type="jakarta.jms.TextMessage">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:223</id>
      <description>Creates an initialized TextMessage object. A TextMessage object is used to send a message containing a String. The message object returned may be sent using any Session or JMSContext. It is not restricted to being sent using the JMSContext used to create it. The message object returned may be optimised for use with the JMS provider used to create it. However it can be sent using any JMS provider, not just the JMS provider used to create it.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createTextMessage" return-type="jakarta.jms.TextMessage">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:224</id>
      <description>if the JMS provider fails to create this message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createTextMessage" return-type="jakarta.jms.TextMessage">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:225</id>
      <description>Indicates whether the session is in transacted mode.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="getTransacted" return-type="boolean"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:226</id>
      <description>if the JMS provider fails to return the transaction mode due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="getTransacted" return-type="boolean">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:227</id>
      <description>Returns the acknowledgement mode of the session. The acknowledgement mode is set at the time that the session is created. If the session is transacted, the acknowledgement mode is ignored.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="getAcknowledgeMode" return-type="int"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:228</id>
      <description>if the JMS provider fails to return the acknowledgment mode due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="getAcknowledgeMode" return-type="int">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:229</id>
      <description>Commits all messages done in this transaction and releases any locks currently held. This method must not return until any incomplete asynchronous send operations for this Session have been completed and any CompletionListener callbacks have returned. Incomplete sends should be allowed to complete normally unless an error occurs. A CompletionListener callback method must not call commit on its own Session. Doing so will cause an IllegalStateException to be thrown.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="commit" return-type="void"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:230</id>
      <description>if the JMS provider fails to commit the transaction due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="commit" return-type="void">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:231</id>
      <description>Rolls back any messages done in this transaction and releases any locks currently held. This method must not return until any incomplete asynchronous send operations for this Session have been completed and any CompletionListener callbacks have returned. Incomplete sends should be allowed to complete normally unless an error occurs. A CompletionListener callback method must not call commit on its own Session. Doing so will cause an IllegalStateException to be thrown.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="rollback" return-type="void"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:232</id>
      <description>if the JMS provider fails to roll back the transaction due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="rollback" return-type="void">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:233</id>
      <description>Closes the session. Since a provider may allocate some resources on behalf of a session outside the JVM, clients should close the resources when they are not needed. Relying on garbage collection to eventually reclaim these resources may not be timely enough. There is no need to close the producers and consumers of a closed session. This call will block until a receive call or message listener in progress has completed. A blocked message consumer receive call returns null when this session is closed. This method must not return until any incomplete asynchronous send operations for this Session have been completed and any CompletionListener callbacks have returned. Incomplete sends should be allowed to complete normally unless an error occurs. For the avoidance of doubt, if an exception listener for this session's connection is running when close is invoked, there is no requirement for the close call to wait until the exception listener has returned before it may return. Closing a transacted session must roll back the transaction in progress. This method is the only Session method that can be called concurrently. A MessageListener must not attempt to close its own Session as this would lead to deadlock. The JMS provider must detect this and throw a IllegalStateException. A CompletionListener callback method must not call close on its own Session. Doing so will cause an IllegalStateException to be thrown. Invoking any other Session method on a closed session must throw a IllegalStateException. Closing a closed session must not throw an exception.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="close" return-type="void"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:234</id>
      <description>if the JMS provider fails to close the session due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="close" return-type="void">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:235</id>
      <description>Stops message delivery in this session, and restarts message delivery with the oldest unacknowledged message. All consumers deliver messages in a serial order. Acknowledging a received message automatically acknowledges all messages that have been delivered to the client. Restarting a session causes it to take the following actions: Stop message delivery Mark all messages that might have been delivered but not acknowledged as "redelivered" Restart the delivery sequence including all unacknowledged messages that had been previously delivered. Redelivered messages do not have to be delivered in exactly their original delivery order.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="recover" return-type="void"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:236</id>
      <description>if the JMS provider fails to stop and restart message delivery due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="recover" return-type="void">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:237</id>
      <description>Returns the session's distinguished message listener (optional). This method must not be used in a Jakarta EE web or Enterprise Beans application. Doing so may cause a JMSException to be thrown though this is not guaranteed.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="getMessageListener" return-type="jakarta.jms.MessageListener"/>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:238</id>
      <description>if the JMS provider fails to get the session's distinguished message listener for one of the following reasons: an internal error has occurred this method has been called in a Jakarta EE web or Enterprise Beans application (though it is not guaranteed that an exception is thrown in this case)</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="getMessageListener" return-type="jakarta.jms.MessageListener">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:239</id>
      <description>Sets the session's distinguished message listener (optional). When the distinguished message listener is set, no other form of message receipt in the session can be used; however, all forms of sending messages are still supported. This is an expert facility not used by ordinary JMS clients. This method must not be used in a Jakarta EE web or Enterprise Beans application. Doing so may cause a JMSException to be thrown though this is not guaranteed.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="setMessageListener" return-type="void">
        <parameters>
          <parameter>jakarta.jms.MessageListener</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:240</id>
      <description>if the JMS provider fails to set the session's distinguished message listener for one of the following reasons: an internal error has occurred this method has been called in a Jakarta EE web or Enterprise Beans application (though it is not guaranteed that an exception is thrown in this case)</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="setMessageListener" return-type="void">
        <parameters>
          <parameter>jakarta.jms.MessageListener</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:241</id>
      <description>Optional operation, intended to be used only by Application Servers, not by ordinary JMS clients. This method must not be used in a Jakarta EE web or Enterprise Beans application. Doing so may cause a JMSRuntimeException to be thrown though this is not guaranteed.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="run" return-type="void"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:242</id>
      <description>Creates a MessageProducer to send messages to the specified destination. A client uses a MessageProducer object to send messages to a destination. Since Queue and Topic both inherit from Destination, they can be used in the destination parameter to create a MessageProducer object.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createProducer" return-type="jakarta.jms.MessageProducer">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:243</id>
      <description>if the session fails to create a MessageProducer due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createProducer" return-type="jakarta.jms.MessageProducer">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:244</id>
      <description>Creates a MessageConsumer for the specified destination. Since Queue and Topic both inherit from Destination, they can be used in the destination parameter to create a MessageConsumer.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createConsumer" return-type="jakarta.jms.MessageConsumer">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:245</id>
      <description>if the session fails to create a consumer due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createConsumer" return-type="jakarta.jms.MessageConsumer">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:246</id>
      <description>Creates a MessageConsumer for the specified destination, using a message selector. Since Queue and Topic both inherit from Destination, they can be used in the destination parameter to create a MessageConsumer. A client uses a MessageConsumer object to receive messages that have been sent to a destination.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createConsumer" return-type="jakarta.jms.MessageConsumer">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:247</id>
      <description>if the session fails to create a MessageConsumer due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createConsumer" return-type="jakarta.jms.MessageConsumer">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:248</id>
      <description>Creates a MessageConsumer for the specified destination, specifying a message selector and the noLocal parameter. Since Queue and Topic both inherit from Destination, they can be used in the destination parameter to create a MessageConsumer. A client uses a MessageConsumer object to receive messages that have been published to a destination. The noLocal argument is for use when the destination is a topic and the session's connection is also being used to publish messages to that topic. If noLocal is set to true then the MessageConsumer will not receive messages published to the topic by its own connection. The default value of this argument is false. If the destination is a queue then the effect of setting noLocal to true is not specified.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createConsumer" return-type="jakarta.jms.MessageConsumer">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>boolean</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:249</id>
      <description>if the session fails to create a MessageConsumer due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createConsumer" return-type="jakarta.jms.MessageConsumer">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>boolean</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:250</id>
      <description>Creates a Queue object which encapsulates a specified provider-specific queue name. The use of provider-specific queue names in an application may render the application non-portable. Portable applications are recommended to not use this method but instead look up an administratively-defined Queue object using JNDI. Note that this method simply creates an object that encapsulates the name of a queue. It does not create the physical queue in the JMS provider. JMS does not provide a method to create the physical queue, since this would be specific to a given JMS provider. Creating a physical queue is provider-specific and is typically an administrative task performed by an administrator, though some providers may create them automatically when needed. The one exception to this is the creation of a temporary queue, which is done using the createTemporaryQueue method.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createQueue" return-type="jakarta.jms.Queue">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:251</id>
      <description>if a Queue object cannot be created due to some internal error</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createQueue" return-type="jakarta.jms.Queue">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:252</id>
      <description>Creates a Topic object which encapsulates a specified provider-specific topic name. The use of provider-specific topic names in an application may render the application non-portable. Portable applications are recommended to not use this method but instead look up an administratively-defined Topic object using JNDI. Note that this method simply creates an object that encapsulates the name of a topic. It does not create the physical topic in the JMS provider. JMS does not provide a method to create the physical topic, since this would be specific to a given JMS provider. Creating a physical topic is provider-specific and is typically an administrative task performed by an administrator, though some providers may create them automatically when needed. The one exception to this is the creation of a temporary topic, which is done using the createTemporaryTopic method.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createTopic" return-type="jakarta.jms.Topic">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:253</id>
      <description>if a Topic object cannot be created due to some internal error</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createTopic" return-type="jakarta.jms.Topic">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:254</id>
      <description>Creates an unshared durable subscription on the specified topic (if one does not already exist) and creates a consumer on that durable subscription. This method creates the durable subscription without a message selector and with a noLocal value of false. A durable subscription is used by an application which needs to receive all the messages published on a topic, including the ones published when there is no active consumer associated with it. The JMS provider retains a record of this durable subscription and ensures that all messages from the topic's publishers are retained until they are delivered to, and acknowledged by, a consumer on this durable subscription or until they have expired. A durable subscription will continue to accumulate messages until it is deleted using the unsubscribe method. This method may only be used with unshared durable subscriptions. Any durable subscription created using this method will be unshared. This means that only one active (i.e. not closed) consumer on the subscription may exist at a time. The term "consumer" here means a TopicSubscriber, MessageConsumer or JMSConsumer object in any client. An unshared durable subscription is identified by a name specified by the client and by the client identifier, which must be set. An application which subsequently wishes to create a consumer on that unshared durable subscription must use the same client identifier. If an unshared durable subscription already exists with the same name and client identifier, and the same topic, message selector and noLocal value has been specified, and there is no consumer already active (i.e. not closed) on the durable subscription then this method creates a TopicSubscriber on the existing durable subscription. If an unshared durable subscription already exists with the same name and client identifier, and there is a consumer already active (i.e. not closed) on the durable subscription, then a JMSException will be thrown. If an unshared durable subscription already exists with the same name and client identifier but a different topic, message selector or noLocal value has been specified, and there is no consumer already active (i.e. not closed) on the durable subscription then this is equivalent to unsubscribing (deleting) the old one and creating a new one. A shared durable subscription and an unshared durable subscription may not have the same name and client identifier. If a shared durable subscription already exists with the same name and client identifier then a JMSException is thrown. There is no restriction on durable subscriptions and shared non-durable subscriptions having the same name and clientId. Such subscriptions would be completely separate. This method is identical to the corresponding createDurableConsumer method except that it returns a TopicSubscriber rather than a MessageConsumer to represent the consumer.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createDurableSubscriber" return-type="jakarta.jms.TopicSubscriber">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:255</id>
      <description>if the session fails to create the unshared durable subscription and TopicSubscriber due to some internal error if an unshared durable subscription already exists with the same name and client identifier, and there is a consumer already active if a shared durable subscription already exists with the same name and client identifier</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createDurableSubscriber" return-type="jakarta.jms.TopicSubscriber">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:256</id>
      <description>Creates an unshared durable subscription on the specified topic (if one does not already exist), specifying a message selector and the noLocal parameter, and creates a consumer on that durable subscription. A durable subscription is used by an application which needs to receive all the messages published on a topic, including the ones published when there is no active consumer associated with it. The JMS provider retains a record of this durable subscription and ensures that all messages from the topic's publishers are retained until they are delivered to, and acknowledged by, a consumer on this durable subscription or until they have expired. A durable subscription will continue to accumulate messages until it is deleted using the unsubscribe method. This method may only be used with unshared durable subscriptions. Any durable subscription created using this method will be unshared. This means that only one active (i.e. not closed) consumer on the subscription may exist at a time. The term "consumer" here means a TopicSubscriber, MessageConsumer or JMSConsumer object in any client. An unshared durable subscription is identified by a name specified by the client and by the client identifier, which must be set. An application which subsequently wishes to create a consumer on that unshared durable subscription must use the same client identifier. If an unshared durable subscription already exists with the same name and client identifier, and the same topic, message selector and noLocal value has been specified, and there is no consumer already active (i.e. not closed) on the durable subscription then this method creates a TopicSubscriber on the existing durable subscription. If an unshared durable subscription already exists with the same name and client identifier, and there is a consumer already active (i.e. not closed) on the durable subscription, then a JMSException will be thrown. If an unshared durable subscription already exists with the same name and client identifier but a different topic, message selector or noLocal value has been specified, and there is no consumer already active (i.e. not closed) on the durable subscription then this is equivalent to unsubscribing (deleting) the old one and creating a new one. If noLocal is set to true then any messages published to the topic using this session's connection, or any other connection with the same client identifier, will not be added to the durable subscription. A shared durable subscription and an unshared durable subscription may not have the same name and client identifier. If a shared durable subscription already exists with the same name and client identifier then a JMSException is thrown. There is no restriction on durable subscriptions and shared non-durable subscriptions having the same name and clientId. Such subscriptions would be completely separate. This method is identical to the corresponding createDurableConsumer method except that it returns a TopicSubscriber rather than a MessageConsumer to represent the consumer.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createDurableSubscriber" return-type="jakarta.jms.TopicSubscriber">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>boolean</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:257</id>
      <description>if the session fails to create the unshared durable subscription and TopicSubscriber due to some internal error if an unshared durable subscription already exists with the same name and client identifier, and there is a consumer already active if a shared durable subscription already exists with the same name and client identifier</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createDurableSubscriber" return-type="jakarta.jms.TopicSubscriber">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>boolean</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:258</id>
      <description>Creates a QueueBrowser object to peek at the messages on the specified queue.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createBrowser" return-type="jakarta.jms.QueueBrowser">
        <parameters>
          <parameter>jakarta.jms.Queue</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:259</id>
      <description>if the session fails to create a browser due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createBrowser" return-type="jakarta.jms.QueueBrowser">
        <parameters>
          <parameter>jakarta.jms.Queue</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:260</id>
      <description>Creates a QueueBrowser object to peek at the messages on the specified queue using a message selector.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createBrowser" return-type="jakarta.jms.QueueBrowser">
        <parameters>
          <parameter>jakarta.jms.Queue</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:261</id>
      <description>if the session fails to create a browser due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createBrowser" return-type="jakarta.jms.QueueBrowser">
        <parameters>
          <parameter>jakarta.jms.Queue</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:262</id>
      <description>Creates a TemporaryQueue object. Its lifetime will be that of the Connection unless it is deleted earlier.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createTemporaryQueue" return-type="jakarta.jms.TemporaryQueue"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:263</id>
      <description>if the session fails to create a temporary queue due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createTemporaryQueue" return-type="jakarta.jms.TemporaryQueue">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:264</id>
      <description>Creates a TemporaryTopic object. Its lifetime will be that of the Connection unless it is deleted earlier.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createTemporaryTopic" return-type="jakarta.jms.TemporaryTopic"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:265</id>
      <description>if the session fails to create a temporary topic due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createTemporaryTopic" return-type="jakarta.jms.TemporaryTopic">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:266</id>
      <description>Unsubscribes a durable subscription that has been created by a client. This method deletes the state being maintained on behalf of the subscriber by its provider. A durable subscription is identified by a name specified by the client and by the client identifier if set. If the client identifier was set when the durable subscription was created then a client which subsequently wishes to use this method to delete a durable subscription must use the same client identifier. It is erroneous for a client to delete a durable subscription while there is an active (not closed) consumer for the subscription, or while a consumed message is part of a pending transaction or has not been acknowledged in the session.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="unsubscribe" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:267</id>
      <description>if the session fails to unsubscribe to the durable subscription due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="unsubscribe" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:268</id>
      <description>Gets the Queue associated with this queue receiver.</description>
      <package>jakarta.jms</package>
      <class-interface>QueueReceiver</class-interface>
      <method name="getQueue" return-type="jakarta.jms.Queue"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:269</id>
      <description>if the JMS provider fails to get the queue for this queue receiver due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>QueueReceiver</class-interface>
      <method name="getQueue" return-type="jakarta.jms.Queue">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:270</id>
      <description>Creates a queue connection with the default user identity. The connection is created in stopped mode. No messages will be delivered until the Connection.start method is explicitly called. .</description>
      <package>jakarta.jms</package>
      <class-interface>QueueConnectionFactory</class-interface>
      <method name="createQueueConnection" return-type="jakarta.jms.QueueConnection"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:271</id>
      <description>if the JMS provider fails to create the queue connection due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>QueueConnectionFactory</class-interface>
      <method name="createQueueConnection" return-type="jakarta.jms.QueueConnection">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:272</id>
      <description>Creates a queue connection with the specified user identity. The connection is created in stopped mode. No messages will be delivered until the Connection.start method is explicitly called.</description>
      <package>jakarta.jms</package>
      <class-interface>QueueConnectionFactory</class-interface>
      <method name="createQueueConnection" return-type="jakarta.jms.QueueConnection">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:273</id>
      <description>if the JMS provider fails to create the queue connection due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>QueueConnectionFactory</class-interface>
      <method name="createQueueConnection" return-type="jakarta.jms.QueueConnection">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:274</id>
      <description>Creates a QueueSession object.</description>
      <package>jakarta.jms</package>
      <class-interface>QueueConnection</class-interface>
      <method name="createQueueSession" return-type="jakarta.jms.QueueSession">
        <parameters>
          <parameter>boolean</parameter>
          <parameter>int</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:275</id>
      <description>if the QueueConnection object fails to create a session due to some internal error or lack of support for the specific transaction and acknowledgement mode.</description>
      <package>jakarta.jms</package>
      <class-interface>QueueConnection</class-interface>
      <method name="createQueueSession" return-type="jakarta.jms.QueueSession">
        <parameters>
          <parameter>boolean</parameter>
          <parameter>int</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:276</id>
      <description>Creates a connection consumer for this connection (optional operation). This is an expert facility not used by regular JMS clients.</description>
      <package>jakarta.jms</package>
      <class-interface>QueueConnection</class-interface>
      <method name="createConnectionConsumer" return-type="jakarta.jms.ConnectionConsumer">
        <parameters>
          <parameter>jakarta.jms.Queue</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>jakarta.jms.ServerSessionPool</parameter>
          <parameter>int</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:277</id>
      <description>if the QueueConnection object fails to create a connection consumer due to some internal error or invalid arguments for sessionPool and messageSelector.</description>
      <package>jakarta.jms</package>
      <class-interface>QueueConnection</class-interface>
      <method name="createConnectionConsumer" return-type="jakarta.jms.ConnectionConsumer">
        <parameters>
          <parameter>jakarta.jms.Queue</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>jakarta.jms.ServerSessionPool</parameter>
          <parameter>int</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:278</id>
      <description>Gets the queue associated with this queue browser.</description>
      <package>jakarta.jms</package>
      <class-interface>QueueBrowser</class-interface>
      <method name="getQueue" return-type="jakarta.jms.Queue"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:279</id>
      <description>if the JMS provider fails to get the queue associated with this browser due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>QueueBrowser</class-interface>
      <method name="getQueue" return-type="jakarta.jms.Queue">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:280</id>
      <description>Gets this queue browser's message selector expression.</description>
      <package>jakarta.jms</package>
      <class-interface>QueueBrowser</class-interface>
      <method name="getMessageSelector" return-type="java.lang.String"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:281</id>
      <description>if the JMS provider fails to get the message selector for this browser due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>QueueBrowser</class-interface>
      <method name="getMessageSelector" return-type="java.lang.String">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:282</id>
      <description>Gets an enumeration for browsing the current queue messages in the order they would be received.</description>
      <package>jakarta.jms</package>
      <class-interface>QueueBrowser</class-interface>
      <method name="getEnumeration" return-type="java.util.Enumeration"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:283</id>
      <description>if the JMS provider fails to get the enumeration for this browser due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>QueueBrowser</class-interface>
      <method name="getEnumeration" return-type="java.util.Enumeration">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:284</id>
      <description>Closes the QueueBrowser. Since a provider may allocate some resources on behalf of a QueueBrowser outside the Java virtual machine, clients should close them when they are not needed. Relying on garbage collection to eventually reclaim these resources may not be timely enough.</description>
      <package>jakarta.jms</package>
      <class-interface>QueueBrowser</class-interface>
      <method name="close" return-type="void"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:285</id>
      <description>if the JMS provider fails to close this browser due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>QueueBrowser</class-interface>
      <method name="close" return-type="void">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:286</id>
      <description>Gets the name of this queue. Clients that depend upon the name are not portable.</description>
      <package>jakarta.jms</package>
      <class-interface>Queue</class-interface>
      <method name="getQueueName" return-type="java.lang.String"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:287</id>
      <description>if the JMS provider implementation of Queue fails to return the queue name due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Queue</class-interface>
      <method name="getQueueName" return-type="java.lang.String">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:288</id>
      <description>Returns a string representation of this object.</description>
      <package>jakarta.jms</package>
      <class-interface>Queue</class-interface>
      <method name="toString" return-type="java.lang.String"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:289</id>
      <description>Sets the serializable object containing this message's data. It is important to note that an ObjectMessage contains a snapshot of the object at the time setObject() is called; subsequent modifications of the object will have no effect on the ObjectMessage body.</description>
      <package>jakarta.jms</package>
      <class-interface>ObjectMessage</class-interface>
      <method name="setObject" return-type="void">
        <parameters>
          <parameter>java.io.Serializable</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:290</id>
      <description>if the JMS provider fails to set the object due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>ObjectMessage</class-interface>
      <method name="setObject" return-type="void">
        <parameters>
          <parameter>java.io.Serializable</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:291</id>
      <description>Gets the serializable object containing this message's data. The default value is null.</description>
      <package>jakarta.jms</package>
      <class-interface>ObjectMessage</class-interface>
      <method name="getObject" return-type="java.io.Serializable"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:292</id>
      <description>if the JMS provider fails to get the object due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>ObjectMessage</class-interface>
      <method name="getObject" return-type="java.io.Serializable">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:293</id>
      <description>Specify whether message IDs may be disabled. Since message IDs take some effort to create and increase a message's size, some JMS providers may be able to optimise message overhead if they are given a hint that the message ID is not used by an application. By calling this method, a JMS application enables this potential optimisation for all messages sent using this MessageProducer. If the JMS provider accepts this hint, these messages must have the message ID set to null; if the provider ignores the hint, the message ID must be set to its normal unique value. Message IDs are enabled by default.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageProducer</class-interface>
      <method name="setDisableMessageID" return-type="void">
        <parameters>
          <parameter>boolean</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:294</id>
      <description>if the JMS provider fails to set message ID to disabled due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageProducer</class-interface>
      <method name="setDisableMessageID" return-type="void">
        <parameters>
          <parameter>boolean</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:295</id>
      <description>Gets an indication of whether message IDs are disabled.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageProducer</class-interface>
      <method name="getDisableMessageID" return-type="boolean"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:296</id>
      <description>if the JMS provider fails to determine if message IDs are disabled due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageProducer</class-interface>
      <method name="getDisableMessageID" return-type="boolean">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:297</id>
      <description>Specify whether message timestamps may be disabled. Since timestamps take some effort to create and increase a message's size, some JMS providers may be able to optimise message overhead if they are given a hint that the timestamp is not used by an application. By calling this method, a JMS application enables this potential optimisation for all messages sent using this MessageProducer. If the JMS provider accepts this hint, these messages must have the timestamp set to zero; if the provider ignores the hint, the timestamp must be set to its normal value. Message timestamps are enabled by default.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageProducer</class-interface>
      <method name="setDisableMessageTimestamp" return-type="void">
        <parameters>
          <parameter>boolean</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:298</id>
      <description>if the JMS provider fails to set timestamps to disabled due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageProducer</class-interface>
      <method name="setDisableMessageTimestamp" return-type="void">
        <parameters>
          <parameter>boolean</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:299</id>
      <description>Gets an indication of whether message timestamps are disabled.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageProducer</class-interface>
      <method name="getDisableMessageTimestamp" return-type="boolean"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:300</id>
      <description>if the JMS provider fails to determine if timestamps are disabled due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageProducer</class-interface>
      <method name="getDisableMessageTimestamp" return-type="boolean">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:301</id>
      <description>Sets the producer's default delivery mode. Delivery mode is set to PERSISTENT by default.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageProducer</class-interface>
      <method name="setDeliveryMode" return-type="void">
        <parameters>
          <parameter>int</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:302</id>
      <description>if the JMS provider fails to set the delivery mode due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageProducer</class-interface>
      <method name="setDeliveryMode" return-type="void">
        <parameters>
          <parameter>int</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:303</id>
      <description>Gets the producer's default delivery mode.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageProducer</class-interface>
      <method name="getDeliveryMode" return-type="int"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:304</id>
      <description>if the JMS provider fails to get the delivery mode due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageProducer</class-interface>
      <method name="getDeliveryMode" return-type="int">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:305</id>
      <description>Sets the producer's default priority. The JMS API defines ten levels of priority value, with 0 as the lowest priority and 9 as the highest. Clients should consider priorities 0-4 as gradations of normal priority and priorities 5-9 as gradations of expedited priority. Priority is set to 4 by default.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageProducer</class-interface>
      <method name="setPriority" return-type="void">
        <parameters>
          <parameter>int</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:306</id>
      <description>if the JMS provider fails to set the priority due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageProducer</class-interface>
      <method name="setPriority" return-type="void">
        <parameters>
          <parameter>int</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:307</id>
      <description>Gets the producer's default priority.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageProducer</class-interface>
      <method name="getPriority" return-type="int"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:308</id>
      <description>if the JMS provider fails to get the priority due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageProducer</class-interface>
      <method name="getPriority" return-type="int">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:309</id>
      <description>Sets the default length of time in milliseconds from its dispatch time that a produced message should be retained by the message system. Time to live is set to zero by default.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageProducer</class-interface>
      <method name="setTimeToLive" return-type="void">
        <parameters>
          <parameter>long</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:310</id>
      <description>if the JMS provider fails to set the time to live due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageProducer</class-interface>
      <method name="setTimeToLive" return-type="void">
        <parameters>
          <parameter>long</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:311</id>
      <description>Gets the default length of time in milliseconds from its dispatch time that a produced message should be retained by the message system.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageProducer</class-interface>
      <method name="getTimeToLive" return-type="long"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:312</id>
      <description>if the JMS provider fails to get the time to live due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageProducer</class-interface>
      <method name="getTimeToLive" return-type="long">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:313</id>
      <description>Gets the destination associated with this MessageProducer.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageProducer</class-interface>
      <method name="getDestination" return-type="jakarta.jms.Destination"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:314</id>
      <description>if the JMS provider fails to get the destination for this MessageProducer due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageProducer</class-interface>
      <method name="getDestination" return-type="jakarta.jms.Destination">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:315</id>
      <description>Closes the message producer. Since a provider may allocate some resources on behalf of a MessageProducer outside the Java virtual machine, clients should close them when they are not needed. Relying on garbage collection to eventually reclaim these resources may not be timely enough. This method must not return until any incomplete asynchronous send operations for this MessageProducer have been completed and any CompletionListener callbacks have returned. Incomplete sends should be allowed to complete normally unless an error occurs. A CompletionListener callback method must not call close on its own MessageProducer. Doing so will cause an IllegalStateException to be thrown.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageProducer</class-interface>
      <method name="close" return-type="void"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:316</id>
      <description>if the JMS provider fails to close the producer due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageProducer</class-interface>
      <method name="close" return-type="void">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:317</id>
      <description>Sends a message using the MessageProducer's default delivery mode, priority, and time to live.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageProducer</class-interface>
      <method name="send" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Message</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:318</id>
      <description>if the JMS provider fails to send the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageProducer</class-interface>
      <method name="send" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Message</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:319</id>
      <description>Sends a message, specifying delivery mode, priority, and time to live.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageProducer</class-interface>
      <method name="send" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Message</parameter>
          <parameter>int</parameter>
          <parameter>int</parameter>
          <parameter>long</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:320</id>
      <description>if the JMS provider fails to send the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageProducer</class-interface>
      <method name="send" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Message</parameter>
          <parameter>int</parameter>
          <parameter>int</parameter>
          <parameter>long</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:321</id>
      <description>Sends a message to a destination for an unidentified message producer using the MessageProducer's default delivery mode, priority, and time to live. Typically, a message producer is assigned a destination at creation time; however, the JMS API also supports unidentified message producers, which require that the destination be supplied every time a message is sent.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageProducer</class-interface>
      <method name="send" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
          <parameter>jakarta.jms.Message</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:322</id>
      <description>if the JMS provider fails to send the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageProducer</class-interface>
      <method name="send" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
          <parameter>jakarta.jms.Message</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:323</id>
      <description>Sends a message to a destination for an unidentified message producer, specifying delivery mode, priority and time to live. Typically, a message producer is assigned a destination at creation time; however, the JMS API also supports unidentified message producers, which require that the destination be supplied every time a message is sent.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageProducer</class-interface>
      <method name="send" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
          <parameter>jakarta.jms.Message</parameter>
          <parameter>int</parameter>
          <parameter>int</parameter>
          <parameter>long</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:324</id>
      <description>if the JMS provider fails to send the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageProducer</class-interface>
      <method name="send" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
          <parameter>jakarta.jms.Message</parameter>
          <parameter>int</parameter>
          <parameter>int</parameter>
          <parameter>long</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:325</id>
      <description>Passes a message to the listener.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageListener</class-interface>
      <method name="onMessage" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Message</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:326</id>
      <description>Gets this message consumer's message selector expression.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageConsumer</class-interface>
      <method name="getMessageSelector" return-type="java.lang.String"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:327</id>
      <description>if the JMS provider fails to get the message selector due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageConsumer</class-interface>
      <method name="getMessageSelector" return-type="java.lang.String">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:328</id>
      <description>Gets the MessageConsumer's MessageListener. This method must not be used in a Jakarta EE web or Enterprise Beans application. Doing so may cause a JMSException to be thrown though this is not guaranteed.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageConsumer</class-interface>
      <method name="getMessageListener" return-type="jakarta.jms.MessageListener"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:329</id>
      <description>if the JMS provider fails to get the MessageListener for one of the following reasons: an internal error has occurred or this method has been called in a Jakarta EE web or Enterprise Beans application (though it is not guaranteed that an exception is thrown in this case)</description>
      <package>jakarta.jms</package>
      <class-interface>MessageConsumer</class-interface>
      <method name="getMessageListener" return-type="jakarta.jms.MessageListener">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:330</id>
      <description>Sets the MessageConsumer's MessageListener. Setting the the MessageListener to null is the equivalent of unsetting the MessageListener for the MessageConsumer. The effect of calling this method while messages are being consumed by an existing listener or the MessageConsumer is being used to consume messages synchronously is undefined. This method must not be used in a Jakarta EE web or Enterprise Beans application. Doing so may cause a JMSException to be thrown though this is not guaranteed.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageConsumer</class-interface>
      <method name="setMessageListener" return-type="void">
        <parameters>
          <parameter>jakarta.jms.MessageListener</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:331</id>
      <description>if the JMS provider fails to set the MessageConsumer's MessageListener for one of the following reasons: an internal error has occurred or this method has been called in a Jakarta EE web or Enterprise Beans application (though it is not guaranteed that an exception is thrown in this case)</description>
      <package>jakarta.jms</package>
      <class-interface>MessageConsumer</class-interface>
      <method name="setMessageListener" return-type="void">
        <parameters>
          <parameter>jakarta.jms.MessageListener</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:332</id>
      <description>Receives the next message produced for this message consumer. This call blocks indefinitely until a message is produced or until this message consumer is closed. If this receive is done within a transaction, the consumer retains the message until the transaction commits.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageConsumer</class-interface>
      <method name="receive" return-type="jakarta.jms.Message"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:333</id>
      <description>if the JMS provider fails to receive the next message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageConsumer</class-interface>
      <method name="receive" return-type="jakarta.jms.Message">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:334</id>
      <description>Receives the next message that arrives within the specified timeout interval. This call blocks until a message arrives, the timeout expires, or this message consumer is closed. A timeout of zero never expires, and the call blocks indefinitely.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageConsumer</class-interface>
      <method name="receive" return-type="jakarta.jms.Message">
        <parameters>
          <parameter>long</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:335</id>
      <description>if the JMS provider fails to receive the next message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageConsumer</class-interface>
      <method name="receive" return-type="jakarta.jms.Message">
        <parameters>
          <parameter>long</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:336</id>
      <description>Receives the next message if one is immediately available.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageConsumer</class-interface>
      <method name="receiveNoWait" return-type="jakarta.jms.Message"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:337</id>
      <description>if the JMS provider fails to receive the next message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageConsumer</class-interface>
      <method name="receiveNoWait" return-type="jakarta.jms.Message">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:338</id>
      <description>Closes the message consumer. Since a provider may allocate some resources on behalf of a MessageConsumer outside the Java virtual machine, clients should close them when they are not needed. Relying on garbage collection to eventually reclaim these resources may not be timely enough. This call will block until a receive call in progress on this consumer has completed. A blocked receive call returns null when this message consumer is closed. If this method is called whilst a message listener is in progress in another thread then it will block until the message listener has completed. This method may be called from a message listener's onMessage method on its own consumer. After this method returns the onMessage method will be allowed to complete normally. This method is the only MessageConsumer method that can be called concurrently.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageConsumer</class-interface>
      <method name="close" return-type="void"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:339</id>
      <description>if the JMS provider fails to close the consumer due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageConsumer</class-interface>
      <method name="close" return-type="void">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:343</id>
      <description>Gets the message ID. The JMSMessageID header field contains a value that uniquely identifies each message sent by a provider. When a message is sent, JMSMessageID can be ignored. When the send or publish method returns, it contains a provider-assigned value. A JMSMessageID is a String value that should function as a unique key for identifying messages in a historical repository. The exact scope of uniqueness is provider-defined. It should at least cover all messages for a specific installation of a provider, where an installation is some connected set of message routers. All JMSMessageID values must start with the prefix 'ID:'. Uniqueness of message ID values across different providers is not required. Since message IDs take some effort to create and increase a message's size, some JMS providers may be able to optimize message overhead if they are given a hint that the message ID is not used by an application. By calling the MessageProducer.setDisableMessageID method, a JMS client enables this potential optimization for all messages sent by that message producer. If the JMS provider accepts this hint, these messages must have the message ID set to null; if the provider ignores the hint, the message ID must be set to its normal unique value.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="getJMSMessageID" return-type="java.lang.String"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:344</id>
      <description>if the JMS provider fails to get the message ID due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="getJMSMessageID" return-type="java.lang.String">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:345</id>
      <description>Sets the message ID. This method is for use by JMS providers only to set this field when a message is sent. This message cannot be used by clients to configure the message ID. This method is public to allow a JMS provider to set this field when sending a message whose implementation is not its own.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="setJMSMessageID" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:346</id>
      <description>if the JMS provider fails to set the message ID due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="setJMSMessageID" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:347</id>
      <description>Gets the message timestamp. The JMSTimestamp header field contains the time a message was handed off to a provider to be sent. It is not the time the message was actually transmitted, because the actual send may occur later due to transactions or other client-side queueing of messages. When a message is sent, JMSTimestamp is ignored. When the send or publish method returns, it contains a time value somewhere in the interval between the call and the return. The value is in the format of a normal millis time value in the Java programming language. Since timestamps take some effort to create and increase a message's size, some JMS providers may be able to optimize message overhead if they are given a hint that the timestamp is not used by an application. By calling the MessageProducer.setDisableMessageTimestamp method, a JMS client enables this potential optimization for all messages sent by that message producer. If the JMS provider accepts this hint, these messages must have the timestamp set to zero; if the provider ignores the hint, the timestamp must be set to its normal value.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="getJMSTimestamp" return-type="long"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:348</id>
      <description>if the JMS provider fails to get the timestamp due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="getJMSTimestamp" return-type="long">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:349</id>
      <description>Sets the message timestamp. This method is for use by JMS providers only to set this field when a message is sent. This message cannot be used by clients to configure the message timestamp. This method is public to allow a JMS provider to set this field when sending a message whose implementation is not its own.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="setJMSTimestamp" return-type="void">
        <parameters>
          <parameter>long</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:350</id>
      <description>if the JMS provider fails to set the timestamp due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="setJMSTimestamp" return-type="void">
        <parameters>
          <parameter>long</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="false" impl-spec="true" status="active" testable="true">
      <id>JMS:JAVADOC:351</id>
      <description>Gets the correlation ID as an array of bytes for the message. The use of a byte[] value for JMSCorrelationID is non-portable.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="getJMSCorrelationIDAsBytes" return-type="byte[]"/>
    </assertion>
<assertion required="false" impl-spec="true" status="active" testable="false">
      <id>JMS:JAVADOC:352</id>
      <description>if the JMS provider fails to get the correlation ID due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="getJMSCorrelationIDAsBytes" return-type="byte[]">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="false" impl-spec="true" status="active" testable="true">
      <id>JMS:JAVADOC:353</id>
      <description>Sets the correlation ID as an array of bytes for the message. The array is copied before the method returns, so future modifications to the array will not alter this message header. If a provider supports the native concept of correlation ID, a JMS client may need to assign specific JMSCorrelationID values to match those expected by native messaging clients. JMS providers without native correlation ID values are not required to support this method and its corresponding get method; their implementation may throw a java.lang.UnsupportedOperationException. The use of a byte[] value for JMSCorrelationID is non-portable.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="setJMSCorrelationIDAsBytes" return-type="void">
        <parameters>
          <parameter>byte[]</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="false" impl-spec="true" status="active" testable="false">
      <id>JMS:JAVADOC:354</id>
      <description>if the JMS provider fails to set the correlation ID due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="setJMSCorrelationIDAsBytes" return-type="void">
        <parameters>
          <parameter>byte[]</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:355</id>
      <description>Sets the correlation ID for the message. A client can use the JMSCorrelationID header field to link one message with another. A typical use is to link a response message with its request message. JMSCorrelationID can hold one of the following: A provider-specific message ID An application-specific String A provider-native byte[] value Since each message sent by a JMS provider is assigned a message ID value, it is convenient to link messages via message ID. All message ID values must start with the 'ID:' prefix. In some cases, an application (made up of several clients) needs to use an application-specific value for linking messages. For instance, an application may use JMSCorrelationID to hold a value referencing some external information. Application-specified values must not start with the 'ID:' prefix; this is reserved for provider-generated message ID values. If a provider supports the native concept of correlation ID, a JMS client may need to assign specific JMSCorrelationID values to match those expected by clients that do not use the JMS API. A byte[] value is used for this purpose. JMS providers without native correlation ID values are not required to support byte[] values. The use of a byte[] value for JMSCorrelationID is non-portable.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="setJMSCorrelationID" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:356</id>
      <description>if the JMS provider fails to set the correlation ID due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="setJMSCorrelationID" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:357</id>
      <description>Gets the correlation ID for the message. This method is used to return correlation ID values that are either provider-specific message IDs or application-specific String values.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="getJMSCorrelationID" return-type="java.lang.String"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:358</id>
      <description>if the JMS provider fails to get the correlation ID due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="getJMSCorrelationID" return-type="java.lang.String">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:359</id>
      <description>Gets the Destination object to which a reply to this message should be sent.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="getJMSReplyTo" return-type="jakarta.jms.Destination"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:360</id>
      <description>if the JMS provider fails to get the JMSReplyTo destination due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="getJMSReplyTo" return-type="jakarta.jms.Destination">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:361</id>
      <description>Sets the Destination object to which a reply to this message should be sent. The JMSReplyTo header field contains the destination where a reply to the current message should be sent. If it is null, no reply is expected. The destination may be either a Queue object or a Topic object. Messages sent with a null JMSReplyTo value may be a notification of some event, or they may just be some data the sender thinks is of interest. Messages with a JMSReplyTo value typically expect a response. A response is optional; it is up to the client to decide. These messages are called requests. A message sent in response to a request is called a reply. In some cases a client may wish to match a request it sent earlier with a reply it has just received. The client can use the JMSCorrelationID header field for this purpose.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="setJMSReplyTo" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:362</id>
      <description>if the JMS provider fails to set the JMSReplyTo destination due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="setJMSReplyTo" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:363</id>
      <description>Gets the Destination object for this message. The JMSDestination header field contains the destination to which the message is being sent. When a message is sent, this field is ignored. After completion of the send or publish method, the field holds the destination specified by the method. When a message is received, its JMSDestination value must be equivalent to the value assigned when it was sent.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="getJMSDestination" return-type="jakarta.jms.Destination"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:364</id>
      <description>if the JMS provider fails to get the destination due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="getJMSDestination" return-type="jakarta.jms.Destination">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:365</id>
      <description>Sets the Destination object for this message. This method is for use by JMS providers only to set this field when a message is sent. This message cannot be used by clients to configure the destination of the message. This method is public to allow a JMS provider to set this field when sending a message whose implementation is not its own.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="setJMSDestination" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:366</id>
      <description>if the JMS provider fails to set the destination due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="setJMSDestination" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:367</id>
      <description>Gets the DeliveryMode value specified for this message.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="getJMSDeliveryMode" return-type="int"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:368</id>
      <description>if the JMS provider fails to get the delivery mode due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="getJMSDeliveryMode" return-type="int">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:369</id>
      <description>Sets the DeliveryMode value for this message. This method is for use by JMS providers only to set this field when a message is sent. This message cannot be used by clients to configure the delivery mode of the message. This method is public to allow a JMS provider to set this field when sending a message whose implementation is not its own.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="setJMSDeliveryMode" return-type="void">
        <parameters>
          <parameter>int</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:370</id>
      <description>if the JMS provider fails to set the delivery mode due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="setJMSDeliveryMode" return-type="void">
        <parameters>
          <parameter>int</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:371</id>
      <description>Gets an indication of whether this message is being redelivered. If a client receives a message with the JMSRedelivered field set, it is likely, but not guaranteed, that this message was delivered earlier but that its receipt was not acknowledged at that time.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="getJMSRedelivered" return-type="boolean"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:372</id>
      <description>if the JMS provider fails to get the redelivered state due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="getJMSRedelivered" return-type="boolean">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:373</id>
      <description>Specifies whether this message is being redelivered. This method is for use by JMS providers only to set this field when a message is delivered. This message cannot be used by clients to configure the redelivered status of the message. This method is public to allow a JMS provider to set this field when sending a message whose implementation is not its own.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="setJMSRedelivered" return-type="void">
        <parameters>
          <parameter>boolean</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:374</id>
      <description>if the JMS provider fails to set the redelivered state due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="setJMSRedelivered" return-type="void">
        <parameters>
          <parameter>boolean</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:375</id>
      <description>Gets the message type identifier supplied by the client when the message was sent.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="getJMSType" return-type="java.lang.String"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:376</id>
      <description>if the JMS provider fails to get the message type due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="getJMSType" return-type="java.lang.String">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:377</id>
      <description>Sets the message type. Some JMS providers use a message repository that contains the definitions of messages sent by applications. The JMSType header field may reference a message's definition in the provider's repository. The JMS API does not define a standard message definition repository, nor does it define a naming policy for the definitions it contains. Some messaging systems require that a message type definition for each application message be created and that each message specify its type. In order to work with such JMS providers, JMS clients should assign a value to JMSType, whether the application makes use of it or not. This ensures that the field is properly set for those providers that require it. To ensure portability, JMS clients should use symbolic values for JMSType that can be configured at installation time to the values defined in the current provider's message repository. If string literals are used, they may not be valid type names for some JMS providers.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="setJMSType" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:378</id>
      <description>if the JMS provider fails to set the message type due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="setJMSType" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:379</id>
      <description>Gets the message's expiration time. When a message is sent, the JMSExpiration header field is left unassigned. After completion of the send or publish method, it holds the expiration time of the message. This is the the difference, measured in milliseconds, between the expiration time and midnight, January 1, 1970 UTC. If the time-to-live is specified as zero, JMSExpiration is set to zero to indicate that the message does not expire. When a message's expiration time is reached, a provider should discard it. The JMS API does not define any form of notification of message expiration. Clients should not receive messages that have expired; however, the JMS API does not guarantee that this will not happen.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="getJMSExpiration" return-type="long"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:380</id>
      <description>if the JMS provider fails to get the message expiration due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="getJMSExpiration" return-type="long">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:381</id>
      <description>Sets the message's expiration value. This method is for use by JMS providers only to set this field when a message is sent. This message cannot be used by clients to configure the expiration time of the message. This method is public to allow a JMS provider to set this field when sending a message whose implementation is not its own.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="setJMSExpiration" return-type="void">
        <parameters>
          <parameter>long</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:382</id>
      <description>if the JMS provider fails to set the message expiration due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="setJMSExpiration" return-type="void">
        <parameters>
          <parameter>long</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:383</id>
      <description>Gets the message priority level. The JMS API defines ten levels of priority value, with 0 as the lowest priority and 9 as the highest. In addition, clients should consider priorities 0-4 as gradations of normal priority and priorities 5-9 as gradations of expedited priority. The JMS API does not require that a provider strictly implement priority ordering of messages; however, it should do its best to deliver expedited messages ahead of normal messages.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="getJMSPriority" return-type="int"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:384</id>
      <description>if the JMS provider fails to get the message priority due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="getJMSPriority" return-type="int">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:385</id>
      <description>Sets the priority level for this message. This method is for use by JMS providers only to set this field when a message is sent. This message cannot be used by clients to configure the priority level of the message. This method is public to allow a JMS provider to set this field when sending a message whose implementation is not its own.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="setJMSPriority" return-type="void">
        <parameters>
          <parameter>int</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:386</id>
      <description>if the JMS provider fails to set the message priority due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="setJMSPriority" return-type="void">
        <parameters>
          <parameter>int</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:387</id>
      <description>Clears a message's properties. The message's header fields and body are not cleared.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="clearProperties" return-type="void"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:388</id>
      <description>if the JMS provider fails to clear the message properties due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="clearProperties" return-type="void">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:389</id>
      <description>Indicates whether a property value exists.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="propertyExists" return-type="boolean">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:390</id>
      <description>if the JMS provider fails to determine if the property exists due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="propertyExists" return-type="boolean">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:391</id>
      <description>Returns the value of the boolean property with the specified name.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="getBooleanProperty" return-type="boolean">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:392</id>
      <description>if the JMS provider fails to get the property value due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="getBooleanProperty" return-type="boolean">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:393</id>
      <description>Returns the value of the byte property with the specified name.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="getByteProperty" return-type="byte">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:394</id>
      <description>if the JMS provider fails to get the property value due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="getByteProperty" return-type="byte">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:395</id>
      <description>Returns the value of the short property with the specified name.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="getShortProperty" return-type="short">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:396</id>
      <description>if the JMS provider fails to get the property value due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="getShortProperty" return-type="short">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:397</id>
      <description>Returns the value of the int property with the specified name.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="getIntProperty" return-type="int">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:398</id>
      <description>if the JMS provider fails to get the property value due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="getIntProperty" return-type="int">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:399</id>
      <description>Returns the value of the long property with the specified name.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="getLongProperty" return-type="long">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:400</id>
      <description>if the JMS provider fails to get the property value due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="getLongProperty" return-type="long">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:401</id>
      <description>Returns the value of the float property with the specified name.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="getFloatProperty" return-type="float">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:402</id>
      <description>if the JMS provider fails to get the property value due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="getFloatProperty" return-type="float">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:403</id>
      <description>Returns the value of the double property with the specified name.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="getDoubleProperty" return-type="double">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:404</id>
      <description>if the JMS provider fails to get the property value due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="getDoubleProperty" return-type="double">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:405</id>
      <description>Returns the value of the String property with the specified name.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="getStringProperty" return-type="java.lang.String">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:406</id>
      <description>if the JMS provider fails to get the property value due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="getStringProperty" return-type="java.lang.String">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:407</id>
      <description>Returns the value of the Java object property with the specified name. This method can be used to return, in objectified format, an object that has been stored as a property in the message with the equivalent setObjectProperty method call, or its equivalent primitive settypeProperty method.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="getObjectProperty" return-type="java.lang.Object">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:408</id>
      <description>if the JMS provider fails to get the property value due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="getObjectProperty" return-type="java.lang.Object">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:409</id>
      <description>Returns an Enumeration of all the property names. Note that JMS standard header fields are not considered properties and are not returned in this enumeration.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="getPropertyNames" return-type="java.util.Enumeration"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:410</id>
      <description>if the JMS provider fails to get the property names due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="getPropertyNames" return-type="java.util.Enumeration">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:411</id>
      <description>Sets a boolean property value with the specified name into the message.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="setBooleanProperty" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>boolean</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:412</id>
      <description>if the JMS provider fails to set the property due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="setBooleanProperty" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>boolean</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:413</id>
      <description>Sets a byte property value with the specified name into the message.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="setByteProperty" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>byte</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:414</id>
      <description>if the JMS provider fails to set the property due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="setByteProperty" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>byte</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:415</id>
      <description>Sets a short property value with the specified name into the message.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="setShortProperty" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>short</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:416</id>
      <description>if the JMS provider fails to set the property due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="setShortProperty" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>short</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:417</id>
      <description>Sets an int property value with the specified name into the message.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="setIntProperty" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>int</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:418</id>
      <description>if the JMS provider fails to set the property due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="setIntProperty" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>int</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:419</id>
      <description>Sets a long property value with the specified name into the message.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="setLongProperty" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>long</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:420</id>
      <description>if the JMS provider fails to set the property due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="setLongProperty" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>long</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:421</id>
      <description>Sets a float property value with the specified name into the message.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="setFloatProperty" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>float</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:422</id>
      <description>if the JMS provider fails to set the property due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="setFloatProperty" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>float</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:423</id>
      <description>Sets a double property value with the specified name into the message.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="setDoubleProperty" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>double</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:424</id>
      <description>if the JMS provider fails to set the property due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="setDoubleProperty" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>double</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:425</id>
      <description>Sets a String property value with the specified name into the message.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="setStringProperty" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:426</id>
      <description>if the JMS provider fails to set the property due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="setStringProperty" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:427</id>
      <description>Sets a Java object property value with the specified name into the message. Note that this method works only for the objectified primitive object types (Integer, Double, Long ...) and String objects.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="setObjectProperty" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:428</id>
      <description>if the JMS provider fails to set the property due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="setObjectProperty" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:429</id>
      <description>Acknowledges all consumed messages of the session of this consumed message. All consumed JMS messages support the acknowledge method for use when a client has specified that its JMS session's consumed messages are to be explicitly acknowledged. By invoking acknowledge on a consumed message, a client acknowledges all messages consumed by the session that the message was delivered to. Calls to acknowledge are ignored for both transacted sessions and sessions specified to use implicit acknowledgement modes. A client may individually acknowledge each message as it is consumed, or it may choose to acknowledge messages as an application-defined group (which is done by calling acknowledge on the last received message of the group, thereby acknowledging all messages consumed by the session.) Messages that have been received but not acknowledged may be redelivered.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="acknowledge" return-type="void"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:430</id>
      <description>if the JMS provider fails to acknowledge the messages due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="acknowledge" return-type="void">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:431</id>
      <description>Clears out the message body. Clearing a message's body does not clear its header values or property entries. If this message body was read-only, calling this method leaves the message body in the same state as an empty body in a newly created message.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="clearBody" return-type="void"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:432</id>
      <description>if the JMS provider fails to clear the message body due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="clearBody" return-type="void">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:433</id>
      <description>Returns the boolean value with the specified name.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="getBoolean" return-type="boolean">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:434</id>
      <description>if the JMS provider fails to read the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="getBoolean" return-type="boolean">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:435</id>
      <description>Returns the byte value with the specified name.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="getByte" return-type="byte">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:436</id>
      <description>if the JMS provider fails to read the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="getByte" return-type="byte">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:437</id>
      <description>Returns the short value with the specified name.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="getShort" return-type="short">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:438</id>
      <description>if the JMS provider fails to read the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="getShort" return-type="short">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:439</id>
      <description>Returns the Unicode character value with the specified name.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="getChar" return-type="char">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:440</id>
      <description>if the JMS provider fails to read the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="getChar" return-type="char">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:441</id>
      <description>Returns the int value with the specified name.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="getInt" return-type="int">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:442</id>
      <description>if the JMS provider fails to read the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="getInt" return-type="int">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:443</id>
      <description>Returns the long value with the specified name.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="getLong" return-type="long">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:444</id>
      <description>if the JMS provider fails to read the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="getLong" return-type="long">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:445</id>
      <description>Returns the float value with the specified name.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="getFloat" return-type="float">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:446</id>
      <description>if the JMS provider fails to read the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="getFloat" return-type="float">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:447</id>
      <description>Returns the double value with the specified name.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="getDouble" return-type="double">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:448</id>
      <description>if the JMS provider fails to read the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="getDouble" return-type="double">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:449</id>
      <description>Returns the String value with the specified name.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="getString" return-type="java.lang.String">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:450</id>
      <description>if the JMS provider fails to read the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="getString" return-type="java.lang.String">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:451</id>
      <description>Returns the byte array value with the specified name.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="getBytes" return-type="byte[]">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:452</id>
      <description>if the JMS provider fails to read the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="getBytes" return-type="byte[]">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:453</id>
      <description>Returns the value of the object with the specified name. This method can be used to return, in objectified format, an object in the Java programming language ("Java object") that had been stored in the Map with the equivalent setObject method call, or its equivalent primitive settype method. Note that byte values are returned as byte[], not Byte[].</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="getObject" return-type="java.lang.Object">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:454</id>
      <description>if the JMS provider fails to read the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="getObject" return-type="java.lang.Object">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:455</id>
      <description>Returns an Enumeration of all the names in the MapMessage object.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="getMapNames" return-type="java.util.Enumeration"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:456</id>
      <description>if the JMS provider fails to read the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="getMapNames" return-type="java.util.Enumeration">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:457</id>
      <description>Sets a boolean value with the specified name into the Map.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="setBoolean" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>boolean</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:458</id>
      <description>if the JMS provider fails to write the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="setBoolean" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>boolean</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:459</id>
      <description>Sets a byte value with the specified name into the Map.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="setByte" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>byte</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:460</id>
      <description>if the JMS provider fails to write the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="setByte" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>byte</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:461</id>
      <description>Sets a short value with the specified name into the Map.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="setShort" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>short</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:462</id>
      <description>if the JMS provider fails to write the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="setShort" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>short</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:463</id>
      <description>Sets a Unicode character value with the specified name into the Map.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="setChar" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>char</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:464</id>
      <description>if the JMS provider fails to write the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="setChar" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>char</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:465</id>
      <description>Sets an int value with the specified name into the Map.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="setInt" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>int</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:466</id>
      <description>if the JMS provider fails to write the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="setInt" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>int</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:467</id>
      <description>Sets a long value with the specified name into the Map.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="setLong" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>long</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:468</id>
      <description>if the JMS provider fails to write the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="setLong" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>long</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:469</id>
      <description>Sets a float value with the specified name into the Map.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="setFloat" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>float</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:470</id>
      <description>if the JMS provider fails to write the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="setFloat" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>float</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:471</id>
      <description>Sets a double value with the specified name into the Map.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="setDouble" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>double</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:472</id>
      <description>if the JMS provider fails to write the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="setDouble" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>double</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:473</id>
      <description>Sets a String value with the specified name into the Map.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="setString" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:474</id>
      <description>if the JMS provider fails to write the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="setString" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:475</id>
      <description>Sets a byte array value with the specified name into the Map.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="setBytes" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>byte[]</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:476</id>
      <description>if the JMS provider fails to write the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="setBytes" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>byte[]</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:477</id>
      <description>Sets a portion of the byte array value with the specified name into the Map.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="setBytes" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>byte[]</parameter>
          <parameter>int</parameter>
          <parameter>int</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:478</id>
      <description>if the JMS provider fails to write the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="setBytes" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>byte[]</parameter>
          <parameter>int</parameter>
          <parameter>int</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:479</id>
      <description>Sets an object value with the specified name into the Map. This method works only for the objectified primitive object types (Integer, Double, Long ...), String objects, and byte arrays.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="setObject" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:480</id>
      <description>if the JMS provider fails to write the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="setObject" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:481</id>
      <description>Indicates whether an item exists in this MapMessage object.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="itemExists" return-type="boolean">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:482</id>
      <description>if the JMS provider fails to determine if the item exists due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="itemExists" return-type="boolean">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:483</id>
      <description>Notifies user of a JMS exception.</description>
      <package>jakarta.jms</package>
      <class-interface>ExceptionListener</class-interface>
      <method name="onException" return-type="void">
        <parameters>
          <parameter>jakarta.jms.JMSException</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:486</id>
      <description>Gets the JMS API version.</description>
      <package>jakarta.jms</package>
      <class-interface>ConnectionMetaData</class-interface>
      <method name="getJMSVersion" return-type="java.lang.String"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:487</id>
      <description>if the JMS provider fails to retrieve the metadata due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>ConnectionMetaData</class-interface>
      <method name="getJMSVersion" return-type="java.lang.String">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:488</id>
      <description>Gets the JMS major version number.</description>
      <package>jakarta.jms</package>
      <class-interface>ConnectionMetaData</class-interface>
      <method name="getJMSMajorVersion" return-type="int"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:489</id>
      <description>if the JMS provider fails to retrieve the metadata due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>ConnectionMetaData</class-interface>
      <method name="getJMSMajorVersion" return-type="int">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:490</id>
      <description>Gets the JMS minor version number.</description>
      <package>jakarta.jms</package>
      <class-interface>ConnectionMetaData</class-interface>
      <method name="getJMSMinorVersion" return-type="int"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:491</id>
      <description>if the JMS provider fails to retrieve the metadata due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>ConnectionMetaData</class-interface>
      <method name="getJMSMinorVersion" return-type="int">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:492</id>
      <description>Gets the JMS provider name.</description>
      <package>jakarta.jms</package>
      <class-interface>ConnectionMetaData</class-interface>
      <method name="getJMSProviderName" return-type="java.lang.String"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:493</id>
      <description>if the JMS provider fails to retrieve the metadata due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>ConnectionMetaData</class-interface>
      <method name="getJMSProviderName" return-type="java.lang.String">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:494</id>
      <description>Gets the JMS provider version.</description>
      <package>jakarta.jms</package>
      <class-interface>ConnectionMetaData</class-interface>
      <method name="getProviderVersion" return-type="java.lang.String"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:495</id>
      <description>if the JMS provider fails to retrieve the metadata due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>ConnectionMetaData</class-interface>
      <method name="getProviderVersion" return-type="java.lang.String">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:496</id>
      <description>Gets the JMS provider major version number.</description>
      <package>jakarta.jms</package>
      <class-interface>ConnectionMetaData</class-interface>
      <method name="getProviderMajorVersion" return-type="int"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:497</id>
      <description>if the JMS provider fails to retrieve the metadata due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>ConnectionMetaData</class-interface>
      <method name="getProviderMajorVersion" return-type="int">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:498</id>
      <description>Gets the JMS provider minor version number.</description>
      <package>jakarta.jms</package>
      <class-interface>ConnectionMetaData</class-interface>
      <method name="getProviderMinorVersion" return-type="int"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:499</id>
      <description>if the JMS provider fails to retrieve the metadata due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>ConnectionMetaData</class-interface>
      <method name="getProviderMinorVersion" return-type="int">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:500</id>
      <description>Gets an enumeration of the JMSX property names.</description>
      <package>jakarta.jms</package>
      <class-interface>ConnectionMetaData</class-interface>
      <method name="getJMSXPropertyNames" return-type="java.util.Enumeration"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:501</id>
      <description>if the JMS provider fails to retrieve the metadata due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>ConnectionMetaData</class-interface>
      <method name="getJMSXPropertyNames" return-type="java.util.Enumeration">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:502</id>
      <description>Creates a connection with the default user identity. The connection is created in stopped mode. No messages will be delivered until the Connection.start method is explicitly called.</description>
      <package>jakarta.jms</package>
      <class-interface>ConnectionFactory</class-interface>
      <method name="createConnection" return-type="jakarta.jms.Connection"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:503</id>
      <description>if the JMS provider fails to create the connection due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>ConnectionFactory</class-interface>
      <method name="createConnection" return-type="jakarta.jms.Connection">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:504</id>
      <description>Creates a connection with the specified user identity. The connection is created in stopped mode. No messages will be delivered until the Connection.start method is explicitly called.</description>
      <package>jakarta.jms</package>
      <class-interface>ConnectionFactory</class-interface>
      <method name="createConnection" return-type="jakarta.jms.Connection">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:505</id>
      <description>if the JMS provider fails to create the connection due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>ConnectionFactory</class-interface>
      <method name="createConnection" return-type="jakarta.jms.Connection">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:506</id>
      <description>Gets the server session pool associated with this connection consumer.</description>
      <package>jakarta.jms</package>
      <class-interface>ConnectionConsumer</class-interface>
      <method name="getServerSessionPool" return-type="jakarta.jms.ServerSessionPool"/>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:507</id>
      <description>if the JMS provider fails to get the server session pool associated with this consumer due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>ConnectionConsumer</class-interface>
      <method name="getServerSessionPool" return-type="jakarta.jms.ServerSessionPool">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:508</id>
      <description>Closes the connection consumer. Since a provider may allocate some resources on behalf of a connection consumer outside the Java virtual machine, clients should close these resources when they are not needed. Relying on garbage collection to eventually reclaim these resources may not be timely enough.</description>
      <package>jakarta.jms</package>
      <class-interface>ConnectionConsumer</class-interface>
      <method name="close" return-type="void"/>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:509</id>
      <description>if the JMS provider fails to release resources on behalf of the connection consumer or fails to close the connection consumer.</description>
      <package>jakarta.jms</package>
      <class-interface>ConnectionConsumer</class-interface>
      <method name="close" return-type="void">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:510</id>
      <description>Creates a Session object, specifying transacted and acknowledgeMode. This method has been superseded by the method createSession(int sessionMode) which specifies the same information using a single argument, and by the method createSession() which is for use in a Jakarta EE JTA transaction. Applications should consider using those methods instead of this one. The effect of setting the transacted and acknowledgeMode arguments depends on whether this method is called in a Java SE environment, in the Jakarta EE application client container, or in the Jakarta EE web or Enterprise Beans container. If this method is called in the Jakarta EE web or Enterprise Beans container then the effect of setting the transacted} and acknowledgeMode arguments also depends on whether or not there is an active JTA transaction in progress. In a Java SE environment or in the Jakarta EE application client container: If transacted is set to true then the session will use a local transaction which may subsequently be committed or rolled back by calling the session's commit or rollback methods. The argument acknowledgeMode is ignored. If transacted is set to false then the session will be non-transacted. In this case the argument acknowledgeMode is used to specify how messages received by this session will be acknowledged. The permitted values are Session.CLIENT_ACKNOWLEDGE, Session.AUTO_ACKNOWLEDGE and Session.DUPS_OK_ACKNOWLEDGE. For a definition of the meaning of these acknowledgement modes see the links below. In a Jakarta EE web or Enterprise Beans container, when there is an active JTA transaction in progress: Both arguments transacted and acknowledgeMode are ignored. The session will participate in the JTA transaction and will be committed or rolled back when that transaction is committed or rolled back, not by calling the session's commit or rollback methods. Since both arguments are ignored, developers are recommended to use createSession(), which has no arguments, instead of this method. In the Jakarta EE web or Enterprise Beans container, when there is no active JTA transaction in progress: The argument transacted is ignored. The session will always be non-transacted, using one of the two acknowledgement modes AUTO_ACKNOWLEDGE and DUPS_OK_ACKNOWLEDGE. The argument acknowledgeMode is used to specify how messages received by this session will be acknowledged. The only permitted values in this case are Session.AUTO_ACKNOWLEDGE and Session.DUPS_OK_ACKNOWLEDGE. The value Session.CLIENT_ACKNOWLEDGE may not be used. For a definition of the meaning of these acknowledgement modes see the links below. Applications running in the Jakarta EE web and Enterprise Beans containers must not attempt to create more than one active (not closed) Session object per connection. If this method is called in a Jakarta EE web or Enterprise Beans container when an active Session object already exists for this connection then a JMSException will be thrown.</description>
      <package>jakarta.jms</package>
      <class-interface>Connection</class-interface>
      <method name="createSession" return-type="jakarta.jms.Session">
        <parameters>
          <parameter>boolean</parameter>
          <parameter>int</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:511</id>
      <description>if the Connection object fails to create a session due to some internal error, lack of support for the specific transaction and acknowledgement mode, or because this method is being called in a Jakarta EE web or Enterprise Beans application and an active session already exists for this connection.</description>
      <package>jakarta.jms</package>
      <class-interface>Connection</class-interface>
      <method name="createSession" return-type="jakarta.jms.Session">
        <parameters>
          <parameter>boolean</parameter>
          <parameter>int</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:512</id>
      <description>Gets the client identifier for this connection. This value is specific to the JMS provider. It is either preconfigured by an administrator in a ConnectionFactory object or assigned dynamically by the application by calling the setClientID method.</description>
      <package>jakarta.jms</package>
      <class-interface>Connection</class-interface>
      <method name="getClientID" return-type="java.lang.String"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:513</id>
      <description>if the JMS provider fails to return the client ID for this connection due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Connection</class-interface>
      <method name="getClientID" return-type="java.lang.String">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:514</id>
      <description>Sets the client identifier for this connection. The preferred way to assign a JMS client's client identifier is for it to be configured in a client-specific ConnectionFactory object and transparently assigned to the Connection object it creates. Alternatively, a client can set a connection's client identifier using a provider-specific value. The facility to set a connection's client identifier explicitly is not a mechanism for overriding the identifier that has been administratively configured. It is provided for the case where no administratively specified identifier exists. If one does exist, an attempt to change it by setting it must throw an IllegalStateException. If a client sets the client identifier explicitly, it must do so immediately after it creates the connection and before any other action on the connection is taken. After this point, setting the client identifier is a programming error that should throw an IllegalStateException. The purpose of the client identifier is to associate a connection and its objects with a state maintained on behalf of the client by a provider. The only such state identified by the JMS API is that required to support durable subscriptions. If another connection with the same clientID is already running when this method is called, the JMS provider should detect the duplicate ID and throw an InvalidClientIDException. This method must not be used in a Jakarta EE web or Enterprise Beans application. Doing so may cause a JMSException to be thrown though this is not guaranteed.</description>
      <package>jakarta.jms</package>
      <class-interface>Connection</class-interface>
      <method name="setClientID" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:515</id>
      <description>if the JMS provider fails to set the client ID for the the connection for one of the following reasons: an internal error has occurred or this method has been called in a Jakarta EE web or Enterprise Beans application (though it is not guaranteed that an exception is thrown in this case)</description>
      <package>jakarta.jms</package>
      <class-interface>Connection</class-interface>
      <method name="setClientID" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:516</id>
      <description>Gets the metadata for this connection.</description>
      <package>jakarta.jms</package>
      <class-interface>Connection</class-interface>
      <method name="getMetaData" return-type="jakarta.jms.ConnectionMetaData"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:517</id>
      <description>if the JMS provider fails to get the connection metadata for this connection.</description>
      <package>jakarta.jms</package>
      <class-interface>Connection</class-interface>
      <method name="getMetaData" return-type="jakarta.jms.ConnectionMetaData">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:518</id>
      <description>Gets the ExceptionListener object for this connection. Not every Connection has an ExceptionListener associated with it.</description>
      <package>jakarta.jms</package>
      <class-interface>Connection</class-interface>
      <method name="getExceptionListener" return-type="jakarta.jms.ExceptionListener"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:519</id>
      <description>if the JMS provider fails to get the ExceptionListener for this connection.</description>
      <package>jakarta.jms</package>
      <class-interface>Connection</class-interface>
      <method name="getExceptionListener" return-type="jakarta.jms.ExceptionListener">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:520</id>
      <description>Sets an exception listener for this connection. If a JMS provider detects a serious problem with a connection, it informs the connection's ExceptionListener, if one has been registered. It does this by calling the listener's onException method, passing it a JMSException object describing the problem. An exception listener allows a client to be notified of a problem asynchronously. Some connections only consume messages, so they would have no other way to learn their connection has failed. A connection serializes execution of its ExceptionListener. A JMS provider should attempt to resolve connection problems itself before it notifies the client of them. This method must not be used in a Jakarta EE web or Enterprise Beans application. Doing so may cause a JMSException to be thrown though this is not guaranteed.</description>
      <package>jakarta.jms</package>
      <class-interface>Connection</class-interface>
      <method name="setExceptionListener" return-type="void">
        <parameters>
          <parameter>jakarta.jms.ExceptionListener</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:521</id>
      <description>if the JMS provider fails to set the exception listener for one of the following reasons: an internal error has occurred or this method has been called in a Jakarta EE web or Enterprise Beans application (though it is not guaranteed that an exception is thrown in this case)</description>
      <package>jakarta.jms</package>
      <class-interface>Connection</class-interface>
      <method name="setExceptionListener" return-type="void">
        <parameters>
          <parameter>jakarta.jms.ExceptionListener</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:522</id>
      <description>Starts (or restarts) a connection's delivery of incoming messages. A call to start on a connection that has already been started is ignored.</description>
      <package>jakarta.jms</package>
      <class-interface>Connection</class-interface>
      <method name="start" return-type="void"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:523</id>
      <description>if the JMS provider fails to start message delivery due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Connection</class-interface>
      <method name="start" return-type="void">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:524</id>
      <description>Temporarily stops a connection's delivery of incoming messages. Delivery can be restarted using the connection's start method. When the connection is stopped, delivery to all the connection's message consumers is inhibited: synchronous receives block, and messages are not delivered to message listeners. This call blocks until receives and/or message listeners in progress have completed. Stopping a connection has no effect on its ability to send messages. A call to stop on a connection that has already been stopped is ignored. A call to stop must not return until delivery of messages has paused. This means that a client can rely on the fact that none of its message listeners will be called and that all threads of control waiting for receive calls to return will not return with a message until the connection is restarted. The receive timers for a stopped connection continue to advance, so receives may time out while the connection is stopped. If message listeners are running when stop is invoked, the stop call must wait until all of them have returned before it may return. While these message listeners are completing, they must have the full services of the connection available to them. A message listener must not attempt to stop its own connection as this would lead to deadlock. The JMS provider must detect this and throw a IllegalStateException. For the avoidance of doubt, if an exception listener for this connection is running when stop is invoked, there is no requirement for the stop call to wait until the exception listener has returned before it may return. This method must not be used in a Jakarta EE web or Enterprise Beans application. Doing so may cause a JMSException to be thrown though this is not guaranteed.</description>
      <package>jakarta.jms</package>
      <class-interface>Connection</class-interface>
      <method name="stop" return-type="void"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:525</id>
      <description>if the JMS provider fails to stop message delivery for one of the following reasons: an internal error has occurred or this method has been called in a Jakarta EE web or Enterprise Beans application (though it is not guaranteed that an exception is thrown in this case)</description>
      <package>jakarta.jms</package>
      <class-interface>Connection</class-interface>
      <method name="stop" return-type="void">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:526</id>
      <description>Closes the connection. Since a provider typically allocates significant resources outside the JVM on behalf of a connection, clients should close these resources when they are not needed. Relying on garbage collection to eventually reclaim these resources may not be timely enough. There is no need to close the sessions, producers, and consumers of a closed connection. Closing a connection causes all temporary destinations to be deleted. When this method is invoked, it should not return until message processing has been shut down in an orderly fashion. This means that all message listeners that may have been running have returned, and that all pending receives have returned. A close terminates all pending message receives on the connection's sessions' consumers. The receives may return with a message or with null, depending on whether there was a message available at the time of the close. If one or more of the connection's sessions' message listeners is processing a message at the time when connection close is invoked, all the facilities of the connection and its sessions must remain available to those listeners until they return control to the JMS provider. This method must not return until any incomplete asynchronous send operations for this Connection have been completed and any CompletionListener callbacks have returned. Incomplete sends should be allowed to complete normally unless an error occurs. For the avoidance of doubt, if an exception listener for this connection is running when close is invoked, there is no requirement for the close call to wait until the exception listener has returned before it may return. Closing a connection causes any of its sessions' transactions in progress to be rolled back. In the case where a session's work is coordinated by an external transaction manager, a session's commit and rollback methods are not used and the result of a closed session's work is determined later by the transaction manager. Closing a connection does NOT force an acknowledgment of client-acknowledged sessions. A message listener must not attempt to close its own connection as this would lead to deadlock. The JMS provider must detect this and throw a IllegalStateException. A CompletionListener callback method must not call close on its own Connection. Doing so will cause an IllegalStateException to be thrown. Invoking the acknowledge method of a received message from a closed connection's session must throw an IllegalStateException. Closing a closed connection must NOT throw an exception.</description>
      <package>jakarta.jms</package>
      <class-interface>Connection</class-interface>
      <method name="close" return-type="void"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:527</id>
      <description>if the JMS provider fails to close the connection due to some internal error. For example, a failure to release resources or to close a socket connection can cause this exception to be thrown.</description>
      <package>jakarta.jms</package>
      <class-interface>Connection</class-interface>
      <method name="close" return-type="void">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:528</id>
      <description>Creates a connection consumer for this connection (optional operation) on the specific destination. This is an expert facility not used by ordinary JMS clients. This method must not be used in a Jakarta EE web or Enterprise Beans application. Doing so may cause a JMSException to be thrown though this is not guaranteed.</description>
      <package>jakarta.jms</package>
      <class-interface>Connection</class-interface>
      <method name="createConnectionConsumer" return-type="jakarta.jms.ConnectionConsumer">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>jakarta.jms.ServerSessionPool</parameter>
          <parameter>int</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:529</id>
      <description>if the Connection object fails to create a connection consumer for one of the following reasons: an internal error has occurred invalid arguments for sessionPool and messageSelector or this method has been called in a Jakarta EE web or Enterprise Beans application (though it is not guaranteed that an exception is thrown in this case)</description>
      <package>jakarta.jms</package>
      <class-interface>Connection</class-interface>
      <method name="createConnectionConsumer" return-type="jakarta.jms.ConnectionConsumer">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>jakarta.jms.ServerSessionPool</parameter>
          <parameter>int</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:530</id>
      <description>Creates a connection consumer for this connection (optional operation) on the specific topic using an unshared durable subscription with the specified name. This is an expert facility not used by ordinary JMS clients. This method must not be used in a Jakarta EE web or Enterprise Beans application. Doing so may cause a JMSException to be thrown though this is not guaranteed.</description>
      <package>jakarta.jms</package>
      <class-interface>Connection</class-interface>
      <method name="createDurableConnectionConsumer" return-type="jakarta.jms.ConnectionConsumer">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>jakarta.jms.ServerSessionPool</parameter>
          <parameter>int</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:531</id>
      <description>if the Connection object fails to create a connection consumer for one of the following reasons: an internal error has occurred invalid arguments for sessionPool and messageSelector or this method has been called in a Jakarta EE web or Enterprise Beans application (though it is not guaranteed that an exception is thrown in this case)</description>
      <package>jakarta.jms</package>
      <class-interface>Connection</class-interface>
      <method name="createDurableConnectionConsumer" return-type="jakarta.jms.ConnectionConsumer">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>jakarta.jms.ServerSessionPool</parameter>
          <parameter>int</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:532</id>
      <description>Gets the number of bytes of the message body when the message is in read-only mode. The value returned can be used to allocate a byte array. The value returned is the entire length of the message body, regardless of where the pointer for reading the message is currently located.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="getBodyLength" return-type="long"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:533</id>
      <description>if the JMS provider fails to read the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="getBodyLength" return-type="long">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:534</id>
      <description>Reads a boolean from the bytes message stream.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="readBoolean" return-type="boolean"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:535</id>
      <description>if the JMS provider fails to read the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="readBoolean" return-type="boolean">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:536</id>
      <description>Reads a signed 8-bit value from the bytes message stream.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="readByte" return-type="byte"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:537</id>
      <description>if the JMS provider fails to read the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="readByte" return-type="byte">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:538</id>
      <description>Reads an unsigned 8-bit number from the bytes message stream.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="readUnsignedByte" return-type="int"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:539</id>
      <description>if the JMS provider fails to read the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="readUnsignedByte" return-type="int">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:540</id>
      <description>Reads a signed 16-bit number from the bytes message stream.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="readShort" return-type="short"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:541</id>
      <description>if the JMS provider fails to read the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="readShort" return-type="short">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:542</id>
      <description>Reads an unsigned 16-bit number from the bytes message stream.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="readUnsignedShort" return-type="int"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:543</id>
      <description>if the JMS provider fails to read the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="readUnsignedShort" return-type="int">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:544</id>
      <description>Reads a Unicode character value from the bytes message stream.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="readChar" return-type="char"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:545</id>
      <description>if the JMS provider fails to read the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="readChar" return-type="char">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:546</id>
      <description>Reads a signed 32-bit integer from the bytes message stream.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="readInt" return-type="int"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:547</id>
      <description>if the JMS provider fails to read the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="readInt" return-type="int">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:548</id>
      <description>Reads a signed 64-bit integer from the bytes message stream.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="readLong" return-type="long"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:549</id>
      <description>if the JMS provider fails to read the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="readLong" return-type="long">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:550</id>
      <description>Reads a float from the bytes message stream.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="readFloat" return-type="float"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:551</id>
      <description>if the JMS provider fails to read the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="readFloat" return-type="float">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:552</id>
      <description>Reads a double from the bytes message stream.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="readDouble" return-type="double"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:553</id>
      <description>if the JMS provider fails to read the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="readDouble" return-type="double">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:554</id>
      <description>Reads a string that has been encoded using a modified UTF-8 format from the bytes message stream. For more information on the UTF-8 format, see "File System Safe UCS Transformation Format (FSS_UTF)", X/Open Preliminary Specification, X/Open Company Ltd., Document Number: P316. This information also appears in ISO/IEC 10646, Annex P.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="readUTF" return-type="java.lang.String"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:555</id>
      <description>if the JMS provider fails to read the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="readUTF" return-type="java.lang.String">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:556</id>
      <description>Reads a byte array from the bytes message stream. If the length of array value is less than the number of bytes remaining to be read from the stream, the array should be filled. A subsequent call reads the next increment, and so on. If the number of bytes remaining in the stream is less than the length of array value, the bytes should be read into the array. The return value of the total number of bytes read will be less than the length of the array, indicating that there are no more bytes left to be read from the stream. The next read of the stream returns -1.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="readBytes" return-type="int">
        <parameters>
          <parameter>byte[]</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:557</id>
      <description>if the JMS provider fails to read the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="readBytes" return-type="int">
        <parameters>
          <parameter>byte[]</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:558</id>
      <description>Reads a portion of the bytes message stream. If the length of array value is less than the number of bytes remaining to be read from the stream, the array should be filled. A subsequent call reads the next increment, and so on. If the number of bytes remaining in the stream is less than the length of array value, the bytes should be read into the array. The return value of the total number of bytes read will be less than the length of the array, indicating that there are no more bytes left to be read from the stream. The next read of the stream returns -1. If length is negative, or length is greater than the length of the array value, then an IndexOutOfBoundsException is thrown. No bytes will be read from the stream for this exception case.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="readBytes" return-type="int">
        <parameters>
          <parameter>byte[]</parameter>
          <parameter>int</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:559</id>
      <description>if the JMS provider fails to read the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="readBytes" return-type="int">
        <parameters>
          <parameter>byte[]</parameter>
          <parameter>int</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:560</id>
      <description>Writes a boolean to the bytes message stream as a 1-byte value. The value true is written as the value (byte)1; the value false is written as the value (byte)0.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="writeBoolean" return-type="void">
        <parameters>
          <parameter>boolean</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:561</id>
      <description>if the JMS provider fails to write the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="writeBoolean" return-type="void">
        <parameters>
          <parameter>boolean</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:562</id>
      <description>Writes a byte to the bytes message stream as a 1-byte value.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="writeByte" return-type="void">
        <parameters>
          <parameter>byte</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:563</id>
      <description>if the JMS provider fails to write the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="writeByte" return-type="void">
        <parameters>
          <parameter>byte</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:564</id>
      <description>Writes a short to the bytes message stream as two bytes, high byte first.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="writeShort" return-type="void">
        <parameters>
          <parameter>short</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:565</id>
      <description>if the JMS provider fails to write the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="writeShort" return-type="void">
        <parameters>
          <parameter>short</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:566</id>
      <description>Writes a char to the bytes message stream as a 2-byte value, high byte first.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="writeChar" return-type="void">
        <parameters>
          <parameter>char</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:567</id>
      <description>if the JMS provider fails to write the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="writeChar" return-type="void">
        <parameters>
          <parameter>char</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:568</id>
      <description>Writes an int to the bytes message stream as four bytes, high byte first.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="writeInt" return-type="void">
        <parameters>
          <parameter>int</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:569</id>
      <description>if the JMS provider fails to write the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="writeInt" return-type="void">
        <parameters>
          <parameter>int</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:570</id>
      <description>Writes a long to the bytes message stream as eight bytes, high byte first.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="writeLong" return-type="void">
        <parameters>
          <parameter>long</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:571</id>
      <description>if the JMS provider fails to write the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="writeLong" return-type="void">
        <parameters>
          <parameter>long</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:572</id>
      <description>Converts the float argument to an int using the floatToIntBits method in class Float, and then writes that int value to the bytes message stream as a 4-byte quantity, high byte first.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="writeFloat" return-type="void">
        <parameters>
          <parameter>float</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:573</id>
      <description>if the JMS provider fails to write the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="writeFloat" return-type="void">
        <parameters>
          <parameter>float</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:574</id>
      <description>Converts the double argument to a long using the doubleToLongBits method in class Double, and then writes that long value to the bytes message stream as an 8-byte quantity, high byte first.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="writeDouble" return-type="void">
        <parameters>
          <parameter>double</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:575</id>
      <description>if the JMS provider fails to write the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="writeDouble" return-type="void">
        <parameters>
          <parameter>double</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:576</id>
      <description>Writes a string to the bytes message stream using UTF-8 encoding in a machine-independent manner. For more information on the UTF-8 format, see "File System Safe UCS Transformation Format (FSS_UTF)", X/Open Preliminary Specification, X/Open Company Ltd., Document Number: P316. This information also appears in ISO/IEC 10646, Annex P.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="writeUTF" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:577</id>
      <description>if the JMS provider fails to write the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="writeUTF" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:578</id>
      <description>Writes a byte array to the bytes message stream.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="writeBytes" return-type="void">
        <parameters>
          <parameter>byte[]</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:579</id>
      <description>if the JMS provider fails to write the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="writeBytes" return-type="void">
        <parameters>
          <parameter>byte[]</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:580</id>
      <description>Writes a portion of a byte array to the bytes message stream.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="writeBytes" return-type="void">
        <parameters>
          <parameter>byte[]</parameter>
          <parameter>int</parameter>
          <parameter>int</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:581</id>
      <description>if the JMS provider fails to write the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="writeBytes" return-type="void">
        <parameters>
          <parameter>byte[]</parameter>
          <parameter>int</parameter>
          <parameter>int</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:582</id>
      <description>Writes an object to the bytes message stream. This method works only for the objectified primitive object types (Integer, Double, Long ...), String objects, and byte arrays.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="writeObject" return-type="void">
        <parameters>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:583</id>
      <description>if the JMS provider fails to write the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="writeObject" return-type="void">
        <parameters>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:584</id>
      <description>Puts the message body in read-only mode and repositions the stream of bytes to the beginning.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="reset" return-type="void"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:585</id>
      <description>if the JMS provider fails to reset the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="reset" return-type="void">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:587</id>
      <description>if client authentication fails due to an invalid user name or password.</description>
      <package>jakarta.jms</package>
      <class-interface>XAQueueConnectionFactory</class-interface>
      <method name="createXAQueueConnection" return-type="jakarta.jms.XAQueueConnection">
        <throw>jakarta.jms.JMSSecurityException</throw>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:588</id>
      <description>if client authentication fails due to an invalid user name or password.</description>
      <package>jakarta.jms</package>
      <class-interface>XAQueueConnectionFactory</class-interface>
      <method name="createXAQueueConnection" return-type="jakarta.jms.XAQueueConnection">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSSecurityException</throw>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:589</id>
      <description>if client authentication fails due to an invalid user name or password.</description>
      <package>jakarta.jms</package>
      <class-interface>XATopicConnectionFactory</class-interface>
      <method name="createXATopicConnection" return-type="jakarta.jms.XATopicConnection">
        <throw>jakarta.jms.JMSSecurityException</throw>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:590</id>
      <description>if client authentication fails due to an invalid user name or password.</description>
      <package>jakarta.jms</package>
      <class-interface>XATopicConnectionFactory</class-interface>
      <method name="createXATopicConnection" return-type="jakarta.jms.XATopicConnection">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSSecurityException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:591</id>
      <description>if client authentication fails due to an invalid user name or password.</description>
      <package>jakarta.jms</package>
      <class-interface>TopicConnectionFactory</class-interface>
      <method name="createTopicConnection" return-type="jakarta.jms.TopicConnection">
        <throw>jakarta.jms.JMSSecurityException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:592</id>
      <description>if client authentication fails due to an invalid user name or password.</description>
      <package>jakarta.jms</package>
      <class-interface>TopicConnectionFactory</class-interface>
      <method name="createTopicConnection" return-type="jakarta.jms.TopicConnection">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSSecurityException</throw>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:593</id>
      <description>if client authentication fails due to an invalid user name or password.</description>
      <package>jakarta.jms</package>
      <class-interface>XAConnectionFactory</class-interface>
      <method name="createXAConnection" return-type="jakarta.jms.XAConnection">
        <throw>jakarta.jms.JMSSecurityException</throw>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:594</id>
      <description>if client authentication fails due to an invalid user name or password.</description>
      <package>jakarta.jms</package>
      <class-interface>XAConnectionFactory</class-interface>
      <method name="createXAConnection" return-type="jakarta.jms.XAConnection">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSSecurityException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:595</id>
      <description>if client authentication fails due to an invalid user name or password.</description>
      <package>jakarta.jms</package>
      <class-interface>QueueConnectionFactory</class-interface>
      <method name="createQueueConnection" return-type="jakarta.jms.QueueConnection">
        <throw>jakarta.jms.JMSSecurityException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:596</id>
      <description>if client authentication fails due to an invalid user name or password.</description>
      <package>jakarta.jms</package>
      <class-interface>QueueConnectionFactory</class-interface>
      <method name="createQueueConnection" return-type="jakarta.jms.QueueConnection">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSSecurityException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:597</id>
      <description>if an invalid message is specified.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageProducer</class-interface>
      <method name="send" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Message</parameter>
        </parameters>
        <throw>jakarta.jms.MessageFormatException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:598</id>
      <description>if a client uses this method with a MessageProducer with an invalid destination.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageProducer</class-interface>
      <method name="send" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Message</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidDestinationException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:599</id>
      <description>if a client uses this method with a MessageProducer that did not specify a destination at creation time.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageProducer</class-interface>
      <method name="send" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Message</parameter>
        </parameters>
        <throw>java.lang.UnsupportedOperationException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:600</id>
      <description>if an invalid message is specified.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageProducer</class-interface>
      <method name="send" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Message</parameter>
          <parameter>int</parameter>
          <parameter>int</parameter>
          <parameter>long</parameter>
        </parameters>
        <throw>jakarta.jms.MessageFormatException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:601</id>
      <description>if a client uses this method with a MessageProducer with an invalid destination.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageProducer</class-interface>
      <method name="send" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Message</parameter>
          <parameter>int</parameter>
          <parameter>int</parameter>
          <parameter>long</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidDestinationException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:602</id>
      <description>if a client uses this method with a MessageProducer that did not specify a destination at creation time.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageProducer</class-interface>
      <method name="send" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Message</parameter>
          <parameter>int</parameter>
          <parameter>int</parameter>
          <parameter>long</parameter>
        </parameters>
        <throw>java.lang.UnsupportedOperationException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:603</id>
      <description>if an invalid message is specified.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageProducer</class-interface>
      <method name="send" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
          <parameter>jakarta.jms.Message</parameter>
        </parameters>
        <throw>jakarta.jms.MessageFormatException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:604</id>
      <description>if a client uses this method with an invalid destination.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageProducer</class-interface>
      <method name="send" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
          <parameter>jakarta.jms.Message</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidDestinationException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:605</id>
      <description>if a client uses this method with a MessageProducer that specified a destination at creation time.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageProducer</class-interface>
      <method name="send" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
          <parameter>jakarta.jms.Message</parameter>
        </parameters>
        <throw>java.lang.UnsupportedOperationException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:606</id>
      <description>if an invalid message is specified.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageProducer</class-interface>
      <method name="send" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
          <parameter>jakarta.jms.Message</parameter>
          <parameter>int</parameter>
          <parameter>int</parameter>
          <parameter>long</parameter>
        </parameters>
        <throw>jakarta.jms.MessageFormatException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:607</id>
      <description>if a client uses this method with an invalid destination.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageProducer</class-interface>
      <method name="send" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
          <parameter>jakarta.jms.Message</parameter>
          <parameter>int</parameter>
          <parameter>int</parameter>
          <parameter>long</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidDestinationException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:608</id>
      <description>if client authentication fails due to an invalid user name or password.</description>
      <package>jakarta.jms</package>
      <class-interface>ConnectionFactory</class-interface>
      <method name="createConnection" return-type="jakarta.jms.Connection">
        <throw>jakarta.jms.JMSSecurityException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:609</id>
      <description>if client authentication fails due to an invalid user name or password.</description>
      <package>jakarta.jms</package>
      <class-interface>ConnectionFactory</class-interface>
      <method name="createConnection" return-type="jakarta.jms.Connection">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSSecurityException</throw>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:610</id>
      <description>if the method is called on an XASession.</description>
      <package>jakarta.jms</package>
      <class-interface>XASession</class-interface>
      <method name="commit" return-type="void">
        <throw>jakarta.jms.TransactionInProgressException</throw>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:611</id>
      <description>if the method is called on an XASession.</description>
      <package>jakarta.jms</package>
      <class-interface>XASession</class-interface>
      <method name="rollback" return-type="void">
        <throw>jakarta.jms.TransactionInProgressException</throw>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:612</id>
      <description>if an invalid topic is specified.</description>
      <package>jakarta.jms</package>
      <class-interface>TopicConnection</class-interface>
      <method name="createConnectionConsumer" return-type="jakarta.jms.ConnectionConsumer">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>jakarta.jms.ServerSessionPool</parameter>
          <parameter>int</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidDestinationException</throw>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:613</id>
      <description>if the message selector is invalid.</description>
      <package>jakarta.jms</package>
      <class-interface>TopicConnection</class-interface>
      <method name="createConnectionConsumer" return-type="jakarta.jms.ConnectionConsumer">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>jakarta.jms.ServerSessionPool</parameter>
          <parameter>int</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidSelectorException</throw>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:614</id>
      <description>if an invalid topic is specified.</description>
      <package>jakarta.jms</package>
      <class-interface>TopicConnection</class-interface>
      <method name="createDurableConnectionConsumer" return-type="jakarta.jms.ConnectionConsumer">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>jakarta.jms.ServerSessionPool</parameter>
          <parameter>int</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidDestinationException</throw>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:615</id>
      <description>if the message selector is invalid.</description>
      <package>jakarta.jms</package>
      <class-interface>TopicConnection</class-interface>
      <method name="createDurableConnectionConsumer" return-type="jakarta.jms.ConnectionConsumer">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>jakarta.jms.ServerSessionPool</parameter>
          <parameter>int</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidSelectorException</throw>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:616</id>
      <description>if an invalid queue is specified.</description>
      <package>jakarta.jms</package>
      <class-interface>QueueConnection</class-interface>
      <method name="createConnectionConsumer" return-type="jakarta.jms.ConnectionConsumer">
        <parameters>
          <parameter>jakarta.jms.Queue</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>jakarta.jms.ServerSessionPool</parameter>
          <parameter>int</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidDestinationException</throw>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:617</id>
      <description>if the message selector is invalid.</description>
      <package>jakarta.jms</package>
      <class-interface>QueueConnection</class-interface>
      <method name="createConnectionConsumer" return-type="jakarta.jms.ConnectionConsumer">
        <parameters>
          <parameter>jakarta.jms.Queue</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>jakarta.jms.ServerSessionPool</parameter>
          <parameter>int</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidSelectorException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:618</id>
      <description>if an invalid queue is specified.</description>
      <package>jakarta.jms</package>
      <class-interface>QueueSession</class-interface>
      <method name="createReceiver" return-type="jakarta.jms.QueueReceiver">
        <parameters>
          <parameter>jakarta.jms.Queue</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidDestinationException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:619</id>
      <description>if an invalid queue is specified.</description>
      <package>jakarta.jms</package>
      <class-interface>QueueSession</class-interface>
      <method name="createReceiver" return-type="jakarta.jms.QueueReceiver">
        <parameters>
          <parameter>jakarta.jms.Queue</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidDestinationException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:620</id>
      <description>if the message selector is invalid.</description>
      <package>jakarta.jms</package>
      <class-interface>QueueSession</class-interface>
      <method name="createReceiver" return-type="jakarta.jms.QueueReceiver">
        <parameters>
          <parameter>jakarta.jms.Queue</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidSelectorException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:621</id>
      <description>if an invalid queue is specified.</description>
      <package>jakarta.jms</package>
      <class-interface>QueueSession</class-interface>
      <method name="createSender" return-type="jakarta.jms.QueueSender">
        <parameters>
          <parameter>jakarta.jms.Queue</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidDestinationException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:622</id>
      <description>if an invalid queue is specified.</description>
      <package>jakarta.jms</package>
      <class-interface>QueueSession</class-interface>
      <method name="createBrowser" return-type="jakarta.jms.QueueBrowser">
        <parameters>
          <parameter>jakarta.jms.Queue</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidDestinationException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:623</id>
      <description>if an invalid queue is specified.</description>
      <package>jakarta.jms</package>
      <class-interface>QueueSession</class-interface>
      <method name="createBrowser" return-type="jakarta.jms.QueueBrowser">
        <parameters>
          <parameter>jakarta.jms.Queue</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidDestinationException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:624</id>
      <description>if the message selector is invalid.</description>
      <package>jakarta.jms</package>
      <class-interface>QueueSession</class-interface>
      <method name="createBrowser" return-type="jakarta.jms.QueueBrowser">
        <parameters>
          <parameter>jakarta.jms.Queue</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidSelectorException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:625</id>
      <description>if an invalid topic is specified.</description>
      <package>jakarta.jms</package>
      <class-interface>TopicSession</class-interface>
      <method name="createSubscriber" return-type="jakarta.jms.TopicSubscriber">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidDestinationException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:626</id>
      <description>if an invalid topic is specified.</description>
      <package>jakarta.jms</package>
      <class-interface>TopicSession</class-interface>
      <method name="createSubscriber" return-type="jakarta.jms.TopicSubscriber">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>boolean</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidDestinationException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:627</id>
      <description>if the message selector is invalid.</description>
      <package>jakarta.jms</package>
      <class-interface>TopicSession</class-interface>
      <method name="createSubscriber" return-type="jakarta.jms.TopicSubscriber">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>boolean</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidSelectorException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:628</id>
      <description>if an invalid topic is specified.</description>
      <package>jakarta.jms</package>
      <class-interface>TopicSession</class-interface>
      <method name="createDurableSubscriber" return-type="jakarta.jms.TopicSubscriber">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidDestinationException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:629</id>
      <description>if an invalid topic is specified.</description>
      <package>jakarta.jms</package>
      <class-interface>TopicSession</class-interface>
      <method name="createDurableSubscriber" return-type="jakarta.jms.TopicSubscriber">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>boolean</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidDestinationException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:630</id>
      <description>if the message selector is invalid.</description>
      <package>jakarta.jms</package>
      <class-interface>TopicSession</class-interface>
      <method name="createDurableSubscriber" return-type="jakarta.jms.TopicSubscriber">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>boolean</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidSelectorException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:631</id>
      <description>if an invalid topic is specified.</description>
      <package>jakarta.jms</package>
      <class-interface>TopicSession</class-interface>
      <method name="createPublisher" return-type="jakarta.jms.TopicPublisher">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidDestinationException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:632</id>
      <description>if an invalid subscription name is specified.</description>
      <package>jakarta.jms</package>
      <class-interface>TopicSession</class-interface>
      <method name="unsubscribe" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidDestinationException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:633</id>
      <description>if the transaction is rolled back due to some internal error during commit.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="commit" return-type="void">
        <throw>jakarta.jms.TransactionRolledBackException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:634</id>
      <description>the session is not using a local transaction this method has been called by a CompletionListener callback method on its own Session</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="commit" return-type="void">
        <throw>jakarta.jms.IllegalStateException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:635</id>
      <description>the session is not using a local transaction this method has been called by a CompletionListener callback method on its own Session</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="rollback" return-type="void">
        <throw>jakarta.jms.IllegalStateException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:636</id>
      <description>if the method is called by a transacted session.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="recover" return-type="void">
        <throw>jakarta.jms.IllegalStateException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:637</id>
      <description>if an invalid destination is specified.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createProducer" return-type="jakarta.jms.MessageProducer">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidDestinationException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:638</id>
      <description>if an invalid destination is specified.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createConsumer" return-type="jakarta.jms.MessageConsumer">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidDestinationException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:639</id>
      <description>if an invalid destination is specified.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createConsumer" return-type="jakarta.jms.MessageConsumer">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidDestinationException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:640</id>
      <description>if the message selector is invalid.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createConsumer" return-type="jakarta.jms.MessageConsumer">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidSelectorException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:641</id>
      <description>if an invalid destination is specified.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createConsumer" return-type="jakarta.jms.MessageConsumer">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>boolean</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidDestinationException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:642</id>
      <description>if the message selector is invalid.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createConsumer" return-type="jakarta.jms.MessageConsumer">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>boolean</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidSelectorException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:643</id>
      <description>if an invalid topic is specified.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createDurableSubscriber" return-type="jakarta.jms.TopicSubscriber">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidDestinationException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:644</id>
      <description>if an invalid topic is specified.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createDurableSubscriber" return-type="jakarta.jms.TopicSubscriber">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>boolean</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidDestinationException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:645</id>
      <description>if the message selector is invalid.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createDurableSubscriber" return-type="jakarta.jms.TopicSubscriber">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>boolean</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidSelectorException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:646</id>
      <description>if an invalid destination is specified</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createBrowser" return-type="jakarta.jms.QueueBrowser">
        <parameters>
          <parameter>jakarta.jms.Queue</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidDestinationException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:647</id>
      <description>if an invalid destination is specified</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createBrowser" return-type="jakarta.jms.QueueBrowser">
        <parameters>
          <parameter>jakarta.jms.Queue</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidDestinationException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:648</id>
      <description>if the message selector is invalid.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createBrowser" return-type="jakarta.jms.QueueBrowser">
        <parameters>
          <parameter>jakarta.jms.Queue</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidSelectorException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:649</id>
      <description>if an invalid subscription name is specified.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="unsubscribe" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidDestinationException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:650</id>
      <description>if the JMS client specifies an invalid or duplicate client ID.</description>
      <package>jakarta.jms</package>
      <class-interface>Connection</class-interface>
      <method name="setClientID" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidClientIDException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:651</id>
      <description>if the JMS client attempts to set a connection's client ID at the wrong time or when it has been administratively configured.</description>
      <package>jakarta.jms</package>
      <class-interface>Connection</class-interface>
      <method name="setClientID" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.IllegalStateException</throw>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:652</id>
      <description>if an invalid destination is specified.</description>
      <package>jakarta.jms</package>
      <class-interface>Connection</class-interface>
      <method name="createConnectionConsumer" return-type="jakarta.jms.ConnectionConsumer">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>jakarta.jms.ServerSessionPool</parameter>
          <parameter>int</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidDestinationException</throw>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:653</id>
      <description>if the message selector is invalid.</description>
      <package>jakarta.jms</package>
      <class-interface>Connection</class-interface>
      <method name="createConnectionConsumer" return-type="jakarta.jms.ConnectionConsumer">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>jakarta.jms.ServerSessionPool</parameter>
          <parameter>int</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidSelectorException</throw>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:654</id>
      <description>if an invalid destination is specified.</description>
      <package>jakarta.jms</package>
      <class-interface>Connection</class-interface>
      <method name="createDurableConnectionConsumer" return-type="jakarta.jms.ConnectionConsumer">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>jakarta.jms.ServerSessionPool</parameter>
          <parameter>int</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidDestinationException</throw>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:655</id>
      <description>if the message selector is invalid.</description>
      <package>jakarta.jms</package>
      <class-interface>Connection</class-interface>
      <method name="createDurableConnectionConsumer" return-type="jakarta.jms.ConnectionConsumer">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>jakarta.jms.ServerSessionPool</parameter>
          <parameter>int</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidSelectorException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:656</id>
      <description>if an invalid message is specified.</description>
      <package>jakarta.jms</package>
      <class-interface>TopicPublisher</class-interface>
      <method name="publish" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Message</parameter>
        </parameters>
        <throw>jakarta.jms.MessageFormatException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:657</id>
      <description>if a client uses this method with a TopicPublisher with an invalid topic.</description>
      <package>jakarta.jms</package>
      <class-interface>TopicPublisher</class-interface>
      <method name="publish" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Message</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidDestinationException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:658</id>
      <description>if a client uses this method with a TopicPublisher that did not specify a topic at creation time.</description>
      <package>jakarta.jms</package>
      <class-interface>TopicPublisher</class-interface>
      <method name="publish" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Message</parameter>
        </parameters>
        <throw>java.lang.UnsupportedOperationException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:659</id>
      <description>if an invalid message is specified.</description>
      <package>jakarta.jms</package>
      <class-interface>TopicPublisher</class-interface>
      <method name="publish" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Message</parameter>
          <parameter>int</parameter>
          <parameter>int</parameter>
          <parameter>long</parameter>
        </parameters>
        <throw>jakarta.jms.MessageFormatException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:660</id>
      <description>if a client uses this method with a TopicPublisher with an invalid topic.</description>
      <package>jakarta.jms</package>
      <class-interface>TopicPublisher</class-interface>
      <method name="publish" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Message</parameter>
          <parameter>int</parameter>
          <parameter>int</parameter>
          <parameter>long</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidDestinationException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:661</id>
      <description>if a client uses this method with a TopicPublisher that did not specify a topic at creation time.</description>
      <package>jakarta.jms</package>
      <class-interface>TopicPublisher</class-interface>
      <method name="publish" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Message</parameter>
          <parameter>int</parameter>
          <parameter>int</parameter>
          <parameter>long</parameter>
        </parameters>
        <throw>java.lang.UnsupportedOperationException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:662</id>
      <description>if an invalid message is specified.</description>
      <package>jakarta.jms</package>
      <class-interface>TopicPublisher</class-interface>
      <method name="publish" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>jakarta.jms.Message</parameter>
        </parameters>
        <throw>jakarta.jms.MessageFormatException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:663</id>
      <description>if a client uses this method with an invalid topic.</description>
      <package>jakarta.jms</package>
      <class-interface>TopicPublisher</class-interface>
      <method name="publish" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>jakarta.jms.Message</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidDestinationException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:664</id>
      <description>if an invalid message is specified.</description>
      <package>jakarta.jms</package>
      <class-interface>TopicPublisher</class-interface>
      <method name="publish" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>jakarta.jms.Message</parameter>
          <parameter>int</parameter>
          <parameter>int</parameter>
          <parameter>long</parameter>
        </parameters>
        <throw>jakarta.jms.MessageFormatException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:665</id>
      <description>if a client uses this method with an invalid topic.</description>
      <package>jakarta.jms</package>
      <class-interface>TopicPublisher</class-interface>
      <method name="publish" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>jakarta.jms.Message</parameter>
          <parameter>int</parameter>
          <parameter>int</parameter>
          <parameter>long</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidDestinationException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:666</id>
      <description>if an invalid message is specified.</description>
      <package>jakarta.jms</package>
      <class-interface>QueueSender</class-interface>
      <method name="send" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Message</parameter>
        </parameters>
        <throw>jakarta.jms.MessageFormatException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:667</id>
      <description>if a client uses this method with a QueueSender with an invalid queue.</description>
      <package>jakarta.jms</package>
      <class-interface>QueueSender</class-interface>
      <method name="send" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Message</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidDestinationException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:668</id>
      <description>if a client uses this method with a QueueSender that did not specify a queue at creation time.</description>
      <package>jakarta.jms</package>
      <class-interface>QueueSender</class-interface>
      <method name="send" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Message</parameter>
        </parameters>
        <throw>java.lang.UnsupportedOperationException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:669</id>
      <description>if an invalid message is specified.</description>
      <package>jakarta.jms</package>
      <class-interface>QueueSender</class-interface>
      <method name="send" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Message</parameter>
          <parameter>int</parameter>
          <parameter>int</parameter>
          <parameter>long</parameter>
        </parameters>
        <throw>jakarta.jms.MessageFormatException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:670</id>
      <description>if a client uses this method with a QueueSender with an invalid queue.</description>
      <package>jakarta.jms</package>
      <class-interface>QueueSender</class-interface>
      <method name="send" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Message</parameter>
          <parameter>int</parameter>
          <parameter>int</parameter>
          <parameter>long</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidDestinationException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:671</id>
      <description>if a client uses this method with a QueueSender that did not specify a queue at creation time.</description>
      <package>jakarta.jms</package>
      <class-interface>QueueSender</class-interface>
      <method name="send" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Message</parameter>
          <parameter>int</parameter>
          <parameter>int</parameter>
          <parameter>long</parameter>
        </parameters>
        <throw>java.lang.UnsupportedOperationException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:672</id>
      <description>if an invalid message is specified.</description>
      <package>jakarta.jms</package>
      <class-interface>QueueSender</class-interface>
      <method name="send" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Queue</parameter>
          <parameter>jakarta.jms.Message</parameter>
        </parameters>
        <throw>jakarta.jms.MessageFormatException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:673</id>
      <description>if a client uses this method with an invalid queue.</description>
      <package>jakarta.jms</package>
      <class-interface>QueueSender</class-interface>
      <method name="send" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Queue</parameter>
          <parameter>jakarta.jms.Message</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidDestinationException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:674</id>
      <description>if an invalid message is specified.</description>
      <package>jakarta.jms</package>
      <class-interface>QueueSender</class-interface>
      <method name="send" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Queue</parameter>
          <parameter>jakarta.jms.Message</parameter>
          <parameter>int</parameter>
          <parameter>int</parameter>
          <parameter>long</parameter>
        </parameters>
        <throw>jakarta.jms.MessageFormatException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:675</id>
      <description>if a client uses this method with an invalid queue.</description>
      <package>jakarta.jms</package>
      <class-interface>QueueSender</class-interface>
      <method name="send" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Queue</parameter>
          <parameter>jakarta.jms.Message</parameter>
          <parameter>int</parameter>
          <parameter>int</parameter>
          <parameter>long</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidDestinationException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:676</id>
      <description>if the message is in write-only mode.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="getBodyLength" return-type="long">
        <throw>jakarta.jms.MessageNotReadableException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:677</id>
      <description>if unexpected end of bytes stream has been reached.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="readBoolean" return-type="boolean">
        <throw>jakarta.jms.MessageEOFException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:678</id>
      <description>if the message is in write-only mode.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="readBoolean" return-type="boolean">
        <throw>jakarta.jms.MessageNotReadableException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:679</id>
      <description>if unexpected end of bytes stream has been reached.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="readByte" return-type="byte">
        <throw>jakarta.jms.MessageEOFException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:680</id>
      <description>if the message is in write-only mode.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="readByte" return-type="byte">
        <throw>jakarta.jms.MessageNotReadableException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:681</id>
      <description>if unexpected end of bytes stream has been reached.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="readUnsignedByte" return-type="int">
        <throw>jakarta.jms.MessageEOFException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:682</id>
      <description>if the message is in write-only mode.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="readUnsignedByte" return-type="int">
        <throw>jakarta.jms.MessageNotReadableException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:683</id>
      <description>if unexpected end of bytes stream has been reached.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="readShort" return-type="short">
        <throw>jakarta.jms.MessageEOFException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:684</id>
      <description>if the message is in write-only mode.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="readShort" return-type="short">
        <throw>jakarta.jms.MessageNotReadableException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:685</id>
      <description>if unexpected end of bytes stream has been reached.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="readUnsignedShort" return-type="int">
        <throw>jakarta.jms.MessageEOFException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:686</id>
      <description>if the message is in write-only mode.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="readUnsignedShort" return-type="int">
        <throw>jakarta.jms.MessageNotReadableException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:687</id>
      <description>if unexpected end of bytes stream has been reached.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="readChar" return-type="char">
        <throw>jakarta.jms.MessageEOFException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:688</id>
      <description>if the message is in write-only mode.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="readChar" return-type="char">
        <throw>jakarta.jms.MessageNotReadableException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:689</id>
      <description>if unexpected end of bytes stream has been reached.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="readInt" return-type="int">
        <throw>jakarta.jms.MessageEOFException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:690</id>
      <description>if the message is in write-only mode.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="readInt" return-type="int">
        <throw>jakarta.jms.MessageNotReadableException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:691</id>
      <description>if unexpected end of bytes stream has been reached.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="readLong" return-type="long">
        <throw>jakarta.jms.MessageEOFException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:692</id>
      <description>if the message is in write-only mode.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="readLong" return-type="long">
        <throw>jakarta.jms.MessageNotReadableException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:693</id>
      <description>if unexpected end of bytes stream has been reached.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="readFloat" return-type="float">
        <throw>jakarta.jms.MessageEOFException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:694</id>
      <description>if the message is in write-only mode.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="readFloat" return-type="float">
        <throw>jakarta.jms.MessageNotReadableException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:695</id>
      <description>if unexpected end of bytes stream has been reached.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="readDouble" return-type="double">
        <throw>jakarta.jms.MessageEOFException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:696</id>
      <description>if the message is in write-only mode.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="readDouble" return-type="double">
        <throw>jakarta.jms.MessageNotReadableException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:697</id>
      <description>if unexpected end of bytes stream has been reached.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="readUTF" return-type="java.lang.String">
        <throw>jakarta.jms.MessageEOFException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:698</id>
      <description>if the message is in write-only mode.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="readUTF" return-type="java.lang.String">
        <throw>jakarta.jms.MessageNotReadableException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:699</id>
      <description>if the message is in write-only mode.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="readBytes" return-type="int">
        <parameters>
          <parameter>byte[]</parameter>
        </parameters>
        <throw>jakarta.jms.MessageNotReadableException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:700</id>
      <description>if the message is in write-only mode.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="readBytes" return-type="int">
        <parameters>
          <parameter>byte[]</parameter>
          <parameter>int</parameter>
        </parameters>
        <throw>jakarta.jms.MessageNotReadableException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:701</id>
      <description>if the message is in read-only mode.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="writeBoolean" return-type="void">
        <parameters>
          <parameter>boolean</parameter>
        </parameters>
        <throw>jakarta.jms.MessageNotWriteableException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:702</id>
      <description>if the message is in read-only mode.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="writeByte" return-type="void">
        <parameters>
          <parameter>byte</parameter>
        </parameters>
        <throw>jakarta.jms.MessageNotWriteableException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:703</id>
      <description>if the message is in read-only mode.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="writeShort" return-type="void">
        <parameters>
          <parameter>short</parameter>
        </parameters>
        <throw>jakarta.jms.MessageNotWriteableException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:704</id>
      <description>if the message is in read-only mode.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="writeChar" return-type="void">
        <parameters>
          <parameter>char</parameter>
        </parameters>
        <throw>jakarta.jms.MessageNotWriteableException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:705</id>
      <description>if the message is in read-only mode.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="writeInt" return-type="void">
        <parameters>
          <parameter>int</parameter>
        </parameters>
        <throw>jakarta.jms.MessageNotWriteableException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:706</id>
      <description>if the message is in read-only mode.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="writeLong" return-type="void">
        <parameters>
          <parameter>long</parameter>
        </parameters>
        <throw>jakarta.jms.MessageNotWriteableException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:707</id>
      <description>if the message is in read-only mode.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="writeFloat" return-type="void">
        <parameters>
          <parameter>float</parameter>
        </parameters>
        <throw>jakarta.jms.MessageNotWriteableException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:708</id>
      <description>if the message is in read-only mode.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="writeDouble" return-type="void">
        <parameters>
          <parameter>double</parameter>
        </parameters>
        <throw>jakarta.jms.MessageNotWriteableException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:709</id>
      <description>if the message is in read-only mode.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="writeUTF" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.MessageNotWriteableException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:710</id>
      <description>if the message is in read-only mode.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="writeBytes" return-type="void">
        <parameters>
          <parameter>byte[]</parameter>
        </parameters>
        <throw>jakarta.jms.MessageNotWriteableException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:711</id>
      <description>if the message is in read-only mode.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="writeBytes" return-type="void">
        <parameters>
          <parameter>byte[]</parameter>
          <parameter>int</parameter>
          <parameter>int</parameter>
        </parameters>
        <throw>jakarta.jms.MessageNotWriteableException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:712</id>
      <description>if the object is of an invalid type.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="writeObject" return-type="void">
        <parameters>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.jms.MessageFormatException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:713</id>
      <description>if the message is in read-only mode.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="writeObject" return-type="void">
        <parameters>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.jms.MessageNotWriteableException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:714</id>
      <description>if the parameter value is null.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="writeObject" return-type="void">
        <parameters>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>java.lang.NullPointerException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:715</id>
      <description>if the message has an invalid format.</description>
      <package>jakarta.jms</package>
      <class-interface>BytesMessage</class-interface>
      <method name="reset" return-type="void">
        <throw>jakarta.jms.MessageFormatException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:716</id>
      <description>if object serialization fails.</description>
      <package>jakarta.jms</package>
      <class-interface>ObjectMessage</class-interface>
      <method name="setObject" return-type="void">
        <parameters>
          <parameter>java.io.Serializable</parameter>
        </parameters>
        <throw>jakarta.jms.MessageFormatException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:717</id>
      <description>if the message is in read-only mode.</description>
      <package>jakarta.jms</package>
      <class-interface>ObjectMessage</class-interface>
      <method name="setObject" return-type="void">
        <parameters>
          <parameter>java.io.Serializable</parameter>
        </parameters>
        <throw>jakarta.jms.MessageNotWriteableException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:718</id>
      <description>if object deserialization fails.</description>
      <package>jakarta.jms</package>
      <class-interface>ObjectMessage</class-interface>
      <method name="getObject" return-type="java.io.Serializable">
        <throw>jakarta.jms.MessageFormatException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:719</id>
      <description>if unexpected end of message stream has been reached.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="readBoolean" return-type="boolean">
        <throw>jakarta.jms.MessageEOFException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:720</id>
      <description>if this type conversion is invalid.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="readBoolean" return-type="boolean">
        <throw>jakarta.jms.MessageFormatException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:721</id>
      <description>if the message is in write-only mode.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="readBoolean" return-type="boolean">
        <throw>jakarta.jms.MessageNotReadableException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:722</id>
      <description>if unexpected end of message stream has been reached.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="readByte" return-type="byte">
        <throw>jakarta.jms.MessageEOFException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:723</id>
      <description>if this type conversion is invalid.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="readByte" return-type="byte">
        <throw>jakarta.jms.MessageFormatException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:724</id>
      <description>if the message is in write-only mode.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="readByte" return-type="byte">
        <throw>jakarta.jms.MessageNotReadableException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:725</id>
      <description>if unexpected end of message stream has been reached.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="readShort" return-type="short">
        <throw>jakarta.jms.MessageEOFException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:726</id>
      <description>if this type conversion is invalid.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="readShort" return-type="short">
        <throw>jakarta.jms.MessageFormatException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:727</id>
      <description>if the message is in write-only mode.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="readShort" return-type="short">
        <throw>jakarta.jms.MessageNotReadableException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:728</id>
      <description>if unexpected end of message stream has been reached.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="readChar" return-type="char">
        <throw>jakarta.jms.MessageEOFException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:729</id>
      <description>if this type conversion is invalid</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="readChar" return-type="char">
        <throw>jakarta.jms.MessageFormatException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:730</id>
      <description>if the message is in write-only mode.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="readChar" return-type="char">
        <throw>jakarta.jms.MessageNotReadableException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:731</id>
      <description>if unexpected end of message stream has been reached.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="readInt" return-type="int">
        <throw>jakarta.jms.MessageEOFException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:732</id>
      <description>if this type conversion is invalid.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="readInt" return-type="int">
        <throw>jakarta.jms.MessageFormatException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:733</id>
      <description>if the message is in write-only mode.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="readInt" return-type="int">
        <throw>jakarta.jms.MessageNotReadableException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:734</id>
      <description>if unexpected end of message stream has been reached.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="readLong" return-type="long">
        <throw>jakarta.jms.MessageEOFException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:735</id>
      <description>if this type conversion is invalid.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="readLong" return-type="long">
        <throw>jakarta.jms.MessageFormatException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:736</id>
      <description>if the message is in write-only mode.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="readLong" return-type="long">
        <throw>jakarta.jms.MessageNotReadableException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:737</id>
      <description>if unexpected end of message stream has been reached.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="readFloat" return-type="float">
        <throw>jakarta.jms.MessageEOFException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:738</id>
      <description>if this type conversion is invalid.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="readFloat" return-type="float">
        <throw>jakarta.jms.MessageFormatException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:739</id>
      <description>if the message is in write-only mode.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="readFloat" return-type="float">
        <throw>jakarta.jms.MessageNotReadableException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:740</id>
      <description>if unexpected end of message stream has been reached.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="readDouble" return-type="double">
        <throw>jakarta.jms.MessageEOFException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:741</id>
      <description>if this type conversion is invalid.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="readDouble" return-type="double">
        <throw>jakarta.jms.MessageFormatException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:742</id>
      <description>if the message is in write-only mode.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="readDouble" return-type="double">
        <throw>jakarta.jms.MessageNotReadableException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:743</id>
      <description>if unexpected end of message stream has been reached.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="readString" return-type="java.lang.String">
        <throw>jakarta.jms.MessageEOFException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:744</id>
      <description>if this type conversion is invalid.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="readString" return-type="java.lang.String">
        <throw>jakarta.jms.MessageFormatException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:745</id>
      <description>if the message is in write-only mode.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="readString" return-type="java.lang.String">
        <throw>jakarta.jms.MessageNotReadableException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:746</id>
      <description>if unexpected end of message stream has been reached.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="readBytes" return-type="int">
        <parameters>
          <parameter>byte[]</parameter>
        </parameters>
        <throw>jakarta.jms.MessageEOFException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:747</id>
      <description>if this type conversion is invalid.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="readBytes" return-type="int">
        <parameters>
          <parameter>byte[]</parameter>
        </parameters>
        <throw>jakarta.jms.MessageFormatException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:748</id>
      <description>if the message is in write-only mode.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="readBytes" return-type="int">
        <parameters>
          <parameter>byte[]</parameter>
        </parameters>
        <throw>jakarta.jms.MessageNotReadableException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:749</id>
      <description>if unexpected end of message stream has been reached.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="readObject" return-type="java.lang.Object">
        <throw>jakarta.jms.MessageEOFException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:750</id>
      <description>if this type conversion is invalid.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="readObject" return-type="java.lang.Object">
        <throw>jakarta.jms.MessageFormatException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:751</id>
      <description>if the message is in write-only mode.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="readObject" return-type="java.lang.Object">
        <throw>jakarta.jms.MessageNotReadableException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:752</id>
      <description>if the message is in read-only mode.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="writeBoolean" return-type="void">
        <parameters>
          <parameter>boolean</parameter>
        </parameters>
        <throw>jakarta.jms.MessageNotWriteableException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:753</id>
      <description>if the message is in read-only mode.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="writeByte" return-type="void">
        <parameters>
          <parameter>byte</parameter>
        </parameters>
        <throw>jakarta.jms.MessageNotWriteableException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:754</id>
      <description>if the message is in read-only mode.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="writeShort" return-type="void">
        <parameters>
          <parameter>short</parameter>
        </parameters>
        <throw>jakarta.jms.MessageNotWriteableException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:755</id>
      <description>if the message is in read-only mode.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="writeChar" return-type="void">
        <parameters>
          <parameter>char</parameter>
        </parameters>
        <throw>jakarta.jms.MessageNotWriteableException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:756</id>
      <description>if the message is in read-only mode.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="writeInt" return-type="void">
        <parameters>
          <parameter>int</parameter>
        </parameters>
        <throw>jakarta.jms.MessageNotWriteableException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:757</id>
      <description>if the message is in read-only mode.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="writeLong" return-type="void">
        <parameters>
          <parameter>long</parameter>
        </parameters>
        <throw>jakarta.jms.MessageNotWriteableException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:758</id>
      <description>if the message is in read-only mode.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="writeFloat" return-type="void">
        <parameters>
          <parameter>float</parameter>
        </parameters>
        <throw>jakarta.jms.MessageNotWriteableException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:759</id>
      <description>if the message is in read-only mode.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="writeDouble" return-type="void">
        <parameters>
          <parameter>double</parameter>
        </parameters>
        <throw>jakarta.jms.MessageNotWriteableException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:760</id>
      <description>if the message is in read-only mode.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="writeString" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.MessageNotWriteableException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:761</id>
      <description>if the message is in read-only mode.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="writeBytes" return-type="void">
        <parameters>
          <parameter>byte[]</parameter>
        </parameters>
        <throw>jakarta.jms.MessageNotWriteableException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:762</id>
      <description>if the message is in read-only mode.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="writeBytes" return-type="void">
        <parameters>
          <parameter>byte[]</parameter>
          <parameter>int</parameter>
          <parameter>int</parameter>
        </parameters>
        <throw>jakarta.jms.MessageNotWriteableException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:763</id>
      <description>if the object is invalid.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="writeObject" return-type="void">
        <parameters>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.jms.MessageFormatException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:764</id>
      <description>if the message is in read-only mode.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="writeObject" return-type="void">
        <parameters>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.jms.MessageNotWriteableException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:765</id>
      <description>if the message has an invalid format.</description>
      <package>jakarta.jms</package>
      <class-interface>StreamMessage</class-interface>
      <method name="reset" return-type="void">
        <throw>jakarta.jms.MessageFormatException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:766</id>
      <description>if the message is in read-only mode.</description>
      <package>jakarta.jms</package>
      <class-interface>TextMessage</class-interface>
      <method name="setText" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.MessageNotWriteableException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:767</id>
      <description>if this type conversion is invalid.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="getBooleanProperty" return-type="boolean">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.MessageFormatException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:768</id>
      <description>if this type conversion is invalid.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="getByteProperty" return-type="byte">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.MessageFormatException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:769</id>
      <description>if this type conversion is invalid.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="getShortProperty" return-type="short">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.MessageFormatException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:770</id>
      <description>if this type conversion is invalid.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="getIntProperty" return-type="int">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.MessageFormatException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:771</id>
      <description>if this type conversion is invalid.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="getLongProperty" return-type="long">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.MessageFormatException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:772</id>
      <description>if this type conversion is invalid.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="getFloatProperty" return-type="float">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.MessageFormatException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:773</id>
      <description>if this type conversion is invalid.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="getDoubleProperty" return-type="double">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.MessageFormatException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:774</id>
      <description>if this type conversion is invalid.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="getStringProperty" return-type="java.lang.String">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.MessageFormatException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:775</id>
      <description>if the name is null or if the name is an empty string.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="setBooleanProperty" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>boolean</parameter>
        </parameters>
        <throw>java.lang.IllegalArgumentException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:776</id>
      <description>if properties are read-only</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="setBooleanProperty" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>boolean</parameter>
        </parameters>
        <throw>jakarta.jms.MessageNotWriteableException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:777</id>
      <description>if the name is null or if the name is an empty string.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="setByteProperty" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>byte</parameter>
        </parameters>
        <throw>java.lang.IllegalArgumentException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:778</id>
      <description>if properties are read-only</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="setByteProperty" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>byte</parameter>
        </parameters>
        <throw>jakarta.jms.MessageNotWriteableException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:779</id>
      <description>if the name is null or if the name is an empty string.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="setShortProperty" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>short</parameter>
        </parameters>
        <throw>java.lang.IllegalArgumentException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:780</id>
      <description>if properties are read-only</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="setShortProperty" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>short</parameter>
        </parameters>
        <throw>jakarta.jms.MessageNotWriteableException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:781</id>
      <description>if the name is null or if the name is an empty string.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="setIntProperty" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>int</parameter>
        </parameters>
        <throw>java.lang.IllegalArgumentException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:782</id>
      <description>if properties are read-only</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="setIntProperty" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>int</parameter>
        </parameters>
        <throw>jakarta.jms.MessageNotWriteableException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:783</id>
      <description>if the name is null or if the name is an empty string.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="setLongProperty" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>long</parameter>
        </parameters>
        <throw>java.lang.IllegalArgumentException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:784</id>
      <description>if properties are read-only</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="setLongProperty" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>long</parameter>
        </parameters>
        <throw>jakarta.jms.MessageNotWriteableException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:785</id>
      <description>if the name is null or if the name is an empty string.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="setFloatProperty" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>float</parameter>
        </parameters>
        <throw>java.lang.IllegalArgumentException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:786</id>
      <description>if properties are read-only</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="setFloatProperty" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>float</parameter>
        </parameters>
        <throw>jakarta.jms.MessageNotWriteableException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:787</id>
      <description>if the name is null or if the name is an empty string.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="setDoubleProperty" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>double</parameter>
        </parameters>
        <throw>java.lang.IllegalArgumentException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:788</id>
      <description>if properties are read-only</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="setDoubleProperty" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>double</parameter>
        </parameters>
        <throw>jakarta.jms.MessageNotWriteableException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:789</id>
      <description>if the name is null or if the name is an empty string.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="setStringProperty" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>java.lang.IllegalArgumentException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:790</id>
      <description>if properties are read-only</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="setStringProperty" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.MessageNotWriteableException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:791</id>
      <description>if the name is null or if the name is an empty string.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="setObjectProperty" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>java.lang.IllegalArgumentException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:792</id>
      <description>if the object is invalid</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="setObjectProperty" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.jms.MessageFormatException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:793</id>
      <description>if properties are read-only</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="setObjectProperty" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.jms.MessageNotWriteableException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:794</id>
      <description>if this method is called on a closed session.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="acknowledge" return-type="void">
        <throw>jakarta.jms.IllegalStateException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:795</id>
      <description>if this type conversion is invalid.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="getBoolean" return-type="boolean">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.MessageFormatException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:796</id>
      <description>if this type conversion is invalid.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="getByte" return-type="byte">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.MessageFormatException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:797</id>
      <description>if this type conversion is invalid.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="getShort" return-type="short">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.MessageFormatException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:798</id>
      <description>if this type conversion is invalid.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="getChar" return-type="char">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.MessageFormatException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:799</id>
      <description>if this type conversion is invalid.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="getInt" return-type="int">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.MessageFormatException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:800</id>
      <description>if this type conversion is invalid.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="getLong" return-type="long">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.MessageFormatException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:801</id>
      <description>if this type conversion is invalid.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="getFloat" return-type="float">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.MessageFormatException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:802</id>
      <description>if this type conversion is invalid.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="getDouble" return-type="double">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.MessageFormatException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:803</id>
      <description>if this type conversion is invalid.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="getString" return-type="java.lang.String">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.MessageFormatException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:804</id>
      <description>if this type conversion is invalid.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="getBytes" return-type="byte[]">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.MessageFormatException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:805</id>
      <description>if the name is null or if the name is an empty string.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="setBoolean" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>boolean</parameter>
        </parameters>
        <throw>java.lang.IllegalArgumentException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:806</id>
      <description>if the message is in read-only mode.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="setBoolean" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>boolean</parameter>
        </parameters>
        <throw>jakarta.jms.MessageNotWriteableException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:807</id>
      <description>if the name is null or if the name is an empty string.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="setByte" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>byte</parameter>
        </parameters>
        <throw>java.lang.IllegalArgumentException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:808</id>
      <description>if the message is in read-only mode.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="setByte" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>byte</parameter>
        </parameters>
        <throw>jakarta.jms.MessageNotWriteableException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:809</id>
      <description>if the name is null or if the name is an empty string.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="setShort" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>short</parameter>
        </parameters>
        <throw>java.lang.IllegalArgumentException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:810</id>
      <description>if the message is in read-only mode.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="setShort" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>short</parameter>
        </parameters>
        <throw>jakarta.jms.MessageNotWriteableException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:811</id>
      <description>if the name is null or if the name is an empty string.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="setChar" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>char</parameter>
        </parameters>
        <throw>java.lang.IllegalArgumentException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:812</id>
      <description>if the message is in read-only mode.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="setChar" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>char</parameter>
        </parameters>
        <throw>jakarta.jms.MessageNotWriteableException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:813</id>
      <description>if the name is null or if the name is an empty string.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="setInt" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>int</parameter>
        </parameters>
        <throw>java.lang.IllegalArgumentException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:814</id>
      <description>if the message is in read-only mode.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="setInt" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>int</parameter>
        </parameters>
        <throw>jakarta.jms.MessageNotWriteableException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:815</id>
      <description>if the name is null or if the name is an empty string.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="setLong" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>long</parameter>
        </parameters>
        <throw>java.lang.IllegalArgumentException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:816</id>
      <description>if the message is in read-only mode.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="setLong" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>long</parameter>
        </parameters>
        <throw>jakarta.jms.MessageNotWriteableException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:817</id>
      <description>if the name is null or if the name is an empty string.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="setFloat" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>float</parameter>
        </parameters>
        <throw>java.lang.IllegalArgumentException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:818</id>
      <description>if the message is in read-only mode.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="setFloat" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>float</parameter>
        </parameters>
        <throw>jakarta.jms.MessageNotWriteableException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:819</id>
      <description>if the name is null or if the name is an empty string.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="setDouble" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>double</parameter>
        </parameters>
        <throw>java.lang.IllegalArgumentException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:820</id>
      <description>if the message is in read-only mode.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="setDouble" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>double</parameter>
        </parameters>
        <throw>jakarta.jms.MessageNotWriteableException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:821</id>
      <description>if the name is null or if the name is an empty string.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="setString" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>java.lang.IllegalArgumentException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:822</id>
      <description>if the message is in read-only mode.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="setString" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.MessageNotWriteableException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:823</id>
      <description>if the name is null, or if the name is an empty string.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="setBytes" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>byte[]</parameter>
        </parameters>
        <throw>java.lang.IllegalArgumentException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:824</id>
      <description>if the message is in read-only mode.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="setBytes" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>byte[]</parameter>
        </parameters>
        <throw>jakarta.jms.MessageNotWriteableException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:825</id>
      <description>if the name is null or if the name is an empty string.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="setBytes" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>byte[]</parameter>
          <parameter>int</parameter>
          <parameter>int</parameter>
        </parameters>
        <throw>java.lang.IllegalArgumentException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:826</id>
      <description>if the message is in read-only mode.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="setBytes" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>byte[]</parameter>
          <parameter>int</parameter>
          <parameter>int</parameter>
        </parameters>
        <throw>jakarta.jms.MessageNotWriteableException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:827</id>
      <description>if the name is null or if the name is an empty string.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="setObject" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>java.lang.IllegalArgumentException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:828</id>
      <description>if the object is invalid.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="setObject" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.jms.MessageFormatException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:829</id>
      <description>if the message is in read-only mode.</description>
      <package>jakarta.jms</package>
      <class-interface>MapMessage</class-interface>
      <method name="setObject" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.jms.MessageNotWriteableException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:830</id>
      <description>if the JMS provider fails to create the TopicRequestor due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>TopicRequestor</class-interface>
      <method name="TopicRequestor" return-type="TopicRequestor">
        <parameters>
          <parameter>jakarta.jms.TopicSession</parameter>
          <parameter>jakarta.jms.Topic</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:831</id>
      <description>if an invalid topic is specified.</description>
      <package>jakarta.jms</package>
      <class-interface>TopicRequestor</class-interface>
      <method name="TopicRequestor" return-type="TopicRequestor">
        <parameters>
          <parameter>jakarta.jms.TopicSession</parameter>
          <parameter>jakarta.jms.Topic</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidDestinationException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:832</id>
      <description>if the JMS provider fails to create the QueueRequestor due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>QueueRequestor</class-interface>
      <method name="QueueRequestor" return-type="QueueRequestor">
        <parameters>
          <parameter>jakarta.jms.QueueSession</parameter>
          <parameter>jakarta.jms.Queue</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:833</id>
      <description>if an invalid queue is specified.</description>
      <package>jakarta.jms</package>
      <class-interface>QueueRequestor</class-interface>
      <method name="QueueRequestor" return-type="QueueRequestor">
        <parameters>
          <parameter>jakarta.jms.QueueSession</parameter>
          <parameter>jakarta.jms.Queue</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidDestinationException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:835</id>
      <description>Notifies the application that the message has been successfully sent</description>
      <package>jakarta.jms</package>
      <class-interface>CompletionListener</class-interface>
      <method name="onCompletion" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Message</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:836</id>
      <description>Notifies user that the specified exception was thrown while attempting to send the specified message. If an exception occurs it is undefined whether or not the message was successfully sent.</description>
      <package>jakarta.jms</package>
      <class-interface>CompletionListener</class-interface>
      <method name="onException" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Message</parameter>
          <parameter>java.lang.Exception</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:837</id>
      <description>Creates a Session object, specifying sessionMode. The effect of setting the sessionMode argument depends on whether this method is called in a Java SE environment, in the Jakarta EE application client container, or in the Jakarta EE web or Enterprise Beans container. If this method is called in the Jakarta EE web or Enterprise Beans container then the effect of setting the sessionMode argument also depends on whether or not there is an active JTA transaction in progress. In a Java SE environment or in the Jakarta EE application client container: If sessionMode is set to Session.SESSION_TRANSACTED then the session will use a local transaction which may subsequently be committed or rolled back by calling the session's commit or rollback methods. If sessionMode is set to any of Session.CLIENT_ACKNOWLEDGE, Session.AUTO_ACKNOWLEDGE or Session.DUPS_OK_ACKNOWLEDGE. then the session will be non-transacted and messages received by this session will be acknowledged according to the value of sessionMode. For a definition of the meaning of these acknowledgement modes see the links below. In a Jakarta EE web or Enterprise Beans container, when there is an active JTA transaction in progress: The argument sessionMode is ignored. The session will participate in the JTA transaction and will be committed or rolled back when that transaction is committed or rolled back, not by calling the session's commit or rollback methods. Since the argument is ignored, developers are recommended to use createSession(), which has no arguments, instead of this method. In the Jakarta EE web or Enterprise Beans container, when there is no active JTA transaction in progress: The argument acknowledgeMode must be set to either of Session.AUTO_ACKNOWLEDGE or Session.DUPS_OK_ACKNOWLEDGE. The session will be non-transacted and messages received by this session will be acknowledged automatically according to the value of acknowledgeMode. For a definition of the meaning of these acknowledgement modes see the links below. The values Session.SESSION_TRANSACTED and Session.CLIENT_ACKNOWLEDGE may not be used. Applications running in the Jakarta EE web and Enterprise Beans containers must not attempt to create more than one active (not closed) Session object per connection. If this method is called in a Jakarta EE web or Enterprise Beans container when an active Session object already exists for this connection then a JMSException will be thrown.</description>
      <package>jakarta.jms</package>
      <class-interface>Connection</class-interface>
      <method name="createSession" return-type="jakarta.jms.Session">
        <parameters>
          <parameter>int</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:838</id>
      <description>if the Connection object fails to create a session due to some internal error, lack of support for the specific transaction and acknowledgement mode, or because this method is being called in a Jakarta EE web or Enterprise Beans application and an active session already exists for this connection.</description>
      <package>jakarta.jms</package>
      <class-interface>Connection</class-interface>
      <method name="createSession" return-type="jakarta.jms.Session">
        <parameters>
          <parameter>int</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:839</id>
      <description>Creates a Session object, specifying no arguments. The behaviour of the session that is created depends on whether this method is called in a Java SE environment, in the Jakarta EE application client container, or in the Jakarta EE web or Enterprise Beans container. If this method is called in the Jakarta EE web or Enterprise Beans container then the behaviour of the session also depends on whether or not there is an active JTA transaction in progress. In a Java SE environment or in the Jakarta EE application client container: The session will be non-transacted and received messages will be acknowledged automatically using an acknowledgement mode of Session.AUTO_ACKNOWLEDGE For a definition of the meaning of this acknowledgement mode see the link below. In a Jakarta EE web or Enterprise Beans container, when there is an active JTA transaction in progress: The session will participate in the JTA transaction and will be committed or rolled back when that transaction is committed or rolled back, not by calling the session's commit or rollback methods. In the Jakarta EE web or Enterprise Beans container, when there is no active JTA transaction in progress: The session will be non-transacted and received messages will be acknowledged automatically using an acknowledgement mode of Session.AUTO_ACKNOWLEDGE For a definition of the meaning of this acknowledgement mode see the link below. Applications running in the Jakarta EE web and Enterprise Beans containers must not attempt to create more than one active (not closed) Session object per connection. If this method is called in a Jakarta EE web or Enterprise Beans container when an active Session object already exists for this connection then a JMSException will be thrown.</description>
      <package>jakarta.jms</package>
      <class-interface>Connection</class-interface>
      <method name="createSession" return-type="jakarta.jms.Session"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:840</id>
      <description>if the Connection object fails to create a session due to some internal error or because this method is being called in a Jakarta EE web or Enterprise Beans application and an active session already exists for this connection.</description>
      <package>jakarta.jms</package>
      <class-interface>Connection</class-interface>
      <method name="createSession" return-type="jakarta.jms.Session">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:841</id>
      <description>Creates a JMSContext with the default user identity and an unspecified sessionMode. A connection and session are created for use by the new JMSContext. The connection is created in stopped mode but will be automatically started when a JMSConsumer is created. The behaviour of the session that is created depends on whether this method is called in a Java SE environment, in the Jakarta EE application client container, or in the Jakarta EE web or Enterprise Beans container. If this method is called in the Jakarta EE web or Enterprise Beans container then the behaviour of the session also depends on whether or not there is an active JTA transaction in progress. In a Java SE environment or in the Jakarta EE application client container: The session will be non-transacted and received messages will be acknowledged automatically using an acknowledgement mode of JMSContext.AUTO_ACKNOWLEDGE For a definition of the meaning of this acknowledgement mode see the link below. In a Jakarta EE web or Enterprise Beans container, when there is an active JTA transaction in progress: The session will participate in the JTA transaction and will be committed or rolled back when that transaction is committed or rolled back, not by calling the JMSContext's commit or rollback methods. In the Jakarta EE web or Enterprise Beans container, when there is no active JTA transaction in progress: The session will be non-transacted and received messages will be acknowledged automatically using an acknowledgement mode of JMSContext.AUTO_ACKNOWLEDGE For a definition of the meaning of this acknowledgement mode see the link below.</description>
      <package>jakarta.jms</package>
      <class-interface>ConnectionFactory</class-interface>
      <method name="createContext" return-type="jakarta.jms.JMSContext"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:842</id>
      <description>if the JMS provider fails to create the JMSContext due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>ConnectionFactory</class-interface>
      <method name="createContext" return-type="jakarta.jms.JMSContext">
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:843</id>
      <description>if client authentication fails due to an invalid user name or password.</description>
      <package>jakarta.jms</package>
      <class-interface>ConnectionFactory</class-interface>
      <method name="createContext" return-type="jakarta.jms.JMSContext">
        <throw>jakarta.jms.JMSSecurityRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:844</id>
      <description>Creates a JMSContext with the specified user identity and an unspecified sessionMode. A connection and session are created for use by the new JMSContext. The connection is created in stopped mode but will be automatically started when a JMSConsumer. The behaviour of the session that is created depends on whether this method is called in a Java SE environment, in the Jakarta EE application client container, or in the Jakarta EE web or Enterprise Beans container. If this method is called in the Jakarta EE web or Enterprise Beans container then the behaviour of the session also depends on whether or not there is an active JTA transaction in progress. In a Java SE environment or in the Jakarta EE application client container: The session will be non-transacted and received messages will be acknowledged automatically using an acknowledgement mode of JMSContext.AUTO_ACKNOWLEDGE For a definition of the meaning of this acknowledgement mode see the link below. In a Jakarta EE web or Enterprise Beans container, when there is an active JTA transaction in progress: The session will participate in the JTA transaction and will be committed or rolled back when that transaction is committed or rolled back, not by calling the JMSContext's commit or rollback methods. In the Jakarta EE web or Enterprise Beans container, when there is no active JTA transaction in progress: The session will be non-transacted and received messages will be acknowledged automatically using an acknowledgement mode of JMSContext.AUTO_ACKNOWLEDGE For a definition of the meaning of this acknowledgement mode see the link below.</description>
      <package>jakarta.jms</package>
      <class-interface>ConnectionFactory</class-interface>
      <method name="createContext" return-type="jakarta.jms.JMSContext">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:845</id>
      <description>if the JMS provider fails to create the JMSContext due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>ConnectionFactory</class-interface>
      <method name="createContext" return-type="jakarta.jms.JMSContext">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:846</id>
      <description>if client authentication fails due to an invalid user name or password.</description>
      <package>jakarta.jms</package>
      <class-interface>ConnectionFactory</class-interface>
      <method name="createContext" return-type="jakarta.jms.JMSContext">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSSecurityRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:847</id>
      <description>Creates a JMSContext with the specified user identity and the specified session mode. A connection and session are created for use by the new JMSContext. The JMSContext is created in stopped mode but will be automatically started when a JMSConsumer is created. The effect of setting the sessionMode argument depends on whether this method is called in a Java SE environment, in the Jakarta EE application client container, or in the Jakarta EE web or Enterprise Beans container. If this method is called in the Jakarta EE web or Enterprise Beans container then the effect of setting the sessionMode argument also depends on whether or not there is an active JTA transaction in progress. In a Java SE environment or in the Jakarta EE application client container: If sessionMode is set to JMSContext.SESSION_TRANSACTED then the session will use a local transaction which may subsequently be committed or rolled back by calling the JMSContext's commit or rollback methods. If sessionMode is set to any of JMSContext.CLIENT_ACKNOWLEDGE, JMSContext.AUTO_ACKNOWLEDGE or JMSContext.DUPS_OK_ACKNOWLEDGE. then the session will be non-transacted and messages received by this session will be acknowledged according to the value of sessionMode. For a definition of the meaning of these acknowledgement modes see the links below. In a Jakarta EE web or Enterprise Beans container, when there is an active JTA transaction in progress: The argument sessionMode is ignored. The session will participate in the JTA transaction and will be committed or rolled back when that transaction is committed or rolled back, not by calling the JMSContext's commit or rollback methods. Since the argument is ignored, developers are recommended to use createSession(), which has no arguments, instead of this method. In the Jakarta EE web or Enterprise Beans container, when there is no active JTA transaction in progress: The argument acknowledgeMode must be set to either of JMSContext.AUTO_ACKNOWLEDGE or JMSContext.DUPS_OK_ACKNOWLEDGE. The session will be non-transacted and messages received by this session will be acknowledged automatically according to the value of acknowledgeMode. For a definition of the meaning of these acknowledgement modes see the links below. The values JMSContext.SESSION_TRANSACTED and JMSContext.CLIENT_ACKNOWLEDGE may not be used.</description>
      <package>jakarta.jms</package>
      <class-interface>ConnectionFactory</class-interface>
      <method name="createContext" return-type="jakarta.jms.JMSContext">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>int</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:848</id>
      <description>if the JMS provider fails to create the JMSContext due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>ConnectionFactory</class-interface>
      <method name="createContext" return-type="jakarta.jms.JMSContext">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>int</parameter>
        </parameters>
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:849</id>
      <description>if client authentication fails due to an invalid user name or password.</description>
      <package>jakarta.jms</package>
      <class-interface>ConnectionFactory</class-interface>
      <method name="createContext" return-type="jakarta.jms.JMSContext">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>int</parameter>
        </parameters>
        <throw>jakarta.jms.JMSSecurityRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:850</id>
      <description>Creates a JMSContext with the default user identity and the specified session mode. A connection and session are created for use by the new JMSContext. The JMSContext is created in stopped mode but will be automatically started when a JMSConsumer is created. The effect of setting the sessionMode argument depends on whether this method is called in a Java SE environment, in the Jakarta EE application client container, or in the Jakarta EE web or Enterprise Beans container. If this method is called in the Jakarta EE web or Enterprise Beans container then the effect of setting the sessionMode argument also depends on whether or not there is an active JTA transaction in progress. In a Java SE environment or in the Jakarta EE application client container: If sessionMode is set to JMSContext.SESSION_TRANSACTED then the session will use a local transaction which may subsequently be committed or rolled back by calling the JMSContext's commit or rollback methods. If sessionMode is set to any of JMSContext.CLIENT_ACKNOWLEDGE, JMSContext.AUTO_ACKNOWLEDGE or JMSContext.DUPS_OK_ACKNOWLEDGE. then the session will be non-transacted and messages received by this session will be acknowledged according to the value of sessionMode. For a definition of the meaning of these acknowledgement modes see the links below. In a Jakarta EE web or Enterprise Beans container, when there is an active JTA transaction in progress: The argument sessionMode is ignored. The session will participate in the JTA transaction and will be committed or rolled back when that transaction is committed or rolled back, not by calling the JMSContext's commit or rollback methods. Since the argument is ignored, developers are recommended to use createSession(), which has no arguments, instead of this method. In the Jakarta EE web or Enterprise Beans container, when there is no active JTA transaction in progress: The argument acknowledgeMode must be set to either of JMSContext.AUTO_ACKNOWLEDGE or JMSContext.DUPS_OK_ACKNOWLEDGE. The session will be non-transacted and messages received by this session will be acknowledged automatically according to the value of acknowledgeMode. For a definition of the meaning of these acknowledgement modes see the links below. The values JMSContext.SESSION_TRANSACTED and JMSContext.CLIENT_ACKNOWLEDGE may not be used.</description>
      <package>jakarta.jms</package>
      <class-interface>ConnectionFactory</class-interface>
      <method name="createContext" return-type="jakarta.jms.JMSContext">
        <parameters>
          <parameter>int</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:851</id>
      <description>if the JMS provider fails to create the JMSContext due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>ConnectionFactory</class-interface>
      <method name="createContext" return-type="jakarta.jms.JMSContext">
        <parameters>
          <parameter>int</parameter>
        </parameters>
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:852</id>
      <description>if client authentication fails due to an invalid user name or password.</description>
      <package>jakarta.jms</package>
      <class-interface>ConnectionFactory</class-interface>
      <method name="createContext" return-type="jakarta.jms.JMSContext">
        <parameters>
          <parameter>int</parameter>
        </parameters>
        <throw>jakarta.jms.JMSSecurityRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:853</id>
      <description>Constructs a IllegalStateRuntimeException with the specified detail message and error code.</description>
      <package>jakarta.jms</package>
      <class-interface>IllegalStateRuntimeException</class-interface>
      <method name="IllegalStateRuntimeException" return-type="IllegalStateRuntimeException">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:854</id>
      <description>Constructs a IllegalStateRuntimeException with the specified detail message</description>
      <package>jakarta.jms</package>
      <class-interface>IllegalStateRuntimeException</class-interface>
      <method name="IllegalStateRuntimeException" return-type="IllegalStateRuntimeException">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:855</id>
      <description>Constructs a IllegalStateRuntimeException with the specified detail message, error code and cause</description>
      <package>jakarta.jms</package>
      <class-interface>IllegalStateRuntimeException</class-interface>
      <method name="IllegalStateRuntimeException" return-type="IllegalStateRuntimeException">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.Throwable</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:856</id>
      <description>Constructs a InvalidClientIDRuntimeException with the specified detail message and error code.</description>
      <package>jakarta.jms</package>
      <class-interface>InvalidClientIDRuntimeException</class-interface>
      <method name="InvalidClientIDRuntimeException" return-type="InvalidClientIDRuntimeException">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:857</id>
      <description>Constructs a InvalidClientIDRuntimeException with the specified detail message</description>
      <package>jakarta.jms</package>
      <class-interface>InvalidClientIDRuntimeException</class-interface>
      <method name="InvalidClientIDRuntimeException" return-type="InvalidClientIDRuntimeException">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:858</id>
      <description>Constructs a InvalidClientIDRuntimeException with the specified detail message, error code and cause</description>
      <package>jakarta.jms</package>
      <class-interface>InvalidClientIDRuntimeException</class-interface>
      <method name="InvalidClientIDRuntimeException" return-type="InvalidClientIDRuntimeException">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.Throwable</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:859</id>
      <description>Constructs a InvalidDestinationRuntimeException with the specified detail message and error code.</description>
      <package>jakarta.jms</package>
      <class-interface>InvalidDestinationRuntimeException</class-interface>
      <method name="InvalidDestinationRuntimeException" return-type="InvalidDestinationRuntimeException">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:860</id>
      <description>Constructs a InvalidDestinationRuntimeException with the specified detail message</description>
      <package>jakarta.jms</package>
      <class-interface>InvalidDestinationRuntimeException</class-interface>
      <method name="InvalidDestinationRuntimeException" return-type="InvalidDestinationRuntimeException">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:861</id>
      <description>Constructs a InvalidDestinationRuntimeException with the specified detail message, error code and cause</description>
      <package>jakarta.jms</package>
      <class-interface>InvalidDestinationRuntimeException</class-interface>
      <method name="InvalidDestinationRuntimeException" return-type="InvalidDestinationRuntimeException">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.Throwable</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:862</id>
      <description>Constructs a InvalidSelectorRuntimeException with the specified detail message and error code.</description>
      <package>jakarta.jms</package>
      <class-interface>InvalidSelectorRuntimeException</class-interface>
      <method name="InvalidSelectorRuntimeException" return-type="InvalidSelectorRuntimeException">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:863</id>
      <description>Constructs a InvalidSelectorRuntimeException with the specified detail message</description>
      <package>jakarta.jms</package>
      <class-interface>InvalidSelectorRuntimeException</class-interface>
      <method name="InvalidSelectorRuntimeException" return-type="InvalidSelectorRuntimeException">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:864</id>
      <description>Constructs a InvalidSelectorRuntimeException with the specified detail message, error code and cause</description>
      <package>jakarta.jms</package>
      <class-interface>InvalidSelectorRuntimeException</class-interface>
      <method name="InvalidSelectorRuntimeException" return-type="InvalidSelectorRuntimeException">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.Throwable</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:865</id>
      <description>Returns the vendor-specific error code.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSRuntimeException</class-interface>
      <method name="getErrorCode" return-type="java.lang.String"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:867</id>
      <description>Constructs a JMSRuntimeException with the specified detail message and error code.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSRuntimeException</class-interface>
      <method name="JMSRuntimeException" return-type="JMSRuntimeException">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:868</id>
      <description>Constructs a JMSRuntimeException with the specified detail message</description>
      <package>jakarta.jms</package>
      <class-interface>JMSRuntimeException</class-interface>
      <method name="JMSRuntimeException" return-type="JMSRuntimeException">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:869</id>
      <description>Constructs a JMSRuntimeException with the specified detail message, error code and cause</description>
      <package>jakarta.jms</package>
      <class-interface>JMSRuntimeException</class-interface>
      <method name="JMSRuntimeException" return-type="JMSRuntimeException">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.Throwable</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:871</id>
      <description>Constructs a JMSSecurityRuntimeException with the specified detail message and error code.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSSecurityRuntimeException</class-interface>
      <method name="JMSSecurityRuntimeException" return-type="JMSSecurityRuntimeException">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:872</id>
      <description>Constructs a JMSSecurityRuntimeException with the specified detail message</description>
      <package>jakarta.jms</package>
      <class-interface>JMSSecurityRuntimeException</class-interface>
      <method name="JMSSecurityRuntimeException" return-type="JMSSecurityRuntimeException">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:873</id>
      <description>Constructs a JMSSecurityRuntimeException with the specified detail message, error code and cause</description>
      <package>jakarta.jms</package>
      <class-interface>JMSSecurityRuntimeException</class-interface>
      <method name="JMSSecurityRuntimeException" return-type="JMSSecurityRuntimeException">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.Throwable</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:875</id>
      <description>Gets the message's delivery time value. When a message is sent, the JMSDeliveryTime header field is left unassigned. After completion of the send or publish method, it holds the delivery time of the message. This is the the difference, measured in milliseconds, between the delivery time and midnight, January 1, 1970 UTC. A message's delivery time is the earliest time when a JMS provider may deliver the message to a consumer. The provider must not deliver messages before the delivery time has been reached.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="getJMSDeliveryTime" return-type="long"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:876</id>
      <description>if the JMS provider fails to get the delivery time due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="getJMSDeliveryTime" return-type="long">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:877</id>
      <description>Sets the message's delivery time value. This method is for use by JMS providers only to set this field when a message is sent. This message cannot be used by clients to configure the delivery time of the message. This method is public to allow a JMS provider to set this field when sending a message whose implementation is not its own.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="setJMSDeliveryTime" return-type="void">
        <parameters>
          <parameter>long</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:878</id>
      <description>if the JMS provider fails to set the delivery time due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="setJMSDeliveryTime" return-type="void">
        <parameters>
          <parameter>long</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:883</id>
      <description>Constructs a MessageFormatRuntimeException with the specified detail message and error code.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageFormatRuntimeException</class-interface>
      <method name="MessageFormatRuntimeException" return-type="MessageFormatRuntimeException">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:884</id>
      <description>Constructs a MessageFormatRuntimeException with the specified detail message</description>
      <package>jakarta.jms</package>
      <class-interface>MessageFormatRuntimeException</class-interface>
      <method name="MessageFormatRuntimeException" return-type="MessageFormatRuntimeException">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:885</id>
      <description>Constructs a MessageFormatRuntimeException with the specified detail message, error code and cause</description>
      <package>jakarta.jms</package>
      <class-interface>MessageFormatRuntimeException</class-interface>
      <method name="MessageFormatRuntimeException" return-type="MessageFormatRuntimeException">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.Throwable</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:886</id>
      <description>Gets the minimum length of time in milliseconds that must elapse after a message is sent before the JMS provider may deliver the message to a consumer.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageProducer</class-interface>
      <method name="getDeliveryDelay" return-type="long"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:887</id>
      <description>if the JMS provider fails to get the delivery delay due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageProducer</class-interface>
      <method name="getDeliveryDelay" return-type="long">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:888</id>
      <description>Sends a message using the MessageProducer's default delivery mode, priority, and time to live, performing part of the work involved in sending the message in a separate thread and notifying the specified CompletionListener when the operation has completed. JMS refers to this as an "asynchronous send". When the message has been successfully sent the JMS provider invokes the callback method onCompletion on an application-specified CompletionListener object. Only when that callback has been invoked can the application be sure that the message has been successfully sent with the same degree of confidence as if a normal synchronous send had been performed. An application which requires this degree of confidence must therefore wait for the callback to be invoked before continuing. The following information is intended to give an indication of how an asynchronous send would typically be implemented. In some JMS providers, a normal synchronous send involves sending the message to a remote JMS server and then waiting for an acknowledgement to be received before returning. It is expected that such a provider would implement an asynchronous send by sending the message to the remote JMS server and then returning without waiting for an acknowledgement. When the acknowledgement is received, the JMS provider would notify the application by invoking the onCompletion method on the application-specified CompletionListener object. If for some reason the acknowledgement is not received the JMS provider would notify the application by invoking the CompletionListener's onException method. In those cases where the JMS specification permits a lower level of reliability, a normal synchronous send might not wait for an acknowledgement. In that case it is expected that an asynchronous send would be similar to a synchronous send: the JMS provider would send the message to the remote JMS server and then return without waiting for an acknowledgement. However the JMS provider would still notify the application that the send had completed by invoking the onCompletion method on the application-specified CompletionListener object. It is up to the JMS provider to decide exactly what is performed in the calling thread and what, if anything, is performed asynchronously, so long as it satisfies the requirements given below: Quality of service: After the send operation has completed successfully, which means that the message has been successfully sent with the same degree of confidence as if a normal synchronous send had been performed, the JMS provider must invoke the CompletionListener's onCompletion method. The CompletionListener must not be invoked earlier than this. Exceptions: If an exception is encountered during the call to the send method then an appropriate exception should be thrown in the thread that is calling the send method. In this case the JMS provider must not invoke the CompletionListener's onCompletion or onException method. If an exception is encountered which cannot be thrown in the thread that is calling the send method then the JMS provider must call the CompletionListener's onException method. In both cases if an exception occurs it is undefined whether or not the message was successfully sent. Message order: If the same MessageProducer is used to send multiple messages then JMS message ordering requirements must be satisfied. This applies even if a combination of synchronous and asynchronous sends has been performed. The application is not required to wait for an asynchronous send to complete before sending the next message. Close, commit or rollback: If the close method is called on the MessageProducer or its Session or Connection then the JMS provider must block until any incomplete send operations have been completed and all CompletionListener callbacks have returned before closing the object and returning. If the session is transacted (uses a local transaction) then when the Session's commit or rollback method is called the JMS provider must block until any incomplete send operations have been completed and all CompletionListener callbacks have returned before performing the commit or rollback. Incomplete sends should be allowed to complete normally unless an error occurs. A CompletionListener callback method must not call close on its own Connection, Session or MessageProducer or call commit or rollback on its own Session. Doing so will cause the close, commit or rollback to throw an IllegalStateException. Restrictions on usage in Jakarta EE This method must not be used in a Jakarta EE Enterprise Beans or web container. Doing so may cause a JMSException to be thrown though this is not guaranteed. Message headers JMS defines a number of message header fields and message properties which must be set by the "JMS provider on send". If the send is asynchronous these fields and properties may be accessed on the sending client only after the CompletionListener has been invoked. If the CompletionListener's onException method is called then the state of these message header fields and properties is undefined. Restrictions on threading: Applications that perform an asynchronous send must confirm to the threading restrictions defined in JMS. This means that the session may be used by only one thread at a time. Setting a CompletionListener does not cause the session to be dedicated to the thread of control which calls the CompletionListener. The application thread may therefore continue to use the session after performing an asynchronous send. However the CompletionListener's callback methods must not use the session if an application thread might be using the session at the same time. Use of the CompletionListener by the JMS provider: A session will only invoke one CompletionListener callback method at a time. For a given MessageProducer, callbacks (both onCompletion and onException) will be performed in the same order as the corresponding calls to the asynchronous send method. A JMS provider must not invoke the CompletionListener from the thread that is calling the asynchronous send method. Restrictions on the use of the Message object: Applications which perform an asynchronous send must take account of the restriction that a Message object is designed to be accessed by one logical thread of control at a time and does not support concurrent use. After the send method has returned, the application must not attempt to read the headers, properties or body of the Message object until the CompletionListener's onCompletion or onException method has been called. This is because the JMS provider may be modifying the Message object in another thread during this time. The JMS provider may throw an JMSException if the application attempts to access or modify the Message object after the send method has returned and before the CompletionListener has been invoked. If the JMS provider does not throw an exception then the behaviour is undefined.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageProducer</class-interface>
      <method name="send" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Message</parameter>
          <parameter>jakarta.jms.CompletionListener</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:889</id>
      <description>if an internal error occurs</description>
      <package>jakarta.jms</package>
      <class-interface>MessageProducer</class-interface>
      <method name="send" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Message</parameter>
          <parameter>jakarta.jms.CompletionListener</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:890</id>
      <description>if an invalid message is specified.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageProducer</class-interface>
      <method name="send" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Message</parameter>
          <parameter>jakarta.jms.CompletionListener</parameter>
        </parameters>
        <throw>jakarta.jms.MessageFormatException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:891</id>
      <description>if a client uses this method with a MessageProducer with an invalid destination.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageProducer</class-interface>
      <method name="send" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Message</parameter>
          <parameter>jakarta.jms.CompletionListener</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidDestinationException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:892</id>
      <description>if a client uses this method with a MessageProducer that did not specify a destination at creation time.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageProducer</class-interface>
      <method name="send" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Message</parameter>
          <parameter>jakarta.jms.CompletionListener</parameter>
        </parameters>
        <throw>java.lang.UnsupportedOperationException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:893</id>
      <description>Sends a message, specifying delivery mode, priority and time to live, performing part of the work involved in sending the message in a separate thread and notifying the specified CompletionListener when the operation has completed. JMS refers to this as an "asynchronous send". When the message has been successfully sent the JMS provider invokes the callback method onCompletion on an application-specified CompletionListener object. Only when that callback has been invoked can the application be sure that the message has been successfully sent with the same degree of confidence as if a normal synchronous send had been performed. An application which requires this degree of confidence must therefore wait for the callback to be invoked before continuing. The following information is intended to give an indication of how an asynchronous send would typically be implemented. In some JMS providers, a normal synchronous send involves sending the message to a remote JMS server and then waiting for an acknowledgement to be received before returning. It is expected that such a provider would implement an asynchronous send by sending the message to the remote JMS server and then returning without waiting for an acknowledgement. When the acknowledgement is received, the JMS provider would notify the application by invoking the onCompletion method on the application-specified CompletionListener object. If for some reason the acknowledgement is not received the JMS provider would notify the application by invoking the CompletionListener's onException method. In those cases where the JMS specification permits a lower level of reliability, a normal synchronous send might not wait for an acknowledgement. In that case it is expected that an asynchronous send would be similar to a synchronous send: the JMS provider would send the message to the remote JMS server and then return without waiting for an acknowledgement. However the JMS provider would still notify the application that the send had completed by invoking the onCompletion method on the application-specified CompletionListener object. It is up to the JMS provider to decide exactly what is performed in the calling thread and what, if anything, is performed asynchronously, so long as it satisfies the requirements given below: Quality of service: After the send operation has completed successfully, which means that the message has been successfully sent with the same degree of confidence as if a normal synchronous send had been performed, the JMS provider must invoke the CompletionListener's onCompletion method. The CompletionListener must not be invoked earlier than this. Exceptions: If an exception is encountered during the call to the send method then an appropriate exception should be thrown in the thread that is calling the send method. In this case the JMS provider must not invoke the CompletionListener's onCompletion or onException method. If an exception is encountered which cannot be thrown in the thread that is calling the send method then the JMS provider must call the CompletionListener's onException method. In both cases if an exception occurs it is undefined whether or not the message was successfully sent. Message order: If the same MessageProducer is used to send multiple messages then JMS message ordering requirements must be satisfied. This applies even if a combination of synchronous and asynchronous sends has been performed. The application is not required to wait for an asynchronous send to complete before sending the next message. Close, commit or rollback: If the close method is called on the MessageProducer or its Session or Connection then the JMS provider must block until any incomplete send operations have been completed and all CompletionListener callbacks have returned before closing the object and returning. If the session is transacted (uses a local transaction) then when the Session's commit or rollback method is called the JMS provider must block until any incomplete send operations have been completed and all CompletionListener callbacks have returned before performing the commit or rollback. Incomplete sends should be allowed to complete normally unless an error occurs. A CompletionListener callback method must not call close on its own Connection, Session or MessageProducer or call commit or rollback on its own Session. Doing so will cause the close, commit or rollback to throw an IllegalStateException. Restrictions on usage in Jakarta EE This method must not be used in a Jakarta EE Enterprise Beans or web container. Doing so may cause a JMSException to be thrown though this is not guaranteed. Message headers JMS defines a number of message header fields and message properties which must be set by the "JMS provider on send". If the send is asynchronous these fields and properties may be accessed on the sending client only after the CompletionListener has been invoked. If the CompletionListener's onException method is called then the state of these message header fields and properties is undefined. Restrictions on threading: Applications that perform an asynchronous send must confirm to the threading restrictions defined in JMS. This means that the session may be used by only one thread at a time. Setting a CompletionListener does not cause the session to be dedicated to the thread of control which calls the CompletionListener. The application thread may therefore continue to use the session after performing an asynchronous send. However the CompletionListener's callback methods must not use the session if an application thread might be using the session at the same time. Use of the CompletionListener by the JMS provider: A session will only invoke one CompletionListener callback method at a time. For a given MessageProducer, callbacks (both onCompletion and onException) will be performed in the same order as the corresponding calls to the asynchronous send method. A JMS provider must not invoke the CompletionListener from the thread that is calling the asynchronous send method. Restrictions on the use of the Message object: Applications which perform an asynchronous send must take account of the restriction that a Message object is designed to be accessed by one logical thread of control at a time and does not support concurrent use. After the send method has returned, the application must not attempt to read the headers, properties or body of the Message object until the CompletionListener's onCompletion or onException method has been called. This is because the JMS provider may be modifying the Message object in another thread during this time. The JMS provider may throw an JMSException if the application attempts to access or modify the Message object after the send method has returned and before the CompletionListener has been invoked. If the JMS provider does not throw an exception then the behaviour is undefined.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageProducer</class-interface>
      <method name="send" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Message</parameter>
          <parameter>int</parameter>
          <parameter>int</parameter>
          <parameter>long</parameter>
          <parameter>jakarta.jms.CompletionListener</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:894</id>
      <description>if an internal error occurs</description>
      <package>jakarta.jms</package>
      <class-interface>MessageProducer</class-interface>
      <method name="send" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Message</parameter>
          <parameter>int</parameter>
          <parameter>int</parameter>
          <parameter>long</parameter>
          <parameter>jakarta.jms.CompletionListener</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:895</id>
      <description>if an invalid message is specified.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageProducer</class-interface>
      <method name="send" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Message</parameter>
          <parameter>int</parameter>
          <parameter>int</parameter>
          <parameter>long</parameter>
          <parameter>jakarta.jms.CompletionListener</parameter>
        </parameters>
        <throw>jakarta.jms.MessageFormatException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:896</id>
      <description>if a client uses this method with a MessageProducer with an invalid destination.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageProducer</class-interface>
      <method name="send" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Message</parameter>
          <parameter>int</parameter>
          <parameter>int</parameter>
          <parameter>long</parameter>
          <parameter>jakarta.jms.CompletionListener</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidDestinationException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:897</id>
      <description>if a client uses this method with a MessageProducer that did not specify a destination at creation time.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageProducer</class-interface>
      <method name="send" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Message</parameter>
          <parameter>int</parameter>
          <parameter>int</parameter>
          <parameter>long</parameter>
          <parameter>jakarta.jms.CompletionListener</parameter>
        </parameters>
        <throw>java.lang.UnsupportedOperationException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:898</id>
      <description>Sends a message to a destination for an unidentified message producer, using the MessageProducer's default delivery mode, priority, and time to live, performing part of the work involved in sending the message in a separate thread and notifying the specified CompletionListener when the operation has completed. JMS refers to this as an "asynchronous send". Typically, a message producer is assigned a destination at creation time; however, the JMS API also supports unidentified message producers, which require that the destination be supplied every time a message is sent. When the message has been successfully sent the JMS provider invokes the callback method onCompletion on an application-specified CompletionListener object. Only when that callback has been invoked can the application be sure that the message has been successfully sent with the same degree of confidence as if a normal synchronous send had been performed. An application which requires this degree of confidence must therefore wait for the callback to be invoked before continuing. The following information is intended to give an indication of how an asynchronous send would typically be implemented. In some JMS providers, a normal synchronous send involves sending the message to a remote JMS server and then waiting for an acknowledgement to be received before returning. It is expected that such a provider would implement an asynchronous send by sending the message to the remote JMS server and then returning without waiting for an acknowledgement. When the acknowledgement is received, the JMS provider would notify the application by invoking the onCompletion method on the application-specified CompletionListener object. If for some reason the acknowledgement is not received the JMS provider would notify the application by invoking the CompletionListener's onException method. In those cases where the JMS specification permits a lower level of reliability, a normal synchronous send might not wait for an acknowledgement. In that case it is expected that an asynchronous send would be similar to a synchronous send: the JMS provider would send the message to the remote JMS server and then return without waiting for an acknowledgement. However the JMS provider would still notify the application that the send had completed by invoking the onCompletion method on the application-specified CompletionListener object. It is up to the JMS provider to decide exactly what is performed in the calling thread and what, if anything, is performed asynchronously, so long as it satisfies the requirements given below: Quality of service: After the send operation has completed successfully, which means that the message has been successfully sent with the same degree of confidence as if a normal synchronous send had been performed, the JMS provider must invoke the CompletionListener's onCompletion method. The CompletionListener must not be invoked earlier than this. Exceptions: If an exception is encountered during the call to the send method then an appropriate exception should be thrown in the thread that is calling the send method. In this case the JMS provider must not invoke the CompletionListener's onCompletion or onException method. If an exception is encountered which cannot be thrown in the thread that is calling the send method then the JMS provider must call the CompletionListener's onException method. In both cases if an exception occurs it is undefined whether or not the message was successfully sent. Message order: If the same MessageProducer is used to send multiple messages then JMS message ordering requirements must be satisfied. This applies even if a combination of synchronous and asynchronous sends has been performed. The application is not required to wait for an asynchronous send to complete before sending the next message. Close, commit or rollback: If the close method is called on the MessageProducer or its Session or Connection then the JMS provider must block until any incomplete send operations have been completed and all CompletionListener callbacks have returned before closing the object and returning. If the session is transacted (uses a local transaction) then when the Session's commit or rollback method is called the JMS provider must block until any incomplete send operations have been completed and all CompletionListener callbacks have returned before performing the commit or rollback. Incomplete sends should be allowed to complete normally unless an error occurs. A CompletionListener callback method must not call close on its own Connection, Session or MessageProducer or call commit or rollback on its own Session. Doing so will cause the close, commit or rollback to throw an IllegalStateException. Restrictions on usage in Jakarta EE This method must not be used in a Jakarta EE Enterprise Beans or web container. Doing so may cause a JMSException to be thrown though this is not guaranteed. Message headers JMS defines a number of message header fields and message properties which must be set by the "JMS provider on send". If the send is asynchronous these fields and properties may be accessed on the sending client only after the CompletionListener has been invoked. If the CompletionListener's onException method is called then the state of these message header fields and properties is undefined. Restrictions on threading: Applications that perform an asynchronous send must confirm to the threading restrictions defined in JMS. This means that the session may be used by only one thread at a time. Setting a CompletionListener does not cause the session to be dedicated to the thread of control which calls the CompletionListener. The application thread may therefore continue to use the session after performing an asynchronous send. However the CompletionListener's callback methods must not use the session if an application thread might be using the session at the same time. Use of the CompletionListener by the JMS provider: A session will only invoke one CompletionListener callback method at a time. For a given MessageProducer, callbacks (both onCompletion and onException) will be performed in the same order as the corresponding calls to the asynchronous send method. A JMS provider must not invoke the CompletionListener from the thread that is calling the asynchronous send method. Restrictions on the use of the Message object: Applications which perform an asynchronous send must take account of the restriction that a Message object is designed to be accessed by one logical thread of control at a time and does not support concurrent use. After the send method has returned, the application must not attempt to read the headers, properties or body of the Message object until the CompletionListener's onCompletion or onException method has been called. This is because the JMS provider may be modifying the Message object in another thread during this time. The JMS provider may throw an JMSException if the application attempts to access or modify the Message object after the send method has returned and before the CompletionListener has been invoked. If the JMS provider does not throw an exception then the behaviour is undefined.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageProducer</class-interface>
      <method name="send" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
          <parameter>jakarta.jms.Message</parameter>
          <parameter>jakarta.jms.CompletionListener</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:899</id>
      <description>if an internal error occurs</description>
      <package>jakarta.jms</package>
      <class-interface>MessageProducer</class-interface>
      <method name="send" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
          <parameter>jakarta.jms.Message</parameter>
          <parameter>jakarta.jms.CompletionListener</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:900</id>
      <description>if an invalid message is specified.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageProducer</class-interface>
      <method name="send" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
          <parameter>jakarta.jms.Message</parameter>
          <parameter>jakarta.jms.CompletionListener</parameter>
        </parameters>
        <throw>jakarta.jms.MessageFormatException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:901</id>
      <description>if a client uses this method with an invalid destination</description>
      <package>jakarta.jms</package>
      <class-interface>MessageProducer</class-interface>
      <method name="send" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
          <parameter>jakarta.jms.Message</parameter>
          <parameter>jakarta.jms.CompletionListener</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidDestinationException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:902</id>
      <description>if a client uses this method with a MessageProducer that specified a destination at creation time.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageProducer</class-interface>
      <method name="send" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
          <parameter>jakarta.jms.Message</parameter>
          <parameter>jakarta.jms.CompletionListener</parameter>
        </parameters>
        <throw>java.lang.UnsupportedOperationException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:903</id>
      <description>Sends a message to a destination for an unidentified message producer, specifying delivery mode, priority and time to live, performing part of the work involved in sending the message in a separate thread and notifying the specified CompletionListener when the operation has completed. JMS refers to this as an "asynchronous send". Typically, a message producer is assigned a destination at creation time; however, the JMS API also supports unidentified message producers, which require that the destination be supplied every time a message is sent. When the message has been successfully sent the JMS provider invokes the callback method onCompletion on an application-specified CompletionListener object. Only when that callback has been invoked can the application be sure that the message has been successfully sent with the same degree of confidence as if a normal synchronous send had been performed. An application which requires this degree of confidence must therefore wait for the callback to be invoked before continuing. The following information is intended to give an indication of how an asynchronous send would typically be implemented. In some JMS providers, a normal synchronous send involves sending the message to a remote JMS server and then waiting for an acknowledgement to be received before returning. It is expected that such a provider would implement an asynchronous send by sending the message to the remote JMS server and then returning without waiting for an acknowledgement. When the acknowledgement is received, the JMS provider would notify the application by invoking the onCompletion method on the application-specified CompletionListener object. If for some reason the acknowledgement is not received the JMS provider would notify the application by invoking the CompletionListener's onException method. In those cases where the JMS specification permits a lower level of reliability, a normal synchronous send might not wait for an acknowledgement. In that case it is expected that an asynchronous send would be similar to a synchronous send: the JMS provider would send the message to the remote JMS server and then return without waiting for an acknowledgement. However the JMS provider would still notify the application that the send had completed by invoking the onCompletion method on the application-specified CompletionListener object. It is up to the JMS provider to decide exactly what is performed in the calling thread and what, if anything, is performed asynchronously, so long as it satisfies the requirements given below: Quality of service: After the send operation has completed successfully, which means that the message has been successfully sent with the same degree of confidence as if a normal synchronous send had been performed, the JMS provider must invoke the CompletionListener's onCompletion method. The CompletionListener must not be invoked earlier than this. Exceptions: If an exception is encountered during the call to the send method then an appropriate exception should be thrown in the thread that is calling the send method. In this case the JMS provider must not invoke the CompletionListener's onCompletion or onException method. If an exception is encountered which cannot be thrown in the thread that is calling the send method then the JMS provider must call the CompletionListener's onException method. In both cases if an exception occurs it is undefined whether or not the message was successfully sent. Message order: If the same MessageProducer is used to send multiple messages then JMS message ordering requirements must be satisfied. This applies even if a combination of synchronous and asynchronous sends has been performed. The application is not required to wait for an asynchronous send to complete before sending the next message. Close, commit or rollback: If the close method is called on the MessageProducer or its Session or Connection then the JMS provider must block until any incomplete send operations have been completed and all CompletionListener callbacks have returned before closing the object and returning. If the session is transacted (uses a local transaction) then when the Session's commit or rollback method is called the JMS provider must block until any incomplete send operations have been completed and all CompletionListener callbacks have returned before performing the commit or rollback. Incomplete sends should be allowed to complete normally unless an error occurs. A CompletionListener callback method must not call close on its own Connection, Session or MessageProducer or call commit or rollback on its own Session. Doing so will cause the close, commit or rollback to throw an IllegalStateException. Restrictions on usage in Jakarta EE This method must not be used in a Jakarta EE Enterprise Beans or web container. Doing so may cause a JMSException to be thrown though this is not guaranteed. Message headers JMS defines a number of message header fields and message properties which must be set by the "JMS provider on send". If the send is asynchronous these fields and properties may be accessed on the sending client only after the CompletionListener has been invoked. If the CompletionListener's onException method is called then the state of these message header fields and properties is undefined. Restrictions on threading: Applications that perform an asynchronous send must confirm to the threading restrictions defined in JMS. This means that the session may be used by only one thread at a time. Setting a CompletionListener does not cause the session to be dedicated to the thread of control which calls the CompletionListener. The application thread may therefore continue to use the session after performing an asynchronous send. However the CompletionListener's callback methods must not use the session if an application thread might be using the session at the same time. Use of the CompletionListener by the JMS provider: A session will only invoke one CompletionListener callback method at a time. For a given MessageProducer, callbacks (both onCompletion and onException) will be performed in the same order as the corresponding calls to the asynchronous send method. A JMS provider must not invoke the CompletionListener from the thread that is calling the asynchronous send method. Restrictions on the use of the Message object: Applications which perform an asynchronous send must take account of the restriction that a Message object is designed to be accessed by one logical thread of control at a time and does not support concurrent use. After the send method has returned, the application must not attempt to read the headers, properties or body of the Message object until the CompletionListener's onCompletion or onException method has been called. This is because the JMS provider may be modifying the Message object in another thread during this time. The JMS provider may throw an JMSException if the application attempts to access or modify the Message object after the send method has returned and before the CompletionListener has been invoked. If the JMS provider does not throw an exception then the behaviour is undefined.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageProducer</class-interface>
      <method name="send" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
          <parameter>jakarta.jms.Message</parameter>
          <parameter>int</parameter>
          <parameter>int</parameter>
          <parameter>long</parameter>
          <parameter>jakarta.jms.CompletionListener</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:904</id>
      <description>if an internal error occurs</description>
      <package>jakarta.jms</package>
      <class-interface>MessageProducer</class-interface>
      <method name="send" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
          <parameter>jakarta.jms.Message</parameter>
          <parameter>int</parameter>
          <parameter>int</parameter>
          <parameter>long</parameter>
          <parameter>jakarta.jms.CompletionListener</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:905</id>
      <description>if an invalid message is specified.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageProducer</class-interface>
      <method name="send" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
          <parameter>jakarta.jms.Message</parameter>
          <parameter>int</parameter>
          <parameter>int</parameter>
          <parameter>long</parameter>
          <parameter>jakarta.jms.CompletionListener</parameter>
        </parameters>
        <throw>jakarta.jms.MessageFormatException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:906</id>
      <description>if a client uses this method with an invalid destination.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageProducer</class-interface>
      <method name="send" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
          <parameter>jakarta.jms.Message</parameter>
          <parameter>int</parameter>
          <parameter>int</parameter>
          <parameter>long</parameter>
          <parameter>jakarta.jms.CompletionListener</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidDestinationException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:907</id>
      <description>Sets the minimum length of time in milliseconds that must elapse after a message is sent before the JMS provider may deliver the message to a consumer. For transacted sends, this time starts when the client sends the message, not when the transaction is committed. deliveryDelay is set to zero by default.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageProducer</class-interface>
      <method name="setDeliveryDelay" return-type="void">
        <parameters>
          <parameter>long</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:908</id>
      <description>if the JMS provider fails to set the delivery delay due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageProducer</class-interface>
      <method name="setDeliveryDelay" return-type="void">
        <parameters>
          <parameter>long</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:909</id>
      <description>Acknowledges all messages consumed by the JMSContext's session. This method is for use when the session has an acknowledgement mode of CLIENT_ACKNOWLEDGE. If the session is transacted or has an acknowledgement mode of AUTO_ACKNOWLEDGE or DUPS_OK_ACKNOWLEDGE calling this method has no effect. This method has identical behaviour to the acknowledge method on Message. A client may individually acknowledge each message as it is consumed, or it may choose to acknowledge messages as an application-defined group. In both cases it makes no difference which of these two methods is used. Messages that have been received but not acknowledged may be redelivered. This method must not be used if the JMSContext is container-managed (injected). Doing so will cause a IllegalStateRuntimeException to be thrown.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="acknowledge" return-type="void"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:912</id>
      <description>Closes the JMSContext This closes the underlying session and any underlying producers and consumers. If there are no other active (not closed) JMSContext objects using the underlying connection then this method also closes the underlying connection. Since a provider typically allocates significant resources outside the JVM on behalf of a connection, clients should close these resources when they are not needed. Relying on garbage collection to eventually reclaim these resources may not be timely enough. Closing a connection causes all temporary destinations to be deleted. When this method is invoked, it should not return until message processing has been shut down in an orderly fashion. This means that all message listeners that may have been running have returned, and that all pending receives have returned. A close terminates all pending message receives on the connection's sessions' consumers. The receives may return with a message or with null, depending on whether there was a message available at the time of the close. If one or more of the connection's sessions' message listeners is processing a message at the time when connection close is invoked, all the facilities of the connection and its sessions must remain available to those listeners until they return control to the JMS provider. This method must not return until any incomplete asynchronous send operations for this JMSContext have been completed and any CompletionListener callbacks have returned. Incomplete sends should be allowed to complete normally unless an error occurs. For the avoidance of doubt, if an exception listener for the JMSContext's connection is running when close is invoked, there is no requirement for the close call to wait until the exception listener has returned before it may return. Closing a connection causes any of its sessions' transactions in progress to be rolled back. In the case where a session's work is coordinated by an external transaction manager, a session's commit and rollback methods are not used and the result of a closed session's work is determined later by the transaction manager. Closing a connection does NOT force an acknowledgment of client-acknowledged sessions. Invoking the acknowledge method of a received message from a closed connection's session must throw an IllegalStateRuntimeException. Closing a closed connection must NOT throw an exception. A MessageListener must not attempt to close its own JMSContext as this would lead to deadlock. The JMS provider must detect this and throw a IllegalStateRuntimeException. A CompletionListener callback method must not call close on its own JMSContext. Doing so will cause an IllegalStateRuntimeException to be thrown. This method must not be used if the JMSContext is container-managed (injected). Doing so will cause a IllegalStateRuntimeException to be thrown.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="close" return-type="void"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:914</id>
      <description>Commits all messages done in this transaction and releases any locks currently held. This method must not return until any incomplete asynchronous send operations for this JMSContext have been completed and any CompletionListener callbacks have returned. Incomplete sends should be allowed to complete normally unless an error occurs. A CompletionListener callback method must not call commit on its own JMSContext. Doing so will cause an IllegalStateRuntimeException to be thrown. This method must not be used if the JMSContext is container-managed (injected). Doing so will cause a IllegalStateRuntimeException to be thrown.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="commit" return-type="void"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:915</id>
      <description>if the JMS provider fails to commit the transaction due to some internal error</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="commit" return-type="void">
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:916</id>
      <description>if the transaction is rolled back due to some internal error during commit.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="commit" return-type="void">
        <throw>jakarta.jms.TransactionRolledBackRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:917</id>
      <description>if the JMSContext's session is not using a local transaction if this method has been called by a CompletionListener callback method on its own JMSContext if the JMSContext is container-managed (injected)</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="commit" return-type="void">
        <throw>jakarta.jms.IllegalStateRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:918</id>
      <description>Creates a QueueBrowser object to peek at the messages on the specified queue.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="createBrowser" return-type="jakarta.jms.QueueBrowser">
        <parameters>
          <parameter>jakarta.jms.Queue</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:919</id>
      <description>if the session fails to create a browser due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="createBrowser" return-type="jakarta.jms.QueueBrowser">
        <parameters>
          <parameter>jakarta.jms.Queue</parameter>
        </parameters>
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:920</id>
      <description>if an invalid destination is specified</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="createBrowser" return-type="jakarta.jms.QueueBrowser">
        <parameters>
          <parameter>jakarta.jms.Queue</parameter>
        </parameters>
        <throw>InvalidRuntimeDestinationException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:921</id>
      <description>Creates a QueueBrowser object to peek at the messages on the specified queue using a message selector.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="createBrowser" return-type="jakarta.jms.QueueBrowser">
        <parameters>
          <parameter>jakarta.jms.Queue</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:922</id>
      <description>if the session fails to create a browser due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="createBrowser" return-type="jakarta.jms.QueueBrowser">
        <parameters>
          <parameter>jakarta.jms.Queue</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:923</id>
      <description>if an invalid destination is specified</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="createBrowser" return-type="jakarta.jms.QueueBrowser">
        <parameters>
          <parameter>jakarta.jms.Queue</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>InvalidRuntimeDestinationException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:924</id>
      <description>if the message selector is invalid.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="createBrowser" return-type="jakarta.jms.QueueBrowser">
        <parameters>
          <parameter>jakarta.jms.Queue</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>InvalidRuntimeSelectorException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:925</id>
      <description>Creates a BytesMessage object. A BytesMessage object is used to send a message containing a stream of uninterpreted bytes.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="createBytesMessage" return-type="jakarta.jms.BytesMessage"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:926</id>
      <description>if the JMS provider fails to create this message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="createBytesMessage" return-type="jakarta.jms.BytesMessage">
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:927</id>
      <description>Creates a MapMessage object. A MapMessage object is used to send a self-defining set of name-value pairs, where names are String objects and values are primitive values in the Java programming language. The message object returned may be sent using any Session or JMSContext. It is not restricted to being sent using the JMSContext used to create it. The message object returned may be optimised for use with the JMS provider used to create it. However it can be sent using any JMS provider, not just the JMS provider used to create it.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="createMapMessage" return-type="jakarta.jms.MapMessage"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:928</id>
      <description>if the JMS provider fails to create this message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="createMapMessage" return-type="jakarta.jms.MapMessage">
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:929</id>
      <description>Creates a Message object. The Message interface is the root interface of all JMS messages. A Message object holds all the standard message header information. It can be sent when a message containing only header information is sufficient. The message object returned may be sent using any Session or JMSContext. It is not restricted to being sent using the JMSContext used to create it. The message object returned may be optimised for use with the JMS provider used to create it. However it can be sent using any JMS provider, not just the JMS provider used to create it.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="createMessage" return-type="jakarta.jms.Message"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:930</id>
      <description>if the JMS provider fails to create this message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="createMessage" return-type="jakarta.jms.Message">
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:931</id>
      <description>Creates a new JMSContext with the specified session mode using the same connection as this JMSContext and creating a new session. This method does not start the connection. If the connection has not already been started then it will be automatically started when a JMSConsumer is created on any of the JMSContext objects for that connection. If sessionMode is set to JMSContext.SESSION_TRANSACTED then the session will use a local transaction which may subsequently be committed or rolled back by calling the JMSContext's commit or rollback methods. If sessionMode is set to any of JMSContext.CLIENT_ACKNOWLEDGE, JMSContext.AUTO_ACKNOWLEDGE or JMSContext.DUPS_OK_ACKNOWLEDGE. then the session will be non-transacted and messages received by this session will be acknowledged according to the value of sessionMode. For a definition of the meaning of these acknowledgement modes see the links below. This method must not be used by applications running in the Jakarta EE web or Enterprise Beans containers because doing so would violate the restriction that such an application must not attempt to create more than one active (not closed) Session object per connection. If this method is called in a Jakarta EE web or Enterprise Beans container then a JMSRuntimeException will be thrown.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="createContext" return-type="jakarta.jms.JMSContext">
        <parameters>
          <parameter>int</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:932</id>
      <description>if the JMS provider fails to create the JMSContext due to some internal error or because this method is being called in a Jakarta EE web or Enterprise Beans application.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="createContext" return-type="jakarta.jms.JMSContext">
        <parameters>
          <parameter>int</parameter>
        </parameters>
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:934</id>
      <description>Creates an ObjectMessage object. An ObjectMessage object is used to send a message that contains a serializable Java object. The message object returned may be sent using any Session or JMSContext. It is not restricted to being sent using the JMSContext used to create it. The message object returned may be optimised for use with the JMS provider used to create it. However it can be sent using any JMS provider, not just the JMS provider used to create it.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="createObjectMessage" return-type="jakarta.jms.ObjectMessage"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:935</id>
      <description>if the JMS provider fails to create this message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="createObjectMessage" return-type="jakarta.jms.ObjectMessage">
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:936</id>
      <description>Creates an initialized ObjectMessage object. An ObjectMessage object is used to send a message that contains a serializable Java object. The message object returned may be sent using any Session or JMSContext. It is not restricted to being sent using the JMSContext used to create it. The message object returned may be optimised for use with the JMS provider used to create it. However it can be sent using any JMS provider, not just the JMS provider used to create it.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="createObjectMessage" return-type="jakarta.jms.ObjectMessage">
        <parameters>
          <parameter>java.io.Serializable</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:937</id>
      <description>if the JMS provider fails to create this message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="createObjectMessage" return-type="jakarta.jms.ObjectMessage">
        <parameters>
          <parameter>java.io.Serializable</parameter>
        </parameters>
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:938</id>
      <description>Creates a Queue object which encapsulates a specified provider-specific queue name. The use of provider-specific queue names in an application may render the application non-portable. Portable applications are recommended to not use this method but instead look up an administratively-defined Queue object using JNDI. Note that this method simply creates an object that encapsulates the name of a queue. It does not create the physical queue in the JMS provider. JMS does not provide a method to create the physical queue, since this would be specific to a given JMS provider. Creating a physical queue is provider-specific and is typically an administrative task performed by an administrator, though some providers may create them automatically when needed. The one exception to this is the creation of a temporary queue, which is done using the createTemporaryQueue method.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="createQueue" return-type="jakarta.jms.Queue">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:939</id>
      <description>if a Queue object cannot be created due to some internal error</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="createQueue" return-type="jakarta.jms.Queue">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:940</id>
      <description>Creates a StreamMessage object. A StreamMessage object is used to send a self-defining stream of primitive values in the Java programming language. The message object returned may be sent using any Session or JMSContext. It is not restricted to being sent using the JMSContext used to create it. The message object returned may be optimised for use with the JMS provider used to create it. However it can be sent using any JMS provider, not just the JMS provider used to create it.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="createStreamMessage" return-type="jakarta.jms.StreamMessage"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:941</id>
      <description>if the JMS provider fails to create this message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="createStreamMessage" return-type="jakarta.jms.StreamMessage">
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:942</id>
      <description>Creates a JMSConsumer for the specified destination. A client uses a JMSConsumer object to receive messages that have been sent to a destination.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="createConsumer" return-type="jakarta.jms.JMSConsumer">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:943</id>
      <description>if the session fails to create a JMSConsumer due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="createConsumer" return-type="jakarta.jms.JMSConsumer">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
        </parameters>
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:944</id>
      <description>if an invalid destination is specified.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="createConsumer" return-type="jakarta.jms.JMSConsumer">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidDestinationRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:945</id>
      <description>Creates a JMSConsumer for the specified destination, using a message selector. A client uses a JMSConsumer object to receive messages that have been sent to a destination.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="createConsumer" return-type="jakarta.jms.JMSConsumer">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:946</id>
      <description>if the session fails to create a JMSConsumer due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="createConsumer" return-type="jakarta.jms.JMSConsumer">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:947</id>
      <description>if an invalid destination is specified.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="createConsumer" return-type="jakarta.jms.JMSConsumer">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidDestinationRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:948</id>
      <description>if the message selector is invalid.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="createConsumer" return-type="jakarta.jms.JMSConsumer">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidSelectorRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:949</id>
      <description>Creates a JMSConsumer for the specified destination, specifying a message selector and the noLocal parameter. A client uses a JMSConsumer object to receive messages that have been sent to a destination. The noLocal argument is for use when the destination is a topic and the JMSContext's connection is also being used to publish messages to that topic. If noLocal is set to true then the JMSConsumer will not receive messages published to the topic by its own connection. The default value of this argument is false. If the destination is a queue then the effect of setting noLocal to true is not specified.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="createConsumer" return-type="jakarta.jms.JMSConsumer">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>boolean</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:950</id>
      <description>if the session fails to create a JMSConsumer due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="createConsumer" return-type="jakarta.jms.JMSConsumer">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>boolean</parameter>
        </parameters>
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:951</id>
      <description>if an invalid destination is specified.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="createConsumer" return-type="jakarta.jms.JMSConsumer">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>boolean</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidDestinationRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:952</id>
      <description>if the message selector is invalid.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="createConsumer" return-type="jakarta.jms.JMSConsumer">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>boolean</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidSelectorRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:953</id>
      <description>Creates an unshared durable subscription on the specified topic (if one does not already exist) and creates a consumer on that durable subscription. This method creates the durable subscription without a message selector and with a noLocal value of false. A durable subscription is used by an application which needs to receive all the messages published on a topic, including the ones published when there is no active consumer associated with it. The JMS provider retains a record of this durable subscription and ensures that all messages from the topic's publishers are retained until they are delivered to, and acknowledged by, a consumer on this durable subscription or until they have expired. A durable subscription will continue to accumulate messages until it is deleted using the unsubscribe method. This method may only be used with unshared durable subscriptions. Any durable subscription created using this method will be unshared. This means that only one active (i.e. not closed) consumer on the subscription may exist at a time. The term "consumer" here means a TopicSubscriber, MessageConsumer or JMSConsumer object in any client. An unshared durable subscription is identified by a name specified by the client and by the client identifier, which must be set. An application which subsequently wishes to create a consumer on that unshared durable subscription must use the same client identifier. If an unshared durable subscription already exists with the same name and client identifier, and the same topic, message selector and noLocal value has been specified, and there is no consumer already active (i.e. not closed) on the durable subscription then this method creates a JMSConsumer on the existing durable subscription. If an unshared durable subscription already exists with the same name and client identifier, and there is a consumer already active (i.e. not closed) on the durable subscription, then a JMSRuntimeException will be thrown. If an unshared durable subscription already exists with the same name and client identifier but a different topic, message selector or noLocal value has been specified, and there is no consumer already active (i.e. not closed) on the durable subscription then this is equivalent to unsubscribing (deleting) the old one and creating a new one. A shared durable subscription and an unshared durable subscription may not have the same name and client identifier. If a shared durable subscription already exists with the same name and client identifier then a JMSRuntimeException is thrown. There is no restriction on durable subscriptions and shared non-durable subscriptions having the same name and clientId. Such subscriptions would be completely separate.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="createDurableConsumer" return-type="jakarta.jms.JMSConsumer">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:954</id>
      <description>if the session fails to create the non-shared durable subscription and JMSConsumer due to some internal error if an unshared durable subscription already exists with the same name and client identifier, and there is a consumer already active if a shared durable subscription already exists with the same name and client identifier</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="createDurableConsumer" return-type="jakarta.jms.JMSConsumer">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:955</id>
      <description>if an invalid topic is specified.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="createDurableConsumer" return-type="jakarta.jms.JMSConsumer">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidDestinationRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:956</id>
      <description>Creates an unshared durable subscription on the specified topic (if one does not already exist), specifying a message selector and the noLocal parameter, and creates a consumer on that durable subscription. A durable subscription is used by an application which needs to receive all the messages published on a topic, including the ones published when there is no active consumer associated with it. The JMS provider retains a record of this durable subscription and ensures that all messages from the topic's publishers are retained until they are delivered to, and acknowledged by, a consumer on this durable subscription or until they have expired. A durable subscription will continue to accumulate messages until it is deleted using the unsubscribe method. This method may only be used with unshared durable subscriptions. Any durable subscription created using this method will be unshared. This means that only one active (i.e. not closed) consumer on the subscription may exist at a time. The term "consumer" here means a TopicSubscriber, MessageConsumer or JMSConsumer object in any client. An unshared durable subscription is identified by a name specified by the client and by the client identifier, which must be set. An application which subsequently wishes to create a consumer on that unshared durable subscription must use the same client identifier. If an unshared durable subscription already exists with the same name and client identifier, and the same topic, message selector and noLocal value has been specified, and there is no consumer already active (i.e. not closed) on the durable subscription then this method creates a JMSConsumer on the existing durable subscription. If an unshared durable subscription already exists with the same name and client identifier, and there is a consumer already active (i.e. not closed) on the durable subscription, then a JMSRuntimeException will be thrown. If an unshared durable subscription already exists with the same name and client identifier but a different topic, message selector or noLocal value has been specified, and there is no consumer already active (i.e. not closed) on the durable subscription then this is equivalent to unsubscribing (deleting) the old one and creating a new one. If noLocal is set to true then any messages published to the topic using this JMSContext's connection, or any other connection with the same client identifier, will not be added to the durable subscription. A shared durable subscription and an unshared durable subscription may not have the same name and client identifier. If a shared durable subscription already exists with the same name and client identifier then a JMSRuntimeException is thrown. There is no restriction on durable subscriptions and shared non-durable subscriptions having the same name and clientId. Such subscriptions would be completely separate. This method is identical to the corresponding createDurableSubscriber method except that it returns a MessageConsumer rather than a TopicSubscriber to represent the consumer.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="createDurableConsumer" return-type="jakarta.jms.JMSConsumer">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>boolean</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:957</id>
      <description>if the session fails to create the non-shared durable subscription and JMSConsumer due to some internal error if an unshared durable subscription already exists with the same name and client identifier, and there is a consumer already active if a shared durable subscription already exists with the same name and client identifier</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="createDurableConsumer" return-type="jakarta.jms.JMSConsumer">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>boolean</parameter>
        </parameters>
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:958</id>
      <description>if an invalid topic is specified.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="createDurableConsumer" return-type="jakarta.jms.JMSConsumer">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>boolean</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidDestinationRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:959</id>
      <description>if the message selector is invalid.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="createDurableConsumer" return-type="jakarta.jms.JMSConsumer">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>boolean</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidSelectorRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:960</id>
      <description>Creates a TemporaryQueue object. Its lifetime will be that of the JMSContext's Connection unless it is deleted earlier.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="createTemporaryQueue" return-type="jakarta.jms.TemporaryQueue"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:961</id>
      <description>if the session fails to create a temporary queue due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="createTemporaryQueue" return-type="jakarta.jms.TemporaryQueue">
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:962</id>
      <description>Creates a TemporaryTopic object. Its lifetime will be that of the JMSContext's Connection unless it is deleted earlier.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="createTemporaryTopic" return-type="jakarta.jms.TemporaryTopic"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:963</id>
      <description>if the session fails to create a temporary topic due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="createTemporaryTopic" return-type="jakarta.jms.TemporaryTopic">
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:964</id>
      <description>Creates a TextMessage object. A TextMessage object is used to send a message containing a String object. The message object returned may be sent using any Session or JMSContext. It is not restricted to being sent using the JMSContext used to create it. The message object returned may be optimised for use with the JMS provider used to create it. However it can be sent using any JMS provider, not just the JMS provider used to create it.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="createTextMessage" return-type="jakarta.jms.TextMessage"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:965</id>
      <description>if the JMS provider fails to create this message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="createTextMessage" return-type="jakarta.jms.TextMessage">
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:966</id>
      <description>Creates an initialized TextMessage object. A TextMessage object is used to send a message containing a String. The message object returned may be sent using any Session or JMSContext. It is not restricted to being sent using the JMSContext used to create it. The message object returned may be optimised for use with the JMS provider used to create it. However it can be sent using any JMS provider, not just the JMS provider used to create it.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="createTextMessage" return-type="jakarta.jms.TextMessage">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:967</id>
      <description>if the JMS provider fails to create this message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="createTextMessage" return-type="jakarta.jms.TextMessage">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:968</id>
      <description>Creates a Topic object which encapsulates a specified provider-specific topic name. The use of provider-specific topic names in an application may render the application non-portable. Portable applications are recommended to not use this method but instead look up an administratively-defined Topic object using JNDI. Note that this method simply creates an object that encapsulates the name of a topic. It does not create the physical topic in the JMS provider. JMS does not provide a method to create the physical topic, since this would be specific to a given JMS provider. Creating a physical topic is provider-specific and is typically an administrative task performed by an administrator, though some providers may create them automatically when needed. The one exception to this is the creation of a temporary topic, which is done using the createTemporaryTopic method.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="createTopic" return-type="jakarta.jms.Topic">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:969</id>
      <description>if a Topic object cannot be created due to some internal error</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="createTopic" return-type="jakarta.jms.Topic">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:970</id>
      <description>Gets the client identifier for the JMSContext's connection. This value is specific to the JMS provider. It is either preconfigured by an administrator in a ConnectionFactory object or assigned dynamically by the application by calling the setClientID method.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="getClientID" return-type="java.lang.String"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:971</id>
      <description>if the JMS provider fails to return the client ID for the JMSContext's connection due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="getClientID" return-type="java.lang.String">
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:980</id>
      <description>Gets the ExceptionListener object for the JMSContext's connection. Not every Connection has an ExceptionListener associated with it.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="getExceptionListener" return-type="jakarta.jms.ExceptionListener"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:981</id>
      <description>if the JMS provider fails to get the ExceptionListener for the JMSContext's connection.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="getExceptionListener" return-type="jakarta.jms.ExceptionListener">
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:982</id>
      <description>Gets the connection metadata for the JMSContext's connection.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="getMetaData" return-type="jakarta.jms.ConnectionMetaData"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:983</id>
      <description>if the JMS provider fails to get the connection metadata</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="getMetaData" return-type="jakarta.jms.ConnectionMetaData">
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:986</id>
      <description>Returns the session mode of the JMSContext's session. This can be set at the time that the JMSContext is created. Possible values are JMSContext.SESSION_TRANSACTED, JMSContext.AUTO_ACKNOWLEDGE, JMSContext.CLIENT_ACKNOWLEDGE and JMSContext.DUPS_OK_ACKNOWLEDGE If a session mode was not specified when the JMSContext was created a value of JMSContext.AUTO_ACKNOWLEDGE will be returned.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="getSessionMode" return-type="int"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:987</id>
      <description>if the JMS provider fails to return the acknowledgment mode due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="getSessionMode" return-type="int">
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:990</id>
      <description>Indicates whether the JMSContext's session is in transacted mode.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="getTransacted" return-type="boolean"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:991</id>
      <description>if the JMS provider fails to return the transaction mode due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="getTransacted" return-type="boolean">
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:992</id>
      <description>Stops message delivery in the JMSContext's session, and restarts message delivery with the oldest unacknowledged message. All consumers deliver messages in a serial order. Acknowledging a received message automatically acknowledges all messages that have been delivered to the client. Restarting a session causes it to take the following actions: Stop message delivery Mark all messages that might have been delivered but not acknowledged as "redelivered" Restart the delivery sequence including all unacknowledged messages that had been previously delivered. Redelivered messages do not have to be delivered in exactly their original delivery order. This method must not be used if the JMSContext is container-managed (injected). Doing so will cause a IllegalStateRuntimeException to be thrown.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="recover" return-type="void"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:993</id>
      <description>if the JMS provider fails to stop and restart message delivery due to some internal error</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="recover" return-type="void">
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:994</id>
      <description>if the JMSContext's session is using a transaction if the JMSContext is container-managed (injected)</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="recover" return-type="void">
        <throw>jakarta.jms.IllegalStateRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:995</id>
      <description>Rolls back any messages done in this transaction and releases any locks currently held. This method must not return until any incomplete asynchronous send operations for this JMSContext have been completed and any CompletionListener callbacks have returned. Incomplete sends should be allowed to complete normally unless an error occurs. A CompletionListener callback method must not call rollback on its own JMSContext. Doing so will cause an IllegalStateRuntimeException to be thrown. This method must not be used if the JMSContext is container-managed (injected). Doing so will cause a IllegalStateRuntimeException to be thrown.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="rollback" return-type="void"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:996</id>
      <description>if the JMS provider fails to roll back the transaction due to some internal error</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="rollback" return-type="void">
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:997</id>
      <description>if the JMSContext's session is not using a local transaction if this method has been called by a CompletionListener callback method on its own JMSContext if the JMSContext is container-managed (injected)</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="rollback" return-type="void">
        <throw>jakarta.jms.IllegalStateRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1040</id>
      <description>Sets the client identifier for the JMSContext's connection. The preferred way to assign a JMS client's client identifier is for it to be configured in a client-specific ConnectionFactory object and transparently assigned to the Connection object it creates. Alternatively, a client can set the client identifier for the MessageContext's connection using a provider-specific value. The facility to set its client identifier explicitly is not a mechanism for overriding the identifier that has been administratively configured. It is provided for the case where no administratively specified identifier exists. If one does exist, an attempt to change it by setting it must throw an IllegalStateRuntimeException. If a client sets the client identifier explicitly, it must do so immediately after it creates the JMSContext and before any other action on the JMSContext is taken. After this point, setting the client identifier is a programming error that should throw an IllegalStateRuntimeException. The purpose of the client identifier is to associate the JMSContext's connection and its objects with a state maintained on behalf of the client by a provider. The only such state identified by the JMS API is that required to support durable subscriptions. If another connection with the same clientID is already running when this method is called, the JMS provider should detect the duplicate ID and throw an InvalidClientIDException. This method must not be used in a Jakarta EE web or Enterprise Beans application. Doing so may cause a JMSRuntimeException to be thrown though this is not guaranteed. This method must not be used if the JMSContext is container-managed (injected). Doing so will cause a IllegalStateRuntimeException to be thrown.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="setClientID" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:1041</id>
      <description>if the JMS provider fails to set the client ID for the the JMSContext's connection for one of the following reasons: an internal error has occurred or this method has been called in a Jakarta EE web or Enterprise Beans application (though it is not guaranteed that an exception is thrown in this case)</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="setClientID" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1042</id>
      <description>if the JMS client specifies an invalid or duplicate client ID.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="setClientID" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidClientIDRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1043</id>
      <description>if the JMS client attempts to set the client ID for the JMSContext's connection at the wrong time or if the client ID has been administratively configured or if the JMSContext is container-managed (injected).</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="setClientID" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.IllegalStateRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1052</id>
      <description>Sets an exception listener for the JMSContext's connection. If a JMS provider detects a serious problem with a connection, it informs the connection's ExceptionListener, if one has been registered. It does this by calling the listener's onException method, passing it a JMSRuntimeException object describing the problem. An exception listener allows a client to be notified of a problem asynchronously. Some connections only consume messages, so they would have no other way to learn their connection has failed. A connection serializes execution of its ExceptionListener. A JMS provider should attempt to resolve connection problems itself before it notifies the client of them. This method must not be used in a Jakarta EE web or Enterprise Beans application. Doing so may cause a JMSRuntimeException to be thrown though this is not guaranteed. This method must not be used if the JMSContext is container-managed (injected). Doing so will cause a IllegalStateRuntimeException to be thrown.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="setExceptionListener" return-type="void">
        <parameters>
          <parameter>jakarta.jms.ExceptionListener</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:1053</id>
      <description>if the JMS provider fails to set the exception listener for one of the following reasons: an internal error has occurred or this method has been called in a Jakarta EE web or Enterprise Beans application (though it is not guaranteed that an exception is thrown in this case)</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="setExceptionListener" return-type="void">
        <parameters>
          <parameter>jakarta.jms.ExceptionListener</parameter>
        </parameters>
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1076</id>
      <description>Starts (or restarts) delivery of incoming messages by the JMSContext's connection. A call to start on a connection that has already been started is ignored. This method must not be used if the JMSContext is container-managed (injected). Doing so will cause a IllegalStateRuntimeException to be thrown.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="start" return-type="void"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:1077</id>
      <description>if the JMS provider fails to start message delivery due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="start" return-type="void">
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1078</id>
      <description>Temporarily stops the delivery of incoming messages by the JMSContext's connection. Delivery can be restarted using the start method. When the connection is stopped, delivery to all the connection's message consumers is inhibited: synchronous receives block, and messages are not delivered to message listeners. This call blocks until receives and/or message listeners in progress have completed. Stopping a connection has no effect on its ability to send messages. A call to stop on a connection that has already been stopped is ignored. A call to stop must not return until delivery of messages has paused. This means that a client can rely on the fact that none of its message listeners will be called and that all threads of control waiting for receive calls to return will not return with a message until the connection is restarted. The receive timers for a stopped connection continue to advance, so receives may time out while the connection is stopped. If message listeners are running when stop is invoked, the stop call must wait until all of them have returned before it may return. While these message listeners are completing, they must have the full services of the connection available to them. A message listener must not attempt to stop its own JMSContext as this would lead to deadlock. The JMS provider must detect this and throw a IllegalStateRuntimeException For the avoidance of doubt, if an exception listener for the JMSContext's connection is running when stop is invoked, there is no requirement for the stop call to wait until the exception listener has returned before it may return. This method must not be used in a Jakarta EE web or Enterprise Beans application. Doing so may cause a JMSRuntimeException to be thrown though this is not guaranteed. This method must not be used if the JMSContext is container-managed (injected). Doing so will cause a IllegalStateRuntimeException to be thrown.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="stop" return-type="void"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:1079</id>
      <description>if the JMS provider fails to stop message delivery for one of the following reasons: an internal error has occurred or this method has been called in a Jakarta EE web or Enterprise Beans application (though it is not guaranteed that an exception is thrown in this case)</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="stop" return-type="void">
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1084</id>
      <description>Unsubscribes a durable subscription that has been created by a client. This method deletes the state being maintained on behalf of the subscriber by its provider. A durable subscription is identified by a name specified by the client and by the client identifier if set. If the client identifier was set when the durable subscription was created then a client which subsequently wishes to use this method to delete a durable subscription must use the same client identifier. It is erroneous for a client to delete a durable subscription while there is an active (not closed) consumer on that subscription, or while a consumed message is part of a pending transaction or has not been acknowledged in the session. If the active consumer is represented by a JMSConsumer then calling close on either that object or the JMSContext used to create it will render the consumer inactive and allow the subscription to be deleted. If the active consumer was created by calling setMessageListener on the JMSContext then calling close on the JMSContext will render the consumer inactive and allow the subscription to be deleted. If the active consumer is represented by a MessageConsumer or TopicSubscriber then calling close on that object or on the Session or Connection used to create it will render the consumer inactive and allow the subscription to be deleted.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="unsubscribe" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:1085</id>
      <description>if the session fails to unsubscribe to the durable subscription due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="unsubscribe" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1086</id>
      <description>if an invalid subscription name is specified.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="unsubscribe" return-type="void">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidDestinationRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1087</id>
      <description>Creates an unshared durable subscription on the specified topic (if one does not already exist) and creates a consumer on that durable subscription. This method creates the durable subscription without a message selector and with a noLocal value of false. A durable subscription is used by an application which needs to receive all the messages published on a topic, including the ones published when there is no active consumer associated with it. The JMS provider retains a record of this durable subscription and ensures that all messages from the topic's publishers are retained until they are delivered to, and acknowledged by, a consumer on this durable subscription or until they have expired. A durable subscription will continue to accumulate messages until it is deleted using the unsubscribe method. This method may only be used with unshared durable subscriptions. Any durable subscription created using this method will be unshared. This means that only one active (i.e. not closed) consumer on the subscription may exist at a time. The term "consumer" here means a TopicSubscriber, MessageConsumer or JMSConsumer object in any client. An unshared durable subscription is identified by a name specified by the client and by the client identifier, which must be set. An application which subsequently wishes to create a consumer on that unshared durable subscription must use the same client identifier. If an unshared durable subscription already exists with the same name and client identifier, and the same topic, message selector and noLocal value has been specified, and there is no consumer already active (i.e. not closed) on the durable subscription then this method creates a MessageConsumer on the existing durable subscription. If an unshared durable subscription already exists with the same name and client identifier, and there is a consumer already active (i.e. not closed) on the durable subscription, then a JMSException will be thrown. If an unshared durable subscription already exists with the same name and client identifier but a different topic, message selector or noLocal value has been specified, and there is no consumer already active (i.e. not closed) on the durable subscription then this is equivalent to unsubscribing (deleting) the old one and creating a new one. A shared durable subscription and an unshared durable subscription may not have the same name and client identifier. If a shared durable subscription already exists with the same name and client identifier then a JMSException is thrown. There is no restriction on durable subscriptions and shared non-durable subscriptions having the same name and clientId. Such subscriptions would be completely separate. This method is identical to the corresponding createDurableSubscriber method except that it returns a MessageConsumer rather than a TopicSubscriber to represent the consumer.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createDurableConsumer" return-type="jakarta.jms.MessageConsumer">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:1088</id>
      <description>if the session fails to create the unshared durable subscription and MessageConsumer due to some internal error if an unshared durable subscription already exists with the same name and client identifier, and there is a consumer already active if a shared durable subscription already exists with the same name and client identifier</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createDurableConsumer" return-type="jakarta.jms.MessageConsumer">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1089</id>
      <description>if an invalid topic is specified.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createDurableConsumer" return-type="jakarta.jms.MessageConsumer">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidDestinationException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1090</id>
      <description>Creates an unshared durable subscription on the specified topic (if one does not already exist), specifying a message selector and the noLocal parameter, and creates a consumer on that durable subscription. A durable subscription is used by an application which needs to receive all the messages published on a topic, including the ones published when there is no active consumer associated with it. The JMS provider retains a record of this durable subscription and ensures that all messages from the topic's publishers are retained until they are delivered to, and acknowledged by, a consumer on this durable subscription or until they have expired. A durable subscription will continue to accumulate messages until it is deleted using the unsubscribe method. This method may only be used with unshared durable subscriptions. Any durable subscription created using this method will be unshared. This means that only one active (i.e. not closed) consumer on the subscription may exist at a time. The term "consumer" here means a TopicSubscriber, MessageConsumer or JMSConsumer object in any client. An unshared durable subscription is identified by a name specified by the client and by the client identifier, which must be set. An application which subsequently wishes to create a consumer on that unshared durable subscription must use the same client identifier. If an unshared durable subscription already exists with the same name and client identifier, and the same topic, message selector and noLocal value has been specified, and there is no consumer already active (i.e. not closed) on the durable subscription then this method creates a MessageConsumer on the existing durable subscription. If an unshared durable subscription already exists with the same name and client identifier, and there is a consumer already active (i.e. not closed) on the durable subscription, then a JMSException will be thrown. If an unshared durable subscription already exists with the same name and client identifier but a different topic, message selector or noLocal value has been specified, and there is no consumer already active (i.e. not closed) on the durable subscription then this is equivalent to unsubscribing (deleting) the old one and creating a new one. If noLocal is set to true then any messages published to the topic using this session's connection, or any other connection with the same client identifier, will not be added to the durable subscription. A shared durable subscription and an unshared durable subscription may not have the same name and client identifier. If a shared durable subscription already exists with the same name and client identifier then a JMSException is thrown. There is no restriction on durable subscriptions and shared non-durable subscriptions having the same name and clientId. Such subscriptions would be completely separate. This method is identical to the corresponding createDurableSubscriber method except that it returns a MessageConsumer rather than a TopicSubscriber to represent the consumer.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createDurableConsumer" return-type="jakarta.jms.MessageConsumer">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>boolean</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:1091</id>
      <description>if the session fails to create the unshared durable subscription and MessageConsumer due to some internal error if an unshared durable subscription already exists with the same name and client identifier, and there is a consumer already active if a shared durable subscription already exists with the same name and client identifier</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createDurableConsumer" return-type="jakarta.jms.MessageConsumer">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>boolean</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1092</id>
      <description>if an invalid topic is specified.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createDurableConsumer" return-type="jakarta.jms.MessageConsumer">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>boolean</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidDestinationException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1093</id>
      <description>if the message selector is invalid.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createDurableConsumer" return-type="jakarta.jms.MessageConsumer">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>boolean</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidSelectorException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1098</id>
      <description>Closes the JMSConsumer. Since a provider may allocate some resources on behalf of a JMSConsumer outside the Java virtual machine, clients should close them when they are not needed. Relying on garbage collection to eventually reclaim these resources may not be timely enough. This call will block until a receive call in progress on this consumer has completed. A blocked receive call returns null when this consumer is closed. If this method is called whilst a message listener is in progress in another thread then it will block until the message listener has completed. This method may be called from a message listener's onMessage method on its own consumer. After this method returns the onMessage method will be allowed to complete normally. This method is the only JMSConsumer method that can be called concurrently.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSConsumer</class-interface>
      <method name="close" return-type="void"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:1099</id>
      <description>if the JMS provider fails to close the consumer due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSConsumer</class-interface>
      <method name="close" return-type="void">
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1100</id>
      <description>Gets this JMSConsumer's message selector expression.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSConsumer</class-interface>
      <method name="getMessageSelector" return-type="java.lang.String"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:1101</id>
      <description>if the JMS provider fails to get the message selector due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSConsumer</class-interface>
      <method name="getMessageSelector" return-type="java.lang.String">
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1102</id>
      <description>Receives the next message produced for this JMSConsumer. This call blocks indefinitely until a message is produced or until this JMSConsumer is closed. If this receive is done within a transaction, the JMSConsumer retains the message until the transaction commits.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSConsumer</class-interface>
      <method name="receive" return-type="jakarta.jms.Message"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:1103</id>
      <description>if the JMS provider fails to receive the next message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSConsumer</class-interface>
      <method name="receive" return-type="jakarta.jms.Message">
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1104</id>
      <description>Receives the next message that arrives within the specified timeout interval. This call blocks until a message arrives, the timeout expires, or this JMSConsumer is closed. A timeout of zero never expires, and the call blocks indefinitely.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSConsumer</class-interface>
      <method name="receive" return-type="jakarta.jms.Message">
        <parameters>
          <parameter>long</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:1105</id>
      <description>if the JMS provider fails to receive the next message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSConsumer</class-interface>
      <method name="receive" return-type="jakarta.jms.Message">
        <parameters>
          <parameter>long</parameter>
        </parameters>
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1106</id>
      <description>Receives the next message if one is immediately available.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSConsumer</class-interface>
      <method name="receiveNoWait" return-type="jakarta.jms.Message"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:1107</id>
      <description>if the JMS provider fails to receive the next message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSConsumer</class-interface>
      <method name="receiveNoWait" return-type="jakarta.jms.Message">
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1117</id>
      <description>Constructs a TransactionRolledBackRuntimeException with the specified detail message and error code.</description>
      <package>jakarta.jms</package>
      <class-interface>TransactionRolledBackRuntimeException</class-interface>
      <method name="TransactionRolledBackRuntimeException" return-type="TransactionRolledBackRuntimeException">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1118</id>
      <description>Constructs a TransactionRolledBackRuntimeException with the specified detail message</description>
      <package>jakarta.jms</package>
      <class-interface>TransactionRolledBackRuntimeException</class-interface>
      <method name="TransactionRolledBackRuntimeException" return-type="TransactionRolledBackRuntimeException">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1119</id>
      <description>Constructs a TransactionRolledBackRuntimeException with the specified detail message, error code and cause</description>
      <package>jakarta.jms</package>
      <class-interface>TransactionRolledBackRuntimeException</class-interface>
      <method name="TransactionRolledBackRuntimeException" return-type="TransactionRolledBackRuntimeException">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.Throwable</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1120</id>
      <description>Specifies the JNDI lookup name of a jakarta.jms.ConnectionFactory to be used when injecting a jakarta.jms.JMSContext object.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSConnectionFactory</class-interface>
      <method name="value" return-type="java.lang.String"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1121</id>
      <description>Specifies the session mode used when injecting a jakarta.jms.JMSContext object.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSSessionMode</class-interface>
      <method name="value" return-type="int"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:1125</id>
      <description>if this method has been called in a Jakarta EE web or Enterprise Beans application (though it is not guaranteed that an exception is thrown in this case)</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="run" return-type="void">
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1127</id>
      <description>Specifies the password to be used when injecting a jakarta.jms.JMSContext object</description>
      <package>jakarta.jms</package>
      <class-interface>JMSPasswordCredential</class-interface>
      <method name="password" return-type="java.lang.String"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1128</id>
      <description>Specifies the userName to be used when injecting a jakarta.jms.JMSContext object</description>
      <package>jakarta.jms</package>
      <class-interface>JMSPasswordCredential</class-interface>
      <method name="userName" return-type="java.lang.String"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1129</id>
      <description>Returns whether the underlying connection used by this JMSContext will be started automatically when a consumer is created.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="getAutoStart" return-type="boolean"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1138</id>
      <description>Specifies whether the underlying connection used by this JMSContext will be started automatically when a consumer is created. This is the default behaviour, and it may be disabled by calling this method with a value of false. This method does not itself either start or stop the connection. This method must not be used if the JMSContext is container-managed (injected). Doing so will cause a IllegalStateRuntimeException to be thrown.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="setAutoStart" return-type="void">
        <parameters>
          <parameter>boolean</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1145</id>
      <description>Gets the JMSConsumer's MessageListener. This method must not be used in a Jakarta EE web or Enterprise Beans application. Doing so may cause a JMSRuntimeException to be thrown though this is not guaranteed.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSConsumer</class-interface>
      <method name="getMessageListener" return-type="jakarta.jms.MessageListener"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:1146</id>
      <description>if the JMS provider fails to get the MessageListener for one of the following reasons: an internal error has occurred or this method has been called in a Jakarta EE web or Enterprise Beans application (though it is not guaranteed that an exception is thrown in this case)</description>
      <package>jakarta.jms</package>
      <class-interface>JMSConsumer</class-interface>
      <method name="getMessageListener" return-type="jakarta.jms.MessageListener">
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1149</id>
      <description>Sets the JMSConsumer's MessageListener. Setting the MessageListener to null is the equivalent of unsetting the MessageListener for the JMSConsumer. The effect of calling this method while messages are being consumed by an existing listener or the JMSConsumer is being used to consume messages synchronously is undefined. This method must not be used in a Jakarta EE web or Enterprise Beans application. Doing so may cause a JMSRuntimeException to be thrown though this is not guaranteed.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSConsumer</class-interface>
      <method name="setMessageListener" return-type="void">
        <parameters>
          <parameter>jakarta.jms.MessageListener</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:1150</id>
      <description>if the JMS provider fails to set the JMSConsumer's MessageListener for one of the following reasons: an internal error has occurred or this method has been called in a Jakarta EE web or Enterprise Beans application (though it is not guaranteed that an exception is thrown in this case)</description>
      <package>jakarta.jms</package>
      <class-interface>JMSConsumer</class-interface>
      <method name="setMessageListener" return-type="void">
        <parameters>
          <parameter>jakarta.jms.MessageListener</parameter>
        </parameters>
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1151</id>
      <description>Creates a shared non-durable subscription with the specified name on the specified topic (if one does not already exist) and creates a consumer on that subscription. This method creates the non-durable subscription without a message selector. If a shared non-durable subscription already exists with the same name and client identifier (if set), and the same topic and message selector has been specified, then this method creates a JMSConsumer on the existing subscription. A non-durable shared subscription is used by a client which needs to be able to share the work of receiving messages from a topic subscription amongst multiple consumers. A non-durable shared subscription may therefore have more than one consumer. Each message from the subscription will be delivered to only one of the consumers on that subscription. Such a subscription is not persisted and will be deleted (together with any undelivered messages associated with it) when there are no consumers on it. The term "consumer" here means a MessageConsumer or JMSConsumer object in any client. A shared non-durable subscription is identified by a name specified by the client and by the client identifier (which may be unset). An application which subsequently wishes to create a consumer on that shared non-durable subscription must use the same client identifier. If a shared non-durable subscription already exists with the same name and client identifier (if set) but a different topic or message selector value has been specified, and there is a consumer already active (i.e. not closed) on the subscription, then a JMSRuntimeException will be thrown. There is no restriction on durable subscriptions and shared non-durable subscriptions having the same name and clientId (which may be unset). Such subscriptions would be completely separate.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="createSharedConsumer" return-type="jakarta.jms.JMSConsumer">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1152</id>
      <description>if the session fails to create the shared non-durable subscription and JMSContext due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="createSharedConsumer" return-type="jakarta.jms.JMSConsumer">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1153</id>
      <description>if an invalid topic is specified.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="createSharedConsumer" return-type="jakarta.jms.JMSConsumer">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidDestinationRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1154</id>
      <description>if the message selector is invalid.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="createSharedConsumer" return-type="jakarta.jms.JMSConsumer">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidSelectorRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1155</id>
      <description>Creates a shared non-durable subscription with the specified name on the specified topic (if one does not already exist) specifying a message selector, and creates a consumer on that subscription. If a shared non-durable subscription already exists with the same name and client identifier (if set), and the same topic and message selector has been specified, then this method creates a JMSConsumer on the existing subscription. A non-durable shared subscription is used by a client which needs to be able to share the work of receiving messages from a topic subscription amongst multiple consumers. A non-durable shared subscription may therefore have more than one consumer. Each message from the subscription will be delivered to only one of the consumers on that subscription. Such a subscription is not persisted and will be deleted (together with any undelivered messages associated with it) when there are no consumers on it. The term "consumer" here means a MessageConsumer or JMSConsumer object in any client. A shared non-durable subscription is identified by a name specified by the client and by the client identifier (which may be unset). An application which subsequently wishes to create a consumer on that shared non-durable subscription must use the same client identifier. If a shared non-durable subscription already exists with the same name and client identifier (if set) but a different topic or message selector has been specified, and there is a consumer already active (i.e. not closed) on the subscription, then a JMSRuntimeException will be thrown. There is no restriction on durable subscriptions and shared non-durable subscriptions having the same name and clientId (which may be unset). Such subscriptions would be completely separate.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="createSharedConsumer" return-type="jakarta.jms.JMSConsumer">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1156</id>
      <description>if the session fails to create the shared non-durable subscription and JMSConsumer due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="createSharedConsumer" return-type="jakarta.jms.JMSConsumer">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1157</id>
      <description>if an invalid topic is specified.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="createSharedConsumer" return-type="jakarta.jms.JMSConsumer">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidDestinationRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1158</id>
      <description>if the message selector is invalid.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="createSharedConsumer" return-type="jakarta.jms.JMSConsumer">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidSelectorRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1160</id>
      <description>if the session fails to create the shared durable subscription and JMSConsumer due to some internal error if a shared durable subscription already exists with the same name and client identifier, but a different topic, or message selector, and there is a consumer already active if an unshared durable subscription already exists with the same name and client identifier</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="createSharedDurableConsumer" return-type="jakarta.jms.JMSConsumer">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1161</id>
      <description>if an invalid topic is specified.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="createSharedDurableConsumer" return-type="jakarta.jms.JMSConsumer">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidDestinationRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1162</id>
      <description>if the message selector is invalid.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="createSharedDurableConsumer" return-type="jakarta.jms.JMSConsumer">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidSelectorRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1163</id>
      <description>Creates a shared non-durable subscription with the specified name on the specified topic (if one does not already exist) and creates a consumer on that subscription. This method creates the non-durable subscription without a message selector. If a shared non-durable subscription already exists with the same name and client identifier (if set), and the same topic and message selector value has been specified, then this method creates a MessageConsumer on the existing subscription. A non-durable shared subscription is used by a client which needs to be able to share the work of receiving messages from a topic subscription amongst multiple consumers. A non-durable shared subscription may therefore have more than one consumer. Each message from the subscription will be delivered to only one of the consumers on that subscription. Such a subscription is not persisted and will be deleted (together with any undelivered messages associated with it) when there are no consumers on it. The term "consumer" here means a MessageConsumer or JMSConsumer object in any client. A shared non-durable subscription is identified by a name specified by the client and by the client identifier (which may be unset). An application which subsequently wishes to create a consumer on that shared non-durable subscription must use the same client identifier. If a shared non-durable subscription already exists with the same name and client identifier (if set) but a different topic or message selector has been specified, and there is a consumer already active (i.e. not closed) on the subscription, then a JMSException will be thrown. There is no restriction on durable subscriptions and shared non-durable subscriptions having the same name and clientId (which may be unset). Such subscriptions would be completely separate.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createSharedConsumer" return-type="jakarta.jms.MessageConsumer">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1164</id>
      <description>if the session fails to create the shared non-durable subscription and MessageConsumer due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createSharedConsumer" return-type="jakarta.jms.MessageConsumer">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1165</id>
      <description>if an invalid topic is specified.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createSharedConsumer" return-type="jakarta.jms.MessageConsumer">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidDestinationException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1166</id>
      <description>if the message selector is invalid.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createSharedConsumer" return-type="jakarta.jms.MessageConsumer">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidSelectorException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1167</id>
      <description>Creates a shared non-durable subscription with the specified name on the specified topic (if one does not already exist) specifying a message selector, and creates a consumer on that subscription. If a shared non-durable subscription already exists with the same name and client identifier (if set), and the same topic and message selector has been specified, then this method creates a MessageConsumer on the existing subscription. A non-durable shared subscription is used by a client which needs to be able to share the work of receiving messages from a topic subscription amongst multiple consumers. A non-durable shared subscription may therefore have more than one consumer. Each message from the subscription will be delivered to only one of the consumers on that subscription. Such a subscription is not persisted and will be deleted (together with any undelivered messages associated with it) when there are no consumers on it. The term "consumer" here means a MessageConsumer or JMSConsumer object in any client. A shared non-durable subscription is identified by a name specified by the client and by the client identifier (which may be unset). An application which subsequently wishes to create a consumer on that shared non-durable subscription must use the same client identifier. If a shared non-durable subscription already exists with the same name and client identifier (if set) but a different topic or message selector has been specified, and there is a consumer already active (i.e. not closed) on the subscription, then a JMSException will be thrown. There is no restriction on durable subscriptions and shared non-durable subscriptions having the same name and clientId (which may be unset). Such subscriptions would be completely separate.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createSharedConsumer" return-type="jakarta.jms.MessageConsumer">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1168</id>
      <description>if the session fails to create the shared non-durable subscription and MessageConsumer due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createSharedConsumer" return-type="jakarta.jms.MessageConsumer">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1169</id>
      <description>if an invalid topic is specified.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createSharedConsumer" return-type="jakarta.jms.MessageConsumer">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidDestinationException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1170</id>
      <description>if the message selector is invalid.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createSharedConsumer" return-type="jakarta.jms.MessageConsumer">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidSelectorException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:1175</id>
      <description>if the JMS provider fails to acknowledge the messages due to some internal error</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="acknowledge" return-type="void">
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:1176</id>
      <description>if the JMS provider fails to close the JMSContext due to some internal error. For example, a failure to release resources or to close a socket connection can cause this exception to be thrown.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="close" return-type="void">
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1177</id>
      <description>Creates a new JMSProducer object which can be used to configure and send messages</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="createProducer" return-type="jakarta.jms.JMSProducer"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1180</id>
      <description>Clears any message properties set on this JMSProducer</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="clearProperties" return-type="jakarta.jms.JMSProducer"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:1181</id>
      <description>if the JMS provider fails to clear the message properties due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="clearProperties" return-type="jakarta.jms.JMSProducer">
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1182</id>
      <description>If subsequent calls to send on this JMSProducer object have been configured to be asynchronous then this method returns the CompletionListener that has previously been configured. If subsequent calls to send have been configured to be synchronous then this method returns null.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="getAsync" return-type="jakarta.jms.CompletionListener"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:1183</id>
      <description>if the JMS provider fails to get the required information due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="getAsync" return-type="jakarta.jms.CompletionListener">
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1184</id>
      <description>Returns the message property with the specified name that has been set on this JMSProducer, converted to a boolean.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="getBooleanProperty" return-type="boolean">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:1185</id>
      <description>if the JMS provider fails to get the property value due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="getBooleanProperty" return-type="boolean">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1186</id>
      <description>if this type conversion is invalid.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="getBooleanProperty" return-type="boolean">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.MessageFormatRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1187</id>
      <description>Returns the message property with the specified name that has been set on this JMSProducer, converted to a String.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="getByteProperty" return-type="byte">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:1188</id>
      <description>if the JMS provider fails to get the property value due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="getByteProperty" return-type="byte">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1189</id>
      <description>if this type conversion is invalid.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="getByteProperty" return-type="byte">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.MessageFormatRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1190</id>
      <description>Gets the minimum length of time in milliseconds that must elapse after a message is sent before the JMS provider may deliver the message to a consumer.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="getDeliveryDelay" return-type="long"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:1191</id>
      <description>if the JMS provider fails to get the delivery delay due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="getDeliveryDelay" return-type="long">
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1192</id>
      <description>Returns the delivery mode of messages that are sent using this JMSProducer</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="getDeliveryMode" return-type="int"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:1193</id>
      <description>if the JMS provider fails to get the delivery mode due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="getDeliveryMode" return-type="int">
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1194</id>
      <description>Gets an indication of whether message IDs are disabled.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="getDisableMessageID" return-type="boolean"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:1195</id>
      <description>if the JMS provider fails to determine if message IDs are disabled due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="getDisableMessageID" return-type="boolean">
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1196</id>
      <description>Gets an indication of whether message timestamps are disabled.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="getDisableMessageTimestamp" return-type="boolean"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:1197</id>
      <description>if the JMS provider fails to determine if timestamps are disabled due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="getDisableMessageTimestamp" return-type="boolean">
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1198</id>
      <description>Returns the message property with the specified name that has been set on this JMSProducer, converted to a double.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="getDoubleProperty" return-type="double">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:1199</id>
      <description>if the JMS provider fails to get the property value due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="getDoubleProperty" return-type="double">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1200</id>
      <description>if this type conversion is invalid.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="getDoubleProperty" return-type="double">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.MessageFormatRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1201</id>
      <description>Returns the message property with the specified name that has been set on this JMSProducer, converted to a float.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="getFloatProperty" return-type="float">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:1202</id>
      <description>if the JMS provider fails to get the property value due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="getFloatProperty" return-type="float">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1203</id>
      <description>if this type conversion is invalid.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="getFloatProperty" return-type="float">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.MessageFormatRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1204</id>
      <description>Returns the message property with the specified name that has been set on this JMSProducer, converted to a int.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="getIntProperty" return-type="int">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:1205</id>
      <description>if the JMS provider fails to get the property value due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="getIntProperty" return-type="int">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1206</id>
      <description>if this type conversion is invalid.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="getIntProperty" return-type="int">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.MessageFormatRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1207</id>
      <description>Returns the JMSCorrelationID header value that has been set on this JMSProducer, as a String. This method is used to return correlation ID values that are either provider-specific message IDs or application-specific String values.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="getJMSCorrelationID" return-type="java.lang.String"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:1208</id>
      <description>if the JMS provider fails to get the correlation ID due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="getJMSCorrelationID" return-type="java.lang.String">
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1209</id>
      <description>Returns the JMSCorrelationID header value that has been set on this JMSProducer, as an array of bytes. The use of a byte[] value for JMSCorrelationID is non-portable.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="getJMSCorrelationIDAsBytes" return-type="byte[]"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:1210</id>
      <description>if the JMS provider fails to get the correlation ID due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="getJMSCorrelationIDAsBytes" return-type="byte[]">
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1211</id>
      <description>Returns the JMSReplyTo header value that has been set on this JMSProducer.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="getJMSReplyTo" return-type="jakarta.jms.Destination"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:1212</id>
      <description>if the JMS provider fails to get the JMSReplyTo destination due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="getJMSReplyTo" return-type="jakarta.jms.Destination">
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1213</id>
      <description>Returns the JMSType header value that has been set on this JMSProducer.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="getJMSType" return-type="java.lang.String"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:1214</id>
      <description>if the JMS provider fails to get the message type due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="getJMSType" return-type="java.lang.String">
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1215</id>
      <description>Returns the message property with the specified name that has been set on this JMSProducer, converted to a long.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="getLongProperty" return-type="long">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:1216</id>
      <description>if the JMS provider fails to get the property value due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="getLongProperty" return-type="long">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1217</id>
      <description>if this type conversion is invalid.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="getLongProperty" return-type="long">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.MessageFormatRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1218</id>
      <description>Returns the message property with the specified name that has been set on this JMSProducer, converted to objectified format. This method can be used to return, in objectified format, an object that has been stored as a property in the message with the equivalent setObjectProperty method call, or its equivalent primitive settypeProperty method.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="getObjectProperty" return-type="java.lang.Object">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:1219</id>
      <description>if the JMS provider fails to get the property value due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="getObjectProperty" return-type="java.lang.Object">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1220</id>
      <description>Return the priority of messages that are sent using this JMSProducer</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="getPriority" return-type="int"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:1221</id>
      <description>if the JMS provider fails to get the priority due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="getPriority" return-type="int">
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1222</id>
      <description>Returns an unmodifiable Set view of the names of all the message properties that have been set on this JMSProducer. Note that JMS standard header fields are not considered properties and are not returned in this Set. The set is backed by the JMSProducer, so changes to the map are reflected in the set. However the set may not be modified. Attempts to modify the returned collection, whether directly or via its iterator, will result in an java.lang.UnsupportedOperationException. Its behaviour matches that defined in the java.util.Collections method unmodifiableSet.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="getPropertyNames" return-type="java.util.Set"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:1223</id>
      <description>if the JMS provider fails to get the property names due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="getPropertyNames" return-type="java.util.Set">
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1224</id>
      <description>Returns the message property with the specified name that has been set on this JMSProducer, converted to a short.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="getShortProperty" return-type="short">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:1225</id>
      <description>if the JMS provider fails to get the property value due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="getShortProperty" return-type="short">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1226</id>
      <description>if this type conversion is invalid.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="getShortProperty" return-type="short">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.MessageFormatRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1227</id>
      <description>Returns the message property with the specified name that has been set on this JMSProducer, converted to a String.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="getStringProperty" return-type="java.lang.String">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:1228</id>
      <description>if the JMS provider fails to get the property value due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="getStringProperty" return-type="java.lang.String">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1229</id>
      <description>if this type conversion is invalid.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="getStringProperty" return-type="java.lang.String">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.MessageFormatRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1230</id>
      <description>Returns the time to live of messages that are sent using this JMSProducer.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="getTimeToLive" return-type="long"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:1231</id>
      <description>if the JMS provider fails to get the time to live due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="getTimeToLive" return-type="long">
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1232</id>
      <description>Indicates whether a message property with the specified name has been set on this JMSProducer</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="propertyExists" return-type="boolean">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:1233</id>
      <description>if the JMS provider fails to determine whether the property exists due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="propertyExists" return-type="boolean">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1234</id>
      <description>Sends a message to the specified destination, using any send options, message properties and message headers that have been defined on this JMSProducer.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="send" return-type="jakarta.jms.JMSProducer">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
          <parameter>jakarta.jms.Message</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1235</id>
      <description>if the JMS provider fails to send the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="send" return-type="jakarta.jms.JMSProducer">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
          <parameter>jakarta.jms.Message</parameter>
        </parameters>
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1236</id>
      <description>if an invalid message is specified.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="send" return-type="jakarta.jms.JMSProducer">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
          <parameter>jakarta.jms.Message</parameter>
        </parameters>
        <throw>jakarta.jms.MessageFormatRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1237</id>
      <description>if a client uses this method with an invalid destination.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="send" return-type="jakarta.jms.JMSProducer">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
          <parameter>jakarta.jms.Message</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidDestinationRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1238</id>
      <description>if this JMSProducer has been configured to set a message property, but the message's properties are read-only</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="send" return-type="jakarta.jms.JMSProducer">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
          <parameter>jakarta.jms.Message</parameter>
        </parameters>
        <throw>jakarta.jms.MessageNotWriteableRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1239</id>
      <description>Send a TextMessage with the specified body to the specified destination, using any send options, message properties and message headers that have been defined on this JMSProducer.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="send" return-type="jakarta.jms.JMSProducer">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:1240</id>
      <description>if the JMS provider fails to send the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="send" return-type="jakarta.jms.JMSProducer">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1241</id>
      <description>if an invalid message is specified.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="send" return-type="jakarta.jms.JMSProducer">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.MessageFormatRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1242</id>
      <description>if a client uses this method with an invalid destination.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="send" return-type="jakarta.jms.JMSProducer">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidDestinationRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1243</id>
      <description>Send a MapMessage with the specified body to the specified destination, using any send options, message properties and message headers that have been defined on this JMSProducer.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="send" return-type="jakarta.jms.JMSProducer">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
          <parameter>java.util.Map</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:1244</id>
      <description>if the JMS provider fails to send the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="send" return-type="jakarta.jms.JMSProducer">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
          <parameter>java.util.Map</parameter>
        </parameters>
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1245</id>
      <description>if an invalid message is specified.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="send" return-type="jakarta.jms.JMSProducer">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
          <parameter>java.util.Map</parameter>
        </parameters>
        <throw>jakarta.jms.MessageFormatRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1246</id>
      <description>if a client uses this method with an invalid destination.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="send" return-type="jakarta.jms.JMSProducer">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
          <parameter>java.util.Map</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidDestinationRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1247</id>
      <description>Send a BytesMessage with the specified body to the specified destination, using any send options, message properties and message headers that have been defined on this JMSProducer.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="send" return-type="jakarta.jms.JMSProducer">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
          <parameter>byte[]</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:1248</id>
      <description>if the JMS provider fails to send the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="send" return-type="jakarta.jms.JMSProducer">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
          <parameter>byte[]</parameter>
        </parameters>
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:1249</id>
      <description>if an invalid message is specified.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="send" return-type="jakarta.jms.JMSProducer">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
          <parameter>byte[]</parameter>
        </parameters>
        <throw>jakarta.jms.MessageFormatRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1250</id>
      <description>if a client uses this method with an invalid destination.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="send" return-type="jakarta.jms.JMSProducer">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
          <parameter>byte[]</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidDestinationRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1251</id>
      <description>Send an ObjectMessage with the specified body to the specified destination, using any send options, message properties and message headers that have been defined on this JMSProducer.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="send" return-type="jakarta.jms.JMSProducer">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
          <parameter>java.io.Serializable</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:1252</id>
      <description>if JMS provider fails to send the message due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="send" return-type="jakarta.jms.JMSProducer">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
          <parameter>java.io.Serializable</parameter>
        </parameters>
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:1253</id>
      <description>if an invalid message is specified.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="send" return-type="jakarta.jms.JMSProducer">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
          <parameter>java.io.Serializable</parameter>
        </parameters>
        <throw>jakarta.jms.MessageFormatRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1254</id>
      <description>if a client uses this method with an invalid destination.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="send" return-type="jakarta.jms.JMSProducer">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
          <parameter>java.io.Serializable</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidDestinationRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1255</id>
      <description>Specifies whether subsequent calls to send on this JMSProducer object should be synchronous or asynchronous. If the specified CompletionListener is not null then subsequent calls to send will be asynchronous. If the specified CompletionListener is null then subsequent calls to send will be synchronous. Calls to send are synchronous by default. If a call to send is asynchronous then part of the work involved in sending the message will be performed in a separate thread and the specified CompletionListener will be notified when the operation has completed. When the message has been successfully sent the JMS provider invokes the callback method onCompletion on the CompletionListener object. Only when that callback has been invoked can the application be sure that the message has been successfully sent with the same degree of confidence as if the send had been synchronous. An application which requires this degree of confidence must therefore wait for the callback to be invoked before continuing. The following information is intended to give an indication of how an asynchronous send would typically be implemented. In some JMS providers, a normal synchronous send involves sending the message to a remote JMS server and then waiting for an acknowledgement to be received before returning. It is expected that such a provider would implement an asynchronous send by sending the message to the remote JMS server and then returning without waiting for an acknowledgement. When the acknowledgement is received, the JMS provider would notify the application by invoking the onCompletion method on the application-specified CompletionListener object. If for some reason the acknowledgement is not received the JMS provider would notify the application by invoking the CompletionListener's onException method. In those cases where the JMS specification permits a lower level of reliability, a normal synchronous send might not wait for an acknowledgement. In that case it is expected that an asynchronous send would be similar to a synchronous send: the JMS provider would send the message to the remote JMS server and then return without waiting for an acknowledgement. However the JMS provider would still notify the application that the send had completed by invoking the onCompletion method on the application-specified CompletionListener object. It is up to the JMS provider to decide exactly what is performed in the calling thread and what, if anything, is performed asynchronously, so long as it satisfies the requirements given below: Quality of service: After the send operation has completed successfully, which means that the message has been successfully sent with the same degree of confidence as if a normal synchronous send had been performed, the JMS provider must invoke the CompletionListener's onCompletion method. The CompletionListener must not be invoked earlier than this. Exceptions: If an exception is encountered during the call to the send method then an appropriate exception should be thrown in the thread that is calling the send method. In this case the JMS provider must not invoke the CompletionListener's onCompletion or onException method. If an exception is encountered which cannot be thrown in the thread that is calling the send method then the JMS provider must call the CompletionListener's onException method. In both cases if an exception occurs it is undefined whether or not the message was successfully sent. Message order: If the same JMSContext is used to send multiple messages then JMS message ordering requirements must be satisfied. This applies even if a combination of synchronous and asynchronous sends has been performed. The application is not required to wait for an asynchronous send to complete before sending the next message. Close, commit or rollback: If the close method is called on the JMSContext then the JMS provider must block until any incomplete send operations have been completed and all CompletionListener callbacks have returned before closing the object and returning. If the session is transacted (uses a local transaction) then when the JMSContext's commit or rollback method is called the JMS provider must block until any incomplete send operations have been completed and all CompletionListener callbacks have returned before performing the commit or rollback. Incomplete sends should be allowed to complete normally unless an error occurs. A CompletionListener callback method must not call close, commit or rollback on its own JMSContext. Doing so will cause the close, commit or rollback to throw an IllegalStateRuntimeException. Restrictions on usage in Jakarta EE This method must not be used in a Jakarta EE Enterprise Beans or web container. Doing so may cause a JMSRuntimeException to be thrown though this is not guaranteed. Message headers JMS defines a number of message header fields and message properties which must be set by the "JMS provider on send". If the send is asynchronous these fields and properties may be accessed on the sending client only after the CompletionListener has been invoked. If the CompletionListener's onException method is called then the state of these message header fields and properties is undefined. Restrictions on threading: Applications that perform an asynchronous send must confirm to the threading restrictions defined in JMS. This means that the session may be used by only one thread at a time. Setting a CompletionListener does not cause the session to be dedicated to the thread of control which calls the CompletionListener. The application thread may therefore continue to use the session after performing an asynchronous send. However the CompletionListener's callback methods must not use the session if an application thread might be using the session at the same time. Use of the CompletionListener by the JMS provider: A session will only invoke one CompletionListener callback method at a time. For a given JMSContext, callbacks (both onCompletion and onException) will be performed in the same order as the corresponding calls to the send method. A JMS provider must not invoke the CompletionListener from the thread that is calling the send method. Restrictions on the use of the Message object: Applications which perform an asynchronous send must take account of the restriction that a Message object is designed to be accessed by one logical thread of control at a time and does not support concurrent use. After the send method has returned, the application must not attempt to read the headers, properties or body of the Message object until the CompletionListener's onCompletion or onException method has been called. This is because the JMS provider may be modifying the Message object in another thread during this time. The JMS provider may throw an JMSException if the application attempts to access or modify the Message object after the send method has returned and before the CompletionListener has been invoked. If the JMS provider does not throw an exception then the behaviour is undefined.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="setAsync" return-type="jakarta.jms.JMSProducer">
        <parameters>
          <parameter>jakarta.jms.CompletionListener</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:1256</id>
      <description>if an internal error occurs</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="setAsync" return-type="jakarta.jms.JMSProducer">
        <parameters>
          <parameter>jakarta.jms.CompletionListener</parameter>
        </parameters>
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1257</id>
      <description>Sets the minimum length of time in milliseconds that must elapse after a message is sent before the JMS provider may deliver the message to a consumer. For transacted sends, this time starts when the client sends the message, not when the transaction is committed. deliveryDelay is set to zero by default.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="setDeliveryDelay" return-type="jakarta.jms.JMSProducer">
        <parameters>
          <parameter>long</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:1258</id>
      <description>if the JMS provider fails to set the delivery delay due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="setDeliveryDelay" return-type="jakarta.jms.JMSProducer">
        <parameters>
          <parameter>long</parameter>
        </parameters>
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1259</id>
      <description>Specifies the delivery mode of messages that are sent using this JMSProducer Delivery mode is set to PERSISTENT by default.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="setDeliveryMode" return-type="jakarta.jms.JMSProducer">
        <parameters>
          <parameter>int</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1260</id>
      <description>if the JMS provider fails to set the delivery mode due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="setDeliveryMode" return-type="jakarta.jms.JMSProducer">
        <parameters>
          <parameter>int</parameter>
        </parameters>
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1261</id>
      <description>Specifies whether message IDs may be disabled for messages that are sent using this JMSProducer Since message IDs take some effort to create and increase a message's size, some JMS providers may be able to optimise message overhead if they are given a hint that the message ID is not used by an application. By calling this method, a JMS application enables this potential optimisation for all messages sent using this JMSProducer. If the JMS provider accepts this hint, these messages must have the message ID set to null; if the provider ignores the hint, the message ID must be set to its normal unique value. Message IDs are enabled by default.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="setDisableMessageID" return-type="jakarta.jms.JMSProducer">
        <parameters>
          <parameter>boolean</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:1262</id>
      <description>if the JMS provider fails to set message ID to disabled due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="setDisableMessageID" return-type="jakarta.jms.JMSProducer">
        <parameters>
          <parameter>boolean</parameter>
        </parameters>
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1263</id>
      <description>Specifies whether message timestamps may be disabled for messages that are sent using this JMSProducer. Since timestamps take some effort to create and increase a message's size, some JMS providers may be able to optimise message overhead if they are given a hint that the timestamp is not used by an application. By calling this method, a JMS application enables this potential optimisation for all messages sent using this JMSProducer. If the JMS provider accepts this hint, these messages must have the timestamp set to zero; if the provider ignores the hint, the timestamp must be set to its normal value. Message timestamps are enabled by default.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="setDisableMessageTimestamp" return-type="jakarta.jms.JMSProducer">
        <parameters>
          <parameter>boolean</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:1264</id>
      <description>if the JMS provider fails to set timestamps to disabled due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="setDisableMessageTimestamp" return-type="jakarta.jms.JMSProducer">
        <parameters>
          <parameter>boolean</parameter>
        </parameters>
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1265</id>
      <description>Specifies that messages sent using this JMSProducer will have their JMSCorrelationID header value set to the specified correlation ID, where correlation ID is specified as a String. This will override any JMSCorrelationID header value that is already set on the message being sent. A client can use the JMSCorrelationID header field to link one message with another. A typical use is to link a response message with its request message. JMSCorrelationID can hold one of the following: A provider-specific message ID An application-specific String A provider-native byte[] value Since each message sent by a JMS provider is assigned a message ID value, it is convenient to link messages via message ID. All message ID values must start with the 'ID:' prefix. In some cases, an application (made up of several clients) needs to use an application-specific value for linking messages. For instance, an application may use JMSCorrelationID to hold a value referencing some external information. Application-specified values must not start with the 'ID:' prefix; this is reserved for provider-generated message ID values. If a provider supports the native concept of correlation ID, a JMS client may need to assign specific JMSCorrelationID values to match those expected by clients that do not use the JMS API. A byte[] value is used for this purpose. JMS providers without native correlation ID values are not required to support byte[] values. The use of a byte[] value for JMSCorrelationID is non-portable.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="setJMSCorrelationID" return-type="jakarta.jms.JMSProducer">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:1266</id>
      <description>if the JMS provider fails to set the correlation ID due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="setJMSCorrelationID" return-type="jakarta.jms.JMSProducer">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1267</id>
      <description>Specifies that messages sent using this JMSProducer will have their JMSCorrelationID header value set to the specified correlation ID, where correlation ID is specified as an array of bytes. This will override any JMSCorrelationID header value that is already set on the message being sent. The array is copied before the method returns, so future modifications to the array will not alter the value in this JMSProducer. If a provider supports the native concept of correlation ID, a JMS client may need to assign specific JMSCorrelationID values to match those expected by native messaging clients. JMS providers without native correlation ID values are not required to support this method and its corresponding get method; their implementation may throw a java.lang.UnsupportedOperationException. The use of a byte[] value for JMSCorrelationID is non-portable.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="setJMSCorrelationIDAsBytes" return-type="jakarta.jms.JMSProducer">
        <parameters>
          <parameter>byte[]</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:1268</id>
      <description>if the JMS provider fails to set the correlation ID due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="setJMSCorrelationIDAsBytes" return-type="jakarta.jms.JMSProducer">
        <parameters>
          <parameter>byte[]</parameter>
        </parameters>
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1269</id>
      <description>Specifies that messages sent using this JMSProducer will have their JMSReplyTo header value set to the specified Destination object. This will override any JMSReplyTo header value that is already set on the message being sent. The JMSReplyTo header field contains the destination where a reply to the current message should be sent. If it is null, no reply is expected. The destination may be either a Queue object or a Topic object. Messages sent with a null JMSReplyTo value may be a notification of some event, or they may just be some data the sender thinks is of interest. Messages with a JMSReplyTo value typically expect a response. A response is optional; it is up to the client to decide. These messages are called requests. A message sent in response to a request is called a reply. In some cases a client may wish to match a request it sent earlier with a reply it has just received. The client can use the JMSCorrelationID header field for this purpose.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="setJMSReplyTo" return-type="jakarta.jms.JMSProducer">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:1270</id>
      <description>if the JMS provider fails to set the JMSReplyTo destination due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="setJMSReplyTo" return-type="jakarta.jms.JMSProducer">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
        </parameters>
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1271</id>
      <description>Specifies that messages sent using this JMSProducer will have their JMSType header value set to the specified message type. This will override any JMSType header value that is already set on the message being sent. Some JMS providers use a message repository that contains the definitions of messages sent by applications. The JMSType header field may reference a message's definition in the provider's repository. The JMS API does not define a standard message definition repository, nor does it define a naming policy for the definitions it contains. Some messaging systems require that a message type definition for each application message be created and that each message specify its type. In order to work with such JMS providers, JMS clients should assign a value to JMSType, whether the application makes use of it or not. This ensures that the field is properly set for those providers that require it. To ensure portability, JMS clients should use symbolic values for JMSType that can be configured at installation time to the values defined in the current provider's message repository. If string literals are used, they may not be valid type names for some JMS providers.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="setJMSType" return-type="jakarta.jms.JMSProducer">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:1272</id>
      <description>if the JMS provider fails to set the message type due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="setJMSType" return-type="jakarta.jms.JMSProducer">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1273</id>
      <description>Specifies the priority of messages that are sent using this JMSProducer The JMS API defines ten levels of priority value, with 0 as the lowest priority and 9 as the highest. Clients should consider priorities 0-4 as gradations of normal priority and priorities 5-9 as gradations of expedited priority. Priority is set to 4 by default.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="setPriority" return-type="jakarta.jms.JMSProducer">
        <parameters>
          <parameter>int</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1274</id>
      <description>if the JMS provider fails to set the priority due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="setPriority" return-type="jakarta.jms.JMSProducer">
        <parameters>
          <parameter>int</parameter>
        </parameters>
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1275</id>
      <description>Specifies that messages sent using this JMSProducer will have the specified property set to the specified boolean value. This will replace any property of the same name that is already set on the message being sent.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="setProperty" return-type="jakarta.jms.JMSProducer">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>boolean</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:1276</id>
      <description>if the JMS provider fails to set the property due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="setProperty" return-type="jakarta.jms.JMSProducer">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>boolean</parameter>
        </parameters>
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1277</id>
      <description>if the name is null or if the name is an empty string.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="setProperty" return-type="jakarta.jms.JMSProducer">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>boolean</parameter>
        </parameters>
        <throw>java.lang.IllegalArgumentException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1278</id>
      <description>Specifies that messages sent using this JMSProducer will have the specified property set to the specified byte value. This will replace any property of the same name that is already set on the message being sent.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="setProperty" return-type="jakarta.jms.JMSProducer">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>byte</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:1279</id>
      <description>if the JMS provider fails to set the property due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="setProperty" return-type="jakarta.jms.JMSProducer">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>byte</parameter>
        </parameters>
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1280</id>
      <description>if the name is null or if the name is an empty string.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="setProperty" return-type="jakarta.jms.JMSProducer">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>byte</parameter>
        </parameters>
        <throw>java.lang.IllegalArgumentException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1281</id>
      <description>Specifies that messages sent using this JMSProducer will have the specified property set to the specified short value. This will replace any property of the same name that is already set on the message being sent.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="setProperty" return-type="jakarta.jms.JMSProducer">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>short</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:1282</id>
      <description>if the JMS provider fails to set the property due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="setProperty" return-type="jakarta.jms.JMSProducer">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>short</parameter>
        </parameters>
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1283</id>
      <description>if the name is null or if the name is an empty string.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="setProperty" return-type="jakarta.jms.JMSProducer">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>short</parameter>
        </parameters>
        <throw>java.lang.IllegalArgumentException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1284</id>
      <description>Specifies that messages sent using this JMSProducer will have the specified property set to the specified int value. This will replace any property of the same name that is already set on the message being sent.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="setProperty" return-type="jakarta.jms.JMSProducer">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>int</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:1285</id>
      <description>if the JMS provider fails to set the property due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="setProperty" return-type="jakarta.jms.JMSProducer">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>int</parameter>
        </parameters>
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1286</id>
      <description>if the name is null or if the name is an empty string.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="setProperty" return-type="jakarta.jms.JMSProducer">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>int</parameter>
        </parameters>
        <throw>java.lang.IllegalArgumentException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1287</id>
      <description>Specifies that messages sent using this JMSProducer will have the specified property set to the specified long value. This will replace any property of the same name that is already set on the message being sent.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="setProperty" return-type="jakarta.jms.JMSProducer">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>long</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:1288</id>
      <description>if the JMS provider fails to set the property due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="setProperty" return-type="jakarta.jms.JMSProducer">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>long</parameter>
        </parameters>
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1289</id>
      <description>if the name is null or if the name is an empty string.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="setProperty" return-type="jakarta.jms.JMSProducer">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>long</parameter>
        </parameters>
        <throw>java.lang.IllegalArgumentException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1290</id>
      <description>Specifies that messages sent using this JMSProducer will have the specified property set to the specified float value. This will replace any property of the same name that is already set on the message being sent.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="setProperty" return-type="jakarta.jms.JMSProducer">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>float</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:1291</id>
      <description>if the JMS provider fails to set the property due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="setProperty" return-type="jakarta.jms.JMSProducer">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>float</parameter>
        </parameters>
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1292</id>
      <description>if the name is null or if the name is an empty string.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="setProperty" return-type="jakarta.jms.JMSProducer">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>float</parameter>
        </parameters>
        <throw>java.lang.IllegalArgumentException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1293</id>
      <description>Specifies that messages sent using this JMSProducer will have the specified property set to the specified double value. This will replace any property of the same name that is already set on the message being sent.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="setProperty" return-type="jakarta.jms.JMSProducer">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>double</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:1294</id>
      <description>if the JMS provider fails to set the property due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="setProperty" return-type="jakarta.jms.JMSProducer">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>double</parameter>
        </parameters>
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1295</id>
      <description>if the name is null or if the name is an empty string.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="setProperty" return-type="jakarta.jms.JMSProducer">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>double</parameter>
        </parameters>
        <throw>java.lang.IllegalArgumentException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1296</id>
      <description>Specifies that messages sent using this JMSProducer will have the specified property set to the specified String value. This will replace any property of the same name that is already set on the message being sent.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="setProperty" return-type="jakarta.jms.JMSProducer">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:1297</id>
      <description>if the JMS provider fails to set the property due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="setProperty" return-type="jakarta.jms.JMSProducer">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1298</id>
      <description>if the name is null or if the name is an empty string.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="setProperty" return-type="jakarta.jms.JMSProducer">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>java.lang.IllegalArgumentException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1299</id>
      <description>Specifies that messages sent using this JMSProducer will have the specified property set to the specified Java object value. Note that this method works only for the objectified primitive object types (Integer, Double, Long ...) and String objects. This will replace any property of the same name that is already set on the message being sent.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="setProperty" return-type="jakarta.jms.JMSProducer">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:1300</id>
      <description>if the JMS provider fails to set the property due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="setProperty" return-type="jakarta.jms.JMSProducer">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1301</id>
      <description>if the name is null or if the name is an empty string.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="setProperty" return-type="jakarta.jms.JMSProducer">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>java.lang.IllegalArgumentException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1302</id>
      <description>if the object is invalid</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="setProperty" return-type="jakarta.jms.JMSProducer">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.Object</parameter>
        </parameters>
        <throw>jakarta.jms.MessageFormatRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1303</id>
      <description>Specifies the time to live of messages that are sent using this JMSProducer. This is used to determine the expiration time of a message. The expiration time of a message is the sum of the message's time to live and the time it is sent. For transacted sends, this is the time the client sends the message, not the time the transaction is committed. Clients should not receive messages that have expired; however, JMS does not guarantee that this will not happen. A JMS provider should do its best to accurately expire messages; however, JMS does not define the accuracy provided. It is not acceptable to simply ignore time-to-live. Time to live is set to zero by default, which means a message never expires.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="setTimeToLive" return-type="jakarta.jms.JMSProducer">
        <parameters>
          <parameter>long</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:1304</id>
      <description>if the JMS provider fails to set the time to live due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSProducer</class-interface>
      <method name="setTimeToLive" return-type="jakarta.jms.JMSProducer">
        <parameters>
          <parameter>long</parameter>
        </parameters>
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1315</id>
      <description/>
      <package>jakarta.jms</package>
      <class-interface>XASession</class-interface>
      <method name="commit" return-type="void">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1316</id>
      <description/>
      <package>jakarta.jms</package>
      <class-interface>XASession</class-interface>
      <method name="rollback" return-type="void">
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1318</id>
      <description>if a client uses this method with a MessageProducer that specified a destination at creation time.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageProducer</class-interface>
      <method name="send" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
          <parameter>jakarta.jms.Message</parameter>
          <parameter>int</parameter>
          <parameter>int</parameter>
          <parameter>long</parameter>
        </parameters>
        <throw>java.lang.UnsupportedOperationException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1319</id>
      <description>if the specified CompletionListener is null</description>
      <package>jakarta.jms</package>
      <class-interface>MessageProducer</class-interface>
      <method name="send" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Message</parameter>
          <parameter>jakarta.jms.CompletionListener</parameter>
        </parameters>
        <throw>java.lang.IllegalArgumentException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1320</id>
      <description>if the specified CompletionListener is null</description>
      <package>jakarta.jms</package>
      <class-interface>MessageProducer</class-interface>
      <method name="send" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Message</parameter>
          <parameter>int</parameter>
          <parameter>int</parameter>
          <parameter>long</parameter>
          <parameter>jakarta.jms.CompletionListener</parameter>
        </parameters>
        <throw>java.lang.IllegalArgumentException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1321</id>
      <description>if the specified CompletionListener is null</description>
      <package>jakarta.jms</package>
      <class-interface>MessageProducer</class-interface>
      <method name="send" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
          <parameter>jakarta.jms.Message</parameter>
          <parameter>jakarta.jms.CompletionListener</parameter>
        </parameters>
        <throw>java.lang.IllegalArgumentException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1322</id>
      <description>if the specified CompletionListener is null</description>
      <package>jakarta.jms</package>
      <class-interface>MessageProducer</class-interface>
      <method name="send" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
          <parameter>jakarta.jms.Message</parameter>
          <parameter>int</parameter>
          <parameter>int</parameter>
          <parameter>long</parameter>
          <parameter>jakarta.jms.CompletionListener</parameter>
        </parameters>
        <throw>java.lang.IllegalArgumentException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1323</id>
      <description>if a client uses this method with a MessageProducer that specified a destination at creation time.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageProducer</class-interface>
      <method name="send" return-type="void">
        <parameters>
          <parameter>jakarta.jms.Destination</parameter>
          <parameter>jakarta.jms.Message</parameter>
          <parameter>int</parameter>
          <parameter>int</parameter>
          <parameter>long</parameter>
          <parameter>jakarta.jms.CompletionListener</parameter>
        </parameters>
        <throw>java.lang.UnsupportedOperationException</throw>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1324</id>
      <description>Fully-qualified name of the JMS connection factory implementation class. Ignored if a resource adapter is used.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSConnectionFactoryDefinition</class-interface>
      <method name="className" return-type="java.lang.String"/>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1325</id>
      <description>Client id to use for connection.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSConnectionFactoryDefinition</class-interface>
      <method name="clientId" return-type="java.lang.String"/>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1327</id>
      <description>Description of this JMS connection factory.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSConnectionFactoryDefinition</class-interface>
      <method name="description" return-type="java.lang.String"/>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1330</id>
      <description>Maximum number of connections that should be concurrently allocated for a connection pool. Default is vendor-specific.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSConnectionFactoryDefinition</class-interface>
      <method name="maxPoolSize" return-type="int"/>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1331</id>
      <description>Minimum number of connections that should be concurrently allocated for a connection pool. Default is vendor-specific.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSConnectionFactoryDefinition</class-interface>
      <method name="minPoolSize" return-type="int"/>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1332</id>
      <description>JNDI name of the JMS connection factory being defined.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSConnectionFactoryDefinition</class-interface>
      <method name="name" return-type="java.lang.String"/>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1333</id>
      <description>Password to use for connection authentication.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSConnectionFactoryDefinition</class-interface>
      <method name="password" return-type="java.lang.String"/>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1334</id>
      <description>JMS connection factory property. This may be a vendor-specific property or a less commonly used ConnectionFactory property. Properties are specified using the format: propertyName=propertyValue with one property per array element.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSConnectionFactoryDefinition</class-interface>
      <method name="properties" return-type="java.lang.String[]"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1335</id>
      <description>Resource adapter name. If not specified then the application server will define the default behaviour, which may or may not involve the use of a resource adapter.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSConnectionFactoryDefinition</class-interface>
      <method name="resourceAdapter" return-type="java.lang.String"/>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1336</id>
      <description>Set to false if connections should not participate in transactions. Default is to enlist in a transaction when one is active or becomes active.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSConnectionFactoryDefinition</class-interface>
      <method name="transactional" return-type="boolean"/>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1338</id>
      <description>User name to use for connection authentication.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSConnectionFactoryDefinition</class-interface>
      <method name="user" return-type="java.lang.String"/>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1339</id>
      <description/>
      <package>jakarta.jms</package>
      <class-interface>JMSConnectionFactoryDefinitions</class-interface>
      <method name="value" return-type="jakarta.jms.JMSConnectionFactoryDefinition[]"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1340</id>
      <description>if the JMSContext is closed. if the JMSContext is container-managed (injected)</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="acknowledge" return-type="void">
        <throw>jakarta.jms.IllegalStateRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1341</id>
      <description>if the client identifier is unset</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="createDurableConsumer" return-type="jakarta.jms.JMSConsumer">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>boolean</parameter>
        </parameters>
        <throw>jakarta.jms.IllegalStateRuntimeException</throw>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1342</id>
      <description>Fully-qualified name of the JMS destination implementation class. Ignored if a resource adapter is used unless the resource adapter defines more than one JMS destination implementation class for the specified interface</description>
      <package>jakarta.jms</package>
      <class-interface>JMSDestinationDefinition</class-interface>
      <method name="className" return-type="java.lang.String"/>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1343</id>
      <description>Description of this JMS destination.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSDestinationDefinition</class-interface>
      <method name="description" return-type="java.lang.String"/>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1344</id>
      <description>Name of the queue or topic.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSDestinationDefinition</class-interface>
      <method name="destinationName" return-type="java.lang.String"/>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1345</id>
      <description>JNDI name of the destination resource being defined.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSDestinationDefinition</class-interface>
      <method name="name" return-type="java.lang.String"/>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1346</id>
      <description>JMS destination property. This may be a vendor-specific property or a less commonly used ConnectionFactory property. Properties are specified using the format: propertyName=propertyValue with one property per array element.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSDestinationDefinition</class-interface>
      <method name="properties" return-type="java.lang.String[]"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1347</id>
      <description>Resource adapter name. If not specified then the application server will define the default behaviour, which may or may not involve the use of a resource adapter.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSDestinationDefinition</class-interface>
      <method name="resourceAdapter" return-type="java.lang.String"/>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1348</id>
      <description/>
      <package>jakarta.jms</package>
      <class-interface>JMSDestinationDefinitions</class-interface>
      <method name="value" return-type="jakarta.jms.JMSDestinationDefinition[]"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1349</id>
      <description>if the client identifier is unset</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createDurableConsumer" return-type="jakarta.jms.MessageConsumer">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>boolean</parameter>
        </parameters>
        <throw>jakarta.jms.IllegalStateException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1350</id>
      <description>if the client identifier is unset</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createDurableSubscriber" return-type="jakarta.jms.TopicSubscriber">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>boolean</parameter>
        </parameters>
        <throw>jakarta.jms.IllegalStateException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1351</id>
      <description>this method has been called by a MessageListener on its own Connection this method has been called by a CompletionListener callback method on its own Connection</description>
      <package>jakarta.jms</package>
      <class-interface>Connection</class-interface>
      <method name="close" return-type="void">
        <throw>jakarta.jms.IllegalStateException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1352</id>
      <description>this method has been called by a MessageListener on its own Connection</description>
      <package>jakarta.jms</package>
      <class-interface>Connection</class-interface>
      <method name="stop" return-type="void">
        <throw>jakarta.jms.IllegalStateException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1353</id>
      <description>if this method has been called by a MessageListener on its own JMSContext if this method has been called by a CompletionListener callback method on its own JMSContext if the JMSContext is container-managed (injected)</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="close" return-type="void">
        <throw>jakarta.jms.IllegalStateRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1354</id>
      <description>if this method has been called by a MessageListener on its own JMSContext if the JMSContext is container-managed (injected).</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="stop" return-type="void">
        <throw>jakarta.jms.IllegalStateRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1355</id>
      <description>this method has been called by a CompletionListener callback method on its own MessageProducer</description>
      <package>jakarta.jms</package>
      <class-interface>MessageProducer</class-interface>
      <method name="close" return-type="void">
        <throw>jakarta.jms.IllegalStateException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1356</id>
      <description>this method has been called by a MessageListener on its own Session this method has been called by a CompletionListener callback method on its own Session</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="close" return-type="void">
        <throw>jakarta.jms.IllegalStateException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1357</id>
      <description>Returns the message body as an object of the specified type. This method may be called on any type of message except for StreamMessage. The message body must be capable of being assigned to the specified type. This means that the specified class or interface must be either the same as, or a superclass or superinterface of, the class of the message body. If the message has no body then any type may be specified and null is returned.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="getBody" return-type="java.lang.Object">
        <parameters>
          <parameter>java.lang.Class</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:1358</id>
      <description>if the JMS provider fails to get the message body due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="getBody" return-type="java.lang.Object">
        <parameters>
          <parameter>java.lang.Class</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1359</id>
      <description>if the message is a StreamMessage if the message body cannot be assigned to the specified type if the message is an ObjectMessage and object deserialization fails.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="getBody" return-type="java.lang.Object">
        <parameters>
          <parameter>java.lang.Class</parameter>
        </parameters>
        <throw>jakarta.jms.MessageFormatException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1361</id>
      <description>Returns whether the message body is capable of being assigned to the specified type. If this method returns true then a subsequent call to the method getBody on the same message with the same type argument would not throw a MessageFormatException. If the message is a StreamMessage then false is always returned. If the message is a ObjectMessage and object deserialization fails then false is returned. If the message has no body then any type may be specified and true is returned.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="isBodyAssignableTo" return-type="boolean">
        <parameters>
          <parameter>java.lang.Class</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:1362</id>
      <description>if the JMS provider fails to return a value due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>Message</class-interface>
      <method name="isBodyAssignableTo" return-type="boolean">
        <parameters>
          <parameter>java.lang.Class</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1366</id>
      <description>if the JMSContext is container-managed (injected)</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="setAutoStart" return-type="void">
        <parameters>
          <parameter>boolean</parameter>
        </parameters>
        <throw>jakarta.jms.IllegalStateRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1367</id>
      <description>if the JMSContext is container-managed (injected).</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="setExceptionListener" return-type="void">
        <parameters>
          <parameter>jakarta.jms.ExceptionListener</parameter>
        </parameters>
        <throw>jakarta.jms.IllegalStateRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1368</id>
      <description>if the JMSContext is container-managed (injected).</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="start" return-type="void">
        <throw>jakarta.jms.IllegalStateRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1369</id>
      <description>Receives the next message produced for this JMSConsumer and returns its body as an object of the specified type. This method may be used to receive any type of message except for StreamMessage and Message, so long as the message has a body which is capable of being assigned to the specified type. This means that the specified class or interface must either be the same as, or a superclass or superinterface of, the class of the message body. If the message is not one of the supported types, or its body cannot be assigned to the specified type, or it has no body, then a MessageFormatRuntimeException is thrown. This method does not give access to the message headers or properties (such as the JMSRedelivered message header field or the JMSXDeliveryCount message property) and should only be used if the application has no need to access them. This call blocks indefinitely until a message is produced or until this JMSConsumer is closed. If this method is called within a transaction, the JMSConsumer retains the message until the transaction commits. The result of this method throwing a MessageFormatRuntimeException depends on the session mode: AUTO_ACKNOWLEDGE or DUPS_OK_ACKNOWLEDGE: The JMS provider will behave as if the unsuccessful call to receiveBody had not occurred. The message will be delivered again before any subsequent messages. This is not considered to be redelivery and does not cause the JMSRedelivered message header field to be set or the JMSXDeliveryCount message property to be incremented. CLIENT_ACKNOWLEDGE: The JMS provider will behave as if the call to receiveBody had been successful and will not deliver the message again. As with any message that is delivered with a session mode of CLIENT_ACKNOWLEDGE, the message will not be acknowledged until acknowledge is called on the JMSContext. If an application wishes to have the failed message redelivered, it must call recover on the JMSContext. The redelivered message's JMSRedelivered message header field will be set and its JMSXDeliveryCount message property will be incremented. Transacted session: The JMS provider will behave as if the call to receiveBody had been successful and will not deliver the message again. As with any message that is delivered in a transacted session, the transaction will remain uncommitted until the transaction is committed or rolled back by the application. If an application wishes to have the failed message redelivered, it must roll back the transaction. The redelivered message's JMSRedelivered message header field will be set and its JMSXDeliveryCount message property will be incremented.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSConsumer</class-interface>
      <method name="receiveBody" return-type="java.lang.Object">
        <parameters>
          <parameter>java.lang.Class</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:1370</id>
      <description>if the JMS provider fails to receive the next message due to some internal error</description>
      <package>jakarta.jms</package>
      <class-interface>JMSConsumer</class-interface>
      <method name="receiveBody" return-type="java.lang.Object">
        <parameters>
          <parameter>java.lang.Class</parameter>
        </parameters>
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1371</id>
      <description>if the message is not one of the supported types listed above if the message body cannot be assigned to the specified type if the message has no body if the message is an ObjectMessage and object deserialization fails.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSConsumer</class-interface>
      <method name="receiveBody" return-type="java.lang.Object">
        <parameters>
          <parameter>java.lang.Class</parameter>
        </parameters>
        <throw>jakarta.jms.MessageFormatRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1372</id>
      <description>Receives the next message produced for this JMSConsumer that arrives within the specified timeout period and returns its body as an object of the specified type. This method may be used to receive any type of message except for StreamMessage and Message, so long as the message has a body which is capable of being assigned to the specified type. This means that the specified class or interface must either be the same as, or a superclass or superinterface of, the class of the message body. If the message is not one of the supported types, or its body cannot be assigned to the specified type, or it has no body, then a MessageFormatRuntimeException is thrown. This method does not give access to the message headers or properties (such as the JMSRedelivered message header field or the JMSXDeliveryCount message property) and should only be used if the application has no need to access them. This call blocks until a message arrives, the timeout expires, or this JMSConsumer is closed. A timeout of zero never expires, and the call blocks indefinitely. If this method is called within a transaction, the JMSConsumer retains the message until the transaction commits. The result of this method throwing a MessageFormatRuntimeException depends on the session mode: AUTO_ACKNOWLEDGE or DUPS_OK_ACKNOWLEDGE: The JMS provider will behave as if the unsuccessful call to receiveBody had not occurred. The message will be delivered again before any subsequent messages. This is not considered to be redelivery and does not cause the JMSRedelivered message header field to be set or the JMSXDeliveryCount message property to be incremented. CLIENT_ACKNOWLEDGE: The JMS provider will behave as if the call to receiveBody had been successful and will not deliver the message again. As with any message that is delivered with a session mode of CLIENT_ACKNOWLEDGE, the message will not be acknowledged until acknowledge is called on the JMSContext. If an application wishes to have the failed message redelivered, it must call recover on the JMSContext. The redelivered message's JMSRedelivered message header field will be set and its JMSXDeliveryCount message property will be incremented. Transacted session: The JMS provider will behave as if the call to receiveBody had been successful and will not deliver the message again. As with any message that is delivered in a transacted session, the transaction will remain uncommitted until the transaction is committed or rolled back by the application. If an application wishes to have the failed message redelivered, it must roll back the transaction. The redelivered message's JMSRedelivered message header field will be set and its JMSXDeliveryCount message property will be incremented.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSConsumer</class-interface>
      <method name="receiveBody" return-type="java.lang.Object">
        <parameters>
          <parameter>java.lang.Class</parameter>
          <parameter>long</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:1373</id>
      <description>if the JMS provider fails to receive the next message due to some internal error</description>
      <package>jakarta.jms</package>
      <class-interface>JMSConsumer</class-interface>
      <method name="receiveBody" return-type="java.lang.Object">
        <parameters>
          <parameter>java.lang.Class</parameter>
          <parameter>long</parameter>
        </parameters>
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1374</id>
      <description>if the message is not one of the supported types listed above if the message body cannot be assigned to the specified type if the message has no body if the message is an ObjectMessage and object deserialization fails.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSConsumer</class-interface>
      <method name="receiveBody" return-type="java.lang.Object">
        <parameters>
          <parameter>java.lang.Class</parameter>
          <parameter>long</parameter>
        </parameters>
        <throw>jakarta.jms.MessageFormatRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1375</id>
      <description>Receives the next message produced for this JMSConsumer if one is immediately available and returns its body as an object of the specified type. This method may be used to receive any type of message except for StreamMessage and Message, so long as the message has a body which is capable of being assigned to the specified type. This means that the specified class or interface must either be the same as, or a superclass or superinterface of, the class of the message body. If the message is not one of the supported types, or its body cannot be assigned to the specified type, or it has no body, then a MessageFormatRuntimeException is thrown. This method does not give access to the message headers or properties (such as the JMSRedelivered message header field or the JMSXDeliveryCount message property) and should only be used if the application has no need to access them. If a message is not immediately available null is returned. If this method is called within a transaction, the JMSConsumer retains the message until the transaction commits. The result of this method throwing a MessageFormatRuntimeException depends on the session mode: AUTO_ACKNOWLEDGE or DUPS_OK_ACKNOWLEDGE: The JMS provider will behave as if the unsuccessful call to receiveBodyNoWait had not occurred. The message will be delivered again before any subsequent messages. This is not considered to be redelivery and does not cause the JMSRedelivered message header field to be set or the JMSXDeliveryCount message property to be incremented. CLIENT_ACKNOWLEDGE: The JMS provider will behave as if the call to receiveBodyNoWait had been successful and will not deliver the message again. As with any message that is delivered with a session mode of CLIENT_ACKNOWLEDGE, the message will not be acknowledged until acknowledge is called on the JMSContext. If an application wishes to have the failed message redelivered, it must call recover on the JMSContext. The redelivered message's JMSRedelivered message header field will be set and its JMSXDeliveryCount message property will be incremented. Transacted session: The JMS provider will behave as if the call to receiveBodyNoWait had been successful and will not deliver the message again. As with any message that is delivered in a transacted session, the transaction will remain uncommitted until the transaction is committed or rolled back by the application. If an application wishes to have the failed message redelivered, it must roll back the transaction. The redelivered message's JMSRedelivered message header field will be set and its JMSXDeliveryCount message property will be incremented.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSConsumer</class-interface>
      <method name="receiveBodyNoWait" return-type="java.lang.Object">
        <parameters>
          <parameter>java.lang.Class</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="false">
      <id>JMS:JAVADOC:1376</id>
      <description>if the JMS provider fails to receive the next message due to some internal error</description>
      <package>jakarta.jms</package>
      <class-interface>JMSConsumer</class-interface>
      <method name="receiveBodyNoWait" return-type="java.lang.Object">
        <parameters>
          <parameter>java.lang.Class</parameter>
        </parameters>
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1377</id>
      <description>if the message is not one of the supported types listed above if the message body cannot be assigned to the specified type if the message has no body if the message is an ObjectMessage and object deserialization fails.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSConsumer</class-interface>
      <method name="receiveBodyNoWait" return-type="java.lang.Object">
        <parameters>
          <parameter>java.lang.Class</parameter>
        </parameters>
        <throw>jakarta.jms.MessageFormatRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1378</id>
      <description>if the client identifier is unset</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="createDurableConsumer" return-type="jakarta.jms.JMSConsumer">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.IllegalStateRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1382</id>
      <description>Creates a shared durable subscription on the specified topic (if one does not already exist), specifying a message selector, and creates a consumer on that durable subscription. This method creates the durable subscription without a message selector. A durable subscription is used by an application which needs to receive all the messages published on a topic, including the ones published when there is no active consumer associated with it. The JMS provider retains a record of this durable subscription and ensures that all messages from the topic's publishers are retained until they are delivered to, and acknowledged by, a consumer on this durable subscription or until they have expired. A durable subscription will continue to accumulate messages until it is deleted using the unsubscribe method. This method may only be used with shared durable subscriptions. Any durable subscription created using this method will be shared. This means that multiple active (i.e. not closed) consumers on the subscription may exist at the same time. The term "consumer" here means a MessageConsumer or JMSConsumer object in any client. A shared durable subscription is identified by a name specified by the client and by the client identifier (which may be unset). An application which subsequently wishes to create a consumer on that shared durable subscription must use the same client identifier. If a shared durable subscription already exists with the same name and client identifier (if set), and the same topic and message selector has been specified, then this method creates a JMSConsumer on the existing shared durable subscription. If a shared durable subscription already exists with the same name and client identifier (if set) but a different topic or message selector has been specified, and there is no consumer already active (i.e. not closed) on the durable subscription then this is equivalent to unsubscribing (deleting) the old one and creating a new one. If a shared durable subscription already exists with the same name and client identifier (if set) but a different topic or message selector has been specified, and there is a consumer already active (i.e. not closed) on the durable subscription, then a JMSRuntimeException will be thrown. A shared durable subscription and an unshared durable subscription may not have the same name and client identifier (if set). If an unshared durable subscription already exists with the same name and client identifier (if set) then a JMSRuntimeException is thrown. If a message selector is specified then only messages with properties matching the message selector expression will be added to the subscription. There is no restriction on durable subscriptions and shared non-durable subscriptions having the same name and clientId (which may be unset). Such subscriptions would be completely separate.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="createSharedDurableConsumer" return-type="jakarta.jms.JMSConsumer">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1383</id>
      <description>if an invalid topic is specified.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="createSharedDurableConsumer" return-type="jakarta.jms.JMSConsumer">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidDestinationRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1384</id>
      <description>if the session fails to create the shared durable subscription and MessageConsumer due to some internal error if a shared durable subscription already exists with the same name and client identifier, but a different topic, or message selector, and there is a consumer already active if an unshared durable subscription already exists with the same name and client identifier</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="createSharedDurableConsumer" return-type="jakarta.jms.JMSConsumer">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1385</id>
      <description>Creates a shared durable subscription on the specified topic (if one does not already exist), specifying a message selector, and creates a consumer on that durable subscription. A durable subscription is used by an application which needs to receive all the messages published on a topic, including the ones published when there is no active consumer associated with it. The JMS provider retains a record of this durable subscription and ensures that all messages from the topic's publishers are retained until they are delivered to, and acknowledged by, a consumer on this durable subscription or until they have expired. A durable subscription will continue to accumulate messages until it is deleted using the unsubscribe method. This method may only be used with shared durable subscriptions. Any durable subscription created using this method will be shared. This means that multiple active (i.e. not closed) consumers on the subscription may exist at the same time. The term "consumer" here means a MessageConsumer or JMSConsumer object in any client. A shared durable subscription is identified by a name specified by the client and by the client identifier (which may be unset). An application which subsequently wishes to create a consumer on that shared durable subscription must use the same client identifier. If a shared durable subscription already exists with the same name and client identifier (if set), and the same topic and message selector have been specified, then this method creates a JMSConsumer on the existing shared durable subscription. If a shared durable subscription already exists with the same name and client identifier (if set), but a different topic or message selector has been specified, and there is no consumer already active (i.e. not closed) on the durable subscription then this is equivalent to unsubscribing (deleting) the old one and creating a new one. If a shared durable subscription already exists with the same name and client identifier (if set) but a different topic or message selector has been specified, and there is a consumer already active (i.e. not closed) on the durable subscription, then a JMSRuntimeException will be thrown. A shared durable subscription and an unshared durable subscription may not have the same name and client identifier (if set). If an unshared durable subscription already exists with the same name and client identifier (if set) then a JMSRuntimeException is thrown. There is no restriction on durable subscriptions and shared non-durable subscriptions having the same name and clientId (which may be unset). Such subscriptions would be completely separate.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSContext</class-interface>
      <method name="createSharedDurableConsumer" return-type="jakarta.jms.JMSConsumer">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1390</id>
      <description>if the client identifier is unset</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createDurableConsumer" return-type="jakarta.jms.MessageConsumer">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.IllegalStateException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1391</id>
      <description>if the client identifier is unset</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createDurableSubscriber" return-type="jakarta.jms.TopicSubscriber">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.IllegalStateException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1393</id>
      <description>Creates a shared durable subscription on the specified topic (if one does not already exist), specifying a message selector and the noLocal parameter, and creates a consumer on that durable subscription. This method creates the durable subscription without a message selector. A durable subscription is used by an application which needs to receive all the messages published on a topic, including the ones published when there is no active consumer associated with it. The JMS provider retains a record of this durable subscription and ensures that all messages from the topic's publishers are retained until they are delivered to, and acknowledged by, a consumer on this durable subscription or until they have expired. A durable subscription will continue to accumulate messages until it is deleted using the unsubscribe method. This method may only be used with shared durable subscriptions. Any durable subscription created using this method will be shared. This means that multiple active (i.e. not closed) consumers on the subscription may exist at the same time. The term "consumer" here means a MessageConsumer or JMSConsumer object in any client. A shared durable subscription is identified by a name specified by the client and by the client identifier (which may be unset). An application which subsequently wishes to create a consumer on that shared durable subscription must use the same client identifier. If a shared durable subscription already exists with the same name and client identifier (if set), and the same topic and message selector has been specified, then this method creates a MessageConsumer on the existing shared durable subscription. If a shared durable subscription already exists with the same name and client identifier (if set) but a different topic or message selector has been specified, and there is no consumer already active (i.e. not closed) on the durable subscription then this is equivalent to unsubscribing (deleting) the old one and creating a new one. If a shared durable subscription already exists with the same name and client identifier (if set) but a different topic or message selector has been specified, and there is a consumer already active (i.e. not closed) on the durable subscription, then a JMSException will be thrown. A shared durable subscription and an unshared durable subscription may not have the same name and client identifier (if set). If an unshared durable subscription already exists with the same name and client identifier (if set) then a JMSException is thrown. There is no restriction on durable subscriptions and shared non-durable subscriptions having the same name and clientId (which may be unset). Such subscriptions would be completely separate.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createSharedDurableConsumer" return-type="jakarta.jms.MessageConsumer">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1394</id>
      <description>if the session fails to create the shared durable subscription and MessageConsumer due to some internal error if a shared durable subscription already exists with the same name and client identifier, but a different topic or message selector, and there is a consumer already active if an unshared durable subscription already exists with the same name and client identifier</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createSharedDurableConsumer" return-type="jakarta.jms.MessageConsumer">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1395</id>
      <description>if an invalid topic is specified.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createSharedDurableConsumer" return-type="jakarta.jms.MessageConsumer">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidDestinationException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1396</id>
      <description>Creates a shared durable subscription on the specified topic (if one does not already exist), specifying a message selector, and creates a consumer on that durable subscription. A durable subscription is used by an application which needs to receive all the messages published on a topic, including the ones published when there is no active consumer associated with it. The JMS provider retains a record of this durable subscription and ensures that all messages from the topic's publishers are retained until they are delivered to, and acknowledged by, a consumer on this durable subscription or until they have expired. A durable subscription will continue to accumulate messages until it is deleted using the unsubscribe method. This method may only be used with shared durable subscriptions. Any durable subscription created using this method will be shared. This means that multiple active (i.e. not closed) consumers on the subscription may exist at the same time. The term "consumer" here means a MessageConsumer or JMSConsumer object in any client. A shared durable subscription is identified by a name specified by the client and by the client identifier (which may be unset). An application which subsequently wishes to create a consumer on that shared durable subscription must use the same client identifier. If a shared durable subscription already exists with the same name and client identifier (if set), and the same topic and message selector has been specified, then this method creates a MessageConsumer on the existing shared durable subscription. If a shared durable subscription already exists with the same name and client identifier (if set) but a different topic or message selector has been specified, and there is no consumer already active (i.e. not closed) on the durable subscription then this is equivalent to unsubscribing (deleting) the old one and creating a new one. If a shared durable subscription already exists with the same name and client identifier (if set) but a different topic or message selector has been specified, and there is a consumer already active (i.e. not closed) on the durable subscription, then a JMSException will be thrown. A shared durable subscription and an unshared durable subscription may not have the same name and client identifier (if set). If an unshared durable subscription already exists with the same name and client identifier (if set) then a JMSException is thrown. There is no restriction on durable subscriptions and shared non-durable subscriptions having the same name and clientId (which may be unset). Such subscriptions would be completely separate.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createSharedDurableConsumer" return-type="jakarta.jms.MessageConsumer">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1397</id>
      <description>if the session fails to create the shared durable subscription and MessageConsumer due to some internal error if a shared durable subscription already exists with the same name and client identifier, but a different topic or message selector, and there is a consumer already active if an unshared durable subscription already exists with the same name and client identifier</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createSharedDurableConsumer" return-type="jakarta.jms.MessageConsumer">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1398</id>
      <description>if an invalid topic is specified.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createSharedDurableConsumer" return-type="jakarta.jms.MessageConsumer">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidDestinationException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1399</id>
      <description>if the message selector is invalid.</description>
      <package>jakarta.jms</package>
      <class-interface>Session</class-interface>
      <method name="createSharedDurableConsumer" return-type="jakarta.jms.MessageConsumer">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidSelectorException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1402</id>
      <description>Constructs a TransactionInProgressRuntimeException with the specified detail message and error code.</description>
      <package>jakarta.jms</package>
      <class-interface>TransactionInProgressRuntimeException</class-interface>
      <method name="TransactionInProgressRuntimeException" return-type="TransactionInProgressRuntimeException">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1403</id>
      <description>Constructs a TransactionInProgressRuntimeException with the specified detail message</description>
      <package>jakarta.jms</package>
      <class-interface>TransactionInProgressRuntimeException</class-interface>
      <method name="TransactionInProgressRuntimeException" return-type="TransactionInProgressRuntimeException">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1404</id>
      <description>Creates a XAJMSContext with the default user identity A connection and session are created for use by the new XAJMSContext. The connection is created in stopped mode but will be automatically started when a JMSConsumer is created.</description>
      <package>jakarta.jms</package>
      <class-interface>XAConnectionFactory</class-interface>
      <method name="createXAContext" return-type="jakarta.jms.XAJMSContext"/>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1405</id>
      <description>if the JMS provider fails to create the XAJMSContext due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>XAConnectionFactory</class-interface>
      <method name="createXAContext" return-type="jakarta.jms.XAJMSContext">
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1406</id>
      <description>if client authentication fails due to an invalid user name or password.</description>
      <package>jakarta.jms</package>
      <class-interface>XAConnectionFactory</class-interface>
      <method name="createXAContext" return-type="jakarta.jms.XAJMSContext">
        <throw>jakarta.jms.JMSSecurityRuntimeException</throw>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1407</id>
      <description>Creates a JMSContext with the specified user identity A connection and session are created for use by the new XAJMSContext. The connection is created in stopped mode but will be automatically started when a JMSConsumer is created.</description>
      <package>jakarta.jms</package>
      <class-interface>XAConnectionFactory</class-interface>
      <method name="createXAContext" return-type="jakarta.jms.XAJMSContext">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1408</id>
      <description>if the JMS provider fails to create the JMSContext due to some internal error.</description>
      <package>jakarta.jms</package>
      <class-interface>XAConnectionFactory</class-interface>
      <method name="createXAContext" return-type="jakarta.jms.XAJMSContext">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSRuntimeException</throw>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1409</id>
      <description>if client authentication fails due to an invalid user name or password.</description>
      <package>jakarta.jms</package>
      <class-interface>XAConnectionFactory</class-interface>
      <method name="createXAContext" return-type="jakarta.jms.XAJMSContext">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
        <throw>jakarta.jms.JMSSecurityRuntimeException</throw>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1410</id>
      <description>Throws a TransactionInProgressRuntimeException, since it should not be called for an XAJMSContext object.</description>
      <package>jakarta.jms</package>
      <class-interface>XAJMSContext</class-interface>
      <method name="commit" return-type="void"/>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1411</id>
      <description>if the method is called on an XAJMSContext.</description>
      <package>jakarta.jms</package>
      <class-interface>XAJMSContext</class-interface>
      <method name="commit" return-type="void">
        <throw>jakarta.jms.TransactionInProgressRuntimeException</throw>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1412</id>
      <description>Returns the JMSContext object associated with this XAJMSContext.</description>
      <package>jakarta.jms</package>
      <class-interface>XAJMSContext</class-interface>
      <method name="getContext" return-type="jakarta.jms.JMSContext"/>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1413</id>
      <description>Returns whether the session is in transacted mode; this method always returns true.</description>
      <package>jakarta.jms</package>
      <class-interface>XAJMSContext</class-interface>
      <method name="getTransacted" return-type="boolean"/>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1414</id>
      <description>Returns an XAResource to the caller.</description>
      <package>jakarta.jms</package>
      <class-interface>XAJMSContext</class-interface>
      <method name="getXAResource" return-type="javax.transaction.xa.XAResource"/>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1415</id>
      <description>Throws a TransactionInProgressRuntimeException, since it should not be called for an XAJMSContext object.</description>
      <package>jakarta.jms</package>
      <class-interface>XAJMSContext</class-interface>
      <method name="rollback" return-type="void"/>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1416</id>
      <description>if the method is called on an XAJMSContext.</description>
      <package>jakarta.jms</package>
      <class-interface>XAJMSContext</class-interface>
      <method name="rollback" return-type="void">
        <throw>jakarta.jms.TransactionInProgressRuntimeException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1422</id>
      <description>Constructs a MessageNotWriteableRuntimeException with the specified reason and error code.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageNotWriteableRuntimeException</class-interface>
      <method name="MessageNotWriteableRuntimeException" return-type="MessageNotWriteableRuntimeException">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1423</id>
      <description>Constructs a MessageNotWriteableRuntimeException with the specified reason. The error code defaults to null.</description>
      <package>jakarta.jms</package>
      <class-interface>MessageNotWriteableRuntimeException</class-interface>
      <method name="MessageNotWriteableRuntimeException" return-type="MessageNotWriteableRuntimeException">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1424</id>
      <description>Constructs a MessageNotWriteableRuntimeException with the specified detail message, error code and cause</description>
      <package>jakarta.jms</package>
      <class-interface>MessageNotWriteableRuntimeException</class-interface>
      <method name="MessageNotWriteableRuntimeException" return-type="MessageNotWriteableRuntimeException">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.Throwable</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1428</id>
      <description>if called on a QueueConnection</description>
      <package>jakarta.jms</package>
      <class-interface>Connection</class-interface>
      <method name="createDurableConnectionConsumer" return-type="jakarta.jms.ConnectionConsumer">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>jakarta.jms.ServerSessionPool</parameter>
          <parameter>int</parameter>
        </parameters>
        <throw>jakarta.jms.IllegalStateException</throw>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1429</id>
      <description>Creates a connection consumer for this connection (optional operation) on the specific topic using a shared non-durable subscription with the specified name. This is an expert facility not used by ordinary JMS clients. This method must not be used in a Jakarta EE web or Enterprise Beans application. Doing so may cause a JMSException to be thrown though this is not guaranteed.</description>
      <package>jakarta.jms</package>
      <class-interface>Connection</class-interface>
      <method name="createSharedConnectionConsumer" return-type="jakarta.jms.ConnectionConsumer">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>jakarta.jms.ServerSessionPool</parameter>
          <parameter>int</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1430</id>
      <description>if the Connection object fails to create a connection consumer for one of the following reasons: an internal error has occurred invalid arguments for sessionPool and messageSelector or this method has been called in a Jakarta EE web or Enterprise Beans application (though it is not guaranteed that an exception is thrown in this case)</description>
      <package>jakarta.jms</package>
      <class-interface>Connection</class-interface>
      <method name="createSharedConnectionConsumer" return-type="jakarta.jms.ConnectionConsumer">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>jakarta.jms.ServerSessionPool</parameter>
          <parameter>int</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1431</id>
      <description>if called on a QueueConnection</description>
      <package>jakarta.jms</package>
      <class-interface>Connection</class-interface>
      <method name="createSharedConnectionConsumer" return-type="jakarta.jms.ConnectionConsumer">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>jakarta.jms.ServerSessionPool</parameter>
          <parameter>int</parameter>
        </parameters>
        <throw>jakarta.jms.IllegalStateException</throw>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1432</id>
      <description>if an invalid destination is specified.</description>
      <package>jakarta.jms</package>
      <class-interface>Connection</class-interface>
      <method name="createSharedConnectionConsumer" return-type="jakarta.jms.ConnectionConsumer">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>jakarta.jms.ServerSessionPool</parameter>
          <parameter>int</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidDestinationException</throw>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1433</id>
      <description>if the message selector is invalid.</description>
      <package>jakarta.jms</package>
      <class-interface>Connection</class-interface>
      <method name="createSharedConnectionConsumer" return-type="jakarta.jms.ConnectionConsumer">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>jakarta.jms.ServerSessionPool</parameter>
          <parameter>int</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidSelectorException</throw>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1434</id>
      <description>Creates a connection consumer for this connection (optional operation) on the specific topic using a shared durable subscription with the specified name. This is an expert facility not used by ordinary JMS clients. This method must not be used in a Jakarta EE web or Enterprise Beans application. Doing so may cause a JMSException to be thrown though this is not guaranteed.</description>
      <package>jakarta.jms</package>
      <class-interface>Connection</class-interface>
      <method name="createSharedDurableConnectionConsumer" return-type="jakarta.jms.ConnectionConsumer">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>jakarta.jms.ServerSessionPool</parameter>
          <parameter>int</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1435</id>
      <description>if the Connection object fails to create a connection consumer for one of the following reasons: an internal error has occurred invalid arguments for sessionPool and messageSelector or this method has been called in a Jakarta EE web or Enterprise Beans application (though it is not guaranteed that an exception is thrown in this case)</description>
      <package>jakarta.jms</package>
      <class-interface>Connection</class-interface>
      <method name="createSharedDurableConnectionConsumer" return-type="jakarta.jms.ConnectionConsumer">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>jakarta.jms.ServerSessionPool</parameter>
          <parameter>int</parameter>
        </parameters>
        <throw>jakarta.jms.JMSException</throw>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1436</id>
      <description>if called on a QueueConnection</description>
      <package>jakarta.jms</package>
      <class-interface>Connection</class-interface>
      <method name="createSharedDurableConnectionConsumer" return-type="jakarta.jms.ConnectionConsumer">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>jakarta.jms.ServerSessionPool</parameter>
          <parameter>int</parameter>
        </parameters>
        <throw>jakarta.jms.IllegalStateException</throw>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1437</id>
      <description>if an invalid destination is specified.</description>
      <package>jakarta.jms</package>
      <class-interface>Connection</class-interface>
      <method name="createSharedDurableConnectionConsumer" return-type="jakarta.jms.ConnectionConsumer">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>jakarta.jms.ServerSessionPool</parameter>
          <parameter>int</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidDestinationException</throw>
      </method>
    </assertion>
<assertion required="false" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1438</id>
      <description>if the message selector is invalid.</description>
      <package>jakarta.jms</package>
      <class-interface>Connection</class-interface>
      <method name="createSharedDurableConnectionConsumer" return-type="jakarta.jms.ConnectionConsumer">
        <parameters>
          <parameter>jakarta.jms.Topic</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>jakarta.jms.ServerSessionPool</parameter>
          <parameter>int</parameter>
        </parameters>
        <throw>jakarta.jms.InvalidSelectorException</throw>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1439</id>
      <description>Constructs a TransactionInProgressRuntimeException with the specified detail message, error code and cause</description>
      <package>jakarta.jms</package>
      <class-interface>TransactionInProgressRuntimeException</class-interface>
      <method name="TransactionInProgressRuntimeException" return-type="TransactionInProgressRuntimeException">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.Throwable</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1440</id>
      <description>Constructs a ResourceAllocationRuntimeException with the specified reason and error code.</description>
      <package>jakarta.jms</package>
      <class-interface>ResourceAllocationRuntimeException</class-interface>
      <method name="ResourceAllocationRuntimeException" return-type="ResourceAllocationRuntimeException">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1441</id>
      <description>Constructs a ResourceAllocationRuntimeException with the specified reason. The error code defaults to null.</description>
      <package>jakarta.jms</package>
      <class-interface>ResourceAllocationRuntimeException</class-interface>
      <method name="ResourceAllocationRuntimeException" return-type="ResourceAllocationRuntimeException">
        <parameters>
          <parameter>java.lang.String</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1442</id>
      <description>Constructs a ResourceAllocationRuntimeException with the specified detail message, error code and cause</description>
      <package>jakarta.jms</package>
      <class-interface>ResourceAllocationRuntimeException</class-interface>
      <method name="ResourceAllocationRuntimeException" return-type="ResourceAllocationRuntimeException">
        <parameters>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.String</parameter>
          <parameter>java.lang.Throwable</parameter>
        </parameters>
      </method>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1451</id>
      <description>Fully qualified name of the JMS connection factory interface. Permitted values are jakarta.jms.ConnectionFactory or jakarta.jms.QueueConnectionFactory or jakarta.jms.TopicConnectionFactory. If not specified then jakarta.jms.ConnectionFactory will be used.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSConnectionFactoryDefinition</class-interface>
      <method name="interfaceName" return-type="java.lang.String"/>
    </assertion>
<assertion required="true" impl-spec="false" status="active" testable="true">
      <id>JMS:JAVADOC:1452</id>
      <description>Fully qualified name of the JMS destination interface. Permitted values are jakarta.jms.Queue or jakarta.jms.Topic.</description>
      <package>jakarta.jms</package>
      <class-interface>JMSDestinationDefinition</class-interface>
      <method name="interfaceName" return-type="java.lang.String"/>
    </assertion>
</assertions>
</javadoc>
