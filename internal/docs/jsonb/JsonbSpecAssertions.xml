<?xml version="1.0"?>
<!--

    Copyright (c) 2018 Oracle and/or its affiliates. All rights reserved.

    This program and the accompanying materials are made available under the
    terms of the Eclipse Public License v. 2.0, which is available at
    http://www.eclipse.org/legal/epl-2.0.

    This Source Code may also be made available under the following Secondary
    Licenses when the conditions for such availability set forth in the
    Eclipse Public License v. 2.0 are satisfied: GNU General Public License,
    version 2 with the GNU Classpath Exception, which is available at
    https://www.gnu.org/software/classpath/license.html.

    SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0

-->

<?xml-stylesheet type="text/xsl"
href="https://raw.githubusercontent.com/eclipse-ee4j/jakartaee-tck/master/internal/docs/xsl/spec_assertions.xsl"?>
<!DOCTYPE spec SYSTEM "https://raw.githubusercontent.com/eclipse-ee4j/jakartaee-tck/master/internal/docs/dtd/spec_assertions.dtd">

<!-- Generated on Tue Jun 16 16:20:08 EDT 2015 -->
<spec>
	<next-available-id></next-available-id>
	<previous-id></previous-id>
	<technology>JSONB</technology>
	<id>JSONB</id>
	<name>Java API for JSON Binding</name>
	<version>1.0</version>
	<location-names>
		<chapters>
			<chapter id="1" name="Introduction">
				<sections>
					<section id="1.1" name="Status"/>
					<section id="1.2" name="Goals"/>
					<section id="1.3" name="Non-Goals"/>
					<section id="1.4" name="Conventions"/>
					<section id="1.5" name="Terminology"/>
          <section id="1.6" name="Expert Group Members"/>
          <section id="1.7" name="Acknowledgements"/>
				</sections>
			</chapter>
			<chapter id="2" name="Runtime API">
				<sections>
					<section id="2.1" name="Runtime API"/>
				</sections>
			</chapter>
			<chapter id="3" name="Default Mapping">
				<sections>
					<section id="3.1" name="General"/>
					<section id="3.2" name="Errors"/>
					<section id="3.3" name="Basic Java Types"/>
          <section id="3.3.1" name="java.lang.String, Character"/>
          <section id="3.3.2" name="java.lang.Byte, Short, Integer, Long, Float, Double"/>
          <section id="3.3.3" name="java.lang.Boolean"/>
          <section id="3.3.4" name="java.lang.Number"/>
					<section id="3.4" name="Specific Standard Java SE Types"/>
          <section id="3.4.1" name="java.math.BigInteger, BigDecimal"/>
          <section id="3.4.2" name="java.net.URL, URI"/>
          <section id="3.4.3" name="java.util.Optional, OptionalInt, OptionalLong, OptionalDouble"/>
					<section id="3.5" name="Dates"/>
          <section id="3.5.1" name="java.util.Date, Calendar, GregorianCalendar"/>
          <section id="3.5.2" name="java.util.TimeZone, SimpleTimeZone"/>
          <section id="3.5.3" name="java.time.*"/>
					<section id="3.6" name="Untyped Mapping"/>
					<section id="3.7" name="Java Class"/>
          <section id="3.7.1" name="Scope and Field access strategy"/>
          <section id="3.7.2" name="Nested Classes"/>
          <section id="3.7.3" name="Static Nested Classes"/>
          <section id="3.7.4" name="Anonymous Classes"/>
					<section id="3.8" name="Polymorphic Types"/>
					<section id="3.9" name="Enum"/>
					<section id="3.10" name="Interfaces"/>
					<section id="3.11" name="Collections"/>
					<section id="3.12" name="Arrays"/>
					<section id="3.13" name="Attribute order"/>
					<section id="3.14" name="Null value handling"/>
          <section id="3.14.1" name="Null Java field"/>
          <section id="3.14.2" name="Null Array Values"/>
					<section id="3.15" name="Names and identifiers"/>
					<section id="3.16" name="Big numbers"/>
          <section id="3.17" name="Generics"/>
          <section id="3.17.1" name="Type resolution algorithm"/>
					<section id="3.18" name="Must-Ignore policy"/>
					<section id="3.19" name="Uniqueness of properties"/>
					<section id="3.20" name="JSON Processing integration"/>
				</sections>
			</chapter>
			<chapter id="4" name="Customizing Mapping">
				<sections>
					<section id="4.1" name="Customizing Property Names"/>
          <section id="4.1.1" name="javax.json.bind.annotation.JsonbTransient"/>
          <section id="4.1.2" name="javax.json.bind.annotation.JsonbProperty"/>
          <section id="4.1.3" name="javax.json.bind.config.PropertyNamingStrategy"/>
          <section id="4.1.4" name="Property names resolution"/>
					<section id="4.2" name="Customizing Property Order"/>
					<section id="4.3" name="Customizing Null Handling"/>
          <section id="4.3.1" name="javax.json.bind.annotation.JsonbNillable"/>
          <section id="4.3.2" name="Global null handling configuration"/>
					<section id="4.4" name="I-JSON support"/>
          <section id="4.4.1" name="Strict date serialization"/>
					<section id="4.5" name="Custom instantiation"/>
					<section id="4.6" name="Custom visibility"/>
					<section id="4.7" name="Custom mapping"/>
          <section id="4.7.1" name="Adapters"/>
          <section id="4.7.2" name="Serializers/Deserializers"/>
					<section id="4.8" name="Custom date format"/>
					<section id="4.9" name="Custom number format"/>
					<section id="4.10" name="Custom binary data handling"/>
				</sections>
			</chapter>
			<chapter id="5" name="Appendix">
				<sections>
					<section id="5.1" name="Change Log"/>
          <section id="5.1.1" name="Changes Since 1.0 Early Draft"/>
				</sections>
			</chapter>
		</chapters>
	</location-names>
	<assertions>

		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
			<id>JSONB:SPEC:JSB-3.1-1</id>
			<description>JSON Binding implementations MUST support binding of JSON documents as defined in RFC 7159 JSON Grammar. Serialized JSON output MUST conform to the RFC 7159 JSON Grammar and be encoded in UTF-8 encoding as defined in Section 8.1 (Character Encoding) of RFC 7159
			</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.1"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
			<id>JSONB:SPEC:JSB-3.1-2</id>
			<description>Implementations MUST support deserialization of documents conforming to RFC 7159 JSON Grammar</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.1"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="false" impl-spec="false" defined-by="technology" status="active" testable="false">
			<id>JSONB:SPEC:JSB-3.1-3</id>
			<description>In addition, implementations SHOULD NOT allow deserialization of RFC 7159 non-conforming text (e.g. unsupported encoding, ...) and report error in such case</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.1"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
			<id>JSONB:SPEC:JSB-3.1-4</id>
			<description>Detection of UTF encoding of deserialized document is done as defined in the Section 3 (Encoding) of RFC 4627</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.1"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.1-5</id>
			<description>Implementations SHOULD ignore presence of UTF byte order mark (BOM) and not treat it as an error.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.1"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
			<id>JSONB:SPEC:JSB-3.2-1</id>
			<description>Implementations SHOULD NOT allow unmarshalling of RFC 7159 non-conforming text (e.g. unsupported encoding) and report error in such case.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.2"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="false" impl-spec="false" defined-by="technology" status="active" testable="false">
			<id>JSONB:SPEC:JSB-3.2-2</id>
			<description>Implementation SHOULD also report error also during unmarshalling operation, if it is not possible to represent JSON document value in the expected Java type</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.2"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.3-1</id>
			<description>Implementation MUST report binding of the following basic java classes and their corresponding primitive types
java.lang.String
java.lang.Character
java.lang.Byte
java.lang.Short
java.lang.Integer
java.lang.Long
java.lang.Float
java.lang.Double
java.lang.Boolean</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.3"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.3.1-1</id>
			<description>Instances of type java.lang.String and java.lang.Character are marshalled to JSON String values as defined within RFC 7159 Section 7 (Strings) in UTF-8 encoding without byte order mark. </description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.3.1"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.3.1-2</id>
			<description>Implementations SHOULD support deserialization of JSON text in other (than UTF-8) UTF encodings into java.lang.String instances</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.3.2"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.3.2-1</id>
			<description>Serialization of type java.lang.Byte, Short, Integer, Long, Float, Double and their corresponding primitive types to JSON Number MUST follow the conversion process defined in javadoc specification for the corresponding toString method</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.3.2"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.3.2-2</id>
			<description>Deserialization of a JSON value into java.lang.Byte, Short, Integer, Long, Float, Double instance or corresponding primitive type MUST follow the conversion process as defined in the specification for their corresponding parse$Type method, such as java.lang.Byte.parseByte for Byte.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.3.2"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.3.3-1</id>
			<description>Serialization of type java.lang.Boolean and its corresponding boolean primitive type to JSON value MUST follow conversion process defined in specification for java.lang.Boolean.toString method</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.3.3"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.3.3-2</id>
			<description>Deserialization of a JSON value into java.lang.Boolean instance or boolean primitive type MUST follow the conversion process as defined in specification for java.lang.Boolean.parseBoolean method.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.3.3"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.3.4-1</id>
			<description>Serialization of type java.lang.Number (if their more concrete type is not defined elsewhere in this chapter) to JSON string MUST retrieve double value returned from java.lang.Number.doubleValue() method and converting the value to JSON Number as defined in subsection 3.3.2</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.3.4"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.3.4-2</id>
			<description>Deserialization of a JSON value into Java type java.lang.Number should return instance of java.math.BigDecimal by using conversion as defined in the specification for constructor of java.math.BigDecimal with java.lang.String.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.3.4"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.4-1</id>
			<description>Implementations MUST support binding of the following standard Java SE classes:
java.math.BigInteger
java.math.BigDecimal
java.net.URL
java.net.URI
java.util.Optional
java.util.OptionalInt
java.util.OptionalLong
java.util.OptionalDouble </description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.4"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.4.1-1</id>
			<description>Serialization of type java.math.BigInteger, BigDecimal to s JSON Number MUST follow the conversion process defined in specification for their toString method</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.4.1"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.4.1-2</id>
			<description>Deserialization of JSON value into java.math.BigInteger, BigDecimal instance MUST follow the conversion process as defined in the specification for constructor of java.math.BigInteger, BigDecimal with java.lang.String.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.4.2"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.4.2-1</id>
			<description>Serialization of type java.net.URL, URI to a JSON String value MUST follow the conversion process defined in specification for their toString method</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.4.2"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.4.2-2</id>
			<description>Deserialization of a JSON value into java.net.URL, URI instance MUST follow the conversion process as defined in the specification for constructor of java.net.URL, URI with java.lang.String input.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.4.2"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.4.3-1</id>
			<description>Non-empty instances of type java.util.Optional, OptionalInt, OptionalLong, OptionalDouble are serialized to a JSON value by retrieving their contained instance and converting it to JSON value based on its type and corresponding mapping definitions within this chapter.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.4.3"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.4.3-2</id>
			<description>Class fields containing empty optional instances are treated as having a null value and serialized based on 3.14.1.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.4.3"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.4.3-3</id>
			<description>Empty optional instances in array items are serialized as null.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.4.3"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.4.3-4</id>
			<description>Deserializing into Optional, OptionalInt, OptionalLong, OptionalDouble return empty optional value for properties containing a null value.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.4.3"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.4.3-5</id>
			<description>Otherwise any non-empty Optional, OptionalInt, OptionalLong, OptionalDouble value is constructed of type unmarshalled based on mappings defined in this chapter.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.4.3"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.4.3-6</id>
			<description>Instances of type java.util.Optional T are serialized to a JSON value as JSON objects when T alone would be serialized as JSON object. When T would be serialized as a JSON value (e.g. java.lang.String, java.lang.Integer), an instance of java.util.Optional T is serialized as a JSON value (without curly brackets).</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.4.3"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.4.3-7</id>
			<description>Deserialization of a JSON value into java.util.Optional(T) MUST be supported if deserialization of a JSON value into instance of T is supported.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.4.3"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.5-1</id>
			<description>Implementations MUST support binding of the following standard Java date/time classes: java.util.Date
java.util.Calendar
java.util.GregorianCalendar
java.util.TimeZone
java.util.SimpleTimeZone
java.time.Instant
java.time.Duration
java.time.Period
java.time.LocalDate
java.time.LocalTime
java.time.LocalDateTime
java.time.ZonedDateTime
java.time.ZoneId
java.time.ZoneOffset
java.time.OffsetDateTime
java.time.OffsetTime</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.5"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.5-2</id>
			<description>If not specified otherwise in this section, GMT standard time zone and offset specified from UTC Greenwich is used.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.5"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.5-3</id>
			<description>If not specified otherwise, date time format for marshalling and unmarshalling is ISO 8601 without offset, as specified in java.time.format.DateTimeFormatter.ISO_DATE.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.5"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.5-4</id>
			<description>Implementations MUST report error if the date/time string in JSON document does not correspond to the expected datetime format. </description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.5"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.5.1-1</id>
			<description>The serialization format of java.util.Date, Calendar, GregorianCalendar instances with no time information is ISO_DATE.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.5.1"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.5.1-2</id>
			<description>If time information is present, the format is ISO_DATE_TIME</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.5.1"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.5.1-3</id>
			<description>Implementations MUST support deserialization of both ISO_DATE and ISO_DATE_TIME into java.util.Date, Calendar and GregorianCalendar instances.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.5.1"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.5.2-1</id>
			<description>Implementations MUST support deserialization of any time zone format specified in java.util.TimeZone into a field or property of type java.util.TimeZone and SimpleTimeZone.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.5.2"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.5.2-2</id>
			<description>Implementations MUST report an error for deprecated three-letter time zone IDs as specified in java.util.Timezone.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.5.2"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.5.2-3</id>
			<description>The serialization format of java.util.TimeZone and SimpleTimeZone is NormalizedCustomID as specified in java.util.TimeZone.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.5.2"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.5.3-1</id>
			<description>The serialization output for a java.time.Instant instance MUST be in a ISO_INSTANT format, as specified in java.time.format.DateTimeFormatter.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.5.3"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.5.3-2</id>
			<description>Implementations MUST support the deserialization of an ISO_INSTANT formatted JSON string to a java.time.Instant instance.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.5.3"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.5.3-3</id>
			<description>Analogically, for other java.time.* classes, following mapping table matches Java types and corresponding formats:
java.time.Instant ISO_INSTANT
java.time.LocalDate ISO_LOCAL_DATE
java.time.LocalTime ISO_LOCAL_TIME
java.time.LocalDateTime ISO_LOCAL_DATE_TIME
java.time.ZonedDateTime ISO_ZONED_DATE_TIME
java.time.OffsetDateTime ISO_OFFSET_DATE_TIME
java.time.OffsetTime ISO_OFFSET_TIME</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.5.3"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.5.3-4</id>
			<description>Implementations MUST support the deserialization of any time zone ID format specified in java.time.ZoneId into a field or property of type java.time.ZoneId.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.5.3"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.5.3-5</id>
			<description>The serialization format of java.time.ZoneId is the normalized zone ID as specified in java.time.ZoneId.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.5.3"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.5.3-6</id>
			<description>Implementations MUST support the deserialization of any time zone ID format specified in java.time.ZoneOffset into a field or property of type java.time.ZoneOffset.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.5.3"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.5.3-7</id>
			<description>The serialization format of java.time.ZoneOffset is the normalized zone ID as specified in java.time.ZoneOffset.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.5.3"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.5.3-8</id>
			<description>Implementations MUST support the deserialization of any duration format specified in java.time.Duration into a field or property of type java.time.Duration.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.5.3"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.5.3-9</id>
			<description>This is super-set of ISO 8601 duration format. The serialization format of java.time.Duration is the ISO 8601 seconds based representation, such as PT8H6M12.345S.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.5.3"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.5.3-10</id>
			<description>Implementations MUST support the deserialization of any period format specified in java.time.Period into a field or property of type java.time.Period.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.5.3"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.5.3-11</id>
			<description>This is a super-set of ISO 8601 period format. The serialization format of java.time.Period is ISO 8601 period representation.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.5.3"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.5.3-12</id>
			<description>A zero-length period is represented as zero days 'P0D'.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.5.3"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.6-1</id>
			<description>For an unspecified output type of a deserialization operation, as well as where output type is specified as Object.class, implementations MUST deserialize a JSON document using Java runtime types specified in table below:
object java.util.Map String,Object
array java.util.List Object
string java.lang.String
number java.math.BigDecimal
true, false java.lang.Boolean
null null
</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.6"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.6-2</id>
			<description>JSON object values are deserialized into an implementation of java.util.Map(String, Object) with a predictable iteration order.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.6"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.7-1</id>
			<description>Any instance passed to a deserialization operation must have a public or protected no-argument constructor. Implementations SHOULD throw an error if this condition is not met.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.7"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.7-2</id>
			<description>This limitation does not apply to serialization operations, as well as to classes which specify explicit instantiation methods as described in section 4.5.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.7"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.7.1-1</id>
			<description>For a deserialization operation of a Java property, if a matching public setter method exists, the method is called to set the value of the property. If a matching setter method with private, protected, or defaulted to package-only access exists, then this field is ignored. If no matching setter method exists and the field is public, then direct field assignment is used.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.7.1"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.7.1-2</id>
			<description>For a serialization operation, if a matching public getter method exists, the method is called to obtain the value of the property. If a matching getter method with private, protected, or defaulted to package-only access exists, then this field is ignored. If no matching getter method exists and the field is public, then the value is obtained directly from the field.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.7.1"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.7.1-3</id>
			<description>JSON Binding implementations MUST NOT deserialize into transient, final or static fields and MUST ignore name/value pairs corresponding to such fields.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.7.1"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.7.1-4</id>
			<description>Implementations MUST support serialization of final fields.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.7.1"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.7.1-5</id>
			<description>Transient and static fields MUST be ignored during serialization operation.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.7.1"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.7.1-6</id>
			<description>If a JSON document contains a name/value pair not corresponding to field or setter method, then this name/value pair MUST be ignored.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.7.1"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.7.1-7</id>
			<description>Public getter/setter methods without a corresponding field MUST be supported. When only public getter/setter method without corresponding field is present in the class, the getter method is called to obtain the value to serialize, and the setter method is called during deserialization operation.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.7.1"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.7.2-1</id>
			<description>Implementations MUST support the binding of public and protected nested classes.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.7.2"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.7.2-2</id>
			<description>For deserialization operations, both nested and encapsulating classes MUST fulfill the same instantiation requirements as specified in 3.7.1.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.7.2"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.7.3-1</id>
			<description>Implementations MUST support the binding of public and protected static nested classes.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.7.3"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.7.3-2</id>
			<description>For deserialization operations, the nested class MUST fulfill the same instantiation requirements as specified in 3.7.1.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.7.3"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.7.4-1</id>
			<description>Deserialization into anonymous classes is not supported. Serialization of anonymous classes is supported by default object mapping.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.7.4"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.8-1</id>
			<description>Deserialization into polymorphic types is not supported by default mapping.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.8"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.9-1</id>
			<description>Serialization of an Enum instance to a JSON String value MUST follow the conversion process defined in javadoc specification for their name().</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.9"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.9-2</id>
			<description>Deserialization of a JSON value into an enum instance MUST be done by calling the enum’s valueOf(String) method.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.9"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.10-1</id>
			<description>Implementations MUST support the deserialization of specific interfaces defined in 3.11 and 3.3.4.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.10"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.10-2</id>
			<description>Deserialization to other interfaces is not supported and implementations SHOULD report error in such case.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.10"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.10-3</id>
			<description>If a class property is defined with an interface and not concrete type, then the mapping for a serialized property is resolved based on its runtime type.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.10"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.11-1</id>
			<description>Implementations MUST support binding of the following collection interfaces, classes and their implementations.
java.util.Collection
java.util.Map
java.util.Set
java.util.HashSet
java.util.NavigableSet
java.util.SortedSet
java.util.TreeSet
java.util.LinkedHashSet
java.util.TreeHashSet
java.util.HashMap
java.util.NavigableMap
java.util.SortedMap
java.util.TreeMap
java.util.LinkedHashMap
java.util.TreeHashMap
java.util.List
java.util.ArrayList
java.util.LinkedList
java.util.Deque
java.util.ArrayDeque
java.util.Queue
java.util.PriorityQueue
java.util.EnumSet
java.util.EnumMap

</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.11"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.11-2</id>
			<description>Implementations of interfaces below must provide accessible default constructor. JSON Binding implementations MUST report unmarshalling error if default constructor is not present or is not in accessible scope.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.11"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.12-1</id>
			<description>JSON Binding implementations MUST support binding of Java arrays of all supported Java types from this chapter into/from JSON array structures as defined in Section 5 of RFC 7159</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.12"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.12-2</id>
			<description>Arrays of primitive types and multi-dimensional arrays MUST be supported.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.12"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.13-1</id>
			<description>Declared fields MUST be serialized in lexicographical order into the resulting JSON document. In case of inheritance, declared fields of super class MUST be serialized before declared fields of child class.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.13"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.13-2</id>
			<description>When deserializing a JSON document, declared fields MUST be set in the order of attributes present in the JSON document.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.13"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.14.1-1</id>
			<description>The result of serializing a java field with a null value is the absence of the property in the resulting JSON document.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.14.1"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.14.1-2</id>
			<description>The deserialization operation of a property absent in JSON document MUST not set the value of the field, the setter (if available) MUST not be called, and thus original value of the field MUST be preserved.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.14.1"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.14.1-3</id>
			<description>The deserialization operation of a property with a null value in a JSON document MUST set the value of the field to null value (or call setter with null value if setter is present). The exception is java.util.Optional, OptionalInt, OptionalLong, OptionalDouble instances. In this case the value of the field is set to an empty optional value.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.14.1"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.14.2-1</id>
			<description>The result of deserialization n-ary array represented in JSON document is n-ary Java array.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.14.2"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.14.2-2</id>
			<description>Null value in JSON array is represented by null value in Java array.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.14.2"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.14.2-3</id>
			<description>Serialization operation on Java array with null value at index i MUST output null value at index i of the array in resulting JSON document.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.14.2"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.15-1</id>
			<description>According to RFC 7159 Section 7 , every Java identifier name can be transformed using identity function into a valid JSON String. Identity function MUST be used for transforming Java identifier names into name Strings in JSON document.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.15"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.15-2</id>
			<description>For deserialization operations defined in 3.6 section, identity function is used to transform JSON name strings into Java String instances in the resulting map Map(String, Object).</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.15"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="deprecated" testable="true">
			<id>JSONB:SPEC:JSB-3.15-3</id>
			<description>Identity function is used also for other deseralization operations.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.15"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.15-4</id>
			<description>If a Java identifier with corresponding name does not exist or is not accessible, the implementations MUST report error.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.15"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.16-1</id>
			<description>JSON Binding implementation MUST serialize numbers that express greater magnitude or precision than an IEEE 754 double precision number as strings.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.16"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.17-1</id>
			<description>JSON Binding implementations MUST support binding of generic types.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.17"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.17-2</id>
			<description>Due to type erasure, there are situations when it is not possible to obtain generic type information.  There are two ways for JSON Binding implementations to obtain generic type information. If there is a class file available (in the following text referred as static type information), it is possible to obtain generic type information (effectively generic type declaration) from Signature attribute (if this information is present).</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.17"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.17-3</id>
			<description>The second option is to provide generic type information at runtime. To provide generic type information at runtime, an argument of java.lang.reflect.Type MUST be passed to Jsonb::toJson or to Jsonb::fromJson method.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.17"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.17.1-1</id>
			<description>There are several levels of information JSON Binding implementations may obtain about the type of field/class/interface:
   1. runtime type provided via java.lang.reflect.Type parameter passed to Jsonb::toJson or Jsonb::fromJson method
   2. static type provided in class file (effectively stored in Signature attribute)
   3. raw type
   4. no information about the type</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.17.1"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.17.1-2</id>
			<description>If there is no information about the type, JSON Binding implementation MUST treat this type as java.lang.Object.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.17.1"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.17.1-3</id>
			<description>If only raw type of given field/class/interface is known, then the type MUST be treated like raw type.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.17.1"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.17.1-4</id>
			<description>For example, if the only available information is that given field/class/interface is of type java.util.ArrayList, than the type MUST be treated as java.util.ArrayList Object.  JSON Binding implementations MUST use the most specific type derived from the information available.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.17.1"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.17.1-5</id>
			<description>Let's consider situation where there is only static type information of a given field/class/interface known,
and there is no runtime type information available. Let GenericClass T1; : : : ; Tn  be part of generic type
declaration, where GenericClass is name of the generic type and T1; : : : ; Tn are type parameters. For every
Ti, where i in 1; : : : ; n, there are 3 possible options:</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.17.1"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.17.1-6</id>
			<description>1. Ti is concrete parameter type
2. Ti is bounded parameter type
3. Ti is wildcard parameter type without bounds
In case 1, the most specific parameter type MUST be given concrete parameter type Ti.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.17.1"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.17.1-7</id>
			<description>For bounded parameter type, using bounds B1; : : : ;Bm. If m = 1, then the most specific parameter type MUST be derived from the given bound B1.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.17.1"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.17.1-8</id>
			<description>If B1 is class or interface, the most specific parameter type MUST be the class or interface.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.17.1"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.17.1-9</id>
			<description>Otherwise, the most specific parameter type SHOULD be java.lang.Object.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.17.1"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.17.1-10</id>
			<description>If multiple bounds are specified, the first step is to resolve every bound separately. Letâ€™s define result of such resolution as S1; : : : ; Sm specific parameter types. If S1; : : : ; Sm are java.lang.Object, then the bounded parameter type Ti MUST be java.lang.Object.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.17.1"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.17.1-11</id>
			<description>If there is exactly one Sk, where 1 &lt;= k &lt;= m is different than java.lang.Object, then the most specific parameter type for this bounded parameter type Ti MUST be Sk.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.17.1"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.17.1-12</id>
			<description>If there exists Sk1; Sk2, where 1 &lt;= k1 &lt;= k2 &lt;= m, then the most specific parameter type is Sk1.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.17.1"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.17.1-13</id>
			<description>For wildcard parameter type without bounds, the most specific parameter type MUST be java.lang.Object.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.17.1"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.17.1-14</id>
			<description>Any unresolved type parameter MUST be treated as java.lang.Object. </description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.17.1"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.17.1-15</id>
			<description>If runtime type is provided via java.lang.reflect.Type parameter passed to Jsonb::toJson or Jsonb::fromJson method, than that runtime type overrides static type declaration wherever applicable</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.17.1"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.18-1</id>
			<description>When JSON Binding implementation encounters key in key/value pair that it does not recognize, it should treat the rest of the JSON document as if the element simply did not appear, and in particular, the implementation MUST NOT treat this as an error condition.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.18"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.19-1</id>
			<description>JSON Binding implementations MUST NOT produce JSON documents with members with duplicate names. In this context, "duplicate" means that the names, after processing any escaped characters, are identical sequences of Unicode characters.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.19"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.19-2</id>
			<description>When non-unique property (after override and rename) is found, implementation MUST throw an exception.  This doesn't apply for customized user serialization behavior implemented with the usage of JsonbAdapter mechanism.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.19"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.20-1</id>
			<description>JSON Binding implementations MUST support binding of the following JSON Processing types.

javax.json.JsonObject
javax.json.JsonArray
javax.json.JsonStructure
javax.json.JsonValue
javax.json.JsonPointer
javax.json.JsonString
javax.json.JsonNumber
			</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.20"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.20-2</id>
			<description>Marshalling of supported javax.json.* objects/interfaces/fields MUST have the same result as marshalling these objects with javax.json.JsonWriter.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.20"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-3.20-3</id>
			<description>Deserialization into supported javax.json.* objects/interfaces/fields MUST have the same result as unmarshalling into such objects with javax.json.JsonReader.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="3" section="3.20"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-4.1.1-1</id>
			<description>JSON Binding implementations MUST NOT serialize fields, JavaBean properties or types annotated with javax.json.bind.annotation.JsonbTransient.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="4" section="4.1.1"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-4.1.1-2</id>
			<description>JsonbTransient annotation is mutually exclusive with all other JSON Binding defined annotations. If this condition is not met, JSON Binding implementation MUST throw JsonbException.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="4" section="4.1.1"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-4.1.2-1</id>
			<description>To provide custom name for given field (or JavaBean property),
javax.json.bind.annotation.JsonbProperty may be used. JsonbProperty annotation may be specified on
field, getter or setter method. If specified on field, custom name is used both for serialization and
deserialization.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="4" section="4.1.2"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-4.1.2-2</id>
			<description>If javax.json.bind.annotation.JsonbProperty is specified on getter method, it is used
only for serialization.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="4" section="4.1.2"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-4.1.2-3</id>
			<description>If javax.json.bind.annotation.JsonbProperty is specified on setter method, it is used only for deserialization.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="4" section="4.1.2"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-4.1.2-4</id>
			<description>It is possible to specify different values for getter and setter method for javax.json.bind.annotation.JsonbProperty annotation. In such case the different custom name will be used for serialization and deserialization.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="4" section="4.1.2"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-4.1.3-1</id>
			<description>The way to set custom property naming strategy is to use javax.json.bin.JsonbConfig::withPropertyNamingStrategy method.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="4" section="4.1.2"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-4.1.4-1</id>
			<description>If duplicate name is found exception MUST be thrown. The definition of duplicate (non-unique) property
can be found in 3.19.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="4" section="4.1.3"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-4.2</id>
			<description>The way to set custom property order strategy is to use javax.json.bin.JsonbConfig::withPropertyOrderStrategy method.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="4" section="4.2"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-4.2-2</id>
			<description>To customize the order of serialized properties only for one specific type, JSON Binding provides javax.json.bind.annotation.JsonbPropertyOrder annotation. Order specified by JsonbPropertyOrder annotation overrides order specified by PropertyOrderStrategy.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="4" section="4.2"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-4.3-1</id>
			<description>If annotations (JsonbNillable or JsonbProperty) on different level apply to the same field (or JavaBean property) or if there is config wide configuration and some annotation (JsonbNillable or JsonbProperty) which apply to the same field (or JavaBean property), the annotation with the smallest scope applies.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="4" section="4.3.1"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-4.3.1-1</id>
			<description>When given object (type or package) is annotated with javax.json.bind.annotation.JsonbNillable annotation, the result of null value will be presence of associated property in JSON document with explicit null value.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="4" section="4.3.1"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-4.3.1-2</id>
			<description>The same behavior as JsonbNillable, but only at field, parameter and method (JavaBean property) level is provided by javax.json.bind.annotation.JsonbProperty annotation with its nillable parameter</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="4" section="4.3.1"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-4.3.1-3</id>
			<description>JSON Binding implementations MUST implement override of annotations according to target of the annotation (FIELD, PARAMETER, METHOD, TYPE, PACKAGE). Type level annotation overrides behavior set at the package level. Method, parameter or field level annotation overrides behavior set at the type level.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="4" section="4.3.1"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-4.3.2-1</id>
			<description>The way to enforce serialization of null values, is to call method javax.json.bind.JsonbConfig::withNullValues with parameter true. The way to skip serialization of null values is to call method javax.json.bind.JsonbConfig::withNullValues with parameter false.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="4" section="4.3.2"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-4.4-1</id>
			<description>To enforce strict compliance of serialized JSON documents, JSON Binding implementations MUST implement configuration option jsonb.i-json.strict-ser-compliance.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="4" section="4.4"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-4.4.1-1</id>
			<description>Uppercase rather than lowercase letters MUST be used.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="4" section="4.4.1"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-4.4.1-2</id>
			<description>The timezone MUST always be included and optional trailing seconds MUST be included even when their value is 00.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="4" section="4.4.1"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-4.4.1-3</id>
			<description>JSON Binding implementations MUST serialize java.util.Date, java.util.Calendar, java.util.GregorianCalendar, java.time.LocalDate, java.time.LocalDateTime and java.time.Instant in the same format as java.time.ZonedDateTime.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="4" section="4.4.1"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-4.4.1-4</id>
			<description>The result of serialization of duration must conform to the duration production in Appendix A of RFC 3339, with the same additional restrictions</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="4" section="4.4.1"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-4.5-1</id>
			<description>At most one JsonbCreator annotation can be used to annotate custom constructor or static void factory method in a class, otherwise JsonbException MUST be thrown.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="4" section="4.5"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-4.5-2</id>
			<description>Factory method annotated with JsonbCreator annotation should return instance of particular class this annotation is used for, otherwise JsonbException MUST be thrown.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="4" section="4.5"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-4.5-3</id>
			<description>Parameters of constructor/factory method annotated with JsonbCreator will be mapped from JSON fields with the same name. The name of a parameter can be changed annotating given parameter with JsonbProperty annotation. When a JSON field is not mappable to a parameter with the same name, JsonbException MUST be thrown</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="4" section="4.5"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-4.6-1</id>
			<description>To customize scope and field access strategy as specified in section 3.7.1, it is possible to specify javax.json.bind.annotation.JsonbVisibility annotation or to override default behavior globally calling JsonbConfig::withPropertyVisibilityStrategy method with given custom property visibility strategy.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="4" section="4.5"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-4.7.1-1</id>
			<description>On serialization of Original type JSONB calls JsonbAdapter::adaptToJson method of the adapter to convert Original to Adapted and serializes Adapted the standard way. There are two ways how to register JsonbAdapter: Using JsonbConfig::withAdapters method;</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="4" section="4.7.1"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-4.7.1-2</id>
			<description>Annotating a class field with JsonbTypeAdapter annotation.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="4" section="4.7.1"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-4.7.1-3</id>
			<description>Implementations	must	provide	a	CDI	support	in	adapters	to	allow	injection	of	CDI managed	beans into	it.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="4" section="4.7.1"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-4.7.2-1</id>
			<description>Serializer is a class implementing javax.json.bind.serializers.JsonbSerializer interface. It is used to serialize the type it’s registered on (Original). On marshalling of Original type JSONB calls JsonbSerializer::serialize method. This method has to contain a custom code to serialize Original type using provided JsonpGenerator.Deserializer is a class implementing javax.json.bind.serializers.JsonbDeserializer interface. It is used to deserialize the type it’s registered on (Original). On deserialization of Original type JSONB calls JsonbDeserializer::deserialize method. This method has to contain a custom code to deserialize Original type using provided JsonpParser. There are two ways how to register JsonbSerializer/JsonbDeserializer:Using JsonbConfig::withSerializers/ JsonbConfig::withDeserializers method;</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="4" section="4.7.2"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-4.7.2-2</id>
			<description>Annotating a type with JsonbSerializer/JsonbDeserializer annotation.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="4" section="4.7.2"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-4.7.2-3</id>
			<description>Implementations	must	provide	a	CDI	support	in	serializers/deserializers	to	allow	injection	of	CDI managed	beans into	it.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="4" section="4.7.2"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-4.8-1</id>
			<description>JsonbDateFormat annotation can be applied to the following targets: field, method, type, parameter, package</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="4" section="4.8"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
 		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-4.8-2</id>
			<description>Annotation	applied	to	more	specific	target overrides	the	same	annotation	applied	to	target	with wider	scope and	global	configuration.	For	example,	annotation	applied	to	type	target	will override	the	same	annotation	applied	to	package	target.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="4" section="4.8"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-4.8-3</id>
			<description>Default date format and default locale can be customized globally using javax.json.bind.JsonbConfig::withDateFormat and javax.json.bind.JsonbConfig::withLocale methods.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="4" section="4.8"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-4.9-1</id>
			<description> JsonbNumberFormat annotation can be applied to the following targets: field, method, type, parameter, package</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="4" section="4.9"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-4.9-2</id>
			<description>Annotation	applied	to	more	specific	target	overrides	the	same	annotation	applied	to	target	with wider	scope.	For	example,	annotation	applied	to	type	target	will	override	the	same	annotation applied	to	package	target.	</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="4" section="4.9"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
		<assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
			<id>JSONB:SPEC:JSB-4.10-1</id>
			<description>The way to set custom binary data handling strategy is to use javax.json.bin.JsonbConfig::withBinaryDataStrategy method.</description>
			<keywords>
				<keyword></keyword>
			</keywords>
			<location chapter="4" section="4.10"/>
			<comment></comment>
			<depends order="">
				<depend></depend>
			</depends>
		</assertion>
	</assertions>

</spec>
