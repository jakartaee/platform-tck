<?xml version = "1.0" encoding = "UTF-8"?>
<!DOCTYPE spec SYSTEM "https://raw.githubusercontent.com/eclipse-ee4j/jakartaee-tck/master/internal/docs/dtd/spec_assertions.dtd">
<!--

    Copyright (c) 2018, 2020 Oracle and/or its affiliates. All rights reserved.

    This program and the accompanying materials are made available under the
    terms of the Eclipse Public License v. 2.0, which is available at
    http://www.eclipse.org/legal/epl-2.0.

    This Source Code may also be made available under the following Secondary
    Licenses when the conditions for such availability set forth in the
    Eclipse Public License v. 2.0 are satisfied: GNU General Public License,
    version 2 with the GNU Classpath Exception, which is available at
    https://www.gnu.org/software/classpath/license.html.

    SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0

-->

<!-- <!DOCTYPE spec SYSTEM "file:///C:/XMLAssertions/spec_assertions.dtd"> -->
<spec>
	<next-available-id>1</next-available-id>
	<previous-id>0</previous-id>
	<technology>JACC</technology>
	<id>1</id>
	<name>Java Authorization Service Provider Contract for Containers.</name>
	<version>0.3</version>
	<location-names>
		<chapters>
			<chapter id = "1" name = "Overview">
				<sections>
					<section id = "1.1" name = "Introduction"/>
					<section id = "1.2" name = "Terminology"/>
					<section id = "1.3" name = "Assumptions"/>
					<section id = "1.4" name = "Requirements"/>
					<section id = "1.4.1" name = "Non Requirements"/>
					<section id = "1.5" name = "Running Without a Security Manager"/>
				</sections>
			</chapter>
			<chapter id = "2" name = "Provider Configuration Subcontract">
				<sections>
					<section id = "2.1" name = "Policy Implementation Class"/>
					<section id = "2.2" name = "Permission Implementation Classes"/>
					<section id = "2.3" name = "Policy Configuratoin Interface"/>
					<section id = "2.4" name = "What a Provider Must do"/>
					<section id = "2.5 " name = "What the Application Server must do"/>
				</sections>
			</chapter>
			<chapter id = "3" name = "Policy Configuration Subcontract">
				<sections>
					<section id = "3.1" name = "What a J2EE Platform's Deploy Tools Must do"/>
					<section id = "3.1.1" name = "Policy Contextsand Policy Context Identifiers"/>
					<section id = "3.1.2" name = "Translating Servlet security-constraint Elements"/>
					<section id = "3.1.3" name = "Translating Servlet security-role-ref Elements"/>
					<section id = "3.1.4" name = "Translating EJB mehod-permission Elements"/>
					<section id = "3.1.5" name = "Translating the EJB exclude-list"/>
					<section id = "3.1.6" name = "Translating EJB security-role-ref Elements"/>
					<section id = "3.1.7" name = "Deploying an Application or Module"/>
					<section id = "3.1.8" name = "Undeploying an Application or Module"/>
					<section id = "3.1.9" name = "Deploying to an existing Policy Configuration"/>
					<section id = "3.1.10" name = "Redeploying a Module"/>
					<section id = "3.2" name = "What the Provider Must do"/>
				</sections>
			</chapter>
			<chapter id = "4" name = "Policy Decision Subcontract">
				<sections>
					<section id = "4.1" name = "Policy Enforcement by Servlet Containers"/>
					<section id = "4.1.1" name = "Permission Names for Transport and Pre-Dispatch Decisions"/>
					<section id = "4.1.2" name = "Evaluation of Transport Guarantees"/>
					<section id = "4.1.3" name = "Pre-dispatch Decision"/>
					<section id = "4.1.4" name = "Application Embedded Privilege Test"/>
					
                    <section id = "4.2" name = "Provider Support for Servlet Policy Enforcement"/>
                    <section id = "4.2.1" name = "Servlet Policy Decision Semantics"/>
					<section id = "4.2.2" name = "Servlet Matching Rules"/>
					<section id = "4.3" name = "Policy Enforcement by EJB Containers"/>
					<section id = "4.3.1" name = "Pre-dispatch Decision"/>
					<section id = "4.3.2" name = "Application Embedded Privilege Test"/>
					<section id = "4.4" name = "Provider Support for EJB Policy Decisions"/>
					<section id = "4.4.1" name = "EJB Policy Decision Semantics"/>
					<section id = "4.4.2" name = "EJB Permission Matching Rules"/>
					<section id = "4.5 " name = "Determining if a Permission is Excluded"/>
					<section id = "4.6" name = "Checking if a Caller has been Granted a Permission"/>
					<section id = "4.7" name = "Policy Compatibility Requirements"/>
				</sections>
			</chapter>
		</chapters>
	</location-names>
	<assertions>
		<assertion required = "true" impl-spec = "false" defined-by = "technology" status = "active" testable = "true">
			<id>1</id>
			<description>J2EE 1.4 platforms must implement the contract defined by this JSR.</description>
			<location chapter = "1" section = "1.4"/>
			<comment>container</comment>
		</assertion>
		<assertion required = "false" impl-spec = "false" defined-by = "technology" status = "active" testable = "false">
			<id>2</id>
			<description>Support for the contract by J2EE 1.3 platforms is optional. (OPTIONAL)</description>
			<location chapter = "1" section = "1.4"/>
			<comment>container</comment>
		</assertion>
		<assertion required = "true" impl-spec = "false" defined-by = "technology" status = "active" testable = "true">
			<id>3</id>
			<description>Each Policy provider which satisfies this contract must perform or
   delegate to another provider all the permission evaluations
   requested of it in the VM;</description>                                              
			<location chapter = "1" section = "1.4"/>
			<comment>provider</comment>
		</assertion>
		<assertion required = "true" impl-spec = "false" defined-by = "technology" status = "active" testable = "true">
			<id/>
			<description>Each provider must export interfaces (defined by this contract) for
   use by containers and or container deployment tools to create policy
   statements within the policy store of the provider. These interfaces
   must be used when an application or module is deployed in a 
   container.</description>
			<location chapter = "" section = ""/>                        
			<comment>container</comment>
		</assertion>
		<assertion required = "true" impl-spec = "false" defined-by = "technology" status = "active" testable = "true">
			<id>4</id>
			<description>Each provider must export interfaces (defined by this contract) for
   use by containers and or container deployment tools to create policy
   statements within the policy store of the provider. These interfaces
   must be used when an application or module is deployed in a 
   container.</description>
			<location chapter = "1" section = "1.4"/>
			<comment>provider</comment>
		</assertion>
		<assertion required = "true" impl-spec = "false" defined-by = "technology" status = "active" testable = "true">
			<id>5</id>
			<description>Each provider must satisfy all of the authorization requirements of 
   the EJB and Servlet specifications corresponding to the target
   platform.</description>
			<location chapter = "1" section = "1.4"/>
			<comment>provider</comment>
		</assertion>
		<assertion required = "true" impl-spec = "false" defined-by = "technology" status = "active" testable = "true">
			<id>6</id>
			<description>A permission corresponding to a resource must identify the context
   of the resource's use such that different policy can be applied to
   a resource used in different contexts (that is, applications or
   instances of an application).</description>
			<location chapter = "1" section = "1.4"/>
			<comment>provider</comment>
		</assertion>
		<assertion required = "true" impl-spec = "false" defined-by = "technology" status = "active" testable = "true">
			<id>7</id>
			<description>In the case of Servlet resources, the provider must be able to
   associate a distinct policy context with each context root
   (including context roots created to support virtual hosting)
   hosted by the server.</description>
			<location chapter = "1" section = "1.4"/>
			<comment>provider</comment>
		</assertion>
		<assertion required = "true" impl-spec = "false" defined-by = "technology" status = "active" testable = "true">
			<id>8</id>
			<description>In protecting Servlet resources, a provider must select the
   constraints that apply to a resource by implementing a best
   match  semantic, where the applicable constraints are selected by
   applying the Servlet matching rules.</description>
			<location chapter = "1" section = "1.4"/>
			<comment>provider</comment>
		</assertion>
		<assertion required = "true" impl-spec = "false" defined-by = "technology" status = "active" testable = "false">
			<id>9</id>
			<description>To allow for the differentiation of sessions of the same subject,
   every Servlet container must include a session identifier as a
   principal within the subject corresponding to the access control
   context. The session identifier need not be related to any specific
   Servlet representation of session.</description>
			<location chapter = "1" section = "1.4"/>
			<comment>container</comment>
		</assertion>
		<assertion required = "true" impl-spec = "false" defined-by = "technology" status = "active" testable = "true">
			<id>10</id>
			<description>To support this contract in a Servlet (2.3) environment, a
   container or its deploy tools must create policy statements as
   necessary to support Servlet's default role-ref semantic.</description>
			<location chapter = "1" section = "1.4"/>
			<comment>container</comment>
		</assertion>
		<assertion required = "true" impl-spec = "false" defined-by = "technology" status = "active" testable = "true">
			<id>11</id>
			<description>A provider must include an implementation of a utility class,
   jakarta.security.jacc.PolicyConfigurationFactory, for container
   deploy tools to use to create and locate instances of a class
   within the provider that implements the PolicyConfiguration
   interface.</description>
			<location chapter = "2" section = "2.3"/>
			<comment>provider</comment>
		</assertion>
		<assertion required = "true" impl-spec = "false" defined-by = "technology" status = "active" testable = "true">
			<id>12</id>
			<description>For a container to avail itself of the authorization functionality
   defined in this contract, it must be provided with implementations
   of the Permission classes in the jakarta.security.jacc package.
   These classes are:
       EJBMethodPermission
       EJBRoleRefPermission
      WebResourcePermission
      WebRoleRefPermission
      WebUserDataPermission</description>
			<location chapter = "2" section = "2.4"/>
			<comment>container</comment>
		</assertion>
		<assertion required = "true" impl-spec = "true" defined-by = "technology" status = "active" testable = "false">
			<id>13</id>
			<description>The container deploy tools must also be provided with an
   implementation ofthe jakarta.security.jacc.PolicyConfigurationFactory
   class along with a matched implementation of a class that
   implements the jakarta.security.jacc.PolicyConfiguration interface.</description>
			<location chapter = "2" section = "2.4"/>
			<comment>tools</comment>
		</assertion>
		<assertion required = "true" impl-spec = "false" defined-by = "technology" status = "active" testable = "true">
			<id>14</id>
			<description>If the container is running a Java 1.3 security environment, then it
   must be provided with the implementation of a class the extends the
   abstract class
   jakarta.security.auth.Policy. If the container is running a Java 1.4
   security environment, then it must also be provided with the
   implementation of a class that extends the abstract class,
   java.security.Policy.</description>
			<location chapter = "2" section = "2.4"/>
			<comment>container</comment>
		</assertion>
		<assertion required = "true" impl-spec = "false" defined-by = "technology" status = "active" testable = "false">
			<id>15</id>
			<description>In each of these cases, the Permission implementation classes made
   available to the container must be compatible with the Policy
   implementation class, and the Policy implementation classes must be
   compatible with the class that implements
   the PolicyConfiguration interface.</description>
			<location chapter = "2" section = "2.4"/>
			<comment>provider</comment>
		</assertion>
		<assertion required = "true" impl-spec = "true" defined-by = "technology" status = "active" testable = "false">
			<id>16</id>
			<description>The Policy objects whose methods are invoked by the container must
   assume responsibility for answering all Policy questions, which may
   be accomplished by delegating non jakarta.security.jacc policy
   decisions to some other Policy object. </description>
			<location chapter = "2" section = "2.4"/>
			<comment>provider</comment>
		</assertion>
		<assertion required = "true" impl-spec = "true" defined-by = "technology" status = "active" testable = "false">
			<id>17</id>
			<description>For each VM of the application server, if the system property
  jacc.auth.policy.provider  is defined, the application server must
   construct an instance of the class identified by the system 
   property, confirm that the resulting object is an instance of
   jakarta.security.auth.Policy, and set, using 
   jakarta.security.auth.Policy.setPolicy(), the resulting
   object as the corresponding Policy object used by the VM.

   If the system property jacc.policy.provider  is defined, an
   application server running a 1.4 VM must use an analogous method to
   construct an instance of the class identified by the system
   property, confirm that the resulting object is an instance of 
   java.security.Policy, and set, using
   java.security.Policy.setPolicy(), the resulting object as the
   corresponding Policy object used by the VM.</description>
			<location chapter = "2" section = "2.5"/>
			<comment>container</comment>
		</assertion>
		<assertion required = "true" impl-spec = "true" defined-by = "technology" status = "active" testable = "false">
			<id>18</id>
			<description>Once an application server has used either of the jacc policy system
   properites to replace a Policy object used by a VM, the application
   server must not use setPolicy() to replace the corresponding Policy
   object of the running VM again.</description>
			<location chapter = "2" section = "2.5"/>
			<comment>container</comment>
		</assertion>
		<assertion required = "true" impl-spec = "true" defined-by = "technology" status = "active" testable = "false">
			<id>19</id>
			<description>The deploy tools must translate the declarative authorization policy
   statements derived from application or module deployment 
   descriptor(s) into instances of the corrresponding
   jakarta.security.jacc Permission classes.</description>
			<location chapter = "3" section = "3.1"/>
			<comment>tools</comment>
		</assertion>
		<assertion required = "true" impl-spec = "true" defined-by = "technology" status = "active" testable = "false">
			<id>20</id>
			<description>The deploy tools must use the methods of the PolicyConfiguration
   interface to cause authorization policy contexts containing policy
   statements corresponding to the permissions resulting from the
   translation to be created within the Policy objects used by the
   containers to which the components of the application or
   module are deployed.</description>
			<location chapter = "3" section = "3.1"/>
			<comment>tools</comment>
		</assertion>
		<assertion required = "true" impl-spec = "true" defined-by = "technology" status = "active" testable = "false">
			<id>21</id>
			<description>Independent of this specification, J2EE deploy tools must translate
   and complete the declarative policy statements appearing in 
   deployment descriptors into a form suitable for securing
   applications on the platform. </description>
			<location chapter = "3" section = "3.1"/>
			<comment>tools</comment>
		</assertion>
		<assertion required = "true" impl-spec = "false" defined-by = "technology" status = "active" testable = "false">
			<id>22</id>
			<description>The resulting policy statements may differ in form from the policy
   statements appearing in the deployment descriptors. The policy
   translation defined by this subcontract is described assuming that
   the policy statement form used by a platform is identical to that
   used to express policy in the deployment descriptors.

   Where this is not the case, the output of the translation must be
   equivalent to the translation that would occur if policy was
   completely specified in the deployment descriptors and the
   translation had proceeded directly from the deployment descriptors
   to the J2SE policy forms defined by this subcontract.</description>
			<location chapter = "3" section = "3.1"/>
			<comment>provider</comment>
		</assertion>
		<assertion required = "true" impl-spec = "false" defined-by = "technology" status = "active" testable = "true">
			<id>23</id>
			<description>It must be possible to define separate authorization policy contexts
   corresponding to each deployed instance of a J2EE module.</description>
			<location chapter = "3" section = "3.1.1"/>
			<comment>provider</comment>
		</assertion>
		<assertion required = "true" impl-spec = "false" defined-by = "technology" status = "active" testable = "true">
			<id>24</id>
			<description>This specification requires that the names of checked permissions
   be sufficient to identify (that is, carry the identifier of) the
   authorization policy context in which the evaluation is to be
   performed. 

   This specification also requires that all permission objects in 
   the policy statements of a policy context include the identifier of
   the policy context in their name.</description>
			<location chapter = "3" section = "3.1.1"/>
			<comment>provider</comment>
		</assertion>
		<assertion required = "true" impl-spec = "false" defined-by = "technology" status = "active" testable = "true">
			<id>25</id>
			<description>A servlet container is responsible for mapping the target name or
   address information of an HTTP request to the appropriate hostname.</description>
			<location chapter = "3" section = "3.1.1.1"/>
			<comment>container</comment>
		</assertion>
		<assertion required = "true" impl-spec = "false" defined-by = "technology" status = "active" testable = "true">
			<id>26</id>
			<description>In the J2EE security model, principal-to-role mappings have
   application scope, that is, the same principal-to-role mappings
   must apply in the access decisions applied at all of the modules
   (that may represent separate policy contexts) that comprise an
   application. 

    Same application policy contexts shall be associated by calling the 
    PolicyConfiguration.link() method. This method shall create a
    transitive and symetric relationship within the provider and 
    between this PolicyConfiguration and the argument
    PolicyConfiguration, such that they and all PolicyConfigurations
    otherwise linked to either of them shall share the same
    principal-to-role mappings. 

   The semantics of the association shall preserve the invariant that
   at most one principal-to-role mapping shall apply to any
   PolicyConfiguration.</description>
			<location chapter = "3" section = "3.1.1.2"/>
			<comment>provider</comment>
		</assertion>
		<assertion required = "true" impl-spec = "false" defined-by = "technology" status = "active" testable = "true">
			<id>27</id>
			<description>A reference to a PolicyConfiguration object shall be obtained by
   calling the getPolicyConfiguration method on the
   PolicyConfigurationFactory class.</description>
			<location chapter = "3" section = "3.1.2"/>
			<comment>provider</comment>
		</assertion>
		<assertion required = "true" impl-spec = "false" defined-by = "technology" status = "active" testable = "true">
			<id>28</id>
			<description>The policy context identifier used in the call to
   getPolicyConfiguration, shall be the string composed from the
   hostname corresponding to the target container, and the
   context path corresponding to the application as described in
   Servlet Policy Context Identifiers  on page 14.</description>
			<location chapter = "3" section = "3.1.2"/>
			<comment>provider</comment>
		</assertion>
		<assertion required = "true" impl-spec = "false" defined-by = "technology" status = "active" testable = "false">
			<id>29</id>
			<description>For each auth-constraint element appearing in the deployment
   descriptor, a WebResourcePermission shall be instantiated for each
   element in the cross-product of url-pattern (in the associated web-
   resource-collection)and role-name appearing in the constraint. 

   If the reserved role-name, * occurs as a role-name in the
   constraint, the cross product shall be computed using all the roles
   defined in the web application. </description>
			<location chapter = "3" section = "3.1.2"/>
			<comment>provider</comment>
		</assertion>
		<assertion required = "true" impl-spec = "false" defined-by = "technology" status = "active" testable = "false">
			<id>30</id>
			<description>The policy context identifier used in the call to getPolicyContext
   shall be combined with the url-pattern from the web-resource-
   collection to define the name used in the construction of the
   WebResourcePermission objects.</description>
			<location chapter = "3" section = "3.1.2"/>
			<comment>provider</comment>
		</assertion>
		<assertion required = "true" impl-spec = "false" defined-by = "technology" status = "active" testable = "true">
			<id>31</id>
			<description>The HTTP methods from the auth-constraint shall be used to define
   the actions used in the permission construction.</description>
			<location chapter = "3" section = "3.1.2"/>
			<comment>provider</comment>
		</assertion>
		<assertion required = "true" impl-spec = "false" defined-by = "technology" status = "active" testable = "true">
			<id>32</id>
			<description>The WebResourcePermission instantiated for each security role to
   which access to a url-pattern is to be granted, shall be added to
   the corresponding role by calling the addToRole method on the
   PolicyConfiguration object.

   If no role name appears in an auth-constraint, a 
   WebResourcePermission object shall be instantiated for each url-
   pattern in the auth-constraint and added to the excluded policy
   statements by calling addToExcludedPolicy on the corresponding
   PolicyConfiguration object.

   For each url-pattern of each userdata-constraint appearing in the
   deployment descriptor, a WebUserDataPermission shall be 
   instantiated. 

   The name used in the construction of the permission shall be
   obtained according to the fashion described for 
   WebResourcePermission objects.

   The actions used in the construction of a WebuserDataPermission
   is obtained by combining the HTTP methods associated with the
   userdata-constraint, and then appending to it a representation of
   the unacceptable transport guarantees.

   (The mapping of deployment descriptor transport-guarantee to
    unacceptable transport guarantee is defined in Table 3-1 on page
    16.)

    In there are no other transport guarantees in the constraint, then
    the url-patterns and methods identified in the constraint are 
    unconstrained (that is, there are no unacceptable transport 
    guarantees) and the value "UNCONSTRAINED" shall be appended to the
    actions used in the construction.</description>
			<location chapter = "3" section = "3.1.2"/>
			<comment>provider</comment>
		</assertion>
		<assertion required = "true" impl-spec = "false" defined-by = "technology" status = "active" testable = "true">
			<id>33</id>
			<description>For each security-role-ref appearing in the deployment descriptor a
   corresponding WebRoleRefPermission shall be created. The name used
   in the construction of each WebRoleRefPermission shall be composed
   of the policy context identifier (used in the call to
   getPolicyConfiguration and shared with the
   trranslation of security-constraint elements of the same deployment
   descriptor)followed by the servlet-name in whose context the
   security-role-reference is defined. The actions used to construct
   the permission shall be the value of the role-name (that is the
   reference), appearing in the security-role-ref. 
                       </description>
			<location chapter = "3" section = "3.1.3"/>
			<comment>provider</comment>                 
		</assertion>         
		<assertion required = "true" impl-spec = "false" defined-by = "technology" status = "active" testable = "true">
			<id/>
			<description>   The deploy tools shall call the addToRole method on the
   PolicyConfiguration object to add the WebRoleRefPermission object
   resulting from the translation to the roleName identified in the
   role-link appearing in the security-role-ref.

   For each servlet element in the deployment descriptor a
   WebRoleRefPermission shall be created for each security-role whose
   name does not appear as the role-name in a security-role-ref within
   the servlet element. Each such WebRoleRefPermission
   shall be created with action (that is, reference) corresponding to
   the role-name and added to the role with the same name (as the
   reference) by calling the addToRole method on the
   PolicyConfiguration object.</description>
			<location chapter = "3" section = "3.1.3"/>
			<comment>tools</comment>
		</assertion>
		<assertion required = "true" impl-spec = "false" defined-by = "technology" status = "active" testable = "true">
			<id>34</id>
			<description>A reference to a PolicyConfiguration object shall be obtained by
   calling the getPolicyConfiguration method on the
   PolicyConfigurationFactory class. The policy context identifier used
   in the call to getPolicyConfiguration shall be a string selected by
   the container to identify the deployment of the EJB jar in the
   context of an application. </description>
			<location chapter = "3" section = "3.1.4"/>
			<comment>provider</comment>
		</assertion>
		<assertion required = "true" impl-spec = "false" defined-by = "technology" status = "active" testable = "true">
			<id>35</id>
			<description>An EJBMethodPermission object shall be created for each method-
   permission element appearing in the deployment descriptor. The name
   of each EJBMethodPermission shall be obtained by combining the
   policy context identifier used in the call to getPolicyConfiguration
   with the ejb-name as defined in the method element of the method-
   permission element. 

   The actions used in the permission construction shall be obtained by
   translating the contents of the method element into a method
   specification according to the methSpec syntax defined in the
   documentation of the EJBMethodPermission class.
 </description>
			<location chapter = "3" section = "3.1.4"/>
			<comment>provider</comment>
		</assertion>
		<assertion required = "true" impl-spec = "false" defined-by = "technology" status = "active" testable = "true">
			<id>36</id>
			<description>If the method-permission element contains the unchecked element,
   then the deploy tools shall create an unchecked policy statement
   corresponding to the derived EJBMethodPermission by calling the
   addToUncheckedPolicy method on the PolicyConfiguration object. 
  
   Alternatively, if the method-permission element contains 1 or more
   role-name elements, then the deploy tools shall create policy
   statements associating the derived EJBMethodPermission with each of
   the role-names contained in the method-permission element. Deploy
   tools shall call the addToRole method to create these policy
   statements.</description>
			<location chapter = "3" section = "3.1.4"/>
			<comment>tools</comment>
		</assertion>
		<assertion required = "true" impl-spec = "false" defined-by = "technology" status = "active" testable = "true">
			<id>37</id>
			<description>An EJBMethodPermission object shall be created for each method
   element occuring in the exclude-list element of the deployment
   descriptor. The name and actions of each EJBMethodPermission shall
   be obtained as described for non-excluded EJBMethodPermission
   objects. The policy context identifier embedded in the names and the
   target PolicyConfiguration object shall be that of the
   PolicyConfiguration object used in the translation of the non-
   excluded method-permission elements of the module.
              </description>
			<location chapter = "3" section = "3.1.5"/>                
			<comment>provider</comment>
		</assertion>
		<assertion required = "true" impl-spec = "false" defined-by = "technology" status = "active" testable = "true">
			<id/>
			<description> The deploy tools shall call the addToExcludedPolicy method on the
   PolicyConfiguration object to create excluded policy statements in
   the provider corresponding to the permissons derived from the
   exclude-list.</description>
			<location chapter = "3" section = "3.1.5"/>
			<comment>tools</comment>
		</assertion>
		<assertion required = "true" impl-spec = "false" defined-by = "technology" status = "active" testable = "true">
			<id>38</id>
			<description>For each security-role-ref appearing in the deployment descriptor a
   corresponding EJBRoleRefPermission shall be created.

   The policy context identifier embedded in the names and the target
   PolicyConfiguration object shall be that of the PolicyConfiguration
   object used in the translation of the method-permission elements of
   the module. The actions used to construct the permission shall be
   the value of the role-name (that is the reference), appearing in the
   security-role-ref. 
                       </description>
			<location chapter = "3" section = "3.1.6"/>
			<comment>provider</comment>
		</assertion>
		<assertion required = "true" impl-spec = "false" defined-by = "technology" status = "active" testable = "true">       
			<id/>
			<description>The deploy tools shall call the addToRole method on the
   PolicyConfiguration object to add a policy statement corresponding
   to the EJBRoleRefPermission to the role identified in the role-link
   appearing in the security-role-ref.</description>
			<location chapter = "3" section = "3.1.6"/>
			<comment>tools</comment>
		</assertion>
		<assertion required = "true" impl-spec = "false" defined-by = "technology" status = "active" testable = "false">
			<id>39</id>
			<description>The server's deploy tools must translate the declarative
   authorization policy appearing in the application or module
   deployment descriptor(s) into policy statements within the Policy
   objects used by the containers to which the components of the]
   application or module are being deployed.</description>
			<location chapter = "3" section = "3.1.7"/>
			<comment>tools</comment>
		</assertion>
		<assertion required = "true" impl-spec = "false" defined-by = "technology" status = "active" testable = "false">
			<id>40</id>
			<description>When a module is deployed, it shall be linked to the
   PolicyConfiguration object of any other module with which it must
   share the same principal-to-role mapping. 

   When an application is deployed, the PolicyConfiguration objects
   corresponding to all the modules of the application must be linked.
   PolicyConfigurations are linked by calling the linkConfiguration
   method of the PolicyConfiguration interface.</description>
			<location chapter = "3" section = "3.1.7"/>
			<comment>provider</comment>
		</assertion>
		<assertion required = "true" impl-spec = "false" defined-by = "technology" status = "active" testable = "false">
			<id>41</id>
			<description>Once the translation is complete, a call must be made to
   Policy.refresh() on the Policy object used by each of the containers
   to which the application or module is being deployed. The calls to
   Policy.refresh() must occur before the containers will accept
   requests for the deployed resources, but may be deffered until after
   principal-to-role mapping.</description>
			<location chapter = "3" section = "3.1.7"/>
			<comment>container</comment>
		</assertion>
		<assertion required = "true" impl-spec = "false" defined-by = "technology" status = "active" testable = "false">
			<id>42</id>
			<description>The policy context identifiers corresponding to the deployed
   application or module must be recorded in the application server so
   that they can be used to create permissions for use in the Policy
   Decision Subcontract, and such that the deployer may subsequently
   remove or modify the corresponding policy configuration as a result
   of the undeployment or redeployment of the application.
  </description>
			<location chapter = "3" section = "3.1.7"/>
			<comment>container</comment>
		</assertion>
		<assertion required = "true" impl-spec = "false" defined-by = "technology" status = "active" testable = "false">
			<id>43</id>
			<description>When undeploying an application or module, the deploy tools shall
   call the delete method on the PolicyConfiguration objects associated
   with the modules of the application and associated with the provider
   of each container to which one or more modules of the application
   have been deployed.</description>
			<location chapter = "3" section = "3.1.8"/>
			<comment>tools</comment>
		</assertion>
		<assertion required = "true" impl-spec = "false" defined-by = "technology" status = "active" testable = "false">
			<id>44</id>
			<description>To ensure that there is not a period during undeployment when the
   removal of policy statements on application components renders what
   were protected components unprotected, the application server must
   stop accepting requests for the application's components before the
   policy statements are deleted. 

   After the policy statements are removed a call shall be made to
   Policy.refresh() on the Policy object used by each of the containers
   from which at least one module of the application was undeployed.</description>
			<location chapter = "3" section = "3.1.8"/>
			<comment>container</comment>
		</assertion>
		<assertion required = "false" impl-spec = "false" defined-by = "technology" status = "active" testable = "false">
			<id>45</id>
			<description>Containers are not required to deploy to an existing policy
   configuration. Containers that chose to provide this functionality
   must satisfy the following requirements. 
 
   An application or module shall be associated with an existing set
   of linked policy configurations by using the policy context
   identifiers of the PolicyConfiguration objects of the existing
   policy configuration in the permissions used in the Policy Decision
   Subcontract.</description>
			<location chapter = "3" section = "3.1.9"/>
			<comment>container</comment>
		</assertion>
		<assertion required = "false" impl-spec = "false" defined-by = "technology" status = "active" testable = "false">
			<id>46</id>
			<description>Containers are not required to implement redeployment functionality.
   Containers that chose to provide this functionality must satisfy the
   following requirements.

   To ensure redeployment does not create a situation where the removal
   of policy statements on application components renders what were
   protected components unprotected, the application server must stop
   accepting requests for the application's components before 
   redeployment begins.
               </description>
			<location chapter = "3" section = "3.1.10"/>
			<comment>container</comment>
		</assertion>
		<assertion required = "false" impl-spec = "false" defined-by = "technology" status = "active" testable = "false">
			<id/>
			<description>   To redeploy a module, the deploy tools shall call the delete method
   on the module's PolicyConfiguration object in the provider
   associated with each of the containers to which the module has been
   deployed. 

   The deploy tools shall translate the declarative authorization
   policy appearing in the module's deployment descriptor into a
   PolicyConfiguration object (that may or may not have the same policy
   context identifier as the deleted objects). The translation shall
   include linking the new PolicyConfiguration module to any other
   modules with which the module must share its principal-to-role
   mappings.

   After the translation and reconfiguration of policy is complete a
   call must be made to Policy.refresh() on the Policy object used by
   each of the containers to which the module has been redeployed.</description>
			<location chapter = "3" section = "3.1.10"/>
			<comment>tools</comment>
		</assertion>
		<assertion required = "true" impl-spec = "false" defined-by = "technology" status = "active" testable = "false">
			<id>47</id>
			<description>In addition to providing a PolicyConfiguration interface for
   integration with the application server's deploy tools, the provider
   must also include a management interface for policy administrators
   to use to grant the collections of permissions that comprise roles,
   to principals.</description>
			<location chapter = "3" section = "3.2"/>
			<comment>provider</comment>
		</assertion>
		<assertion required = "true" impl-spec = "false" defined-by = "technology" status = "active" testable = "true">
			<id>48</id>
			<description>The provider must ensure that all of the permissions added to a role
   in a policy configuration context are granted to any principal 
   mapped to the role by the policy administrator. The provider must
   ensure that the same principal-to-role mappings are applied to all
   linked policy configuration contexts.</description>
			<location chapter = "3" section = "3.2"/>
			<comment>provider</comment>
		</assertion>
		<assertion required = "true" impl-spec = "false" defined-by = "technology" status = "active" testable = "true">
			<id>49</id>
			<description>The provider must ensure that excluded policy statements take 
   precedence over overlapping unchecked policy statements, and that
   both excluded and unchecked policy statements take precedence over
   overlapping role based policy statements.</description>
			<location chapter = "3" section = "3.2"/>
			<comment>provider</comment>
		</assertion>
		<assertion required = "true" impl-spec = "false" defined-by = "technology" status = "active" testable = "false">
			<id>50</id>
			<description>A container must rely on the java.security.Policy and or
   jakarta.security.auth.Policy objects of the VM (available via
   java.security.Policy.getPolicy(), and
   jakarta.security.auth.getPolicy() respectively) for all of the policy
   decisions defined by this contract.</description>
			<location chapter = "4" section = "4.1"/>
			<comment>container</comment>
		</assertion>
		<assertion required = "true" impl-spec = "false" defined-by = "technology" status = "active" testable = "false">
			<id>51</id>
			<description>If a container employs a custom SecurityManager, the necessary
   reliance on the Policy objects of the VM may be accomplished by
   ensuring that the custom SecurityManager relies on the Policy object
   of the VM for all of its policy decisions defined by this contract.</description>
			<location chapter = "4" section = "4.1"/>
			<comment>container</comment>
		</assertion>
		<assertion required = "true" impl-spec = "false" defined-by = "technology" status = "active" testable = "true">
			<id>52</id>
			<description>Servlet containers shall enforce the authorization policies
   established for web resources as a result of the deployment of
   application modules containing web resources.</description>
			<location chapter = "4" section = "4.1"/>
			<comment>container</comment>
		</assertion>
		<assertion required = "true" impl-spec = "false" defined-by = "technology" status = "active" testable = "true">
			<id>53</id>
			<description>The Servlet container shall construct (or reuse) a 
   WebUserDataPermission object identifying the target resource in the
   authorization policy context and with action composed from the HTTP
   method of the request and transport guarantees corresponding to the
   properties of the connection on which the request arrived.</description>
			<location chapter = "4" section = "4.1.1"/>
			<comment>container</comment>
		</assertion>
		<assertion required = "true" impl-spec = "false" defined-by = "technology" status = "active" testable = "true">
			<id>54</id>
			<description>The Servlet container shall use one of the methods described in
   Section 4.5,
    Determining if a Permission is Excluded  to determine if access to
   the resource under the transport guarantee encapsulated in the
   WebUserDataPermission has been excluded. 

   If access to the resource has been excluded the request shall be
   redirected as defined by the Servlet Specification. If access to the
   resource has not been excluded, the request shall be subjected to a
   pre-dispatch decision.</description>
			<location chapter = "4" section = "4.1.1"/>
			<comment>container</comment>
		</assertion>
		<assertion required = "true" impl-spec = "false" defined-by = "technology" status = "active" testable = "true">
			<id>55</id>
			<description>The Servlet container shall construct (or reuse) a
   WebResourcePermission object corresponding to the target resource in
   the authorization policy context and with action composed from the
   HTTP method of the request. The Servlet container shall use one of
   the methods described in Section 4.6, 
    Checking if a Caller has been Granted a Permission" to determine if
   the WebResourcePermission has been granted to the caller. If a 
   security exception is thrown in the permission determination, it
   shall be caught, and the result of the determination shall be that
   the permission is not granted to the caller. The Servlet container
   shall only dispatch the request to the web resource, if the
   WebResourcePermission is determined to be granted to the caller.
   Otherwise the request shall be rejected with the appropriate HTTP
   error message.</description>
			<location chapter = "4" section = "4.1.2"/>
			<comment>container</comment>
		</assertion>
		<assertion required = "true" impl-spec = "false" defined-by = "technology" status = "active" testable = "false">
			<id>56</id>
			<description>Prior to dispatching a call to a web resource, the container shall
   associate an AccessControlContext containing the principals of the
   authorized caller with the call thread.</description>
			<location chapter = "4" section = "4.1.2"/>
			<comment>container</comment>
		</assertion>
		<assertion required = "true" impl-spec = "false" defined-by = "technology" status = "active" testable = "true">
			<id>57</id>
			<description>When a call is made from a web resource to isUserInRole(String
   roleName) the implementation of this method shall construct (or
   reuse) a WebRoleRefPermission object identifying the component
   context of the embedded privilege evaluation (that is, the web
   resource and role reference) in the corresponding authorization
   policy context. The implementation of the isUserInRole method shall
   then use one of the methods described in Section 4.6,
    Checking if a Caller has been Granted a Permission  to determine
   if the WebRoleRefPermission has been granted to the caller. If a
   security exception is thrown in the permission determination, it
   shall be caught, and the result of the determination shall be that
   the permission is not granted to the caller. If it is determined
   that the WebRoleRefPermission has been granted to the caller,
   isUserInRole shall return true. Otherwise the return value shall be
   false.</description>
			<location chapter = "4" section = "4.1.3"/>
			<comment>provider</comment>
		</assertion>
		<assertion required = "true" impl-spec = "false" defined-by = "technology" status = "active" testable = "true">
			<id>58</id>
			<description>Constraints shall be matched (using the servlet matching rules) on
   url-pattern first. 

   All constraints (in the policy configuration identified in the name
   of the checked permission) with the best (according to the servlet
   matching rules) matching url-pattern (to the url-pattern in the name
   of the checked permission), shall be tested to see if any of them
   constrain an action of the checked permission.

   If none do, the request shall be permitted. If one or more constrain
   an action of the checked permission, the set of actions in the
   checked permission shall be reduced to the set that are constrained,
   and then Policy shall be evaluated to determine if one or more
   permissions which "satisfy" the url-pattern of the constraining
   permissions, and which when taken together confer all of the actions
   determined to be constrained have been granted to the invocation
   context.</description>
			<location chapter = "4" section = "4.2.1"/>
			<comment>provider</comment>
		</assertion>
		<assertion required = "true" impl-spec = "false" defined-by = "technology" status = "active" testable = "true">
			<id>59</id>
			<description>The url-pattern in the name of a satisfying granted permission must
   be a better than or equal match (according to the servlet matching
   rules) to the url-pattern of the best matching constraints, and its
   url-pattern must also match the url-pattern in the name of the
   checked permission. A granted permission whose url-pattern is equal
   to the url-pattern in the names of the best matching constraints is
   one example of a satisfying granted permission.</description>
			<location chapter = "4" section = "4.2.1"/>
			<comment>provider</comment>
		</assertion>
		<assertion required = "true" impl-spec = "false" defined-by = "technology" status = "active" testable = "true">
			<id>60</id>
			<description>The best matching user-data-constraint shall be determined
   independent of the best-matching auth-constraint.</description>
			<location chapter = "4" section = "4.2.1"/>
			<comment>provider</comment>
		</assertion>
		<assertion required = "true" impl-spec = "false" defined-by = "technology" status = "active" testable = "true">
			<id>61</id>
			<description>URL pattern matching shall be be guided by pattern type such that exact patterns
(those not ending with * or /, or beginning with *.) shall match better than
path prefix patterns (those ending with /*) and such that path prefix patterns
shall match better than extension patterns (those beginning with *.), and such
that extension patterns shall match better than the universal pattern /. Within
each pattern type, longer string length patterns shall match better than shorter
patterns.</description>
			<location chapter = "4" section = "4.2.2"/>
			<comment>provider</comment>
		</assertion>
		<assertion required = "true" impl-spec = "false" defined-by = "technology" status = "active" testable = "true">
			<id>62</id>
			<description>EJB containers shall enforce the authorization policies established
   for EJB resources as a result of the deployment of application
   modules containing EJB resources. </description>
			<location chapter = "4" section = "4.3"/>
			<comment>container</comment>
		</assertion>
		<assertion required = "true" impl-spec = "false" defined-by = "technology" status = "active" testable = "false">
			<id>63</id>
			<description>The EJB container shall construct (or reuse) a EJBMethodPermission
   with name constructed from the authorization policy context
   identifier corresponding to the deployed instance of the module
   containing the target resource and the ejb-name of the target
   resource. The actions used in the permission construction shall
   completely specify the method of the EJB by identifing the method
   interface, method name, and method signature as defined for a
   methodSpec in the documentation of the EJBMethodPermission class.</description>
			<location chapter = "4" section = "4.3.1"/>
			<comment>container</comment>
		</assertion>
		<assertion required = "false" impl-spec = "false" defined-by = "technology" status = "active" testable = "true">
			<id>64</id>
			<description>EJBMethodPermission may optionally include copies of the arguments
   of the proposed invocation, and in the case of an Entity Bean it may
   also optionally include a reference to the target EntityBean.</description>
			<location chapter = "4" section = "4.3.1"/>
			<comment>provider</comment>
		</assertion>
		<assertion required = "true" impl-spec = "false" defined-by = "technology" status = "active" testable = "true">
			<id>65</id>
			<description>The EJB container shall use one of the methods described in 
   Section 4.6,
    Checking if a Caller has been Granted a Permission  to determine
   if the EJBMethodPermission has been granted to the caller. If a
   security exception is thrown in the permission determination, it
   shall be caught, and the result of the determination shall be that
   the permission is not granted to the caller. The EJB container shall
   only dispatch the request to the EJB resource, if the
   EJBMethodPermission is determined to be granted to the caller.
   Otherwise the request shall be rejected with the appropriate RMI
   security exception, as defined by the EJB specification.</description>
			<location chapter = "4" section = "4.3.1"/>
			<comment>container</comment>
		</assertion>
		<assertion required = "true" impl-spec = "false" defined-by = "technology" status = "active" testable = "false">
			<id>66</id>
			<description>  Prior to dispatching a call to an EJB, the container shall
    associate an AccessControlContext containing the principals of the
    authorized caller with the call thread</description>
			<location chapter = "4" section = "4.3.1"/>
			<comment>container</comment>
		</assertion>
		<assertion required = "true" impl-spec = "false" defined-by = "technology" status = "active" testable = "true">
			<id>67</id>
			<description>When an EJB makes a call to isCallerInRole(String roleName) the
   implementation of this method shall construct (or reuse) an
   EJBRoleRefPermission identifying the component context of the
   embedded privilege evaluation (that is, the EJB and role reference)
   in the corresponding authorization policy context. The
   implementation of the isCallerInRole method shall then use one of
   the methods described in Section 4.6, 
    Checking if a Caller has been Granted a Permission,  to determine
   if the EJBRoleRefPermission has been granted to the caller. If a
   security exception is thrown in the permission determination, it
   shall be caught, and the result of the determination shall be that
   the permission is not granted to the caller. If it is determined
   that the EJBRoleRefPermission has been granted to the caller, then
   isCallerInRole shall return true. Otherwise the return value shall
   be false.</description>
			<location chapter = "4" section = "4.3.2"/>
			<comment>provider</comment>
		</assertion>
		<assertion required = "true" impl-spec = "false" defined-by = "technology" status = "active" testable = "true">
			<id>68</id>
			<description>The policy statements of the policy configuration identified in the
   name of the checked permission shall be tested to determine if they
   match the permission being evaluated. If one or more excluded policy
   statements match the checked permission, the evaluation may
   terminate and, independent of subject, the checked permission shall
   be determined not to be accorded. Otherwise, if one or more
   unchecked policy statements match the checked permission, the
   checked permission shall be determined to be accorded independent of
   subject. If neither of the excluded or unchecked comparisons yield a
   match, then the subject shall only be determined to have been
   accorded the checked permission if a permission corresponding to a
   matching role-based policy statement is determined to have been
   granted to the subject.</description>
			<location chapter = "4" section = "4.4.1"/>
			<comment>provider</comment>
		</assertion>
		<assertion required = "true" impl-spec = "false" defined-by = "technology" status = "active" testable = "true">
			<id>69</id>
			<description>A granted EJBMethodPermission matches a checked EJBMethodPermission
   if their names are equivalent, and if the method specification in
   the actions of the granted permission matches the method
   specification in the actions of the checked permission (as described
   in the definition of the EJBMethodPermission class).

   One or more granted EJBRoleRefPermission objects match a checked
   EJBRoleRefPermission if their names are equivalent to the name of
   the checked permission and if the actions of the granted permissions
   together contain all of the role references in the actions of the
   checked permission.</description>
			<location chapter = "4" section = "4.4.2"/>
			<comment>provider</comment>
		</assertion>
		<assertion required = "true" impl-spec = "false" defined-by = "technology" status = "active" testable = "false">
			<id>70</id>
			<description>The policy statements corresponding to WebUserDataPermission objects
   are represented as excluded policy statements. The techniques that
   shall be used to determine if a WebUserDataPermission is excluded
   are described below

   a)The container shall call AccessControlContext.checkPermission with
   the WebUserDataPermission as argument. The call to checkPermission
   may be made on any AccessControlContext. If checkPermission throws
   an access exception, the WebUserDataPermission is excluded.
   Otherwise the permission is not excluded.

   b)The container shall call SecurityManager.checkPermission with the
   WebUserDataPermission as argument. If checkPermission throws an
   access exception, the WebUserDataPermission is excluded. Otherwise
   the permission is not excluded.
     
   A container that relies on a jakarta.security.auth.Policy provider may
   also use the following technique to determine if 
   WebUserDataPermission is excluded.

   a)The container shall call 
   jakarta.security.auth.Policy.getPermissions() to determine
   the collection of permissions granted independent of Subject.
   To do this, the Subject in the call to getPermissions may be null.
   If getPermission returns an empty PermissionCollection, or if the
   returned PermissionCollection does not imply the
   WebUserDataPermission being tested, then the permission is excluded.

   A container that relies on a J2SE 1.4 java.security.Policy provider
   may also use the following techniques to determine if a
   WebUserDataPermission is excluded.

   The container shall call Policy.implies with two arguments; the
   WebUserDataPermission, and an argument ProtectionDomain that was
   constructed without static permissions and that need not be
   constructed with principals. The boolean result returned by
   policy.implies shall indicate whether or not the permission is
   excluded.</description>
			<location chapter = "4" section = "4.5"/>
			<comment>container</comment>
		</assertion>
		<assertion required = "true" impl-spec = "false" defined-by = "technology" status = "active" testable = "false">
			<id>71</id>
			<description>A container shall determine if a caller has been granted a
   permission by evaluating the permission in an AccessControlContext
   or ProtectionDomain containing the principals of the Subject
   correponding to the caller.

   Independent of whether a container employs a
   jakarta.security.auth.Policy or a J2SE 1.4 java.security.Policy
   provider for its authorization decisions it may use one of the
   following techniques to determine if a permission has been granted
   to the caller.

   a)The container shall call AccessControlContext.checkPermission with
   the permission as argument. The call to checkPermission must be made
   on an AccessControlContext containing the principals of the Subject
   corresponding to the caller. If checkPermission throws an access
   exception, the permission is not granted to the caller. Otherwise
   the permission is granted.
    
   b)The container shall call SecurityManager.checkPermission with the
   permission as argument and using the principals of the
   AccessControlContext associated with the thread on which the call
   to checkPermission is performed. If checkPermission throws an
   access exception, the permission is not granted to the caller.
   Otherwise the permission is granted.

   A container that relies on a jakarta.security.auth.Policy provider may
   also use the following technique to determine if a permission has
   been granted to the caller.

   a)The container shall call
   jakarta.security.auth.Policy.getPermissions() with the
   Subject corresponding to the caller. The returned
   PermissionCollection will contain the collection of permissions
   granted to the caller. The container shall call the implies method
   on the returned PermissionCollection using the permission being
   checked as argument. If the PermissionCollection implies the
   permission being tested, the permission has been granted to the
   caller. Otherwise it has not.

   A container that relies on a J2SE 1.4 java.secuirty.Policy provider
   may also use the following techniques to determine if a permission
   has been granted to a caller.

   a)The container shall call
   javax.security.Policy.getPermissions() with an argument
   ProtectionDomain that was constructed with the principals obtained
   from the Subject corresponding to the caller. The container shall
   call the implies method on the returned PermissionCollection using
   the permission being checked as argument. If the
   PermissionCollection implies the permission being tested, the
   permission has been granted to the caller. Otherwise it has not.

   b)The container shall call Policy.implies with two arguments; the
   permission being checked, and a ProtectionDomain constructed with
   the principals obtained from the Subject corresponding to the
   caller. The boolean result returned by policy.implies shall indicate
   whether or not the permission has been granted to the caller.
   Otherwise it has not.</description>
			<location chapter = "4" section = "4.6"/>
			<comment>container</comment>
		</assertion>
		<assertion required = "true" impl-spec = "false" defined-by = "technology" status = "active" testable = "true">
			<id>72</id>
			<description>To be compatible with this contract, a J2EE 1.3 container must
   perform all of its policy decisions as defined by this contract by
   interacting with a concrete implementation of the 
   jakarta.security.auth.Policy abstract class.

   A J2EE 1.4 container must perform all of its policy decisions as
   defined by this contract by interacting with concrete
   implementations of either or both of the java.security.Policy and
   jakarta.security.auth.Policy abstract classes.</description>
			<location chapter = "4" section = "4.7"/>
			<comment>container</comment>
		</assertion>
		<assertion required = "true" impl-spec = "false" defined-by = "technology" status = "active" testable = "true">
			<id>73</id>
			<description>
            The following list defines changes to this contract that 
              apply to containers running without a Java SE SecurityManager. 
 
                  1. The restrictions defined in Section 3.3,  Permission to 
                     Configure Policy" need not be enforced. Also, the 
                     containers of the application server must not be 
                     denied permission to perform any operation that would 
                     have been permitted in the presence of a SecurityManager. 

                  2. Such containers are not required (before dispatching a 
                     call) to associate an AccessControlContext with the call 
                     thread (as otherwise required by Section 4.1.3,  
                     Pre-dispatch Decision" and Section 4.3.1,  
                     EJB Pre-dispatch Decision"). 

                  3. When performing the operations defined in Section 4.7,  
                     Checking AccessControlContext Independent Grants" and in 
                     Section 4.8,  Checking the Caller for a Permission", 
                     such containers must not employ the 
                     SecurityManager.checkPermission and 
                     AccessControlContext.checkPermission techniques defined 
                     in these sections.  
            </description>
			<location chapter = "1" section = "1.5"/>
			<comment>container</comment>
		</assertion>
		<assertion required = "true" impl-spec = "false" defined-by = "technology" status = "active" testable = "true">
			<id>74</id>
			<description>
             This subcontract also applies to the translation of 
             authorization policy annotations that have an equivalent 
             representation in Java EE deployment descriptor policy
             constructs(i.e security-constraint, method-permission,
             security-role-ref, and exclude-list elements)   
            </description>
			<location chapter = "3" section = "3.0"/>
			<comment>container</comment>
		</assertion>
		
        <assertion required = "true" impl-spec = "false" defined-by = "technology" status = "active" testable = "true">
			<id>75</id>
			<description>
               Independent of this specification, J2EE deployment tools must 
        translate and complete the declarative policy statements appearing 
        in deployment descriptors into a form suitable for securing 
        applications on the platform. On versions of the Java EE platform 
        that require support for authorization policy annotations, the 
        deployment tools must combine policy annotations in Java code with 
        policy statements appearing in deployment descriptors to yield 
        complete representations of authorization policy suitable for 
        securing applications on the platform. The rules for combining 
        authorization policy annotations with declarative policy statements 
        are described in the versions of the EJB, Servlet, and Java EE 
        platform specifications that require support for the annotations. 
        Independent of whether annotations factor in the translation, 
        the resulting policy statements may differ in form from the policy 
        statements appearing in the deployment descriptors.
            </description>
			<location chapter = "3" section = "3.1"/>
			<comment>container</comment>
		</assertion>
		<assertion required = "true" impl-spec = "false" defined-by = "technology" status = "active" testable = "true">
			<id>76</id>
			<description>
             When an application is composed of multiple web modules, a separate 
             policy context must be defined per module. This is necessary to ensure 
             that url-pattern based and servlet name based policy statements 
             configured for one module do not interfere with those configured 
             for another.  
            </description>
			<location chapter = "3" section = "3.1.2"/>
			<comment>container</comment>
		</assertion>
		<assertion required = "true" impl-spec = "false" defined-by = "technology" status = "active" testable = "true">
			<id>77</id>
			<description>
            When an application is composed of multiple EJB jars, no two jars 
            that share at least one ejb-name value in common may share the same 
            policy context identifiers.  
            </description>
			<location chapter = "3" section = "3.1.4"/>
			<comment>container</comment>
		</assertion>
		<assertion required = "true" impl-spec = "false" defined-by = "technology" status = "active" testable = "true">
			<id>78</id>
			<description>
             Permission Names for Transport and Pre-Dispatch Decisions 
            The name of the permission checked in a transport or pre-dispatch 
       decision must be the value that would result from applying the Servlet 
       welcome file processing rules to the unqualified request URI minus the 
       context path. 
  
            For the special case where this transformation of the request URI 
       yields the URLPattern "/", the empty string URLPattern, "", must be 
       used as the permission name. The welcome file processing rules are 
       defined in the Servlet specification. For the special case where the 
       empty string must be substituted for the "/" pattern in the permission 
       evaluation, all target related processing (including servlet mapping, 
       filter mapping, and form based login processing) must be performed 
       using the original pattern, "/". 
            </description>
			<location chapter = "4" section = "4.1.1"/>
			<comment>container</comment>
		</assertion>
        <assertion required = "true" impl-spec = "false" defined-by = "technology" status = "active" testable = "true">
			<id>79</id>
			<description>
             The EnterpriseBean object must only be returned when this handler 
       is activated within the scope of a container's processing of a 
       business method of the EJB Remote, Local, or ServiceEndpoint 
       interfaces of the EnterpriseBean object. The value null must be 
       returned if the bean implementation class does not implement the 
       jakarta.ejb.EnterpriseBean interface.
            </description>
			<location chapter = "4" section = "4.6.1.4"/>
			<comment>container</comment>
		</assertion>
	</assertions>
</spec>
