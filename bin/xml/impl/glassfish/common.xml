<?xml version="1.0"?>
<!--

    Copyright (c) 2018 Oracle and/or its affiliates. All rights reserved.

    This program and the accompanying materials are made available under the
    terms of the Eclipse Public License v. 2.0, which is available at
    http://www.eclipse.org/legal/epl-2.0.

    This Source Code may also be made available under the following Secondary
    Licenses when the conditions for such availability set forth in the
    Eclipse Public License v. 2.0 are satisfied: GNU General Public License,
    version 2 with the GNU Classpath Exception, which is available at
    https://www.gnu.org/software/classpath/license.html.

    SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0

-->

<project name="Commonxml" basedir=".">

    <!-- ========================================================== -->
    <!--  CTS s1as.xml & javaee_ri.xml Common Properties & targets  -->
    <!-- ========================================================== -->

    <!-- IMPORTS -->
    <import file="../../ts.common.props.xml"/>

    <property name="server.start.delay.mins" value="1"/>
    <property name="server" value="server"/> 
    <property name="resources.dottedname.prefix" value="domain.resources"/>
    <property name="server.policy" value="server.policy" />
    <property name="server.policy.orig" value="${server.policy}_orig"/>
    <property name="client.policy" value="client.policy" />
    <property name="client.policy.orig" value="${client.policy}_orig"/>
    <property name="sun-acc.xml.template" value="sun-acc.xml.template" />
    <property name="sun-acc.xml.template.orig" value="sun-acc.xml.template.orig" />
    <property name="timer.poolName" value="cts-derby-XA-pool"/>
    <property name="keystore.password" value="changeit"/>
    <property name="server.cert.alias" value="s1as"/>
    <property name="client.cert.alias" value="cts"/>
    <property name="NSSConfigDir" value="${s1as.domain.dir}/${s1as.domain.name}/config" />
    <property name="appclient.log.level" value="INFO"/>
    <property name="appclient.log.dir" value="${ts.home}/tmp/appclient"/>

    <!--
      Check to see if we are using the pointbase pool, if so
      we will skip pinging the connection pool.
    -->
    <target name="checkIfUsingDerbyPool" >
        <condition property="usingDerbyPool">
          <equals arg1="${use.jdbc.poolName}" arg2="${use.derby.poolName}" casesensitive="true" trim="true"/>
      </condition>
    </target> 

    <!--
         configUnix will be invoked when ant is being run on
         unix/Linux.  It will configure the values for ${os}
         and ${dir.sep}

         Due to differences on how ant invokes external commands
         on windows, we need to execute asadmin and imqusermgr
         differently on each platform.
    -->

    <target name="configUnix" depends="checkPlatform" if="isUnixPlatform" >
           <echo message="on unix"/>
           <property name="dir.sep" value="/"/>
           <property name="exec.asadmin" value="${cli.path}" />
           <property name="exec.asadmin.part2" value="" />
           <property name="exec.imqusermgr" value="${imqbin.loc}/imqusermgr" />
           <property name="exec.imqusermgr.part2" value="" />
           <property name="cert.file" value="${bin.dir}/certificates/cts_cert"/>
           <property name="server.config.dir.path" value="${server.domain}/${server.config.dir}" />
           <property name="cacerts.jks" value="${server.config.dir.path}/cacerts.jks"/>
           <property name="keystore.jks" value="${server.config.dir.path}/keystore.jks"/>
           <property name="cert8.db" value="${server.config.dir.path}/cert8.db"/>
           <property name="key3.db" value="${server.config.dir.path}/key3.db"/>
           <property name="secmod.db" value="${server.config.dir.path}/secmod.db"/>
           <property name="exec.keytool" value= "${java.home}/bin/keytool" />
           <property name="exec.keytool.part2" value= "" />
           <property name="exec.certutil" value= "${server.home}/lib/certutil" />
           <property name="exec.certutil.part2" value= "" />
           <property name="password.file.template"
                     value="${common.bin.dir}/xml/impl/glassfish/templates/password.template"/>
           <property name="password.file" value="${bin.dir}/password.txt"/>
           <property name="nodeagent.path" value="" />
    </target>

    <!--
         configWindows will be invoked when ant is being run on
         windows.  It will configure the values for ${os}
         and ${dir.sep}

         Due to differences on how ant invokes external commands
         on windows, we need to execute asadmin and imqusermgr
         differently on each platform.
    -->

    <target name="configWindows" depends="checkPlatform" if="isWindowsPlatform" >
           <echo message="on windows"/>
           <property name="dir.sep" value="\\"/>
           <property name="exec.asadmin" value="cmd.exe" />
           <property name="exec.asadmin.part2" value= " /c ${cli.path}" />
           <property name="exec.imqusermgr" value="cmd.exe" />
           <property name="exec.imqusermgr.part2" value="/c ${imqbin.loc}\imqusermgr" />
           <property name="cert.file" value="${ts.home}\bin\certificates\cts_cert"/>
           <property name="server.config.dir.path" value="${server.domain}\${server.config.dir}" />
           <property name="cacerts.jks" value="${server.config.dir.path}\cacerts.jks"/>
           <property name="keystore.jks" value="${server.config.dir.path}\keystore.jks"/>
           <property name="cert8.db" value="${server.config.dir.path}\cert8.db"/>
           <property name="key3.db" value="${server.config.dir.path}\key3.db"/>
           <property name="secmod.db" value="${server.config.dir.path}\secmod.db"/>
           <property name="exec.keytool" value="cmd.exe" />
           <property name="exec.keytool.part2" value= " /c ${java.home}\bin\keytool" />
           <property name="exec.certutil" value= "${server.home}\lib\certutil" />
           <property name="exec.certutil.part2" value= " /c ${server.home}/lib/certutil" />
           <property name="password.file.template"
                     value="${ts.home}\bin\xml\impl\glassfish\templates\password.template"/>
           <property name="password.file" value="${ts.home}\bin\password.txt"/>
           <property name="nodeagent.path" value="--agentdir ${drive}\${sjsas.node.agent.dir.name}" />
    </target>

    <!--
      checkForFiles determines if the following files exist:
      server.policy_orig
      client.policy_orig
    -->
    <target name="checkForFiles">
        <available file="${server.domain}/${server.config.dir}/${server.policy.orig}"
           type="file" property="found.server.policy.orig"/>
        <available file="${server.home}/lib/appclient/${client.policy.orig}"
           type="file" property="found.client.policy.orig"/>

         <condition property="java.keystore.generated" >
           <and>
             <available  file="${keystore.jks}" type="file" />
             <available  file="${cacerts.jks}" type="file" />
           </and>
         </condition>

         <condition property="found.nss.databases" >
           <and>
             <available  file="${cert8.db}" type="file" />
             <available  file="${key3.db}" type="file" />
             <available  file="${secmod.db}" type="file" />
           </and>
         </condition>

    </target>

    <target name="setNSSConfigDir" >
	<condition property="NSSConfigDir" value="${s1as.domain.dir}/${s1as.domain.name}/config">
	  <equals arg1="${sjsas.env.type}" arg2="das" casesensitive="true" trim="true"/>
	</condition>

	<condition property="NSSConfigDir" value="${javaee.home}/nodeagents/${sjsas.nodeagent.name}/${sjsas.nodeinstance.name}/config">
	  <equals arg1="${sjsas.env.type}" arg2="remote" casesensitive="true" trim="true"/>
	</condition>

	<condition property="NSSConfigDir" value="${javaee.home}/nodeagents/${sjsas.nodeagent.name}/${sjsas.nodeinstance.name}/config">
	  <equals arg1="${sjsas.env.type}" arg2="cluster" casesensitive="true" trim="true"/>
	</condition>

    </target>

    <!--
      copy.server.policy makes an archive copy of the server.policy
      file.
    -->
    <target name="copy.server.policy" unless="found.server.policy.orig">
        <copy file="${server.domain}/${server.config.dir}/${server.policy}"
              tofile="${server.domain}/${server.config.dir}/${server.policy.orig}"
              overwrite="yes" />
    </target>

    <!--
      copy.client.policy  makes an archive copy of the client.policy
      file.
    -->
    <target name="copy.client.policy" unless="found.client.policy.orig">
        <copy file="${server.home}/lib/appclient/${client.policy}"
              tofile="${server.home}/lib/appclient/${client.policy.orig}"
              overwrite="yes" />
    </target>


    <!--
      concat.security concatinates the cts files required to create:
      server.policy
      client.policy

      with the saved original S1AS copies of the above files.

    -->
    <target name="concat.security"
            depends="checkForFiles, copy.server.policy,  copy.client.policy">
        <concat destfile="${server.domain}/${server.config.dir}/${server.policy}" >
           <filelist dir="${server.domain}/${server.config.dir}" files="${server.policy.orig}" />
           <filelist dir="${bin.dir}" files="server_policy.append" />
        </concat>
        <concat destfile="${server.home}/lib/appclient/${client.policy}" >
           <filelist dir="${server.home}/lib/appclient" files="${client.policy.orig}" />
           <filelist dir="${bin.dir}" files="client_policy.append" />
        </concat>

    </target>

    <!--
       Enable the S1AS security configuration settings
    -->
    <target name="enable.security" depends="concat.security"/>
    
    <!--
        Filter and copy sun-acc.xml to $TS_HOME/tmp.
        Also copy the needed DTD to $TS_HOME/tmp
    -->
    <target name="filter.sun-acc.xml" depends="configPlatform">
       <!--<copy file="${as.base}/lib/install/templates/${sun-acc.xml.template}"-->
       <copy file="${bin.dir}/xml/impl/glassfish/templates/${sun-acc.xml.template}"
             tofile="${ts.home}/tmp/appclient/${sun-acc.xml}" overwrite="yes">
           <filterset begintoken="%%%" endtoken="%%%">
              <filter token="SERVER_ROOT" value="${as.base}" />
              <filter token="SERVER_NAME" value="${sun-acc.host}" />
              <filter token="ORB_LISTENER1_PORT" value="${sun-acc.port}" />
           </filterset>
        </copy>
        
        <if>
            <istrue value="${appclient.log.output}"/>
        <then>
            <replace  file="${ts.home}/tmp/appclient/${sun-acc.xml}"
                token="log-service file=&quot;&quot; level=&quot;WARNING&quot;"
                value="log-service file=&quot;${appclient.log.dir}/${sun-acc.xml}.log&quot; level=&quot;${appclient.log.level}&quot;"/>    
        </then>
        </if>
        
    </target>

    <!--
        Start The App Server by calling the appropriate target
        depending on whether we are on unix/linux or windows.
    -->
    <target name="start.appserver" depends="configPlatform" >

       <antcall target="start.appserver.unix"/>
       <antcall target="start.appserver.win"/>
    </target>
    <!--
        Start The App Server on unix/linux
    -->
    <target name="start.appserver.unix" depends="configPlatform" if="isUnixPlatform">
      <exec executable="${exec.asadmin}" failifexecutionfails="false">
        <arg line="${exec.asadmin.part2}" />
        <arg line=" --user ${admin.user}"/>
        <arg line=" --passwordfile ${password.file}"/>
        <arg line=" start-domain"/>
        <arg line=" ${server.domain.name}"/>
      </exec>
      <echo message=" The App Server is now available." />
    </target>

    <!--
        Start the App Server on windoze
    -->
    <target name="start.appserver.win" depends="configPlatform" if="isWindowsPlatform">
      <spawn executable="${exec.asadmin}" failifexecutionfails="false">
        <arg line="${exec.asadmin.part2}" />
        <arg line=" --user ${admin.user}"/>
        <arg line=" --passwordfile ${password.file}"/>
        <arg line=" start-domain"/>
        <arg line=" ${server.domain.name}"/>
      </spawn>
      <echo message=" ...Waiting for server to be up ...(sleeping for ${server.start.delay.mins} minutes) " /> 
      <!-- 
        Currently the waitfor task allocates a port everytime it checks the admin server URL.
        If one of the server ports is allocated to the waitfor task we get a server startup error.
        Asadmin start-domain is a synchronous call but in the case of ant on windows the asadmin
        start-domain never returns to the ant exec task so it hangs forever.  For now we simply
        sleep for server.start.delay.mins minutes to give the app server more than enough time to come up.  This is
        a temparay fix until we implement something better.
      -->
      <sleep minutes="${server.start.delay.mins}"/> 
      <echo message=" HTTP server is now available at http://${server.host}:${server.port}" />
    </target>

    <!--
       Create cts-asadmin.bat for the harness:
       Appends an echo statement to the asadmin.bat file on windows only.
       This is done so the CTS porting can read the return status of
       the exec'ed asadmin command.  On Unix the return value is propogated
       back to the exec'ed process.
    -->
    <target name="create.asadmin.bat" depends="configPlatform,checkForFiles" if="isWindowsPlatform">
        <concat destfile="${server.home}/bin/cts-asadmin.bat">
           <filelist dir="${server.home}/bin" files="asadmin.bat" />
           <filelist dir="${bin.dir}/xml/impl/glassfish/templates" files="asadmin.bat.concat.template" />
        </concat>
    </target>

    <!--
        Stop The App Server
    -->
    <target name="stop-domain" depends="configPlatform">
      <exec executable="${exec.asadmin}" failifexecutionfails="false">
        <arg line="${exec.asadmin.part2}" />
        <arg line=" stop-domain"/>
        <arg line=" ${server.domain.name}"/>
      </exec>
    </target>

     <!--
       list.jdbc.pools provides the names of the configured jdbc pools.
     -->
     <target name="list.jdbc.pools" depends="configPlatform">
        <exec executable="${exec.asadmin}" >
            <arg line="${exec.asadmin.part2}" />
            <arg line=" --user ${admin.user}"/>
            <arg line=" --passwordfile ${password.file}"/>
            <arg line=" --host ${server.host}"/>
            <arg line=" --port ${server.port}"/>
            <arg line=" list-jdbc-connection-pools"/>
        </exec>
     </target>

     <!--
      create-jdbc-connection-pool configures the connection pools defined in the
      build.properties files.
     -->
     <target name="create-jdbc-connection-pool">
        <exec executable="${exec.asadmin}" >
            <arg line="${exec.asadmin.part2}" />
            <arg line=" --user ${admin.user}"/>
            <arg line=" --passwordfile ${password.file}"/>
            <arg line=" --host ${server.host}"/>
            <arg line=" --port ${server.port}"/>
            <arg line=" create-jdbc-connection-pool"/>
            <arg line=" --restype ${restype}"/>
            <arg line=" --datasourceclassname ${datasourceclassname}"/>
            <arg line=" --steadypoolsize ${use.jdbc.steadypoolsize}"/>
            <arg line=" --maxpoolsize ${use.jdbc.maxpoolsize}"/>
            <arg line=" --property ${pool.properties}"/>
            <arg line=" ${poolName}"/>
        </exec>
     </target>

     <!--
        delete-jdbc-connection-pool removes the connection pools defined in the
        build.properties files.
     -->
     <target name="delete-jdbc-connection-pool">
        <exec executable="${exec.asadmin}" >
            <arg line="${exec.asadmin.part2}" />
            <arg line=" --user ${admin.user}"/>
            <arg line=" --passwordfile ${password.file}"/>
            <arg line=" --host ${server.host}"/>
            <arg line=" --port ${server.port}"/>
            <arg line=" delete-jdbc-connection-pool"/>
            <arg line=" ${poolName}"/>
        </exec>
     </target>

     <target name="ping.jdbc.pool.check" depends="configPlatform, checkIfUsingDerbyPool"
             unless="usingDerbyPool">

        <antcall target="ping.jdbc.pool"/>
     </target>
     <!-- 
       ping.jdbc.pool validates that that configured JDBC Connection Pool
       can be accessed.

     -->
     <target name="ping.jdbc.pool" depends="configPlatform">
        <echo message= "****Validating Connection pool: ${use.jdbc.poolName} ***"/>
        <echo message= ""/>
        <echo message= "Note: this will fail if your DB server is not started"/>
        <echo message= "      and you can just start your DB server"/>
        <echo message= ""/>
        <antcall target="ping-connection-pool" >
          <param name="poolName" value="${use.jdbc.poolName}" />
        </antcall>
     </target>
   
     <!--
        ping-connection-pool removes the connection pools defined in the
        build.properties files.
     -->
     <target name="ping-connection-pool">
        <exec executable="${exec.asadmin}" >
            <arg line="${exec.asadmin.part2}" />
            <arg line=" --user ${admin.user}"/>
            <arg line=" --passwordfile ${password.file}"/>
            <arg line=" --host ${server.host}"/>
            <arg line=" --port ${server.port}"/>
            <arg line=" ping-connection-pool"/>
            <arg line=" ${poolName}"/>
        </exec>
     </target>
     <!--
       Create a JDBC JNDI resource using an existing Connection pool
     -->
     <target name="create-jdbc-resource">
        <exec executable="${exec.asadmin}" >
            <arg line="${exec.asadmin.part2}" />
            <arg line=" --user ${admin.user}"/>
            <arg line=" --passwordfile ${password.file}"/>
            <arg line=" --host ${server.host}"/>
            <arg line=" --port ${server.port}"/>
            <arg line=" create-jdbc-resource"/>
            <arg line=" --connectionpoolid ${connectionpoolid}"/>
            <arg line=" ${jndiName}"/>
        </exec>
     </target>

     <!--
        Delete an existing JDBC JNDI resource
     -->
     <target name="delete-jdbc-resource">
        <exec executable="${exec.asadmin}" >
            <arg line="${exec.asadmin.part2}" />
            <arg line=" --user ${admin.user}"/>
            <arg line=" --passwordfile ${password.file}"/>
            <arg line=" --host ${server.host}"/>
            <arg line=" --port ${server.port}"/>
            <arg line=" delete-jdbc-resource"/>
            <arg line=" ${jndiName}"/>
        </exec>
     </target>

     
     <!--
         Add a jvm option to the server
     -->
   <target name="create-jvm-options" depends="delete-jvm-options">
        <exec executable="${exec.asadmin}" >
            <arg line="${exec.asadmin.part2}" />
            <arg line=" --user ${admin.user}"/>
            <arg line=" --passwordfile ${password.file}"/>
            <arg line=" --host ${server.host}"/>
            <arg line=" --port ${server.port}"/>
            <arg line=" create-jvm-options "/>
            <arg line=" ${jvm.options}"/>
        </exec>
     </target>



     <!--
         Remove a jvm option that was prevously added
     -->
     <target name="delete-jvm-options">
        <exec executable="${exec.asadmin}" >
            <arg line="${exec.asadmin.part2}" />
            <arg line=" --user ${admin.user}"/>
            <arg line=" --passwordfile ${password.file}"/>
            <arg line=" --host ${server.host}"/>
            <arg line=" --port ${server.port}"/>
            <arg line=" delete-jvm-options "/>
            <arg line=" ${jvm.options}"/>
        </exec>
     </target>


     <!--
         this is best used for the case where we want to delete a single
         JVM option that happens to contain a file or path.  The reason for
         using this over the 'create-jvm-options' target is that this is 
         designed to better handle paths on Windows platform where
         the paths may contain a colon (":") character.  The colon char 
         requires special escape char handling in (GF) asadmin command.
         Bottom line - use this for creating a JVM option that contains
         a file/dir path AND use its counterpart for deleting that same
         JVM option.  (the counterpart is 'delete-one-jvm-option')
      -->
     <target name="create-one-jvm-option" depends="checkPlatform,delete-one-jvm-option">
        <if> <or>
                 <istrue value="isWindowsPlatform"/>
                 <os family="windows"/>
                 <os family="dos"/>
             </or>
           <then>
               <propertyregex property="the.jvm.option"
                        input="${jvm.options}"
                        regexp=":"
                        replace="\\\\:"
                        defaultvalue="${jvm.options}"
                        override="true"/>
           </then>
           <else>
                 <property  name="the.jvm.option"  value="${jvm.options}"/>
           </else>
        </if>
 

        <exec executable="${exec.asadmin}" >
            <arg line="${exec.asadmin.part2}" />
            <arg line=" --user ${admin.user}"/>
            <arg line=" --passwordfile ${password.file}"/>
            <arg line=" --host ${server.host}"/>
            <arg line=" --port ${server.port}"/>
            <arg line=" create-jvm-options "/>
            <arg line=" ${the.jvm.option}"/>
        </exec>
     </target>


     <target name="delete-one-jvm-option" depends="checkPlatform">
        <if> <or>
                 <istrue value="isWindowsPlatform"/>
                 <os family="windows"/>
                 <os family="dos"/>
             </or>
           <then>
               <propertyregex property="the.jvm.option"
                        input="${jvm.options}"
                        regexp=":"
                        replace="\\\\:"
                        defaultvalue="${jvm.options}"
                        override="true"/>
           </then>
           <else>
                 <property  name="the.jvm.option"  value="${jvm.options}"/>
           </else>
        </if>

        <exec executable="${exec.asadmin}" >
            <arg line="${exec.asadmin.part2}" />
            <arg line=" --user ${admin.user}"/>
            <arg line=" --passwordfile ${password.file}"/>
            <arg line=" --host ${server.host}"/>
            <arg line=" --port ${server.port}"/>
            <arg line=" delete-jvm-options "/>
            <arg line=" ${the.jvm.option}"/>
        </exec>
     </target>


     <!--
        Set an attribute for an existing domain element
     -->
     <target name="set" >
        <exec executable="${exec.asadmin}" >
            <arg line="${exec.asadmin.part2}" />
            <arg line=" --user ${admin.user}"/>
            <arg line=" --passwordfile ${password.file}"/>
            <arg line=" --host ${server.host}"/>
            <arg line=" --port ${server.port}"/>
            <arg line=" set"/>
            <arg line=" ${set.value}"/>
        </exec>
     </target>

     <target name="create-file-user" >
        <!-- filter a template file to $ts.home/tmp for this particular user and pass it to the -->
        <!-- asadmin command below.  Form of AS_ADMIN_USERPASSWORD=${userpassword} -->
        <copy file="${password.file.template}"
              tofile="${password.file}"
              overwrite="true">
          <filterset>
            <filter token="sjsas.master.password" value="${sjsas.master.password}"/>
            <filter token="sjsas.admin.password" value="${admin.password}"/>
            <filter token="user.password" value="${userpassword}" />
          </filterset>
        </copy>
        <exec executable="${exec.asadmin}" >
            <arg line="${exec.asadmin.part2}" />
            <arg line=" --user ${admin.user}"/>
            <arg line=" --passwordfile ${password.file}"/>
            <arg line=" --host ${server.host}"/>
            <arg line=" --port ${server.port}"/>
            <arg line=" create-file-user"/>
            <arg line=" --groups ${usergroups}"/>
            <arg line=" ${userName}"/>
        </exec>
     </target>

     <target name="delete-file-user" >
        <exec executable="${exec.asadmin}" >
            <arg line="${exec.asadmin.part2}" />
            <arg line=" --user ${admin.user}"/>
            <arg line=" --passwordfile ${password.file}"/>
            <arg line=" --host ${server.host}"/>
            <arg line=" --port ${server.port}"/>
            <arg line=" delete-file-user"/>
            <arg line=" ${userName}"/>
        </exec>
     </target>

     <!--
       Remove the javamail JNDI resources
     -->
     <target name="delete-javamail-resource">
        <exec executable="${exec.asadmin}" >
            <arg line="${exec.asadmin.part2}" />
            <arg line=" --user ${admin.user}"/>
            <arg line=" --passwordfile ${password.file}"/>
            <arg line=" --host ${server.host}"/>
            <arg line=" --port ${server.port}"/>
            <arg line=" delete-javamail-resource"/>
            <arg line=" ${jndiName}"/>
        </exec>
     </target>

     <!--
       Add the javamail JNDI resources
     -->
     <target name="create-javamail-resource" >
        <exec executable="${exec.asadmin}" >
            <arg line="${exec.asadmin.part2}" />
            <arg line=" --user ${admin.user}"/>
            <arg line=" --passwordfile ${password.file}"/>
            <arg line=" --host ${server.host}"/>
            <arg line=" --port ${server.port}"/>
            <arg line=" create-javamail-resource"/>
            <arg line=" --mailhost ${mailHost}"/>
            <arg line=" --mailuser ${mailuser1}"/>
            <arg line=" --fromaddress ${mailFrom}"/>
            <arg line=" --property mail.smtp.port=${smtp.port}"/>
            <arg line=" ${jndiName}"/>
        </exec>
     </target>

     <!--
        Add the a JMS user
     -->
     <target name="create-jms-user" >
       <exec executable="${exec.imqusermgr}" >
            <env key="IMQ_JAVAHOME" value="${java.home}"/>
            <arg line="${exec.imqusermgr.part2}"/>
            <arg line="-i ${jmsServer}"/>
            <arg line=" add"/>
            <arg line=" -u ${userName} "/>
            <arg line=" -p ${userPassword} "/>
            <arg line=" -g ${userGroup} "/>
            <arg line=" -f "/>
            <arg line=" -c "/>
        </exec>
     </target>

     <!--
        Delete the a JMS user
     -->
     <target name="delete-jms-user" >
       <exec executable="${exec.imqusermgr}" >
            <env key="IMQ_JAVAHOME" value="${java.home}"/>
            <arg line="${exec.imqusermgr.part2}"/>
            <arg line="-i ${jmsServer}"/>
            <arg line=" delete"/>
            <arg line=" -u ${userName} "/>
            <arg line=" -p ${userPassword} "/>
            <arg line=" -g ${userGroup} "/>
            <arg line=" -f "/>
        </exec>
     </target>

     <!--
       Delete a Connector Connection Pool
     -->
     <target name="delete-connector-connection-pool" >
        <exec executable="${exec.asadmin}" >
            <arg line="${exec.asadmin.part2}" />
            <arg line=" --user ${admin.user}"/>
            <arg line=" --passwordfile ${password.file}"/>
            <arg line=" --host ${server.host}"/>
            <arg line=" --port ${server.port}"/>
            <arg line=" delete-connector-connection-pool"/>
            <arg line=" --cascade=true"/>
            <arg line=" ${poolName}"/>
        </exec>
    </target>

     <!--
       Create a Connector Connection Pool
     -->
     <target name="create-connector-connection-pool" >
       <exec executable="${exec.asadmin}" >
            <arg line="${exec.asadmin.part2}" />
            <arg line=" --user ${admin.user}"/>
            <arg line=" --passwordfile ${password.file}"/>
            <arg line=" --host ${server.host}"/>
            <arg line=" --port ${server.port}"/>
            <arg line=" create-connector-connection-pool"/>
            <arg line=" --raname ${rarName}"/>
            <arg line=" --connectiondefinition com.sun.connector.jaxr.JaxrConnectionFactory"/>
            <arg line=" ${poolName}"/>
        </exec>
     </target>

     <!--
       Create a Connector Resource
     -->
     <target name="create-connector-resource" >
        <exec executable="${exec.asadmin}" >
            <arg line="${exec.asadmin.part2}" />
            <arg line=" --user ${admin.user}"/>
            <arg line=" --passwordfile ${password.file}"/>
            <arg line=" --host ${server.host}"/>
            <arg line=" --port ${server.port}"/>
            <arg line=" create-connector-resource"/>
            <arg line=" --poolname ${poolName}"/>
            <arg line=" ${jndiName}"/>
        </exec>
     </target>


     <!--
       Delete a Connector Resource
     -->
     <target name="delete-connector-resource" >
        <exec executable="${exec.asadmin}" >
            <arg line="${exec.asadmin.part2}" />
            <arg line=" --user ${admin.user}"/>
            <arg line=" --passwordfile ${password.file}"/>
            <arg line=" --host ${server.host}"/>
            <arg line=" --port ${server.port}"/>
            <arg line=" delete-connector-resource"/>
            <arg line=" ${jndiName}"/>
        </exec>
     </target>


     <!--
       SSL config stuff for CSIv2 interop tests
     -->
     <target name="add.ssl.client.config" depends="configPlatform" unless="use.create.system.properties">
        <exec executable="${exec.asadmin}" >
            <arg line="${exec.asadmin.part2}" />
            <arg line=" --user ${admin.user}"/>
            <arg line=" --passwordfile ${password.file}"/>
            <arg line=" --host ${server.host}"/>
            <arg line=" --port ${server.port}"/>
            <arg line=" create-ssl"/>
            <arg line=" --type iiop-service"/>
            <arg line=" --certname s1as"/>
        </exec>
     </target>
     <target name="drop.ssl.client.config" depends="configPlatform" unless="use.create.system.properties">
        <exec executable="${exec.asadmin}" >
            <arg line="${exec.asadmin.part2}" />
            <arg line=" --user ${admin.user}"/>
            <arg line=" --passwordfile ${password.file}"/>
            <arg line=" --host ${server.host}"/>
            <arg line=" --port ${server.port}"/>
            <arg line=" delete-ssl"/>
            <arg line=" --type iiop-service"/>
        </exec>
     </target>

      <!--
       drop.classpathsuffix removes the classpath settings previously defined
     -->
     <target name="drop.classpathsuffix" depends="configPlatform" >
         <antcall target="set" >
          <param name="set.value" value=" ${server.instance}-config.java-config.classpath_suffix="/>
         </antcall>
     </target>


    <!--
       rerestart.server reconfigures and restarts the App Server
     -->
     <target name="restart.server" depends="configPlatform">
       <antcall target="stop-domain"/>
       <delete quiet="true">
         <fileset dir="${s1as.domain}/logs" includes="jacc_log*"/>
       </delete>
       <antcall target="start.appserver"/>
     </target>


     <!--
       Modify the applicationRoot. Needed for windows tests.
     -->
     <target name="change.applicationRoot" depends="configPlatform" if="isWindowsPlatform">
         <antcall target="set" >
          <param name="set.value" value=" domain.application_root=${drive}"/>
         </antcall>
         <antcall target="restart.server"/>
     </target>

     <!--
       Enable Tx interoperability
     -->
     <target name="enable.tx.interop" depends="configPlatform" >
       <antcall target="delete.tx.interop"/>
       <antcall target="create-jvm-options" >
         <param name="jvm.options" value=" -Dcom.sun.jts.pi.INTEROP_MODE=true"/>
       </antcall>
       <antcall target="restart.server"/>
     </target>

     <!--
       Disable Tx interoperability
     -->
     <target name="disable.tx.interop" depends="configPlatform" >
       <antcall target="delete.tx.interop"/>
       <antcall target="create-jvm-options" >
         <param name="jvm.options" value=" -Dcom.sun.jts.pi.INTEROP_MODE=false"/>
       </antcall>
       <antcall target="restart.server"/>
     </target>

     <!--
       Delete the Tx interoperability settings
     -->
     <target name="delete.tx.interop" depends="configPlatform" >
       <antcall target="delete-jvm-options" >
         <param name="jvm.options" value=" -Dcom.sun.jts.pi.INTEROP_MODE=true"/>
       </antcall>

       <antcall target="delete-jvm-options" >
         <param name="jvm.options" value=" -Dcom.sun.jts.pi.INTEROP_MODE=false"/>
       </antcall>
     </target>

     <!--
       Add the certificate needed for csiv2
     -->
     <target name="import.cert" depends="configPlatform,checkForFiles,generate.certs" >
        <exec executable="${exec.keytool}" >
            <env key="JAVA_HOME" value="${java.home}" />
            <arg line=" ${exec.keytool.part2}" />
            <arg line=" -import"/>
			<arg line=" -keyalg DSA"/>
            <arg line=" -alias ${cert.alias}"/>
            <arg line=" -file ${cert.file}"/>
            <arg line=" -noprompt"/>
            <arg line=" -trustcacerts"/>
            <arg line=" -keystore ${trustStore}"/>
            <arg line=" -storepass ${trustStore.password}"/>
        </exec>

     </target>


     <target name="export.cert" depends="configPlatform,checkForFiles,generate.certs" >
        <exec executable="${exec.keytool}" >
            <env key="JAVA_HOME" value="${java.home}" />
            <arg line=" ${exec.keytool.part2}" />
            <arg line=" -export"/>
			<arg line=" -keyalg DSA"/>
            <arg line=" -rfc"/>
            <arg line=" -alias ${cert.alias}"/>
            <arg line=" -file ${cert.file}"/>
            <arg line=" -keystore ${trustStore}"/>
            <arg line=" -storepass ${trustStore.password}"/>
        </exec>

     </target>


     <!--
       Drop the certificate used for csiv2
     -->
     <target name="delete.cert" depends="configPlatform" >
        <exec executable="${exec.keytool}" >
            <env key="JAVA_HOME" value="${java.home}" />
            <arg line=" ${exec.keytool.part2}" />
            <arg line=" -delete"/>
            <arg line=" -alias ${cert.alias}"/>
            <arg line=" -file ${cert.file}"/>
            <arg line=" -storepass ${trustStore.password}"/>
            <arg line=" -noprompt"/>
            <arg line=" -trustcacerts"/>
            <arg line=" -keystore ${trustStore}"/>
        </exec>
     </target>


     <!--
       This target is only used for SE/EE it generates the jks files from the 
       NSS database.  This is needed by appclient on SE/EE.
     -->
     <target name="generate.certs"  unless="java.keystore.generated" >
        <echo message="***Exporting certificate from NSS database" />
        <exec executable="${exec.certutil}" 
              output="${server.config.dir.path}/${server.cert.alias}.cert" >
            <env key="JAVA_HOME" value="${java.home}" />
            <arg line=" ${exec.certutil.part2}" />
            <arg line=" -L" />
            <arg line=" -n" />
            <arg line=" ${server.cert.alias}" />
            <arg line=" -d" />
            <arg line=" ${server.config.dir.path}" />
            <arg line=" -a" />
        </exec>

        <echo message="***Generating Java Keystore from generated certificate "/>
        <exec executable="${exec.keytool}" >
            <env key="JAVA_HOME" value="${java.home}" />
            <arg line=" ${exec.keytool.part2}" />
            <arg line=" -import" />
            <arg line=" -v" />
            <arg line=" -noprompt" />
            <arg line=" -alias ${server.cert.alias}" />
            <arg line=" -file" />
            <arg line="${server.config.dir.path}/${server.cert.alias}.cert" />
            <arg line=" -keypass   ${keystore.password}" />
            <arg line=" -keystore  ${keystore.jks}" />
            <arg line=" -storepass ${keystore.password}" />
        </exec>

        <echo message="***Generating Java trust store from generated certificate "/>
        <exec executable="${exec.keytool}" >
            <env key="JAVA_HOME" value="${java.home}" />
            <arg line=" ${exec.keytool.part2}" />
            <arg line=" -import" />
            <arg line=" -v" />
            <arg line=" -noprompt" />
            <arg line=" -trustcacerts" />
            <arg line=" -alias ${server.cert.alias}" />
            <arg line=" -file" />
            <arg line="${server.config.dir.path}/${server.cert.alias}.cert" />
            <arg line=" -keypass   ${keystore.password}" />
            <arg line=" -keystore  ${cacerts.jks}" />
            <arg line=" -storepass ${keystore.password}" />
        </exec>
     </target>


     <!--
          targets to stop and start Derby
     
          It may be necessary to add the following system property to the JavaDB startup when running on the Mac.
          The bug is suppossed to be fixed, making the property unnecessary,  but one never knows.
          This URL describes the issue and the fix:  http://db.apache.org/derby/faq.html#createdb_OS_X

            <sysproperty key="derby.storage.fileSyncTransactionLog" value="true"/>
     -->
      <target name="start.javadb" depends="configPlatform">
        <var name="is.derby.running" unset="true" />
        <echo message="*** Checking if Derby is running "/>
        <antcallback target="is.derby.running" return="isDBRunning"/>
        <if>
            <isfalse value="${isDBRunning}"/>
        <then>
            <echo message="Derby not running, now starting it"/>
            <java classname="org.apache.derby.drda.NetworkServerControl"
                  classpath="${use.derby.classpath}" fork="true" spawn="true">
              <sysproperty key="derby.system.home" value="${use.derby.system.home}"/>
              <sysproperty key="java.security.manager" value=""/>
              <sysproperty key="java.security.policy" value="${server.config.dir.path}/server.policy"/>
              <arg line="-h ${use.derby.server} -p ${use.derby.port} start"/>
            </java>
            <sleep seconds="${use.derby.startup.delay}"/>
            <echo message="*** Now checking if Derby is running "/>
            <var name="is.derby.running" unset="true" />
            <antcallback target="is.derby.running" return="isDBRunning"/>
            <if>
                <isfalse value="${isDBRunning}"/>
            <then>
                <echo message="Derby was NOT started successfully" />
            </then>
            <else>
                <echo message="Derby was started successfully"/>
            </else>
            </if>
        </then>
        <else>
            <echo message="Derby is already running"/>
        </else>
        </if>
     </target>

     <target name="stop.javadb" depends="configPlatform">
         <echo message="*** Stopping JavaDB"/>
         <java classname="org.apache.derby.drda.NetworkServerControl"
                 classpath="${use.derby.classpath}" fork="true" spawn="true">
              <arg line="-h ${use.derby.server} -p ${use.derby.port} shutdown"/>
         </java>
     </target>

    <target name="is.derby.running" depends="configPlatform">
            <!-- check to see if the specified port on the specified server is available -->
            <waitfor maxwait="5" maxwaitunit="second" checkevery="1" checkeveryunit="second">
      			<socket server="${use.derby.server}" port="${use.derby.port}"/>
      		</waitfor>
      		<if>
      			<socket server="${use.derby.server}" port="${use.derby.port}"/>
      			<then>
                    <!-- check that we can actually get to the DB -->
                  		<var name="isDBRunning" unset="true"/>
                  		<var name="db.sql.test.output" unset="true"/>
                  		<var name="db.sql.test.error" unset="true"/>
                  		<trycatch property="db.sql.test.output" reference="bar">
                  			<try>
                 				<sql classpath="${use.derby.classes}"
               				   driver="${use.derby.driver}" url="${use.derby.url}"
               				   userid="${use.derby.user}" password="${use.derby.passwd}"
               				   errorproperty="derby.sql.test.error" >
               				   values user;
                    			</sql>
                  			</try>
                  			<catch>
                  				<var name="isDBRunning" value="false"/>
                  				<echo message="*** There was a problem connecting to DB at ${use.derby.url}"/>
                  				<if>
                  					<isset property="db.sql.test.output"/>
                  					<then>
                  						<echo message="Output:${db.sql.test.output}"/>
                  					</then>
                  				</if>
                  				<if>
                  					<isset property="db.sql.test.error"/>
                  					<then>
                  						<echo message="Error:${db.sql.test.error}"/>
                  					</then>
                  				</if>
                  			</catch>
                  			<finally>
                  				<if>
                  					<and>
                  						<not>
                                           <or>
                                               <contains string="${db.sql.test.output}" substring="refused" />
                                               <contains string="${db.sql.test.output}" substring="Exception" />
                                           </or>
                  						</not>
                  						<not>
                  							<isset property="db.sql.test.error"/>
                  						</not>
                  					</and>
                  					<then>
                  						<echo message="*** DB is running and can be connected to."/>
                  						<var name="isDBRunning" value="true"/>
                  					</then>
                  					<else>
                  						<var name="isDBRunning" value="false"/>
                  					</else>
                  				</if>
                  			</finally>
                  		</trycatch>
      			</then>
      			<else>
                    <var name="isDBRunning" value="false"/>
      			</else>
      		</if>
     	</target>


     <!--
          Determine whether we are running the Java EE RI, PE, SE or EE
          edition.
     -->
     <target name="get.platform.edition" depends="configPlatform">
        <exec executable="${exec.asadmin}"  outputproperty="viVersion">
            <arg line="${exec.asadmin.part2}" />
            <arg line=" version"/>
            <arg line=" --user ${s1as.admin.user}"/>
            <arg line=" --passwordfile ${password.file}"/>
            <arg line=" --host ${s1as.admin.host}"/>
            <arg line=" --port ${s1as.admin.port}"/>
        </exec>
     
        <condition  property="foundPE">
           <or>
              <contains string="${viVersion}"
                        substring="Reference Implementation"/>
              <contains string="${viVersion}"
                        substring="Platform Edition"/>
           </or>
        </condition>
     </target>

     <!--
        create-nodeagent
     -->
     <target name="create-nodeagent">
       <echo message= "****create-nodeagent ${nodeagent.name}"/>
        <exec executable="${exec.asadmin}" >
            <arg line="${exec.asadmin.part2}" />
            <arg line="create-node-agent"/>
            <arg line="--host ${server.host}"/>
            <arg line="--port ${server.port}"/>
            <arg line="--user ${admin.user}"/>
            <arg line="--passwordfile ${password.file}"/>
            <arg line="--savemasterpassword"/>
            <arg line="--passwordfile ${password.file}"/>
            <arg line="${nodeagent.path}"/>
            <arg line="${nodeagent.name}"/>
        </exec>
     </target>

     <!--
        create-node-instance
     -->
     <target name="create-node-instance">
       <echo message= "****create-node-instance ${node.instance.name}"/>
        <exec executable="${exec.asadmin}" >
            <arg line="${exec.asadmin.part2}" />
            <arg line="create-instance"/>
            <arg line="--user ${admin.user}"/>
            <arg line="--passwordfile ${password.file}"/>
            <arg line="--host ${server.host}"/>
            <arg line="--port ${server.port}"/>
            <arg line="--nodeagent ${nodeagent.name}"/>
            <arg line=" ${node.instance.name}"/>
        </exec>
     </target>


     <!--
        create-cluster-instance
     -->
     <target name="create-cluster-instance">
        <exec executable="${exec.asadmin}" >
            <arg line="${exec.asadmin.part2}" />
            <arg line="create-instance"/>
            <arg line="--user ${admin.user}"/>
            <arg line="--passwordfile ${password.file}"/>
            <arg line="--cluster ${cluster.name}"/>
            <arg line="--nodeagent ${nodeagent.name}"/>
            <arg line=" ${node.instance.name}"/>
        </exec>
     </target>

     <!--
        start-nodeagent
     -->
     <target name="start-nodeagent.win" if="isWindowsPlatform">
       <echo message= "****start-nodeagent ${nodeagent.name}"/>
        <spawn executable="${exec.asadmin}" >
            <arg line="${exec.asadmin.part2}" />
            <arg line="start-node-agent"/>
            <arg line="--user ${admin.user}"/>
            <arg line="--passwordfile ${password.file}"/>
            <arg line="${nodeagent.path}"/>
            <arg line="${nodeagent.name}"/>
        </spawn>
        <echo message="Sleeping for ${server.start.delay.mins} minutes waiting for node agent to start"/>
        <sleep minutes="${server.start.delay.mins}"/>
     </target>
     <target name="start-nodeagent.unix" if="isUnixPlatform">
       <echo message= "****start-nodeagent ${nodeagent.name}"/>
        <exec executable="${exec.asadmin}" >
            <arg line="${exec.asadmin.part2}" />
            <arg line="start-node-agent"/>
            <arg line="--user ${admin.user}"/>
            <arg line="--passwordfile ${password.file}"/>
            <arg line="${nodeagent.name}"/>
        </exec>
     </target>
     <target name="start-nodeagent" depends="configPlatform">
        <antcall target="start-nodeagent.win"/>
        <antcall target="start-nodeagent.unix"/>
     </target>

     <!--
        stop-nodeagent
     -->
     <target name="stop-nodeagent">
       <echo message= "****stop-nodeagent ${nodeagent.name}"/>
        <exec executable="${exec.asadmin}" >
            <arg line="${exec.asadmin.part2}" />
            <arg line="stop-node-agent"/>
            <arg line="${nodeagent.path}"/>
            <arg line="${nodeagent.name}"/>
        </exec>
     </target>

     <!--
        delete-nodeagent
     -->
     <target name="delete-nodeagent">
       <echo message= "****delete-nodeagent ${nodeagent.name}"/>
        <exec executable="${exec.asadmin}" >
            <arg line="${exec.asadmin.part2}" />
            <arg line="delete-node-agent"/>
            <arg line="${nodeagent.path}"/>
            <arg line="${nodeagent.name}"/>
        </exec>
     </target>

     <!--
        delete-nodeagent-config
     -->
     <target name="delete-nodeagent-config">
       <echo message= "****delete-nodeagent-config ${nodeagent.name}"/>
        <exec executable="${exec.asadmin}" >
            <arg line="${exec.asadmin.part2}" />
            <arg line="delete-node-agent-config"/>
            <arg line="--user ${admin.user}"/>
            <arg line="--passwordfile ${password.file}"/>
            <arg line="--host ${server.host}"/>
            <arg line="--port ${server.port}"/>
            <arg line="${nodeagent.name}"/>
        </exec>
     </target>
     <!--
        create-cluster
     -->
     <target name="create-cluster">
        <exec executable="${exec.asadmin}" >
            <arg line="${exec.asadmin.part2}" />
            <arg line="create-cluster"/>
            <arg line="--user ${admin.user}"/>
            <arg line="--passwordfile ${password.file}"/>
            <arg line=" ${cluster.name}"/>
        </exec>
     </target>


     <!--
        start-cluster
     -->
     <target name="start-cluster.win" if="isWindowsPlatform">
        <spawn executable="${exec.asadmin}" >
            <arg line="${exec.asadmin.part2}" />
            <arg line="start-cluster"/>
            <arg line="--user ${admin.user}"/>
            <arg line="--passwordfile ${password.file}"/>
            <arg line=" ${cluster.name}"/>
        </spawn>
       <echo message="Sleeping for ${server.start.delay.mins} minutes waiting for clusterto start"/>
        <sleep minutes="${server.start.delay.mins}"/>
     </target>
     <target name="start-cluster.unix" if="isUnixPlatform">
        <exec executable="${exec.asadmin}" >
            <arg line="${exec.asadmin.part2}" />
            <arg line="start-cluster"/>
            <arg line="--user ${admin.user}"/>
            <arg line="--passwordfile ${password.file}"/>
            <arg line=" ${cluster.name}"/>
        </exec>
     </target>
     <target name="start-cluster" depends="configPlatform">
       <antcall target="start-cluster.win"/>
       <antcall target="start-cluster.unix"/>
     </target>


     <!--
        start-instance
     -->
     <target name="start-instance.win" if="isWindowsPlatform">
        <spawn executable="${exec.asadmin}" >
            <arg line="${exec.asadmin.part2}" />
            <arg line="start-instance"/>
            <arg line="--user ${admin.user}"/>
            <arg line="--passwordfile ${password.file}"/>
            <arg line="--host ${server.host}"/>
            <arg line="--port ${server.port}"/>
            <arg line=" ${instance.name}"/>
        </spawn>
        <echo message="Sleeping for ${server.start.delay.mins} minutes waiting for remote instance to start"/>
        <sleep minutes="${server.start.delay.mins}"/>
     </target>
     <target name="start-instance.unix" if="isUnixPlatform">
        <exec executable="${exec.asadmin}" >
            <arg line="${exec.asadmin.part2}" />
            <arg line="start-instance"/>
            <arg line="--user ${admin.user}"/>
            <arg line="--passwordfile ${password.file}"/>
            <arg line="--host ${server.host}"/>
            <arg line="--port ${server.port}"/>
            <arg line=" ${instance.name}"/>
        </exec>
     </target>
     <target name="start-instance" depends="configPlatform">
       <antcall target="start-instance.win"/>
       <antcall target="start-instance.unix"/>
     </target>

     <!--
        stop-instance
     -->
     <target name="stop-instance" depends="configPlatform">
        <exec executable="${exec.asadmin}" >
            <arg line="${exec.asadmin.part2}" />
            <arg line="stop-instance"/>
            <arg line="--user ${admin.user}"/>
            <arg line="--passwordfile ${password.file}"/>
            <arg line="--host ${server.host}"/>
            <arg line="--port ${server.port}"/>
            <arg line=" ${instance.name}"/>
        </exec> 
        <echo message="Sleeping for ${server.start.delay.mins} minutes waiting for instance to stop"/>
        <sleep minutes="${server.start.delay.mins}"/>       
     </target>

     <!--
        delete-instance
     -->
     <target name="delete-instance">
        <exec executable="${exec.asadmin}" >
            <arg line="${exec.asadmin.part2}" />
            <arg line="delete-instance"/>
            <arg line="--user ${admin.user}"/>
            <arg line="--passwordfile ${password.file}"/>
            <arg line="--host ${server.host}"/>
            <arg line="--port ${server.port}"/>
            <arg line=" ${instance.name}"/>
        </exec>
     </target>

     <!--
        create-system-properties
     -->
     <target name="create-system-properties" >
        <exec executable="${exec.asadmin}" >
            <arg line="${exec.asadmin.part2}" />
            <arg line="--user ${admin.user}"/>
            <arg line="--host ${server.host}"/>
            <arg line="--port ${server.port}"/>
            <arg line="--passwordfile ${password.file}"/>
            <arg line="create-system-properties"/>
            <arg line=" ${property}"/>
        </exec>
     </target>
    
  <!-- Adding wss security providers to secure SOAP messages -->

  <target name="enable.wss.providers"  >
      <!-- Add default server provider -->
     <echo message="Adding default server provider" />
        <antcall target="enable.server.provider">
        </antcall>

      <!-- Add default server side client provider -->
     <echo message="Adding default server side client provider" />
        <antcall target="enable.serverside.client.provider">
        </antcall>
       
     <echo message="Coping sun-acc.xml.template to the appserver config directory" />
     
     <copy file="${javaee.home}/lib/install/templates/${sun-acc.xml.template}" 
             tofile="${javaee.home}/lib/install/templates/${sun-acc.xml.template.orig}" overwrite="yes">
     </copy>
     
     <echo message="Coping wss-client-config.xml to the appserver lib directory" />
     
     <copy file="${javaee.home}/lib/appclient/wss-client-config.xml" 
             tofile="${javaee.home}/lib/appclient/wss-client-config.xml.orig" overwrite="yes">
     </copy>
     
     <copy file="${ts.home}/src/com/sun/ts/tests/jaspic/ejb/xms/wss-client-config.xml" 
             tofile="${javaee.home}/lib/appclient/wss-client-config.xml" overwrite="yes">
     </copy>

     <copy file="${ts.home}/src/com/sun/ts/tests/jaspic/ejb/xms/${sun-acc.xml.template}" 
             tofile="${javaee.home}/lib/install/templates/${sun-acc.xml.template}" overwrite="yes">
        <filterset begintoken="%%%" endtoken="%%%">
        <filter token="INSTALL_ROOT" value="${javaee.home}" />
        <filter token="SERVER_NAME" value="${s1as.admin.host}" />
        <filter token="ORB_LISTENER_PORT" value="${orb.port.ri}" />
     </filterset>
     </copy>

  </target>

   <target name="enable.server.provider" >
           <property name="exec.asadmin" value="${cli.path}" />
           <property name="exec.asadmin.part2" value="" />
            <exec executable="${exec.asadmin}" >
            <arg line="${exec.asadmin.part2}" /> 
            <arg line=" set "/>
            <arg line=" server-config.security-service.message-security-config.SOAP.default_provider=ServerProvider"/>
        </exec>
     </target>

  <target name="enable.serverside.client.provider" >
           <property name="exec.asadmin" value="${cli.path}" />
           <property name="exec.asadmin.part2" value="" />
        <exec executable="${exec.asadmin}" >
            <arg line="${exec.asadmin.part2}" />
            <arg line="set "/>
            <arg line="server-config.security-service.message-security-config.SOAP.default_client_provider=ClientProvider "/>
        </exec>
     </target>
    
    <!--
       Disable wss providers configuration 
    -->
   <target name="disable.wss.providers" depends="configPlatform">
        <property name="exec.asadmin" value="${cli.path}" />
        <property name="exec.asadmin.part2" value="" />
        <exec executable="${exec.asadmin}" >
            <arg line="${exec.asadmin.part2}" />
            <arg line="set "/>
            <arg line=" server-config.security-service.message-security-config.SOAP.default_provider="/>
        </exec>
     <echo message="Removing wss client-provider" />
        <property name="exec.asadmin" value="${cli.path}" />
        <property name="exec.asadmin.part2" value="" />
        <exec executable="${exec.asadmin}" >
            <arg line="${exec.asadmin.part2}" />
            <arg line="set "/>
            <arg line="server-config.security-service.message-security-config.SOAP.default_client_provider="/>
        </exec> 
    
    <echo message="Reverting to default sun-acc.xml" />
    
    <copy file="${javaee.home}/lib/install/templates/${sun-acc.xml.template.orig}" 
             tofile="${javaee.home}/lib/install/templates/${sun-acc.xml.template}" overwrite="yes">
     </copy>
     
     <echo message="Coping wss-client-config.xml to the appserver lib directory" />
     
     <copy file="${javaee.home}/lib/appclient/wss-client-config.xml.orig" 
             tofile="${javaee.home}/lib/appclient/wss-client-config.xml" overwrite="yes">
     </copy>

      <!-- Restart server -->
        <antcall target="restart.server" />
   </target>

    <!--
       Enable the configuration required by jacc   
    -->
    <target name="enable.jacc" depends="configPlatform" >
        <antcall target="create.jacc.vm.options"/>
    </target>

    <!--
        config the required jvm options for the JPA tests
    -->
    <target name="create.jpa.vm.options" depends="configPlatform">
         <antcall target="create-one-jvm-option" >
          <param name="jvm.options" value=" -Dlog.file.location=${log.file.location}"/>
         </antcall>
    </target>

   <target name="delete.jpa.vm.options" depends="configPlatform">
         <antcall target="delete-one-jvm-option" >
          <param name="jvm.options" value=" -Dlog.file.location=${log.file.location}"/>
         </antcall>
   </target>

    <!--
       This target was created because we have tools, namely the runcts ant task,
       that would like to be able to add the JVM options for JACC but not call
       server restart.  This was due to techical glitches when restarting the server
       from a spawned process in the task.
    -->
    <target name="create.jacc.vm.options" depends="configPlatform">
         <antcall target="create-jvm-options" >
          <param name="jvm.options" value=" -Djavax.security.jacc.policy.provider=com.sun.ts.tests.jacc.provider.TSPolicy"/>
         </antcall>

         <antcall target="create-jvm-options" >
          <param name="jvm.options" value=" -Dvendor.javax.security.jacc.policy.provider=com.sun.enterprise.security.provider.PolicyWrapper"/>
         </antcall>

         <antcall target="create-jvm-options" >
          <param name="jvm.options" value=" -Djavax.security.jacc.PolicyConfigurationFactory.provider=com.sun.ts.tests.jacc.provider.TSPolicyConfigurationFactoryImpl"/>
         </antcall>

         <antcall target="create-jvm-options" >
          <param name="jvm.options" value=" -Dvendor.javax.security.jacc.PolicyConfigurationFactory.provider=com.sun.enterprise.security.provider.PolicyConfigurationFactoryImpl "/>
         </antcall>

         <antcall target="create-one-jvm-option" >
          <param name="jvm.options" value=" -Dlog.file.location=${log.file.location}"/>
         </antcall>
    </target>

    <!--
       Disable jacc configuration 
    -->
    <target name="disable.jacc" depends="configPlatform" >
         <antcall target="delete.jacc.vm.options"/>
         <antcall target="restart.server"/>
    </target>


    <!--
       This target was created because we have tools, namely the runcts ant task,
       that would like to be able to remove the JVM options for JACC but not call
       server restart.  This was due to techical glitches when restarting the server
       from a spawned process in the task.
    -->
    <target name="delete.jacc.vm.options" depends="configPlatform">
         <antcall target="delete-jvm-options" >
          <param name="jvm.options" value=" -Djavax.security.jacc.policy.provider=com.sun.ts.tests.jacc.provider.TSPolicy"/>
         </antcall>
        
         <antcall target="delete-jvm-options" >
          <param name="jvm.options" value=" -Dvendor.javax.security.jacc.policy.provider=com.sun.enterprise.security.provider.PolicyWrapper"/>
         </antcall>

         <antcall target="delete-jvm-options" >
          <param name="jvm.options" value=" -Djavax.security.jacc.PolicyConfigurationFactory.provider=com.sun.ts.tests.jacc.provider.TSPolicyConfigurationFactoryImpl"/>
         </antcall>

         <antcall target="delete-jvm-options" >
          <param name="jvm.options" value=" -Dvendor.javax.security.jacc.PolicyConfigurationFactory.provider=com.sun.enterprise.security.provider.PolicyConfigurationFactoryImpl "/>
         </antcall>

         <antcall target="delete-one-jvm-option" >
          <param name="jvm.options" value=" -Dlog.file.location=${log.file.location}"/>
         </antcall>
     </target>


     <!--
         Get the platform version and store the return value in
         the property "platformVersion".  Currently this method is only
         required by the target start.appserver
     -->
     <target name="get.platform.version" depends="configPlatform" unless="gotVersion">
        <exec executable="${exec.asadmin}"  outputproperty="platformVersion">
            <arg line="${exec.asadmin.part2}" />
            <arg line=" version"/>
            <arg line=" --user ${admin.user}"/>
            <arg line=" --passwordfile ${password.file}"/>
            <arg line=" --host ${server.host}"/>
            <arg line=" --port ${server.port}"/>
        </exec>

     </target>
        
     <!--
       Used to create a password file for SJSAS.  Only needed by SJSAS 8.1 but it is
       compatible
       -->
     <target name="filter.password.file" depends="configPlatform">
       <copy file="${password.file.template}"
             tofile="${password.file}"
             overwrite="true"
             force="true">
        <filterset>
           <filter token="sjsas.master.password" value="${sjsas.master.password}"/>
           <filter token="sjsas.admin.password" value="${admin.password}"/>
         </filterset>
       </copy>
     </target>

     <!--
         For Appserver EE: Import RI's server certificate into EE's 
         certificate database using certutil
     -->
     <target name="import.into.nss.databases" if="found.nss.databases" >
          <echo message="Importing RI's server certificate into NSS database" />
          <exec executable="${exec.certutil}">
            <env key="JAVA_HOME" value="${java.home}" />
            <arg line=" ${exec.certutil.part2}" />
            <arg line=" -A" />
            <arg line=" -a" />
            <arg line=" -n" />
            <arg line=" ricert" />
            <arg line=" -t" />
            <arg line=" CTP,CTP,CTP" />
            <arg line=" -d" />
            <arg line=" ${NSSConfigDir}" />
            <arg line=" -i" />
            <arg line=" ${ts.home}/tmp/ri_server_cert.file" />
          </exec>
     </target>

<!-- Please remove if the new version of SE fixes this issue, see start.javadb above for details.
     <target name="set.fileSyncTransactionLogValue.mac" if="isMac">
       <property name="fileSyncTransactionLogValue" value="true"/>
     </target>

     <target name="set.fileSyncTransactionLogValue.non.mac" unless="isMac">
       <property name="fileSyncTransactionLogValue" value="false"/>       
     </target>
-->


	<!-- 
	     GF V3.1.2 build 14 now requires an admin password be set before the
	     domain is started.  This target sets the admin password to the value
	     defined in the ts.jte.  The s1as.admin.passwd property for the VI and
	     ri.admin.passwd for the RI.  Eventually this target will be called by
	     config.vi but for now users will need to invoke this target
	     manually.  There are just too many different versions of GF under test
	     and we don't want to be in the business of parsing GF version strings
	     and ending up with giant if/else blocks everywhere.  When there is an
	     official 3.1.2 RI available, this target can also be called from
	     config.ri (if necessary).
	     
	     The current.admin.password can be used to specify an existing password
	     other than the empty string.  Useful if users find a reason to call
	     this target after a non-empty string password has been set (seems like
	     a rare use case).  The default value is the empty string since that is
	     the out-of-the-box admin password.
	-->
	<property name="current.admin.password" value=""/>
	<target name="change.admin.password" depends="configPlatform">
        <echo>******* BEGIN. CHANGE ADMIN PASSWORD ********</echo>
		<property name="temp.pass.file" value="${ts.home}/tmp/change-admin-password.txt"/>
        <delete file="${temp.pass.file}" quiet="true"/>
        <echo file="${temp.pass.file}">AS_ADMIN_PASSWORD=${current.admin.password}
AS_ADMIN_NEWPASSWORD=${admin.password}</echo>
        <exec executable="${exec.asadmin}">
          <arg line="${exec.asadmin.part2}" />
          <arg line=" --user ${admin.user}"/>
          <arg line=" --passwordfile ${temp.pass.file}"/>
          <arg line=" change-admin-password"/>
          <arg line=" --domain_name"/>
          <arg line=" ${server.domain.name}"/>
        </exec>
        <loadfile srcFile="${temp.pass.file}" property="password.contents"/>
        <echo>Contents of ${temp.pass.file}:</echo>
        <echo>${password.contents}</echo>
        <delete file="${temp.pass.file}"/>
        <echo>******* DONE. CHANGE ADMIN PASSWORD ********</echo>
	</target>
	
	
	<!--
	  Adding a target to enable secure administration.  This needs to be done
	  for cases where we wish to manage a remote machine.  As an example,
	  deploying from the VI to the RI requires that remote administration be
	  enabled on the RI.  This target will eventually be tied to the config.ri
	  target (when a new GF 3.1.2 RI is released).  It looks like this target
	  may never be applicable to the VI but it is located here in common.xml
	  in case it is ever needed on the VI side.
	  
	  If/when this target is called from config.ri, remove the
	  filter.password.file dependency since this happens prior to this target
	  being invoked (in javaee_ri.xml=>config.ri).
	  
	  This is not a local command so the domain must be running to execute
	  this command.  The admin password will also have to be set to a non-empty
	  string before running this command (use change.admin.password target).
	  To run this command stand alone, you must call filter.password.file as a
	  precondition.  Remove this paragraph once this target is called from
	  config.ri since all these issues are handled there.
	  
	  To invoke stand-alone (until it is added to config.ri):
	    ant -f TS_HOME/install/jakartaee/bin/xml/impl/glassfish/javaee_ri.xml \
	        enable.secure.admin
	-->
	<target name="enable.secure.admin" depends="filter.password.file, configPlatform">
        <echo>******* BEGIN. ENABLE SECURE ADMIN ********</echo>
        <exec executable="${exec.asadmin}">
          <arg line="${exec.asadmin.part2}" />
          <arg line=" --user ${admin.user}"/>
          <arg line=" --passwordfile ${password.file}"/>
          <arg line=" --host ${server.host}"/>
          <arg line=" --port ${server.port}"/>
          <arg line=" enable-secure-admin"/>
        </exec>
        <echo>******* DONE. ENABLE SECURE ADMIN ********</echo>
    </target>
	
</project>
