#Signature file v4.3
#Version 2.0_se8

# Copyright (c) 2018 Oracle and/or its affiliates. All rights reserved.


CLSS public jakarta.enterprise.concurrent.AbortedException
cons public <init>()
cons public <init>(java.lang.String)
cons public <init>(java.lang.String,java.lang.Throwable)
cons public <init>(java.lang.Throwable)
intf java.io.Serializable
supr java.util.concurrent.ExecutionException
hfds serialVersionUID

CLSS public abstract interface jakarta.enterprise.concurrent.ContextService
meth public abstract !varargs java.lang.Object createContextualProxy(java.lang.Object,java.lang.Class<?>[])
meth public abstract !varargs java.lang.Object createContextualProxy(java.lang.Object,java.util.Map<java.lang.String,java.lang.String>,java.lang.Class<?>[])
meth public abstract <%0 extends java.lang.Object> {%%0} createContextualProxy({%%0},java.lang.Class<{%%0}>)
meth public abstract <%0 extends java.lang.Object> {%%0} createContextualProxy({%%0},java.util.Map<java.lang.String,java.lang.String>,java.lang.Class<{%%0}>)
meth public abstract java.util.Map<java.lang.String,java.lang.String> getExecutionProperties(java.lang.Object)

CLSS public abstract interface jakarta.enterprise.concurrent.LastExecution
meth public abstract java.lang.Object getResult()
meth public abstract java.lang.String getIdentityName()
meth public abstract java.util.Date getRunEnd()
meth public abstract java.util.Date getRunStart()
meth public abstract java.util.Date getScheduledStart()

CLSS public abstract interface jakarta.enterprise.concurrent.ManageableThread
meth public abstract boolean isShutdown()

CLSS public abstract interface jakarta.enterprise.concurrent.ManagedExecutorService
intf java.util.concurrent.ExecutorService

CLSS public jakarta.enterprise.concurrent.ManagedExecutors
meth public static <%0 extends java.lang.Object> java.util.concurrent.Callable<{%%0}> managedTask(java.util.concurrent.Callable<{%%0}>,jakarta.enterprise.concurrent.ManagedTaskListener)
meth public static <%0 extends java.lang.Object> java.util.concurrent.Callable<{%%0}> managedTask(java.util.concurrent.Callable<{%%0}>,java.util.Map<java.lang.String,java.lang.String>,jakarta.enterprise.concurrent.ManagedTaskListener)
meth public static boolean isCurrentThreadShutdown()
meth public static java.lang.Runnable managedTask(java.lang.Runnable,jakarta.enterprise.concurrent.ManagedTaskListener)
meth public static java.lang.Runnable managedTask(java.lang.Runnable,java.util.Map<java.lang.String,java.lang.String>,jakarta.enterprise.concurrent.ManagedTaskListener)
supr java.lang.Object
hfds NULL_TASK_ERROR_MSG
hcls Adapter,CallableAdapter,RunnableAdapter

CLSS public abstract interface jakarta.enterprise.concurrent.ManagedScheduledExecutorService
intf jakarta.enterprise.concurrent.ManagedExecutorService
intf java.util.concurrent.ScheduledExecutorService
meth public abstract <%0 extends java.lang.Object> java.util.concurrent.ScheduledFuture<{%%0}> schedule(java.util.concurrent.Callable<{%%0}>,jakarta.enterprise.concurrent.Trigger)
meth public abstract java.util.concurrent.ScheduledFuture<?> schedule(java.lang.Runnable,jakarta.enterprise.concurrent.Trigger)

CLSS public abstract interface jakarta.enterprise.concurrent.ManagedTask
fld public final static java.lang.String IDENTITY_NAME = "javax.enterprise.concurrent.IDENTITY_NAME"
fld public final static java.lang.String LONGRUNNING_HINT = "javax.enterprise.concurrent.LONGRUNNING_HINT"
fld public final static java.lang.String SUSPEND = "SUSPEND"
fld public final static java.lang.String TRANSACTION = "javax.enterprise.concurrent.TRANSACTION"
fld public final static java.lang.String USE_TRANSACTION_OF_EXECUTION_THREAD = "USE_TRANSACTION_OF_EXECUTION_THREAD"
meth public abstract jakarta.enterprise.concurrent.ManagedTaskListener getManagedTaskListener()
meth public abstract java.util.Map<java.lang.String,java.lang.String> getExecutionProperties()

CLSS public abstract interface jakarta.enterprise.concurrent.ManagedTaskListener
meth public abstract void taskAborted(java.util.concurrent.Future<?>,jakarta.enterprise.concurrent.ManagedExecutorService,java.lang.Object,java.lang.Throwable)
meth public abstract void taskDone(java.util.concurrent.Future<?>,jakarta.enterprise.concurrent.ManagedExecutorService,java.lang.Object,java.lang.Throwable)
meth public abstract void taskStarting(java.util.concurrent.Future<?>,jakarta.enterprise.concurrent.ManagedExecutorService,java.lang.Object)
meth public abstract void taskSubmitted(java.util.concurrent.Future<?>,jakarta.enterprise.concurrent.ManagedExecutorService,java.lang.Object)

CLSS public abstract interface jakarta.enterprise.concurrent.ManagedThreadFactory
intf java.util.concurrent.ThreadFactory

CLSS public jakarta.enterprise.concurrent.SkippedException
cons public <init>()
cons public <init>(java.lang.String)
cons public <init>(java.lang.String,java.lang.Throwable)
cons public <init>(java.lang.Throwable)
intf java.io.Serializable
supr java.util.concurrent.ExecutionException
hfds serialVersionUID

CLSS public abstract interface jakarta.enterprise.concurrent.Trigger
meth public abstract boolean skipRun(jakarta.enterprise.concurrent.LastExecution,java.util.Date)
meth public abstract java.util.Date getNextRunTime(jakarta.enterprise.concurrent.LastExecution,java.util.Date)

CLSS public abstract interface !annotation jakarta.enterprise.context.ApplicationScoped
 anno 0 jakarta.enterprise.context.NormalScope(boolean passivating=false)
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Inherited()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[TYPE, METHOD, FIELD])
innr public final static Literal
intf java.lang.annotation.Annotation

CLSS public final static jakarta.enterprise.context.ApplicationScoped$Literal
 outer jakarta.enterprise.context.ApplicationScoped
cons public <init>()
fld public final static jakarta.enterprise.context.ApplicationScoped$Literal INSTANCE
intf jakarta.enterprise.context.ApplicationScoped
supr jakarta.enterprise.util.AnnotationLiteral<jakarta.enterprise.context.ApplicationScoped>
hfds serialVersionUID

CLSS public abstract interface !annotation jakarta.enterprise.context.BeforeDestroyed
 anno 0 jakarta.inject.Qualifier()
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[TYPE, METHOD, PARAMETER, FIELD])
innr public final static Literal
intf java.lang.annotation.Annotation
meth public abstract java.lang.Class<? extends java.lang.annotation.Annotation> value()

CLSS public final static jakarta.enterprise.context.BeforeDestroyed$Literal
 outer jakarta.enterprise.context.BeforeDestroyed
fld public final static jakarta.enterprise.context.BeforeDestroyed$Literal APPLICATION
fld public final static jakarta.enterprise.context.BeforeDestroyed$Literal CONVERSATION
fld public final static jakarta.enterprise.context.BeforeDestroyed$Literal REQUEST
fld public final static jakarta.enterprise.context.BeforeDestroyed$Literal SESSION
intf jakarta.enterprise.context.BeforeDestroyed
meth public java.lang.Class<? extends java.lang.annotation.Annotation> value()
meth public static jakarta.enterprise.context.BeforeDestroyed$Literal of(java.lang.Class<? extends java.lang.annotation.Annotation>)
supr jakarta.enterprise.util.AnnotationLiteral<jakarta.enterprise.context.BeforeDestroyed>
hfds serialVersionUID,value

CLSS public jakarta.enterprise.context.BusyConversationException
cons public <init>()
cons public <init>(java.lang.String)
cons public <init>(java.lang.String,java.lang.Throwable)
cons public <init>(java.lang.Throwable)
supr jakarta.enterprise.context.ContextException
hfds serialVersionUID

CLSS public jakarta.enterprise.context.ContextException
cons public <init>()
cons public <init>(java.lang.String)
cons public <init>(java.lang.String,java.lang.Throwable)
cons public <init>(java.lang.Throwable)
supr java.lang.RuntimeException
hfds serialVersionUID

CLSS public jakarta.enterprise.context.ContextNotActiveException
cons public <init>()
cons public <init>(java.lang.String)
cons public <init>(java.lang.String,java.lang.Throwable)
cons public <init>(java.lang.Throwable)
supr jakarta.enterprise.context.ContextException
hfds serialVersionUID

CLSS public abstract interface jakarta.enterprise.context.Conversation
meth public abstract boolean isTransient()
meth public abstract java.lang.String getId()
meth public abstract long getTimeout()
meth public abstract void begin()
meth public abstract void begin(java.lang.String)
meth public abstract void end()
meth public abstract void setTimeout(long)

CLSS public abstract interface !annotation jakarta.enterprise.context.ConversationScoped
 anno 0 jakarta.enterprise.context.NormalScope(boolean passivating=true)
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Inherited()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[TYPE, METHOD, FIELD])
innr public final static Literal
intf java.lang.annotation.Annotation

CLSS public final static jakarta.enterprise.context.ConversationScoped$Literal
 outer jakarta.enterprise.context.ConversationScoped
cons public <init>()
fld public final static jakarta.enterprise.context.ConversationScoped$Literal INSTANCE
intf jakarta.enterprise.context.ConversationScoped
supr jakarta.enterprise.util.AnnotationLiteral<jakarta.enterprise.context.ConversationScoped>
hfds serialVersionUID

CLSS public abstract interface !annotation jakarta.enterprise.context.Dependent
 anno 0 jakarta.inject.Scope()
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Inherited()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[METHOD, TYPE, FIELD])
innr public final static Literal
intf java.lang.annotation.Annotation

CLSS public final static jakarta.enterprise.context.Dependent$Literal
 outer jakarta.enterprise.context.Dependent
cons public <init>()
fld public final static jakarta.enterprise.context.Dependent$Literal INSTANCE
intf jakarta.enterprise.context.Dependent
supr jakarta.enterprise.util.AnnotationLiteral<jakarta.enterprise.context.Dependent>
hfds serialVersionUID

CLSS public abstract interface !annotation jakarta.enterprise.context.Destroyed
 anno 0 jakarta.inject.Qualifier()
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[TYPE, METHOD, PARAMETER, FIELD])
innr public final static Literal
intf java.lang.annotation.Annotation
meth public abstract java.lang.Class<? extends java.lang.annotation.Annotation> value()

CLSS public final static jakarta.enterprise.context.Destroyed$Literal
 outer jakarta.enterprise.context.Destroyed
fld public final static jakarta.enterprise.context.Destroyed$Literal APPLICATION
fld public final static jakarta.enterprise.context.Destroyed$Literal CONVERSATION
fld public final static jakarta.enterprise.context.Destroyed$Literal REQUEST
fld public final static jakarta.enterprise.context.Destroyed$Literal SESSION
intf jakarta.enterprise.context.Destroyed
meth public java.lang.Class<? extends java.lang.annotation.Annotation> value()
meth public static jakarta.enterprise.context.Destroyed$Literal of(java.lang.Class<? extends java.lang.annotation.Annotation>)
supr jakarta.enterprise.util.AnnotationLiteral<jakarta.enterprise.context.Destroyed>
hfds serialVersionUID,value

CLSS public abstract interface !annotation jakarta.enterprise.context.Initialized
 anno 0 jakarta.inject.Qualifier()
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[TYPE, METHOD, PARAMETER, FIELD])
innr public final static Literal
intf java.lang.annotation.Annotation
meth public abstract java.lang.Class<? extends java.lang.annotation.Annotation> value()

CLSS public final static jakarta.enterprise.context.Initialized$Literal
 outer jakarta.enterprise.context.Initialized
fld public final static jakarta.enterprise.context.Initialized$Literal APPLICATION
fld public final static jakarta.enterprise.context.Initialized$Literal CONVERSATION
fld public final static jakarta.enterprise.context.Initialized$Literal REQUEST
fld public final static jakarta.enterprise.context.Initialized$Literal SESSION
intf jakarta.enterprise.context.Initialized
meth public java.lang.Class<? extends java.lang.annotation.Annotation> value()
meth public static jakarta.enterprise.context.Initialized$Literal of(java.lang.Class<? extends java.lang.annotation.Annotation>)
supr jakarta.enterprise.util.AnnotationLiteral<jakarta.enterprise.context.Initialized>
hfds serialVersionUID,value

CLSS public jakarta.enterprise.context.NonexistentConversationException
cons public <init>()
cons public <init>(java.lang.String)
cons public <init>(java.lang.String,java.lang.Throwable)
cons public <init>(java.lang.Throwable)
supr jakarta.enterprise.context.ContextException
hfds serialVersionUID

CLSS public abstract interface !annotation jakarta.enterprise.context.NormalScope
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[ANNOTATION_TYPE])
intf java.lang.annotation.Annotation
meth public abstract !hasdefault boolean passivating() value= false

CLSS public abstract interface !annotation jakarta.enterprise.context.RequestScoped
 anno 0 jakarta.enterprise.context.NormalScope(boolean passivating=false)
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Inherited()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[TYPE, METHOD, FIELD])
innr public final static Literal
intf java.lang.annotation.Annotation

CLSS public final static jakarta.enterprise.context.RequestScoped$Literal
 outer jakarta.enterprise.context.RequestScoped
cons public <init>()
fld public final static jakarta.enterprise.context.RequestScoped$Literal INSTANCE
intf jakarta.enterprise.context.RequestScoped
supr jakarta.enterprise.util.AnnotationLiteral<jakarta.enterprise.context.RequestScoped>
hfds serialVersionUID

CLSS public abstract interface !annotation jakarta.enterprise.context.SessionScoped
 anno 0 jakarta.enterprise.context.NormalScope(boolean passivating=true)
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Inherited()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[TYPE, METHOD, FIELD])
innr public final static Literal
intf java.lang.annotation.Annotation

CLSS public final static jakarta.enterprise.context.SessionScoped$Literal
 outer jakarta.enterprise.context.SessionScoped
cons public <init>()
fld public final static jakarta.enterprise.context.SessionScoped$Literal INSTANCE
intf jakarta.enterprise.context.SessionScoped
supr jakarta.enterprise.util.AnnotationLiteral<jakarta.enterprise.context.SessionScoped>
hfds serialVersionUID

CLSS public abstract interface !annotation jakarta.enterprise.context.control.ActivateRequestContext
 anno 0 jakarta.interceptor.InterceptorBinding()
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[METHOD, TYPE])
intf java.lang.annotation.Annotation

CLSS public abstract interface jakarta.enterprise.context.control.RequestContextController
meth public abstract boolean activate()
meth public abstract void deactivate()

CLSS public abstract interface jakarta.enterprise.context.spi.AlterableContext
intf jakarta.enterprise.context.spi.Context
meth public abstract void destroy(jakarta.enterprise.context.spi.Contextual<?>)

CLSS public abstract interface jakarta.enterprise.context.spi.Context
meth public abstract <%0 extends java.lang.Object> {%%0} get(jakarta.enterprise.context.spi.Contextual<{%%0}>)
meth public abstract <%0 extends java.lang.Object> {%%0} get(jakarta.enterprise.context.spi.Contextual<{%%0}>,jakarta.enterprise.context.spi.CreationalContext<{%%0}>)
meth public abstract boolean isActive()
meth public abstract java.lang.Class<? extends java.lang.annotation.Annotation> getScope()

CLSS public abstract interface jakarta.enterprise.context.spi.Contextual<%0 extends java.lang.Object>
meth public abstract void destroy({jakarta.enterprise.context.spi.Contextual%0},jakarta.enterprise.context.spi.CreationalContext<{jakarta.enterprise.context.spi.Contextual%0}>)
meth public abstract {jakarta.enterprise.context.spi.Contextual%0} create(jakarta.enterprise.context.spi.CreationalContext<{jakarta.enterprise.context.spi.Contextual%0}>)

CLSS public abstract interface jakarta.enterprise.context.spi.CreationalContext<%0 extends java.lang.Object>
meth public abstract void push({jakarta.enterprise.context.spi.CreationalContext%0})
meth public abstract void release()

CLSS public abstract interface jakarta.enterprise.event.Event<%0 extends java.lang.Object>
meth public abstract !varargs <%0 extends {jakarta.enterprise.event.Event%0}> jakarta.enterprise.event.Event<{%%0}> select(jakarta.enterprise.util.TypeLiteral<{%%0}>,java.lang.annotation.Annotation[])
meth public abstract !varargs <%0 extends {jakarta.enterprise.event.Event%0}> jakarta.enterprise.event.Event<{%%0}> select(java.lang.Class<{%%0}>,java.lang.annotation.Annotation[])
meth public abstract !varargs jakarta.enterprise.event.Event<{jakarta.enterprise.event.Event%0}> select(java.lang.annotation.Annotation[])
meth public abstract <%0 extends {jakarta.enterprise.event.Event%0}> java.util.concurrent.CompletionStage<{%%0}> fireAsync({%%0})
meth public abstract <%0 extends {jakarta.enterprise.event.Event%0}> java.util.concurrent.CompletionStage<{%%0}> fireAsync({%%0},jakarta.enterprise.event.NotificationOptions)
meth public abstract void fire({jakarta.enterprise.event.Event%0})

CLSS public abstract interface jakarta.enterprise.event.NotificationOptions
innr public abstract interface static Builder
meth public abstract java.lang.Object get(java.lang.String)
meth public abstract java.util.concurrent.Executor getExecutor()
meth public static jakarta.enterprise.event.NotificationOptions of(java.lang.String,java.lang.Object)
meth public static jakarta.enterprise.event.NotificationOptions ofExecutor(java.util.concurrent.Executor)
meth public static jakarta.enterprise.event.NotificationOptions$Builder builder()

CLSS public abstract interface static jakarta.enterprise.event.NotificationOptions$Builder
 outer jakarta.enterprise.event.NotificationOptions
meth public abstract jakarta.enterprise.event.NotificationOptions build()
meth public abstract jakarta.enterprise.event.NotificationOptions$Builder set(java.lang.String,java.lang.Object)
meth public abstract jakarta.enterprise.event.NotificationOptions$Builder setExecutor(java.util.concurrent.Executor)

CLSS public jakarta.enterprise.event.ObserverException
cons public <init>()
cons public <init>(java.lang.String)
cons public <init>(java.lang.String,java.lang.Throwable)
cons public <init>(java.lang.Throwable)
supr java.lang.RuntimeException
hfds serialVersionUID

CLSS public abstract interface !annotation jakarta.enterprise.event.Observes
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[PARAMETER])
intf java.lang.annotation.Annotation
meth public abstract !hasdefault jakarta.enterprise.event.Reception notifyObserver() value= ALWAYS
meth public abstract !hasdefault jakarta.enterprise.event.TransactionPhase during() value= IN_PROGRESS

CLSS public abstract interface !annotation jakarta.enterprise.event.ObservesAsync
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[PARAMETER])
intf java.lang.annotation.Annotation
meth public abstract !hasdefault jakarta.enterprise.event.Reception notifyObserver() value= ALWAYS

CLSS public final !enum jakarta.enterprise.event.Reception
fld public final static jakarta.enterprise.event.Reception ALWAYS
fld public final static jakarta.enterprise.event.Reception IF_EXISTS
meth public static jakarta.enterprise.event.Reception valueOf(java.lang.String)
meth public static jakarta.enterprise.event.Reception[] values()
supr java.lang.Enum<jakarta.enterprise.event.Reception>

CLSS public final !enum jakarta.enterprise.event.TransactionPhase
fld public final static jakarta.enterprise.event.TransactionPhase AFTER_COMPLETION
fld public final static jakarta.enterprise.event.TransactionPhase AFTER_FAILURE
fld public final static jakarta.enterprise.event.TransactionPhase AFTER_SUCCESS
fld public final static jakarta.enterprise.event.TransactionPhase BEFORE_COMPLETION
fld public final static jakarta.enterprise.event.TransactionPhase IN_PROGRESS
meth public static jakarta.enterprise.event.TransactionPhase valueOf(java.lang.String)
meth public static jakarta.enterprise.event.TransactionPhase[] values()
supr java.lang.Enum<jakarta.enterprise.event.TransactionPhase>

CLSS public abstract interface !annotation jakarta.enterprise.inject.Alternative
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[TYPE, METHOD, FIELD])
innr public final static Literal
intf java.lang.annotation.Annotation

CLSS public final static jakarta.enterprise.inject.Alternative$Literal
 outer jakarta.enterprise.inject.Alternative
cons public <init>()
fld public final static jakarta.enterprise.inject.Alternative$Literal INSTANCE
intf jakarta.enterprise.inject.Alternative
supr jakarta.enterprise.util.AnnotationLiteral<jakarta.enterprise.inject.Alternative>
hfds serialVersionUID

CLSS public jakarta.enterprise.inject.AmbiguousResolutionException
cons public <init>()
cons public <init>(java.lang.String)
cons public <init>(java.lang.String,java.lang.Throwable)
cons public <init>(java.lang.Throwable)
supr jakarta.enterprise.inject.ResolutionException
hfds serialVersionUID

CLSS public abstract interface !annotation jakarta.enterprise.inject.Any
 anno 0 jakarta.inject.Qualifier()
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[TYPE, METHOD, FIELD, PARAMETER])
innr public final static Literal
intf java.lang.annotation.Annotation

CLSS public final static jakarta.enterprise.inject.Any$Literal
 outer jakarta.enterprise.inject.Any
cons public <init>()
fld public final static jakarta.enterprise.inject.Any$Literal INSTANCE
intf jakarta.enterprise.inject.Any
supr jakarta.enterprise.util.AnnotationLiteral<jakarta.enterprise.inject.Any>
hfds serialVersionUID

CLSS public jakarta.enterprise.inject.CreationException
cons public <init>()
cons public <init>(java.lang.String)
cons public <init>(java.lang.String,java.lang.Throwable)
cons public <init>(java.lang.Throwable)
supr jakarta.enterprise.inject.InjectionException
hfds serialVersionUID

CLSS public abstract interface !annotation jakarta.enterprise.inject.Decorated
 anno 0 jakarta.inject.Qualifier()
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[PARAMETER, FIELD])
intf java.lang.annotation.Annotation

CLSS public abstract interface !annotation jakarta.enterprise.inject.Default
 anno 0 jakarta.inject.Qualifier()
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[TYPE, METHOD, PARAMETER, FIELD])
innr public final static Literal
intf java.lang.annotation.Annotation

CLSS public final static jakarta.enterprise.inject.Default$Literal
 outer jakarta.enterprise.inject.Default
cons public <init>()
fld public final static jakarta.enterprise.inject.Default$Literal INSTANCE
intf jakarta.enterprise.inject.Default
supr jakarta.enterprise.util.AnnotationLiteral<jakarta.enterprise.inject.Default>
hfds serialVersionUID

CLSS public abstract interface !annotation jakarta.enterprise.inject.Disposes
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[PARAMETER])
intf java.lang.annotation.Annotation

CLSS public jakarta.enterprise.inject.IllegalProductException
cons public <init>()
cons public <init>(java.lang.String)
cons public <init>(java.lang.String,java.lang.Throwable)
cons public <init>(java.lang.Throwable)
supr jakarta.enterprise.inject.InjectionException
hfds serialVersionUID

CLSS public jakarta.enterprise.inject.InjectionException
cons public <init>()
cons public <init>(java.lang.String)
cons public <init>(java.lang.String,java.lang.Throwable)
cons public <init>(java.lang.Throwable)
supr java.lang.RuntimeException
hfds serialVersionUID

CLSS public abstract interface jakarta.enterprise.inject.Instance<%0 extends java.lang.Object>
intf jakarta.inject.Provider<{jakarta.enterprise.inject.Instance%0}>
intf java.lang.Iterable<{jakarta.enterprise.inject.Instance%0}>
meth public abstract !varargs <%0 extends {jakarta.enterprise.inject.Instance%0}> jakarta.enterprise.inject.Instance<{%%0}> select(jakarta.enterprise.util.TypeLiteral<{%%0}>,java.lang.annotation.Annotation[])
meth public abstract !varargs <%0 extends {jakarta.enterprise.inject.Instance%0}> jakarta.enterprise.inject.Instance<{%%0}> select(java.lang.Class<{%%0}>,java.lang.annotation.Annotation[])
meth public abstract !varargs jakarta.enterprise.inject.Instance<{jakarta.enterprise.inject.Instance%0}> select(java.lang.annotation.Annotation[])
meth public abstract boolean isAmbiguous()
meth public abstract boolean isUnsatisfied()
meth public abstract void destroy({jakarta.enterprise.inject.Instance%0})
meth public boolean isResolvable()
meth public java.util.stream.Stream<{jakarta.enterprise.inject.Instance%0}> stream()

CLSS public abstract interface !annotation jakarta.enterprise.inject.Intercepted
 anno 0 jakarta.inject.Qualifier()
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[PARAMETER, FIELD])
intf java.lang.annotation.Annotation

CLSS public abstract interface !annotation jakarta.enterprise.inject.Model
 anno 0 jakarta.enterprise.context.RequestScoped()
 anno 0 jakarta.enterprise.inject.Stereotype()
 anno 0 jakarta.inject.Named(java.lang.String value="")
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[TYPE, METHOD, FIELD])
intf java.lang.annotation.Annotation

CLSS public abstract interface !annotation jakarta.enterprise.inject.New
 anno 0 jakarta.inject.Qualifier()
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[FIELD, PARAMETER, METHOD, TYPE])
innr public final static Literal
intf java.lang.annotation.Annotation
meth public abstract !hasdefault java.lang.Class<?> value() value= class jakarta.enterprise.inject.New

CLSS public final static jakarta.enterprise.inject.New$Literal
 outer jakarta.enterprise.inject.New
fld public final static jakarta.enterprise.inject.New$Literal INSTANCE
intf jakarta.enterprise.inject.New
meth public java.lang.Class<?> value()
meth public static jakarta.enterprise.inject.New$Literal of(java.lang.Class<?>)
supr jakarta.enterprise.util.AnnotationLiteral<jakarta.enterprise.inject.New>
hfds serialVersionUID,value

CLSS public abstract interface !annotation jakarta.enterprise.inject.Produces
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[METHOD, FIELD])
intf java.lang.annotation.Annotation

CLSS public jakarta.enterprise.inject.ResolutionException
cons public <init>()
cons public <init>(java.lang.String)
cons public <init>(java.lang.String,java.lang.Throwable)
cons public <init>(java.lang.Throwable)
supr jakarta.enterprise.inject.InjectionException
hfds serialVersionUID

CLSS public abstract interface !annotation jakarta.enterprise.inject.Specializes
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[TYPE, METHOD])
innr public final static Literal
intf java.lang.annotation.Annotation

CLSS public final static jakarta.enterprise.inject.Specializes$Literal
 outer jakarta.enterprise.inject.Specializes
cons public <init>()
fld public final static jakarta.enterprise.inject.Specializes$Literal INSTANCE
intf jakarta.enterprise.inject.Specializes
supr jakarta.enterprise.util.AnnotationLiteral<jakarta.enterprise.inject.Specializes>
hfds serialVersionUID

CLSS public abstract interface !annotation jakarta.enterprise.inject.Stereotype
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[ANNOTATION_TYPE])
intf java.lang.annotation.Annotation

CLSS public abstract interface !annotation jakarta.enterprise.inject.TransientReference
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[PARAMETER])
innr public final static Literal
intf java.lang.annotation.Annotation

CLSS public final static jakarta.enterprise.inject.TransientReference$Literal
 outer jakarta.enterprise.inject.TransientReference
cons public <init>()
fld public final static jakarta.enterprise.inject.TransientReference$Literal INSTANCE
intf jakarta.enterprise.inject.TransientReference
supr jakarta.enterprise.util.AnnotationLiteral<jakarta.enterprise.inject.TransientReference>
hfds serialVersionUID

CLSS public abstract interface !annotation jakarta.enterprise.inject.Typed
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[FIELD, METHOD, TYPE])
innr public final static Literal
intf java.lang.annotation.Annotation
meth public abstract !hasdefault java.lang.Class<?>[] value() value= []

CLSS public final static jakarta.enterprise.inject.Typed$Literal
 outer jakarta.enterprise.inject.Typed
fld public final static jakarta.enterprise.inject.Typed$Literal INSTANCE
intf jakarta.enterprise.inject.Typed
meth public java.lang.Class<?>[] value()
meth public static jakarta.enterprise.inject.Typed$Literal of(java.lang.Class<?>[])
supr jakarta.enterprise.util.AnnotationLiteral<jakarta.enterprise.inject.Typed>
hfds serialVersionUID,value

CLSS public jakarta.enterprise.inject.UnproxyableResolutionException
cons public <init>()
cons public <init>(java.lang.String)
cons public <init>(java.lang.String,java.lang.Throwable)
cons public <init>(java.lang.Throwable)
supr jakarta.enterprise.inject.ResolutionException
hfds serialVersionUID

CLSS public jakarta.enterprise.inject.UnsatisfiedResolutionException
cons public <init>()
cons public <init>(java.lang.String)
cons public <init>(java.lang.String,java.lang.Throwable)
cons public <init>(java.lang.Throwable)
supr jakarta.enterprise.inject.ResolutionException
hfds serialVersionUID

CLSS public abstract interface !annotation jakarta.enterprise.inject.Vetoed
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[TYPE, PACKAGE])
innr public final static Literal
intf java.lang.annotation.Annotation

CLSS public final static jakarta.enterprise.inject.Vetoed$Literal
 outer jakarta.enterprise.inject.Vetoed
cons public <init>()
fld public final static jakarta.enterprise.inject.Vetoed$Literal INSTANCE
intf jakarta.enterprise.inject.Vetoed
supr jakarta.enterprise.util.AnnotationLiteral<jakarta.enterprise.inject.Vetoed>
hfds serialVersionUID

CLSS public final jakarta.enterprise.inject.literal.InjectLiteral
cons public <init>()
fld public final static jakarta.enterprise.inject.literal.InjectLiteral INSTANCE
intf jakarta.inject.Inject
supr jakarta.enterprise.util.AnnotationLiteral<jakarta.inject.Inject>
hfds serialVersionUID

CLSS public final jakarta.enterprise.inject.literal.NamedLiteral
fld public final static jakarta.inject.Named INSTANCE
intf jakarta.inject.Named
meth public java.lang.String value()
meth public static jakarta.enterprise.inject.literal.NamedLiteral of(java.lang.String)
supr jakarta.enterprise.util.AnnotationLiteral<jakarta.inject.Named>
hfds serialVersionUID,value

CLSS public final jakarta.enterprise.inject.literal.QualifierLiteral
cons public <init>()
fld public final static jakarta.enterprise.inject.literal.QualifierLiteral INSTANCE
intf jakarta.inject.Qualifier
supr jakarta.enterprise.util.AnnotationLiteral<jakarta.inject.Qualifier>
hfds serialVersionUID

CLSS public final jakarta.enterprise.inject.literal.SingletonLiteral
cons public <init>()
fld public final static jakarta.enterprise.inject.literal.SingletonLiteral INSTANCE
intf jakarta.inject.Singleton
supr jakarta.enterprise.util.AnnotationLiteral<jakarta.inject.Singleton>
hfds serialVersionUID

CLSS public abstract interface jakarta.enterprise.inject.se.SeContainer
intf jakarta.enterprise.inject.Instance<java.lang.Object>
intf java.lang.AutoCloseable
meth public abstract boolean isRunning()
meth public abstract jakarta.enterprise.inject.spi.BeanManager getBeanManager()
meth public abstract void close()

CLSS public abstract jakarta.enterprise.inject.se.SeContainerInitializer
cons public <init>()
meth public abstract !varargs jakarta.enterprise.inject.se.SeContainerInitializer addBeanClasses(java.lang.Class<?>[])
meth public abstract !varargs jakarta.enterprise.inject.se.SeContainerInitializer addExtensions(jakarta.enterprise.inject.spi.Extension[])
meth public abstract !varargs jakarta.enterprise.inject.se.SeContainerInitializer addExtensions(java.lang.Class<? extends jakarta.enterprise.inject.spi.Extension>[])
meth public abstract !varargs jakarta.enterprise.inject.se.SeContainerInitializer addPackages(boolean,java.lang.Class<?>[])
meth public abstract !varargs jakarta.enterprise.inject.se.SeContainerInitializer addPackages(boolean,java.lang.Package[])
meth public abstract !varargs jakarta.enterprise.inject.se.SeContainerInitializer addPackages(java.lang.Class<?>[])
meth public abstract !varargs jakarta.enterprise.inject.se.SeContainerInitializer addPackages(java.lang.Package[])
meth public abstract !varargs jakarta.enterprise.inject.se.SeContainerInitializer enableDecorators(java.lang.Class<?>[])
meth public abstract !varargs jakarta.enterprise.inject.se.SeContainerInitializer enableInterceptors(java.lang.Class<?>[])
meth public abstract !varargs jakarta.enterprise.inject.se.SeContainerInitializer selectAlternativeStereotypes(java.lang.Class<? extends java.lang.annotation.Annotation>[])
meth public abstract !varargs jakarta.enterprise.inject.se.SeContainerInitializer selectAlternatives(java.lang.Class<?>[])
meth public abstract jakarta.enterprise.inject.se.SeContainer initialize()
meth public abstract jakarta.enterprise.inject.se.SeContainerInitializer addProperty(java.lang.String,java.lang.Object)
meth public abstract jakarta.enterprise.inject.se.SeContainerInitializer disableDiscovery()
meth public abstract jakarta.enterprise.inject.se.SeContainerInitializer setClassLoader(java.lang.ClassLoader)
meth public abstract jakarta.enterprise.inject.se.SeContainerInitializer setProperties(java.util.Map<java.lang.String,java.lang.Object>)
meth public static jakarta.enterprise.inject.se.SeContainerInitializer newInstance()
supr java.lang.Object

CLSS public abstract interface jakarta.enterprise.inject.spi.AfterBeanDiscovery
meth public abstract <%0 extends java.lang.Object> jakarta.enterprise.inject.spi.AnnotatedType<{%%0}> getAnnotatedType(java.lang.Class<{%%0}>,java.lang.String)
meth public abstract <%0 extends java.lang.Object> jakarta.enterprise.inject.spi.configurator.BeanConfigurator<{%%0}> addBean()
meth public abstract <%0 extends java.lang.Object> jakarta.enterprise.inject.spi.configurator.ObserverMethodConfigurator<{%%0}> addObserverMethod()
meth public abstract <%0 extends java.lang.Object> java.lang.Iterable<jakarta.enterprise.inject.spi.AnnotatedType<{%%0}>> getAnnotatedTypes(java.lang.Class<{%%0}>)
meth public abstract void addBean(jakarta.enterprise.inject.spi.Bean<?>)
meth public abstract void addContext(jakarta.enterprise.context.spi.Context)
meth public abstract void addDefinitionError(java.lang.Throwable)
meth public abstract void addObserverMethod(jakarta.enterprise.inject.spi.ObserverMethod<?>)

CLSS public abstract interface jakarta.enterprise.inject.spi.AfterDeploymentValidation
meth public abstract void addDeploymentProblem(java.lang.Throwable)

CLSS public abstract interface jakarta.enterprise.inject.spi.AfterTypeDiscovery
meth public abstract <%0 extends java.lang.Object> jakarta.enterprise.inject.spi.configurator.AnnotatedTypeConfigurator<{%%0}> addAnnotatedType(java.lang.Class<{%%0}>,java.lang.String)
meth public abstract java.util.List<java.lang.Class<?>> getAlternatives()
meth public abstract java.util.List<java.lang.Class<?>> getDecorators()
meth public abstract java.util.List<java.lang.Class<?>> getInterceptors()
meth public abstract void addAnnotatedType(jakarta.enterprise.inject.spi.AnnotatedType<?>,java.lang.String)

CLSS public abstract interface jakarta.enterprise.inject.spi.Annotated
meth public abstract <%0 extends java.lang.annotation.Annotation> java.util.Set<{%%0}> getAnnotations(java.lang.Class<{%%0}>)
meth public abstract <%0 extends java.lang.annotation.Annotation> {%%0} getAnnotation(java.lang.Class<{%%0}>)
meth public abstract boolean isAnnotationPresent(java.lang.Class<? extends java.lang.annotation.Annotation>)
meth public abstract java.lang.reflect.Type getBaseType()
meth public abstract java.util.Set<java.lang.annotation.Annotation> getAnnotations()
meth public abstract java.util.Set<java.lang.reflect.Type> getTypeClosure()

CLSS public abstract interface jakarta.enterprise.inject.spi.AnnotatedCallable<%0 extends java.lang.Object>
intf jakarta.enterprise.inject.spi.AnnotatedMember<{jakarta.enterprise.inject.spi.AnnotatedCallable%0}>
meth public abstract java.util.List<jakarta.enterprise.inject.spi.AnnotatedParameter<{jakarta.enterprise.inject.spi.AnnotatedCallable%0}>> getParameters()

CLSS public abstract interface jakarta.enterprise.inject.spi.AnnotatedConstructor<%0 extends java.lang.Object>
intf jakarta.enterprise.inject.spi.AnnotatedCallable<{jakarta.enterprise.inject.spi.AnnotatedConstructor%0}>
meth public <%0 extends java.lang.annotation.Annotation> java.util.Set<{%%0}> getAnnotations(java.lang.Class<{%%0}>)
meth public abstract java.lang.reflect.Constructor<{jakarta.enterprise.inject.spi.AnnotatedConstructor%0}> getJavaMember()

CLSS public abstract interface jakarta.enterprise.inject.spi.AnnotatedField<%0 extends java.lang.Object>
intf jakarta.enterprise.inject.spi.AnnotatedMember<{jakarta.enterprise.inject.spi.AnnotatedField%0}>
meth public <%0 extends java.lang.annotation.Annotation> java.util.Set<{%%0}> getAnnotations(java.lang.Class<{%%0}>)
meth public abstract java.lang.reflect.Field getJavaMember()

CLSS public abstract interface jakarta.enterprise.inject.spi.AnnotatedMember<%0 extends java.lang.Object>
intf jakarta.enterprise.inject.spi.Annotated
meth public abstract boolean isStatic()
meth public abstract jakarta.enterprise.inject.spi.AnnotatedType<{jakarta.enterprise.inject.spi.AnnotatedMember%0}> getDeclaringType()
meth public abstract java.lang.reflect.Member getJavaMember()

CLSS public abstract interface jakarta.enterprise.inject.spi.AnnotatedMethod<%0 extends java.lang.Object>
intf jakarta.enterprise.inject.spi.AnnotatedCallable<{jakarta.enterprise.inject.spi.AnnotatedMethod%0}>
meth public <%0 extends java.lang.annotation.Annotation> java.util.Set<{%%0}> getAnnotations(java.lang.Class<{%%0}>)
meth public abstract java.lang.reflect.Method getJavaMember()

CLSS public abstract interface jakarta.enterprise.inject.spi.AnnotatedParameter<%0 extends java.lang.Object>
intf jakarta.enterprise.inject.spi.Annotated
meth public <%0 extends java.lang.annotation.Annotation> java.util.Set<{%%0}> getAnnotations(java.lang.Class<{%%0}>)
meth public abstract int getPosition()
meth public abstract jakarta.enterprise.inject.spi.AnnotatedCallable<{jakarta.enterprise.inject.spi.AnnotatedParameter%0}> getDeclaringCallable()
meth public java.lang.reflect.Parameter getJavaParameter()

CLSS public abstract interface jakarta.enterprise.inject.spi.AnnotatedType<%0 extends java.lang.Object>
intf jakarta.enterprise.inject.spi.Annotated
meth public <%0 extends java.lang.annotation.Annotation> java.util.Set<{%%0}> getAnnotations(java.lang.Class<{%%0}>)
meth public abstract java.lang.Class<{jakarta.enterprise.inject.spi.AnnotatedType%0}> getJavaClass()
meth public abstract java.util.Set<jakarta.enterprise.inject.spi.AnnotatedConstructor<{jakarta.enterprise.inject.spi.AnnotatedType%0}>> getConstructors()
meth public abstract java.util.Set<jakarta.enterprise.inject.spi.AnnotatedField<? super {jakarta.enterprise.inject.spi.AnnotatedType%0}>> getFields()
meth public abstract java.util.Set<jakarta.enterprise.inject.spi.AnnotatedMethod<? super {jakarta.enterprise.inject.spi.AnnotatedType%0}>> getMethods()

CLSS public abstract interface jakarta.enterprise.inject.spi.Bean<%0 extends java.lang.Object>
intf jakarta.enterprise.context.spi.Contextual<{jakarta.enterprise.inject.spi.Bean%0}>
intf jakarta.enterprise.inject.spi.BeanAttributes<{jakarta.enterprise.inject.spi.Bean%0}>
meth public abstract boolean isNullable()
meth public abstract java.lang.Class<?> getBeanClass()
meth public abstract java.util.Set<jakarta.enterprise.inject.spi.InjectionPoint> getInjectionPoints()

CLSS public abstract interface jakarta.enterprise.inject.spi.BeanAttributes<%0 extends java.lang.Object>
meth public abstract boolean isAlternative()
meth public abstract java.lang.Class<? extends java.lang.annotation.Annotation> getScope()
meth public abstract java.lang.String getName()
meth public abstract java.util.Set<java.lang.Class<? extends java.lang.annotation.Annotation>> getStereotypes()
meth public abstract java.util.Set<java.lang.annotation.Annotation> getQualifiers()
meth public abstract java.util.Set<java.lang.reflect.Type> getTypes()

CLSS public abstract interface jakarta.enterprise.inject.spi.BeanManager
meth public abstract !varargs <%0 extends java.lang.Object> java.util.Set<jakarta.enterprise.inject.spi.ObserverMethod<? super {%%0}>> resolveObserverMethods({%%0},java.lang.annotation.Annotation[])
meth public abstract !varargs java.util.List<jakarta.enterprise.inject.spi.Decorator<?>> resolveDecorators(java.util.Set<java.lang.reflect.Type>,java.lang.annotation.Annotation[])
meth public abstract !varargs java.util.List<jakarta.enterprise.inject.spi.Interceptor<?>> resolveInterceptors(jakarta.enterprise.inject.spi.InterceptionType,java.lang.annotation.Annotation[])
meth public abstract !varargs java.util.Set<jakarta.enterprise.inject.spi.Bean<?>> getBeans(java.lang.reflect.Type,java.lang.annotation.Annotation[])
meth public abstract !varargs void fireEvent(java.lang.Object,java.lang.annotation.Annotation[])
meth public abstract <%0 extends jakarta.enterprise.inject.spi.Extension> {%%0} getExtension(java.lang.Class<{%%0}>)
meth public abstract <%0 extends java.lang.Object, %1 extends java.lang.Object> jakarta.enterprise.inject.spi.Bean<{%%0}> createBean(jakarta.enterprise.inject.spi.BeanAttributes<{%%0}>,java.lang.Class<{%%1}>,jakarta.enterprise.inject.spi.ProducerFactory<{%%1}>)
meth public abstract <%0 extends java.lang.Object> jakarta.enterprise.context.spi.CreationalContext<{%%0}> createCreationalContext(jakarta.enterprise.context.spi.Contextual<{%%0}>)
meth public abstract <%0 extends java.lang.Object> jakarta.enterprise.inject.spi.AnnotatedType<{%%0}> createAnnotatedType(java.lang.Class<{%%0}>)
meth public abstract <%0 extends java.lang.Object> jakarta.enterprise.inject.spi.Bean<? extends {%%0}> resolve(java.util.Set<jakarta.enterprise.inject.spi.Bean<? extends {%%0}>>)
meth public abstract <%0 extends java.lang.Object> jakarta.enterprise.inject.spi.Bean<{%%0}> createBean(jakarta.enterprise.inject.spi.BeanAttributes<{%%0}>,java.lang.Class<{%%0}>,jakarta.enterprise.inject.spi.InjectionTargetFactory<{%%0}>)
meth public abstract <%0 extends java.lang.Object> jakarta.enterprise.inject.spi.BeanAttributes<{%%0}> createBeanAttributes(jakarta.enterprise.inject.spi.AnnotatedType<{%%0}>)
meth public abstract <%0 extends java.lang.Object> jakarta.enterprise.inject.spi.InjectionTarget<{%%0}> createInjectionTarget(jakarta.enterprise.inject.spi.AnnotatedType<{%%0}>)
meth public abstract <%0 extends java.lang.Object> jakarta.enterprise.inject.spi.InjectionTargetFactory<{%%0}> getInjectionTargetFactory(jakarta.enterprise.inject.spi.AnnotatedType<{%%0}>)
meth public abstract <%0 extends java.lang.Object> jakarta.enterprise.inject.spi.InterceptionFactory<{%%0}> createInterceptionFactory(jakarta.enterprise.context.spi.CreationalContext<{%%0}>,java.lang.Class<{%%0}>)
meth public abstract <%0 extends java.lang.Object> jakarta.enterprise.inject.spi.ProducerFactory<{%%0}> getProducerFactory(jakarta.enterprise.inject.spi.AnnotatedField<? super {%%0}>,jakarta.enterprise.inject.spi.Bean<{%%0}>)
meth public abstract <%0 extends java.lang.Object> jakarta.enterprise.inject.spi.ProducerFactory<{%%0}> getProducerFactory(jakarta.enterprise.inject.spi.AnnotatedMethod<? super {%%0}>,jakarta.enterprise.inject.spi.Bean<{%%0}>)
meth public abstract boolean areInterceptorBindingsEquivalent(java.lang.annotation.Annotation,java.lang.annotation.Annotation)
meth public abstract boolean areQualifiersEquivalent(java.lang.annotation.Annotation,java.lang.annotation.Annotation)
meth public abstract boolean isInterceptorBinding(java.lang.Class<? extends java.lang.annotation.Annotation>)
meth public abstract boolean isNormalScope(java.lang.Class<? extends java.lang.annotation.Annotation>)
meth public abstract boolean isPassivatingScope(java.lang.Class<? extends java.lang.annotation.Annotation>)
meth public abstract boolean isQualifier(java.lang.Class<? extends java.lang.annotation.Annotation>)
meth public abstract boolean isScope(java.lang.Class<? extends java.lang.annotation.Annotation>)
meth public abstract boolean isStereotype(java.lang.Class<? extends java.lang.annotation.Annotation>)
meth public abstract int getInterceptorBindingHashCode(java.lang.annotation.Annotation)
meth public abstract int getQualifierHashCode(java.lang.annotation.Annotation)
meth public abstract jakarta.el.ELResolver getELResolver()
meth public abstract jakarta.el.ExpressionFactory wrapExpressionFactory(jakarta.el.ExpressionFactory)
meth public abstract jakarta.enterprise.context.spi.Context getContext(java.lang.Class<? extends java.lang.annotation.Annotation>)
meth public abstract jakarta.enterprise.event.Event<java.lang.Object> getEvent()
meth public abstract jakarta.enterprise.inject.Instance<java.lang.Object> createInstance()
meth public abstract jakarta.enterprise.inject.spi.Bean<?> getPassivationCapableBean(java.lang.String)
meth public abstract jakarta.enterprise.inject.spi.BeanAttributes<?> createBeanAttributes(jakarta.enterprise.inject.spi.AnnotatedMember<?>)
meth public abstract jakarta.enterprise.inject.spi.InjectionPoint createInjectionPoint(jakarta.enterprise.inject.spi.AnnotatedField<?>)
meth public abstract jakarta.enterprise.inject.spi.InjectionPoint createInjectionPoint(jakarta.enterprise.inject.spi.AnnotatedParameter<?>)
meth public abstract java.lang.Object getInjectableReference(jakarta.enterprise.inject.spi.InjectionPoint,jakarta.enterprise.context.spi.CreationalContext<?>)
meth public abstract java.lang.Object getReference(jakarta.enterprise.inject.spi.Bean<?>,java.lang.reflect.Type,jakarta.enterprise.context.spi.CreationalContext<?>)
meth public abstract java.util.Set<jakarta.enterprise.inject.spi.Bean<?>> getBeans(java.lang.String)
meth public abstract java.util.Set<java.lang.annotation.Annotation> getInterceptorBindingDefinition(java.lang.Class<? extends java.lang.annotation.Annotation>)
meth public abstract java.util.Set<java.lang.annotation.Annotation> getStereotypeDefinition(java.lang.Class<? extends java.lang.annotation.Annotation>)
meth public abstract void validate(jakarta.enterprise.inject.spi.InjectionPoint)

CLSS public abstract interface jakarta.enterprise.inject.spi.BeforeBeanDiscovery
meth public abstract !varargs void addInterceptorBinding(java.lang.Class<? extends java.lang.annotation.Annotation>,java.lang.annotation.Annotation[])
meth public abstract !varargs void addStereotype(java.lang.Class<? extends java.lang.annotation.Annotation>,java.lang.annotation.Annotation[])
meth public abstract <%0 extends java.lang.Object> jakarta.enterprise.inject.spi.configurator.AnnotatedTypeConfigurator<{%%0}> addAnnotatedType(java.lang.Class<{%%0}>,java.lang.String)
meth public abstract <%0 extends java.lang.annotation.Annotation> jakarta.enterprise.inject.spi.configurator.AnnotatedTypeConfigurator<{%%0}> configureInterceptorBinding(java.lang.Class<{%%0}>)
meth public abstract <%0 extends java.lang.annotation.Annotation> jakarta.enterprise.inject.spi.configurator.AnnotatedTypeConfigurator<{%%0}> configureQualifier(java.lang.Class<{%%0}>)
meth public abstract void addAnnotatedType(jakarta.enterprise.inject.spi.AnnotatedType<?>)
meth public abstract void addAnnotatedType(jakarta.enterprise.inject.spi.AnnotatedType<?>,java.lang.String)
meth public abstract void addInterceptorBinding(jakarta.enterprise.inject.spi.AnnotatedType<? extends java.lang.annotation.Annotation>)
meth public abstract void addQualifier(jakarta.enterprise.inject.spi.AnnotatedType<? extends java.lang.annotation.Annotation>)
meth public abstract void addQualifier(java.lang.Class<? extends java.lang.annotation.Annotation>)
meth public abstract void addScope(java.lang.Class<? extends java.lang.annotation.Annotation>,boolean,boolean)

CLSS public abstract interface jakarta.enterprise.inject.spi.BeforeShutdown

CLSS public abstract jakarta.enterprise.inject.spi.CDI<%0 extends java.lang.Object>
cons public <init>()
fld protected static volatile jakarta.enterprise.inject.spi.CDIProvider configuredProvider
fld protected static volatile java.util.Set<jakarta.enterprise.inject.spi.CDIProvider> discoveredProviders
intf jakarta.enterprise.inject.Instance<{jakarta.enterprise.inject.spi.CDI%0}>
meth public abstract jakarta.enterprise.inject.spi.BeanManager getBeanManager()
meth public static jakarta.enterprise.inject.spi.CDI<java.lang.Object> current()
meth public static void setCDIProvider(jakarta.enterprise.inject.spi.CDIProvider)
supr java.lang.Object
hfds lock

CLSS public abstract interface jakarta.enterprise.inject.spi.CDIProvider
fld public final static int DEFAULT_CDI_PROVIDER_PRIORITY = 0
intf jakarta.enterprise.inject.spi.Prioritized
meth public abstract jakarta.enterprise.inject.spi.CDI<java.lang.Object> getCDI()
meth public int getPriority()

CLSS public abstract interface jakarta.enterprise.inject.spi.Decorator<%0 extends java.lang.Object>
intf jakarta.enterprise.inject.spi.Bean<{jakarta.enterprise.inject.spi.Decorator%0}>
meth public abstract java.lang.reflect.Type getDelegateType()
meth public abstract java.util.Set<java.lang.annotation.Annotation> getDelegateQualifiers()
meth public abstract java.util.Set<java.lang.reflect.Type> getDecoratedTypes()

CLSS public jakarta.enterprise.inject.spi.DefinitionException
cons public <init>(java.lang.String)
cons public <init>(java.lang.String,java.lang.Throwable)
cons public <init>(java.lang.Throwable)
supr java.lang.RuntimeException
hfds serialVersionUID

CLSS public jakarta.enterprise.inject.spi.DeploymentException
cons public <init>(java.lang.String)
cons public <init>(java.lang.String,java.lang.Throwable)
cons public <init>(java.lang.Throwable)
supr java.lang.RuntimeException
hfds serialVersionUID

CLSS public abstract interface jakarta.enterprise.inject.spi.EventContext<%0 extends java.lang.Object>
meth public abstract jakarta.enterprise.inject.spi.EventMetadata getMetadata()
meth public abstract {jakarta.enterprise.inject.spi.EventContext%0} getEvent()

CLSS public abstract interface jakarta.enterprise.inject.spi.EventMetadata
meth public abstract jakarta.enterprise.inject.spi.InjectionPoint getInjectionPoint()
meth public abstract java.lang.reflect.Type getType()
meth public abstract java.util.Set<java.lang.annotation.Annotation> getQualifiers()

CLSS public abstract interface jakarta.enterprise.inject.spi.Extension

CLSS public abstract interface jakarta.enterprise.inject.spi.InjectionPoint
meth public abstract boolean isDelegate()
meth public abstract boolean isTransient()
meth public abstract jakarta.enterprise.inject.spi.Annotated getAnnotated()
meth public abstract jakarta.enterprise.inject.spi.Bean<?> getBean()
meth public abstract java.lang.reflect.Member getMember()
meth public abstract java.lang.reflect.Type getType()
meth public abstract java.util.Set<java.lang.annotation.Annotation> getQualifiers()

CLSS public abstract interface jakarta.enterprise.inject.spi.InjectionTarget<%0 extends java.lang.Object>
intf jakarta.enterprise.inject.spi.Producer<{jakarta.enterprise.inject.spi.InjectionTarget%0}>
meth public abstract void inject({jakarta.enterprise.inject.spi.InjectionTarget%0},jakarta.enterprise.context.spi.CreationalContext<{jakarta.enterprise.inject.spi.InjectionTarget%0}>)
meth public abstract void postConstruct({jakarta.enterprise.inject.spi.InjectionTarget%0})
meth public abstract void preDestroy({jakarta.enterprise.inject.spi.InjectionTarget%0})

CLSS public abstract interface jakarta.enterprise.inject.spi.InjectionTargetFactory<%0 extends java.lang.Object>
meth public abstract jakarta.enterprise.inject.spi.InjectionTarget<{jakarta.enterprise.inject.spi.InjectionTargetFactory%0}> createInjectionTarget(jakarta.enterprise.inject.spi.Bean<{jakarta.enterprise.inject.spi.InjectionTargetFactory%0}>)
meth public jakarta.enterprise.inject.spi.configurator.AnnotatedTypeConfigurator<{jakarta.enterprise.inject.spi.InjectionTargetFactory%0}> configure()

CLSS public abstract interface jakarta.enterprise.inject.spi.InterceptionFactory<%0 extends java.lang.Object>
meth public abstract jakarta.enterprise.inject.spi.InterceptionFactory<{jakarta.enterprise.inject.spi.InterceptionFactory%0}> ignoreFinalMethods()
meth public abstract jakarta.enterprise.inject.spi.configurator.AnnotatedTypeConfigurator<{jakarta.enterprise.inject.spi.InterceptionFactory%0}> configure()
meth public abstract {jakarta.enterprise.inject.spi.InterceptionFactory%0} createInterceptedInstance({jakarta.enterprise.inject.spi.InterceptionFactory%0})

CLSS public final !enum jakarta.enterprise.inject.spi.InterceptionType
fld public final static jakarta.enterprise.inject.spi.InterceptionType AROUND_CONSTRUCT
fld public final static jakarta.enterprise.inject.spi.InterceptionType AROUND_INVOKE
fld public final static jakarta.enterprise.inject.spi.InterceptionType AROUND_TIMEOUT
fld public final static jakarta.enterprise.inject.spi.InterceptionType POST_ACTIVATE
fld public final static jakarta.enterprise.inject.spi.InterceptionType POST_CONSTRUCT
fld public final static jakarta.enterprise.inject.spi.InterceptionType PRE_DESTROY
fld public final static jakarta.enterprise.inject.spi.InterceptionType PRE_PASSIVATE
meth public static jakarta.enterprise.inject.spi.InterceptionType valueOf(java.lang.String)
meth public static jakarta.enterprise.inject.spi.InterceptionType[] values()
supr java.lang.Enum<jakarta.enterprise.inject.spi.InterceptionType>

CLSS public abstract interface jakarta.enterprise.inject.spi.Interceptor<%0 extends java.lang.Object>
intf jakarta.enterprise.inject.spi.Bean<{jakarta.enterprise.inject.spi.Interceptor%0}>
meth public abstract boolean intercepts(jakarta.enterprise.inject.spi.InterceptionType)
meth public abstract java.lang.Object intercept(jakarta.enterprise.inject.spi.InterceptionType,{jakarta.enterprise.inject.spi.Interceptor%0},jakarta.interceptor.InvocationContext) throws java.lang.Exception
meth public abstract java.util.Set<java.lang.annotation.Annotation> getInterceptorBindings()

CLSS public abstract interface jakarta.enterprise.inject.spi.ObserverMethod<%0 extends java.lang.Object>
fld public final static int DEFAULT_PRIORITY = 2500
intf jakarta.enterprise.inject.spi.Prioritized
meth public abstract jakarta.enterprise.event.Reception getReception()
meth public abstract jakarta.enterprise.event.TransactionPhase getTransactionPhase()
meth public abstract java.lang.Class<?> getBeanClass()
meth public abstract java.lang.reflect.Type getObservedType()
meth public abstract java.util.Set<java.lang.annotation.Annotation> getObservedQualifiers()
meth public boolean isAsync()
meth public int getPriority()
meth public void notify(jakarta.enterprise.inject.spi.EventContext<{jakarta.enterprise.inject.spi.ObserverMethod%0}>)
meth public void notify({jakarta.enterprise.inject.spi.ObserverMethod%0})

CLSS public abstract interface jakarta.enterprise.inject.spi.PassivationCapable
meth public abstract java.lang.String getId()

CLSS public abstract interface jakarta.enterprise.inject.spi.Prioritized
meth public abstract int getPriority()

CLSS public abstract interface jakarta.enterprise.inject.spi.ProcessAnnotatedType<%0 extends java.lang.Object>
meth public abstract jakarta.enterprise.inject.spi.AnnotatedType<{jakarta.enterprise.inject.spi.ProcessAnnotatedType%0}> getAnnotatedType()
meth public abstract jakarta.enterprise.inject.spi.configurator.AnnotatedTypeConfigurator<{jakarta.enterprise.inject.spi.ProcessAnnotatedType%0}> configureAnnotatedType()
meth public abstract void setAnnotatedType(jakarta.enterprise.inject.spi.AnnotatedType<{jakarta.enterprise.inject.spi.ProcessAnnotatedType%0}>)
meth public abstract void veto()

CLSS public abstract interface jakarta.enterprise.inject.spi.ProcessBean<%0 extends java.lang.Object>
meth public abstract jakarta.enterprise.inject.spi.Annotated getAnnotated()
meth public abstract jakarta.enterprise.inject.spi.Bean<{jakarta.enterprise.inject.spi.ProcessBean%0}> getBean()
meth public abstract void addDefinitionError(java.lang.Throwable)

CLSS public abstract interface jakarta.enterprise.inject.spi.ProcessBeanAttributes<%0 extends java.lang.Object>
meth public abstract jakarta.enterprise.inject.spi.Annotated getAnnotated()
meth public abstract jakarta.enterprise.inject.spi.BeanAttributes<{jakarta.enterprise.inject.spi.ProcessBeanAttributes%0}> getBeanAttributes()
meth public abstract jakarta.enterprise.inject.spi.configurator.BeanAttributesConfigurator<{jakarta.enterprise.inject.spi.ProcessBeanAttributes%0}> configureBeanAttributes()
meth public abstract void addDefinitionError(java.lang.Throwable)
meth public abstract void ignoreFinalMethods()
meth public abstract void setBeanAttributes(jakarta.enterprise.inject.spi.BeanAttributes<{jakarta.enterprise.inject.spi.ProcessBeanAttributes%0}>)
meth public abstract void veto()

CLSS public abstract interface jakarta.enterprise.inject.spi.ProcessInjectionPoint<%0 extends java.lang.Object, %1 extends java.lang.Object>
meth public abstract jakarta.enterprise.inject.spi.InjectionPoint getInjectionPoint()
meth public abstract jakarta.enterprise.inject.spi.configurator.InjectionPointConfigurator configureInjectionPoint()
meth public abstract void addDefinitionError(java.lang.Throwable)
meth public abstract void setInjectionPoint(jakarta.enterprise.inject.spi.InjectionPoint)

CLSS public abstract interface jakarta.enterprise.inject.spi.ProcessInjectionTarget<%0 extends java.lang.Object>
meth public abstract jakarta.enterprise.inject.spi.AnnotatedType<{jakarta.enterprise.inject.spi.ProcessInjectionTarget%0}> getAnnotatedType()
meth public abstract jakarta.enterprise.inject.spi.InjectionTarget<{jakarta.enterprise.inject.spi.ProcessInjectionTarget%0}> getInjectionTarget()
meth public abstract void addDefinitionError(java.lang.Throwable)
meth public abstract void setInjectionTarget(jakarta.enterprise.inject.spi.InjectionTarget<{jakarta.enterprise.inject.spi.ProcessInjectionTarget%0}>)

CLSS public abstract interface jakarta.enterprise.inject.spi.ProcessManagedBean<%0 extends java.lang.Object>
intf jakarta.enterprise.inject.spi.ProcessBean<{jakarta.enterprise.inject.spi.ProcessManagedBean%0}>
meth public abstract jakarta.enterprise.inject.spi.AnnotatedType<{jakarta.enterprise.inject.spi.ProcessManagedBean%0}> getAnnotatedBeanClass()

CLSS public abstract interface jakarta.enterprise.inject.spi.ProcessObserverMethod<%0 extends java.lang.Object, %1 extends java.lang.Object>
meth public abstract jakarta.enterprise.inject.spi.AnnotatedMethod<{jakarta.enterprise.inject.spi.ProcessObserverMethod%1}> getAnnotatedMethod()
meth public abstract jakarta.enterprise.inject.spi.ObserverMethod<{jakarta.enterprise.inject.spi.ProcessObserverMethod%0}> getObserverMethod()
meth public abstract jakarta.enterprise.inject.spi.configurator.ObserverMethodConfigurator<{jakarta.enterprise.inject.spi.ProcessObserverMethod%0}> configureObserverMethod()
meth public abstract void addDefinitionError(java.lang.Throwable)
meth public abstract void setObserverMethod(jakarta.enterprise.inject.spi.ObserverMethod<{jakarta.enterprise.inject.spi.ProcessObserverMethod%0}>)
meth public abstract void veto()

CLSS public abstract interface jakarta.enterprise.inject.spi.ProcessProducer<%0 extends java.lang.Object, %1 extends java.lang.Object>
meth public abstract jakarta.enterprise.inject.spi.AnnotatedMember<{jakarta.enterprise.inject.spi.ProcessProducer%0}> getAnnotatedMember()
meth public abstract jakarta.enterprise.inject.spi.Producer<{jakarta.enterprise.inject.spi.ProcessProducer%1}> getProducer()
meth public abstract jakarta.enterprise.inject.spi.configurator.ProducerConfigurator<{jakarta.enterprise.inject.spi.ProcessProducer%1}> configureProducer()
meth public abstract void addDefinitionError(java.lang.Throwable)
meth public abstract void setProducer(jakarta.enterprise.inject.spi.Producer<{jakarta.enterprise.inject.spi.ProcessProducer%1}>)

CLSS public abstract interface jakarta.enterprise.inject.spi.ProcessProducerField<%0 extends java.lang.Object, %1 extends java.lang.Object>
intf jakarta.enterprise.inject.spi.ProcessBean<{jakarta.enterprise.inject.spi.ProcessProducerField%1}>
meth public abstract jakarta.enterprise.inject.spi.AnnotatedField<{jakarta.enterprise.inject.spi.ProcessProducerField%0}> getAnnotatedProducerField()
meth public abstract jakarta.enterprise.inject.spi.AnnotatedParameter<{jakarta.enterprise.inject.spi.ProcessProducerField%0}> getAnnotatedDisposedParameter()

CLSS public abstract interface jakarta.enterprise.inject.spi.ProcessProducerMethod<%0 extends java.lang.Object, %1 extends java.lang.Object>
intf jakarta.enterprise.inject.spi.ProcessBean<{jakarta.enterprise.inject.spi.ProcessProducerMethod%1}>
meth public abstract jakarta.enterprise.inject.spi.AnnotatedMethod<{jakarta.enterprise.inject.spi.ProcessProducerMethod%0}> getAnnotatedProducerMethod()
meth public abstract jakarta.enterprise.inject.spi.AnnotatedParameter<{jakarta.enterprise.inject.spi.ProcessProducerMethod%0}> getAnnotatedDisposedParameter()

CLSS public abstract interface jakarta.enterprise.inject.spi.ProcessSessionBean<%0 extends java.lang.Object>
intf jakarta.enterprise.inject.spi.ProcessManagedBean<java.lang.Object>
meth public abstract jakarta.enterprise.inject.spi.SessionBeanType getSessionBeanType()
meth public abstract java.lang.String getEjbName()

CLSS public abstract interface jakarta.enterprise.inject.spi.ProcessSyntheticAnnotatedType<%0 extends java.lang.Object>
intf jakarta.enterprise.inject.spi.ProcessAnnotatedType<{jakarta.enterprise.inject.spi.ProcessSyntheticAnnotatedType%0}>
meth public abstract jakarta.enterprise.inject.spi.Extension getSource()

CLSS public abstract interface jakarta.enterprise.inject.spi.ProcessSyntheticBean<%0 extends java.lang.Object>
intf jakarta.enterprise.inject.spi.ProcessBean<{jakarta.enterprise.inject.spi.ProcessSyntheticBean%0}>
meth public abstract jakarta.enterprise.inject.spi.Extension getSource()

CLSS public abstract interface jakarta.enterprise.inject.spi.ProcessSyntheticObserverMethod<%0 extends java.lang.Object, %1 extends java.lang.Object>
intf jakarta.enterprise.inject.spi.ProcessObserverMethod<{jakarta.enterprise.inject.spi.ProcessSyntheticObserverMethod%0},{jakarta.enterprise.inject.spi.ProcessSyntheticObserverMethod%1}>
meth public abstract jakarta.enterprise.inject.spi.Extension getSource()

CLSS public abstract interface jakarta.enterprise.inject.spi.Producer<%0 extends java.lang.Object>
meth public abstract java.util.Set<jakarta.enterprise.inject.spi.InjectionPoint> getInjectionPoints()
meth public abstract void dispose({jakarta.enterprise.inject.spi.Producer%0})
meth public abstract {jakarta.enterprise.inject.spi.Producer%0} produce(jakarta.enterprise.context.spi.CreationalContext<{jakarta.enterprise.inject.spi.Producer%0}>)

CLSS public abstract interface jakarta.enterprise.inject.spi.ProducerFactory<%0 extends java.lang.Object>
meth public abstract <%0 extends java.lang.Object> jakarta.enterprise.inject.spi.Producer<{%%0}> createProducer(jakarta.enterprise.inject.spi.Bean<{%%0}>)

CLSS public final !enum jakarta.enterprise.inject.spi.SessionBeanType
fld public final static jakarta.enterprise.inject.spi.SessionBeanType SINGLETON
fld public final static jakarta.enterprise.inject.spi.SessionBeanType STATEFUL
fld public final static jakarta.enterprise.inject.spi.SessionBeanType STATELESS
meth public static jakarta.enterprise.inject.spi.SessionBeanType valueOf(java.lang.String)
meth public static jakarta.enterprise.inject.spi.SessionBeanType[] values()
supr java.lang.Enum<jakarta.enterprise.inject.spi.SessionBeanType>

CLSS public jakarta.enterprise.inject.spi.Unmanaged<%0 extends java.lang.Object>
cons public <init>(jakarta.enterprise.inject.spi.BeanManager,java.lang.Class<{jakarta.enterprise.inject.spi.Unmanaged%0}>)
cons public <init>(java.lang.Class<{jakarta.enterprise.inject.spi.Unmanaged%0}>)
innr public static UnmanagedInstance
meth public jakarta.enterprise.inject.spi.Unmanaged$UnmanagedInstance<{jakarta.enterprise.inject.spi.Unmanaged%0}> newInstance()
supr java.lang.Object
hfds beanManager,injectionTarget

CLSS public static jakarta.enterprise.inject.spi.Unmanaged$UnmanagedInstance<%0 extends java.lang.Object>
 outer jakarta.enterprise.inject.spi.Unmanaged
meth public jakarta.enterprise.inject.spi.Unmanaged$UnmanagedInstance<{jakarta.enterprise.inject.spi.Unmanaged$UnmanagedInstance%0}> dispose()
meth public jakarta.enterprise.inject.spi.Unmanaged$UnmanagedInstance<{jakarta.enterprise.inject.spi.Unmanaged$UnmanagedInstance%0}> inject()
meth public jakarta.enterprise.inject.spi.Unmanaged$UnmanagedInstance<{jakarta.enterprise.inject.spi.Unmanaged$UnmanagedInstance%0}> postConstruct()
meth public jakarta.enterprise.inject.spi.Unmanaged$UnmanagedInstance<{jakarta.enterprise.inject.spi.Unmanaged$UnmanagedInstance%0}> preDestroy()
meth public jakarta.enterprise.inject.spi.Unmanaged$UnmanagedInstance<{jakarta.enterprise.inject.spi.Unmanaged$UnmanagedInstance%0}> produce()
meth public {jakarta.enterprise.inject.spi.Unmanaged$UnmanagedInstance%0} get()
supr java.lang.Object
hfds ctx,disposed,injectionTarget,instance

CLSS public abstract interface !annotation jakarta.enterprise.inject.spi.WithAnnotations
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[PARAMETER])
intf java.lang.annotation.Annotation
meth public abstract java.lang.Class<? extends java.lang.annotation.Annotation>[] value()

CLSS public abstract interface jakarta.enterprise.inject.spi.configurator.AnnotatedConstructorConfigurator<%0 extends java.lang.Object>
meth public abstract jakarta.enterprise.inject.spi.AnnotatedConstructor<{jakarta.enterprise.inject.spi.configurator.AnnotatedConstructorConfigurator%0}> getAnnotated()
meth public abstract jakarta.enterprise.inject.spi.configurator.AnnotatedConstructorConfigurator<{jakarta.enterprise.inject.spi.configurator.AnnotatedConstructorConfigurator%0}> add(java.lang.annotation.Annotation)
meth public abstract jakarta.enterprise.inject.spi.configurator.AnnotatedConstructorConfigurator<{jakarta.enterprise.inject.spi.configurator.AnnotatedConstructorConfigurator%0}> remove(java.util.function.Predicate<java.lang.annotation.Annotation>)
meth public abstract java.util.List<jakarta.enterprise.inject.spi.configurator.AnnotatedParameterConfigurator<{jakarta.enterprise.inject.spi.configurator.AnnotatedConstructorConfigurator%0}>> params()
meth public jakarta.enterprise.inject.spi.configurator.AnnotatedConstructorConfigurator<{jakarta.enterprise.inject.spi.configurator.AnnotatedConstructorConfigurator%0}> removeAll()
meth public java.util.stream.Stream<jakarta.enterprise.inject.spi.configurator.AnnotatedParameterConfigurator<{jakarta.enterprise.inject.spi.configurator.AnnotatedConstructorConfigurator%0}>> filterParams(java.util.function.Predicate<jakarta.enterprise.inject.spi.AnnotatedParameter<{jakarta.enterprise.inject.spi.configurator.AnnotatedConstructorConfigurator%0}>>)

CLSS public abstract interface jakarta.enterprise.inject.spi.configurator.AnnotatedFieldConfigurator<%0 extends java.lang.Object>
meth public abstract jakarta.enterprise.inject.spi.AnnotatedField<{jakarta.enterprise.inject.spi.configurator.AnnotatedFieldConfigurator%0}> getAnnotated()
meth public abstract jakarta.enterprise.inject.spi.configurator.AnnotatedFieldConfigurator<{jakarta.enterprise.inject.spi.configurator.AnnotatedFieldConfigurator%0}> add(java.lang.annotation.Annotation)
meth public abstract jakarta.enterprise.inject.spi.configurator.AnnotatedFieldConfigurator<{jakarta.enterprise.inject.spi.configurator.AnnotatedFieldConfigurator%0}> remove(java.util.function.Predicate<java.lang.annotation.Annotation>)
meth public jakarta.enterprise.inject.spi.configurator.AnnotatedFieldConfigurator<{jakarta.enterprise.inject.spi.configurator.AnnotatedFieldConfigurator%0}> removeAll()

CLSS public abstract interface jakarta.enterprise.inject.spi.configurator.AnnotatedMethodConfigurator<%0 extends java.lang.Object>
meth public abstract jakarta.enterprise.inject.spi.AnnotatedMethod<{jakarta.enterprise.inject.spi.configurator.AnnotatedMethodConfigurator%0}> getAnnotated()
meth public abstract jakarta.enterprise.inject.spi.configurator.AnnotatedMethodConfigurator<{jakarta.enterprise.inject.spi.configurator.AnnotatedMethodConfigurator%0}> add(java.lang.annotation.Annotation)
meth public abstract jakarta.enterprise.inject.spi.configurator.AnnotatedMethodConfigurator<{jakarta.enterprise.inject.spi.configurator.AnnotatedMethodConfigurator%0}> remove(java.util.function.Predicate<java.lang.annotation.Annotation>)
meth public abstract java.util.List<jakarta.enterprise.inject.spi.configurator.AnnotatedParameterConfigurator<{jakarta.enterprise.inject.spi.configurator.AnnotatedMethodConfigurator%0}>> params()
meth public jakarta.enterprise.inject.spi.configurator.AnnotatedMethodConfigurator<{jakarta.enterprise.inject.spi.configurator.AnnotatedMethodConfigurator%0}> removeAll()
meth public java.util.stream.Stream<jakarta.enterprise.inject.spi.configurator.AnnotatedParameterConfigurator<{jakarta.enterprise.inject.spi.configurator.AnnotatedMethodConfigurator%0}>> filterParams(java.util.function.Predicate<jakarta.enterprise.inject.spi.AnnotatedParameter<{jakarta.enterprise.inject.spi.configurator.AnnotatedMethodConfigurator%0}>>)

CLSS public abstract interface jakarta.enterprise.inject.spi.configurator.AnnotatedParameterConfigurator<%0 extends java.lang.Object>
meth public abstract jakarta.enterprise.inject.spi.AnnotatedParameter<{jakarta.enterprise.inject.spi.configurator.AnnotatedParameterConfigurator%0}> getAnnotated()
meth public abstract jakarta.enterprise.inject.spi.configurator.AnnotatedParameterConfigurator<{jakarta.enterprise.inject.spi.configurator.AnnotatedParameterConfigurator%0}> add(java.lang.annotation.Annotation)
meth public abstract jakarta.enterprise.inject.spi.configurator.AnnotatedParameterConfigurator<{jakarta.enterprise.inject.spi.configurator.AnnotatedParameterConfigurator%0}> remove(java.util.function.Predicate<java.lang.annotation.Annotation>)
meth public jakarta.enterprise.inject.spi.configurator.AnnotatedParameterConfigurator<{jakarta.enterprise.inject.spi.configurator.AnnotatedParameterConfigurator%0}> removeAll()

CLSS public abstract interface jakarta.enterprise.inject.spi.configurator.AnnotatedTypeConfigurator<%0 extends java.lang.Object>
meth public abstract jakarta.enterprise.inject.spi.AnnotatedType<{jakarta.enterprise.inject.spi.configurator.AnnotatedTypeConfigurator%0}> getAnnotated()
meth public abstract jakarta.enterprise.inject.spi.configurator.AnnotatedTypeConfigurator<{jakarta.enterprise.inject.spi.configurator.AnnotatedTypeConfigurator%0}> add(java.lang.annotation.Annotation)
meth public abstract jakarta.enterprise.inject.spi.configurator.AnnotatedTypeConfigurator<{jakarta.enterprise.inject.spi.configurator.AnnotatedTypeConfigurator%0}> remove(java.util.function.Predicate<java.lang.annotation.Annotation>)
meth public abstract java.util.Set<jakarta.enterprise.inject.spi.configurator.AnnotatedConstructorConfigurator<{jakarta.enterprise.inject.spi.configurator.AnnotatedTypeConfigurator%0}>> constructors()
meth public abstract java.util.Set<jakarta.enterprise.inject.spi.configurator.AnnotatedFieldConfigurator<? super {jakarta.enterprise.inject.spi.configurator.AnnotatedTypeConfigurator%0}>> fields()
meth public abstract java.util.Set<jakarta.enterprise.inject.spi.configurator.AnnotatedMethodConfigurator<? super {jakarta.enterprise.inject.spi.configurator.AnnotatedTypeConfigurator%0}>> methods()
meth public jakarta.enterprise.inject.spi.configurator.AnnotatedTypeConfigurator<{jakarta.enterprise.inject.spi.configurator.AnnotatedTypeConfigurator%0}> removeAll()
meth public java.util.stream.Stream<jakarta.enterprise.inject.spi.configurator.AnnotatedConstructorConfigurator<{jakarta.enterprise.inject.spi.configurator.AnnotatedTypeConfigurator%0}>> filterConstructors(java.util.function.Predicate<jakarta.enterprise.inject.spi.AnnotatedConstructor<{jakarta.enterprise.inject.spi.configurator.AnnotatedTypeConfigurator%0}>>)
meth public java.util.stream.Stream<jakarta.enterprise.inject.spi.configurator.AnnotatedFieldConfigurator<? super {jakarta.enterprise.inject.spi.configurator.AnnotatedTypeConfigurator%0}>> filterFields(java.util.function.Predicate<jakarta.enterprise.inject.spi.AnnotatedField<? super {jakarta.enterprise.inject.spi.configurator.AnnotatedTypeConfigurator%0}>>)
meth public java.util.stream.Stream<jakarta.enterprise.inject.spi.configurator.AnnotatedMethodConfigurator<? super {jakarta.enterprise.inject.spi.configurator.AnnotatedTypeConfigurator%0}>> filterMethods(java.util.function.Predicate<jakarta.enterprise.inject.spi.AnnotatedMethod<? super {jakarta.enterprise.inject.spi.configurator.AnnotatedTypeConfigurator%0}>>)

CLSS public abstract interface jakarta.enterprise.inject.spi.configurator.BeanAttributesConfigurator<%0 extends java.lang.Object>
meth public abstract !varargs jakarta.enterprise.inject.spi.configurator.BeanAttributesConfigurator<{jakarta.enterprise.inject.spi.configurator.BeanAttributesConfigurator%0}> addQualifiers(java.lang.annotation.Annotation[])
meth public abstract !varargs jakarta.enterprise.inject.spi.configurator.BeanAttributesConfigurator<{jakarta.enterprise.inject.spi.configurator.BeanAttributesConfigurator%0}> addTypes(java.lang.reflect.Type[])
meth public abstract !varargs jakarta.enterprise.inject.spi.configurator.BeanAttributesConfigurator<{jakarta.enterprise.inject.spi.configurator.BeanAttributesConfigurator%0}> qualifiers(java.lang.annotation.Annotation[])
meth public abstract !varargs jakarta.enterprise.inject.spi.configurator.BeanAttributesConfigurator<{jakarta.enterprise.inject.spi.configurator.BeanAttributesConfigurator%0}> types(java.lang.reflect.Type[])
meth public abstract jakarta.enterprise.inject.spi.configurator.BeanAttributesConfigurator<{jakarta.enterprise.inject.spi.configurator.BeanAttributesConfigurator%0}> addQualifier(java.lang.annotation.Annotation)
meth public abstract jakarta.enterprise.inject.spi.configurator.BeanAttributesConfigurator<{jakarta.enterprise.inject.spi.configurator.BeanAttributesConfigurator%0}> addQualifiers(java.util.Set<java.lang.annotation.Annotation>)
meth public abstract jakarta.enterprise.inject.spi.configurator.BeanAttributesConfigurator<{jakarta.enterprise.inject.spi.configurator.BeanAttributesConfigurator%0}> addStereotype(java.lang.Class<? extends java.lang.annotation.Annotation>)
meth public abstract jakarta.enterprise.inject.spi.configurator.BeanAttributesConfigurator<{jakarta.enterprise.inject.spi.configurator.BeanAttributesConfigurator%0}> addStereotypes(java.util.Set<java.lang.Class<? extends java.lang.annotation.Annotation>>)
meth public abstract jakarta.enterprise.inject.spi.configurator.BeanAttributesConfigurator<{jakarta.enterprise.inject.spi.configurator.BeanAttributesConfigurator%0}> addTransitiveTypeClosure(java.lang.reflect.Type)
meth public abstract jakarta.enterprise.inject.spi.configurator.BeanAttributesConfigurator<{jakarta.enterprise.inject.spi.configurator.BeanAttributesConfigurator%0}> addType(jakarta.enterprise.util.TypeLiteral<?>)
meth public abstract jakarta.enterprise.inject.spi.configurator.BeanAttributesConfigurator<{jakarta.enterprise.inject.spi.configurator.BeanAttributesConfigurator%0}> addType(java.lang.reflect.Type)
meth public abstract jakarta.enterprise.inject.spi.configurator.BeanAttributesConfigurator<{jakarta.enterprise.inject.spi.configurator.BeanAttributesConfigurator%0}> addTypes(java.util.Set<java.lang.reflect.Type>)
meth public abstract jakarta.enterprise.inject.spi.configurator.BeanAttributesConfigurator<{jakarta.enterprise.inject.spi.configurator.BeanAttributesConfigurator%0}> alternative(boolean)
meth public abstract jakarta.enterprise.inject.spi.configurator.BeanAttributesConfigurator<{jakarta.enterprise.inject.spi.configurator.BeanAttributesConfigurator%0}> name(java.lang.String)
meth public abstract jakarta.enterprise.inject.spi.configurator.BeanAttributesConfigurator<{jakarta.enterprise.inject.spi.configurator.BeanAttributesConfigurator%0}> qualifiers(java.util.Set<java.lang.annotation.Annotation>)
meth public abstract jakarta.enterprise.inject.spi.configurator.BeanAttributesConfigurator<{jakarta.enterprise.inject.spi.configurator.BeanAttributesConfigurator%0}> scope(java.lang.Class<? extends java.lang.annotation.Annotation>)
meth public abstract jakarta.enterprise.inject.spi.configurator.BeanAttributesConfigurator<{jakarta.enterprise.inject.spi.configurator.BeanAttributesConfigurator%0}> stereotypes(java.util.Set<java.lang.Class<? extends java.lang.annotation.Annotation>>)
meth public abstract jakarta.enterprise.inject.spi.configurator.BeanAttributesConfigurator<{jakarta.enterprise.inject.spi.configurator.BeanAttributesConfigurator%0}> types(java.util.Set<java.lang.reflect.Type>)

CLSS public abstract interface jakarta.enterprise.inject.spi.configurator.BeanConfigurator<%0 extends java.lang.Object>
meth public abstract !varargs jakarta.enterprise.inject.spi.configurator.BeanConfigurator<{jakarta.enterprise.inject.spi.configurator.BeanConfigurator%0}> addInjectionPoints(jakarta.enterprise.inject.spi.InjectionPoint[])
meth public abstract !varargs jakarta.enterprise.inject.spi.configurator.BeanConfigurator<{jakarta.enterprise.inject.spi.configurator.BeanConfigurator%0}> addQualifiers(java.lang.annotation.Annotation[])
meth public abstract !varargs jakarta.enterprise.inject.spi.configurator.BeanConfigurator<{jakarta.enterprise.inject.spi.configurator.BeanConfigurator%0}> addTypes(java.lang.reflect.Type[])
meth public abstract !varargs jakarta.enterprise.inject.spi.configurator.BeanConfigurator<{jakarta.enterprise.inject.spi.configurator.BeanConfigurator%0}> injectionPoints(jakarta.enterprise.inject.spi.InjectionPoint[])
meth public abstract !varargs jakarta.enterprise.inject.spi.configurator.BeanConfigurator<{jakarta.enterprise.inject.spi.configurator.BeanConfigurator%0}> qualifiers(java.lang.annotation.Annotation[])
meth public abstract !varargs jakarta.enterprise.inject.spi.configurator.BeanConfigurator<{jakarta.enterprise.inject.spi.configurator.BeanConfigurator%0}> types(java.lang.reflect.Type[])
meth public abstract <%0 extends {jakarta.enterprise.inject.spi.configurator.BeanConfigurator%0}> jakarta.enterprise.inject.spi.configurator.BeanConfigurator<{%%0}> createWith(java.util.function.Function<jakarta.enterprise.context.spi.CreationalContext<{%%0}>,{%%0}>)
meth public abstract <%0 extends {jakarta.enterprise.inject.spi.configurator.BeanConfigurator%0}> jakarta.enterprise.inject.spi.configurator.BeanConfigurator<{%%0}> produceWith(java.util.function.Function<jakarta.enterprise.inject.Instance<java.lang.Object>,{%%0}>)
meth public abstract <%0 extends {jakarta.enterprise.inject.spi.configurator.BeanConfigurator%0}> jakarta.enterprise.inject.spi.configurator.BeanConfigurator<{%%0}> read(jakarta.enterprise.inject.spi.AnnotatedType<{%%0}>)
meth public abstract jakarta.enterprise.inject.spi.configurator.BeanConfigurator<{jakarta.enterprise.inject.spi.configurator.BeanConfigurator%0}> addInjectionPoint(jakarta.enterprise.inject.spi.InjectionPoint)
meth public abstract jakarta.enterprise.inject.spi.configurator.BeanConfigurator<{jakarta.enterprise.inject.spi.configurator.BeanConfigurator%0}> addInjectionPoints(java.util.Set<jakarta.enterprise.inject.spi.InjectionPoint>)
meth public abstract jakarta.enterprise.inject.spi.configurator.BeanConfigurator<{jakarta.enterprise.inject.spi.configurator.BeanConfigurator%0}> addQualifier(java.lang.annotation.Annotation)
meth public abstract jakarta.enterprise.inject.spi.configurator.BeanConfigurator<{jakarta.enterprise.inject.spi.configurator.BeanConfigurator%0}> addQualifiers(java.util.Set<java.lang.annotation.Annotation>)
meth public abstract jakarta.enterprise.inject.spi.configurator.BeanConfigurator<{jakarta.enterprise.inject.spi.configurator.BeanConfigurator%0}> addStereotype(java.lang.Class<? extends java.lang.annotation.Annotation>)
meth public abstract jakarta.enterprise.inject.spi.configurator.BeanConfigurator<{jakarta.enterprise.inject.spi.configurator.BeanConfigurator%0}> addStereotypes(java.util.Set<java.lang.Class<? extends java.lang.annotation.Annotation>>)
meth public abstract jakarta.enterprise.inject.spi.configurator.BeanConfigurator<{jakarta.enterprise.inject.spi.configurator.BeanConfigurator%0}> addTransitiveTypeClosure(java.lang.reflect.Type)
meth public abstract jakarta.enterprise.inject.spi.configurator.BeanConfigurator<{jakarta.enterprise.inject.spi.configurator.BeanConfigurator%0}> addType(jakarta.enterprise.util.TypeLiteral<?>)
meth public abstract jakarta.enterprise.inject.spi.configurator.BeanConfigurator<{jakarta.enterprise.inject.spi.configurator.BeanConfigurator%0}> addType(java.lang.reflect.Type)
meth public abstract jakarta.enterprise.inject.spi.configurator.BeanConfigurator<{jakarta.enterprise.inject.spi.configurator.BeanConfigurator%0}> addTypes(java.util.Set<java.lang.reflect.Type>)
meth public abstract jakarta.enterprise.inject.spi.configurator.BeanConfigurator<{jakarta.enterprise.inject.spi.configurator.BeanConfigurator%0}> alternative(boolean)
meth public abstract jakarta.enterprise.inject.spi.configurator.BeanConfigurator<{jakarta.enterprise.inject.spi.configurator.BeanConfigurator%0}> beanClass(java.lang.Class<?>)
meth public abstract jakarta.enterprise.inject.spi.configurator.BeanConfigurator<{jakarta.enterprise.inject.spi.configurator.BeanConfigurator%0}> destroyWith(java.util.function.BiConsumer<{jakarta.enterprise.inject.spi.configurator.BeanConfigurator%0},jakarta.enterprise.context.spi.CreationalContext<{jakarta.enterprise.inject.spi.configurator.BeanConfigurator%0}>>)
meth public abstract jakarta.enterprise.inject.spi.configurator.BeanConfigurator<{jakarta.enterprise.inject.spi.configurator.BeanConfigurator%0}> disposeWith(java.util.function.BiConsumer<{jakarta.enterprise.inject.spi.configurator.BeanConfigurator%0},jakarta.enterprise.inject.Instance<java.lang.Object>>)
meth public abstract jakarta.enterprise.inject.spi.configurator.BeanConfigurator<{jakarta.enterprise.inject.spi.configurator.BeanConfigurator%0}> id(java.lang.String)
meth public abstract jakarta.enterprise.inject.spi.configurator.BeanConfigurator<{jakarta.enterprise.inject.spi.configurator.BeanConfigurator%0}> injectionPoints(java.util.Set<jakarta.enterprise.inject.spi.InjectionPoint>)
meth public abstract jakarta.enterprise.inject.spi.configurator.BeanConfigurator<{jakarta.enterprise.inject.spi.configurator.BeanConfigurator%0}> name(java.lang.String)
meth public abstract jakarta.enterprise.inject.spi.configurator.BeanConfigurator<{jakarta.enterprise.inject.spi.configurator.BeanConfigurator%0}> qualifiers(java.util.Set<java.lang.annotation.Annotation>)
meth public abstract jakarta.enterprise.inject.spi.configurator.BeanConfigurator<{jakarta.enterprise.inject.spi.configurator.BeanConfigurator%0}> read(jakarta.enterprise.inject.spi.BeanAttributes<?>)
meth public abstract jakarta.enterprise.inject.spi.configurator.BeanConfigurator<{jakarta.enterprise.inject.spi.configurator.BeanConfigurator%0}> scope(java.lang.Class<? extends java.lang.annotation.Annotation>)
meth public abstract jakarta.enterprise.inject.spi.configurator.BeanConfigurator<{jakarta.enterprise.inject.spi.configurator.BeanConfigurator%0}> stereotypes(java.util.Set<java.lang.Class<? extends java.lang.annotation.Annotation>>)
meth public abstract jakarta.enterprise.inject.spi.configurator.BeanConfigurator<{jakarta.enterprise.inject.spi.configurator.BeanConfigurator%0}> types(java.util.Set<java.lang.reflect.Type>)

CLSS public abstract interface jakarta.enterprise.inject.spi.configurator.InjectionPointConfigurator
meth public abstract !varargs jakarta.enterprise.inject.spi.configurator.InjectionPointConfigurator addQualifiers(java.lang.annotation.Annotation[])
meth public abstract !varargs jakarta.enterprise.inject.spi.configurator.InjectionPointConfigurator qualifiers(java.lang.annotation.Annotation[])
meth public abstract jakarta.enterprise.inject.spi.configurator.InjectionPointConfigurator addQualifier(java.lang.annotation.Annotation)
meth public abstract jakarta.enterprise.inject.spi.configurator.InjectionPointConfigurator addQualifiers(java.util.Set<java.lang.annotation.Annotation>)
meth public abstract jakarta.enterprise.inject.spi.configurator.InjectionPointConfigurator delegate(boolean)
meth public abstract jakarta.enterprise.inject.spi.configurator.InjectionPointConfigurator qualifiers(java.util.Set<java.lang.annotation.Annotation>)
meth public abstract jakarta.enterprise.inject.spi.configurator.InjectionPointConfigurator transientField(boolean)
meth public abstract jakarta.enterprise.inject.spi.configurator.InjectionPointConfigurator type(java.lang.reflect.Type)

CLSS public abstract interface jakarta.enterprise.inject.spi.configurator.ObserverMethodConfigurator<%0 extends java.lang.Object>
innr public abstract interface static EventConsumer
meth public abstract !varargs jakarta.enterprise.inject.spi.configurator.ObserverMethodConfigurator<{jakarta.enterprise.inject.spi.configurator.ObserverMethodConfigurator%0}> addQualifiers(java.lang.annotation.Annotation[])
meth public abstract !varargs jakarta.enterprise.inject.spi.configurator.ObserverMethodConfigurator<{jakarta.enterprise.inject.spi.configurator.ObserverMethodConfigurator%0}> qualifiers(java.lang.annotation.Annotation[])
meth public abstract jakarta.enterprise.inject.spi.configurator.ObserverMethodConfigurator<{jakarta.enterprise.inject.spi.configurator.ObserverMethodConfigurator%0}> addQualifier(java.lang.annotation.Annotation)
meth public abstract jakarta.enterprise.inject.spi.configurator.ObserverMethodConfigurator<{jakarta.enterprise.inject.spi.configurator.ObserverMethodConfigurator%0}> addQualifiers(java.util.Set<java.lang.annotation.Annotation>)
meth public abstract jakarta.enterprise.inject.spi.configurator.ObserverMethodConfigurator<{jakarta.enterprise.inject.spi.configurator.ObserverMethodConfigurator%0}> async(boolean)
meth public abstract jakarta.enterprise.inject.spi.configurator.ObserverMethodConfigurator<{jakarta.enterprise.inject.spi.configurator.ObserverMethodConfigurator%0}> beanClass(java.lang.Class<?>)
meth public abstract jakarta.enterprise.inject.spi.configurator.ObserverMethodConfigurator<{jakarta.enterprise.inject.spi.configurator.ObserverMethodConfigurator%0}> notifyWith(jakarta.enterprise.inject.spi.configurator.ObserverMethodConfigurator$EventConsumer<{jakarta.enterprise.inject.spi.configurator.ObserverMethodConfigurator%0}>)
meth public abstract jakarta.enterprise.inject.spi.configurator.ObserverMethodConfigurator<{jakarta.enterprise.inject.spi.configurator.ObserverMethodConfigurator%0}> observedType(java.lang.reflect.Type)
meth public abstract jakarta.enterprise.inject.spi.configurator.ObserverMethodConfigurator<{jakarta.enterprise.inject.spi.configurator.ObserverMethodConfigurator%0}> priority(int)
meth public abstract jakarta.enterprise.inject.spi.configurator.ObserverMethodConfigurator<{jakarta.enterprise.inject.spi.configurator.ObserverMethodConfigurator%0}> qualifiers(java.util.Set<java.lang.annotation.Annotation>)
meth public abstract jakarta.enterprise.inject.spi.configurator.ObserverMethodConfigurator<{jakarta.enterprise.inject.spi.configurator.ObserverMethodConfigurator%0}> read(jakarta.enterprise.inject.spi.AnnotatedMethod<?>)
meth public abstract jakarta.enterprise.inject.spi.configurator.ObserverMethodConfigurator<{jakarta.enterprise.inject.spi.configurator.ObserverMethodConfigurator%0}> read(jakarta.enterprise.inject.spi.ObserverMethod<{jakarta.enterprise.inject.spi.configurator.ObserverMethodConfigurator%0}>)
meth public abstract jakarta.enterprise.inject.spi.configurator.ObserverMethodConfigurator<{jakarta.enterprise.inject.spi.configurator.ObserverMethodConfigurator%0}> read(java.lang.reflect.Method)
meth public abstract jakarta.enterprise.inject.spi.configurator.ObserverMethodConfigurator<{jakarta.enterprise.inject.spi.configurator.ObserverMethodConfigurator%0}> reception(jakarta.enterprise.event.Reception)
meth public abstract jakarta.enterprise.inject.spi.configurator.ObserverMethodConfigurator<{jakarta.enterprise.inject.spi.configurator.ObserverMethodConfigurator%0}> transactionPhase(jakarta.enterprise.event.TransactionPhase)

CLSS public abstract interface static jakarta.enterprise.inject.spi.configurator.ObserverMethodConfigurator$EventConsumer<%0 extends java.lang.Object>
 outer jakarta.enterprise.inject.spi.configurator.ObserverMethodConfigurator
 anno 0 java.lang.FunctionalInterface()
meth public abstract void accept(jakarta.enterprise.inject.spi.EventContext<{jakarta.enterprise.inject.spi.configurator.ObserverMethodConfigurator$EventConsumer%0}>) throws java.lang.Exception

CLSS public abstract interface jakarta.enterprise.inject.spi.configurator.ProducerConfigurator<%0 extends java.lang.Object>
meth public abstract <%0 extends {jakarta.enterprise.inject.spi.configurator.ProducerConfigurator%0}> jakarta.enterprise.inject.spi.configurator.ProducerConfigurator<{jakarta.enterprise.inject.spi.configurator.ProducerConfigurator%0}> produceWith(java.util.function.Function<jakarta.enterprise.context.spi.CreationalContext<{%%0}>,{%%0}>)
meth public abstract jakarta.enterprise.inject.spi.configurator.ProducerConfigurator<{jakarta.enterprise.inject.spi.configurator.ProducerConfigurator%0}> disposeWith(java.util.function.Consumer<{jakarta.enterprise.inject.spi.configurator.ProducerConfigurator%0}>)

CLSS public abstract jakarta.enterprise.util.AnnotationLiteral<%0 extends java.lang.annotation.Annotation>
cons protected <init>()
intf java.io.Serializable
intf java.lang.annotation.Annotation
meth public boolean equals(java.lang.Object)
meth public int hashCode()
meth public java.lang.Class<? extends java.lang.annotation.Annotation> annotationType()
meth public java.lang.String toString()
supr java.lang.Object
hfds annotationType,cachedHashCode,members,serialVersionUID

CLSS public abstract interface !annotation jakarta.enterprise.util.Nonbinding
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[METHOD])
innr public final static Literal
intf java.lang.annotation.Annotation

CLSS public final static jakarta.enterprise.util.Nonbinding$Literal
 outer jakarta.enterprise.util.Nonbinding
cons public <init>()
fld public final static jakarta.enterprise.util.Nonbinding$Literal INSTANCE
intf jakarta.enterprise.util.Nonbinding
supr jakarta.enterprise.util.AnnotationLiteral<jakarta.enterprise.util.Nonbinding>
hfds serialVersionUID

CLSS public abstract jakarta.enterprise.util.TypeLiteral<%0 extends java.lang.Object>
cons protected <init>()
intf java.io.Serializable
meth public boolean equals(java.lang.Object)
meth public final java.lang.Class<{jakarta.enterprise.util.TypeLiteral%0}> getRawType()
meth public final java.lang.reflect.Type getType()
meth public int hashCode()
meth public java.lang.String toString()
supr java.lang.Object
hfds actualType,serialVersionUID

CLSS public abstract interface !annotation jakarta.inject.Inject
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[METHOD, CONSTRUCTOR, FIELD])
intf java.lang.annotation.Annotation

CLSS public abstract interface !annotation jakarta.inject.Named
 anno 0 jakarta.inject.Qualifier()
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
intf java.lang.annotation.Annotation
meth public abstract !hasdefault java.lang.String value() value= ""

CLSS public abstract interface jakarta.inject.Provider<%0 extends java.lang.Object>
meth public abstract {jakarta.inject.Provider%0} get()

CLSS public abstract interface !annotation jakarta.inject.Qualifier
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[ANNOTATION_TYPE])
intf java.lang.annotation.Annotation

CLSS public abstract interface !annotation jakarta.inject.Scope
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[ANNOTATION_TYPE])
intf java.lang.annotation.Annotation

CLSS public abstract interface !annotation jakarta.inject.Singleton
 anno 0 jakarta.inject.Scope()
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
intf java.lang.annotation.Annotation

CLSS public abstract interface !annotation jakarta.interceptor.InterceptorBinding
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[ANNOTATION_TYPE])
intf java.lang.annotation.Annotation

CLSS public abstract interface jakarta.json.bind.Jsonb
intf java.lang.AutoCloseable
meth public abstract <%0 extends java.lang.Object> {%%0} fromJson(java.io.InputStream,java.lang.Class<{%%0}>)
meth public abstract <%0 extends java.lang.Object> {%%0} fromJson(java.io.InputStream,java.lang.reflect.Type)
meth public abstract <%0 extends java.lang.Object> {%%0} fromJson(java.io.Reader,java.lang.Class<{%%0}>)
meth public abstract <%0 extends java.lang.Object> {%%0} fromJson(java.io.Reader,java.lang.reflect.Type)
meth public abstract <%0 extends java.lang.Object> {%%0} fromJson(java.lang.String,java.lang.Class<{%%0}>)
meth public abstract <%0 extends java.lang.Object> {%%0} fromJson(java.lang.String,java.lang.reflect.Type)
meth public abstract java.lang.String toJson(java.lang.Object)
meth public abstract java.lang.String toJson(java.lang.Object,java.lang.reflect.Type)
meth public abstract void toJson(java.lang.Object,java.io.OutputStream)
meth public abstract void toJson(java.lang.Object,java.io.Writer)
meth public abstract void toJson(java.lang.Object,java.lang.reflect.Type,java.io.OutputStream)
meth public abstract void toJson(java.lang.Object,java.lang.reflect.Type,java.io.Writer)

CLSS public abstract interface jakarta.json.bind.JsonbBuilder
meth public abstract jakarta.json.bind.Jsonb build()
meth public abstract jakarta.json.bind.JsonbBuilder withConfig(jakarta.json.bind.JsonbConfig)
meth public abstract jakarta.json.bind.JsonbBuilder withProvider(jakarta.json.spi.JsonProvider)
meth public static jakarta.json.bind.Jsonb create()
meth public static jakarta.json.bind.Jsonb create(jakarta.json.bind.JsonbConfig)
meth public static jakarta.json.bind.JsonbBuilder newBuilder()
meth public static jakarta.json.bind.JsonbBuilder newBuilder(jakarta.json.bind.spi.JsonbProvider)
meth public static jakarta.json.bind.JsonbBuilder newBuilder(java.lang.String)

CLSS public jakarta.json.bind.JsonbConfig
cons public <init>()
fld public final static java.lang.String ADAPTERS = "jsonb.adapters"
fld public final static java.lang.String BINARY_DATA_STRATEGY = "jsonb.binary-data-strategy"
fld public final static java.lang.String DATE_FORMAT = "jsonb.date-format"
fld public final static java.lang.String DESERIALIZERS = "jsonb.derializers"
fld public final static java.lang.String ENCODING = "jsonb.encoding"
fld public final static java.lang.String FORMATTING = "jsonb.formatting"
fld public final static java.lang.String LOCALE = "jsonb.locale"
fld public final static java.lang.String NULL_VALUES = "jsonb.null-values"
fld public final static java.lang.String PROPERTY_NAMING_STRATEGY = "jsonb.property-naming-strategy"
fld public final static java.lang.String PROPERTY_ORDER_STRATEGY = "jsonb.property-order-strategy"
fld public final static java.lang.String PROPERTY_VISIBILITY_STRATEGY = "jsonb.property-visibility-strategy"
fld public final static java.lang.String SERIALIZERS = "jsonb.serializers"
fld public final static java.lang.String STRICT_IJSON = "jsonb.strict-ijson"
meth public !varargs final jakarta.json.bind.JsonbConfig withAdapters(jakarta.json.bind.adapter.JsonbAdapter[])
meth public !varargs final jakarta.json.bind.JsonbConfig withDeserializers(jakarta.json.bind.serializer.JsonbDeserializer[])
meth public !varargs final jakarta.json.bind.JsonbConfig withSerializers(jakarta.json.bind.serializer.JsonbSerializer[])
meth public final jakarta.json.bind.JsonbConfig setProperty(java.lang.String,java.lang.Object)
meth public final jakarta.json.bind.JsonbConfig withBinaryDataStrategy(java.lang.String)
meth public final jakarta.json.bind.JsonbConfig withDateFormat(java.lang.String,java.util.Locale)
meth public final jakarta.json.bind.JsonbConfig withEncoding(java.lang.String)
meth public final jakarta.json.bind.JsonbConfig withFormatting(java.lang.Boolean)
meth public final jakarta.json.bind.JsonbConfig withLocale(java.util.Locale)
meth public final jakarta.json.bind.JsonbConfig withNullValues(java.lang.Boolean)
meth public final jakarta.json.bind.JsonbConfig withPropertyNamingStrategy(jakarta.json.bind.config.PropertyNamingStrategy)
meth public final jakarta.json.bind.JsonbConfig withPropertyNamingStrategy(java.lang.String)
meth public final jakarta.json.bind.JsonbConfig withPropertyOrderStrategy(java.lang.String)
meth public final jakarta.json.bind.JsonbConfig withPropertyVisibilityStrategy(jakarta.json.bind.config.PropertyVisibilityStrategy)
meth public final jakarta.json.bind.JsonbConfig withStrictIJSON(java.lang.Boolean)
meth public final java.util.Map<java.lang.String,java.lang.Object> getAsMap()
meth public final java.util.Optional<java.lang.Object> getProperty(java.lang.String)
supr java.lang.Object
hfds configuration

CLSS public jakarta.json.bind.JsonbException
cons public <init>(java.lang.String)
cons public <init>(java.lang.String,java.lang.Throwable)
supr java.lang.RuntimeException
hfds serialVersionUID

CLSS public abstract interface jakarta.json.bind.adapter.JsonbAdapter<%0 extends java.lang.Object, %1 extends java.lang.Object>
meth public abstract {jakarta.json.bind.adapter.JsonbAdapter%0} adaptFromJson({jakarta.json.bind.adapter.JsonbAdapter%1}) throws java.lang.Exception
meth public abstract {jakarta.json.bind.adapter.JsonbAdapter%1} adaptToJson({jakarta.json.bind.adapter.JsonbAdapter%0}) throws java.lang.Exception

CLSS public abstract interface !annotation jakarta.json.bind.annotation.JsonbAnnotation
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
intf java.lang.annotation.Annotation

CLSS public abstract interface !annotation jakarta.json.bind.annotation.JsonbCreator
 anno 0 jakarta.json.bind.annotation.JsonbAnnotation()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[ANNOTATION_TYPE, METHOD, CONSTRUCTOR])
intf java.lang.annotation.Annotation

CLSS public abstract interface !annotation jakarta.json.bind.annotation.JsonbDateFormat
 anno 0 jakarta.json.bind.annotation.JsonbAnnotation()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[ANNOTATION_TYPE, FIELD, METHOD, TYPE, PARAMETER, PACKAGE])
fld public final static java.lang.String DEFAULT_FORMAT = "##default"
fld public final static java.lang.String DEFAULT_LOCALE = "##default"
fld public final static java.lang.String TIME_IN_MILLIS = "##time-in-millis"
intf java.lang.annotation.Annotation
meth public abstract !hasdefault java.lang.String locale() value= "##default"
meth public abstract !hasdefault java.lang.String value() value= "##default"

CLSS public abstract interface !annotation jakarta.json.bind.annotation.JsonbNillable
 anno 0 jakarta.json.bind.annotation.JsonbAnnotation()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[ANNOTATION_TYPE, TYPE, PACKAGE])
intf java.lang.annotation.Annotation
meth public abstract !hasdefault boolean value() value= true

CLSS public abstract interface !annotation jakarta.json.bind.annotation.JsonbNumberFormat
 anno 0 jakarta.json.bind.annotation.JsonbAnnotation()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[ANNOTATION_TYPE, FIELD, METHOD, TYPE, PARAMETER, PACKAGE])
fld public final static java.lang.String DEFAULT_LOCALE = "##default"
intf java.lang.annotation.Annotation
meth public abstract !hasdefault java.lang.String locale() value= "##default"
meth public abstract !hasdefault java.lang.String value() value= ""

CLSS public abstract interface !annotation jakarta.json.bind.annotation.JsonbProperty
 anno 0 jakarta.json.bind.annotation.JsonbAnnotation()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[ANNOTATION_TYPE, METHOD, FIELD, PARAMETER])
intf java.lang.annotation.Annotation
meth public abstract !hasdefault boolean nillable() value= false
meth public abstract !hasdefault java.lang.String value() value= ""

CLSS public abstract interface !annotation jakarta.json.bind.annotation.JsonbPropertyOrder
 anno 0 jakarta.json.bind.annotation.JsonbAnnotation()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[ANNOTATION_TYPE, TYPE])
intf java.lang.annotation.Annotation
meth public abstract java.lang.String[] value()

CLSS public abstract interface !annotation jakarta.json.bind.annotation.JsonbTransient
 anno 0 jakarta.json.bind.annotation.JsonbAnnotation()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[ANNOTATION_TYPE, FIELD, METHOD])
intf java.lang.annotation.Annotation

CLSS public abstract interface !annotation jakarta.json.bind.annotation.JsonbTypeAdapter
 anno 0 jakarta.json.bind.annotation.JsonbAnnotation()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[ANNOTATION_TYPE, TYPE, FIELD, METHOD])
intf java.lang.annotation.Annotation
meth public abstract java.lang.Class<? extends jakarta.json.bind.adapter.JsonbAdapter> value()

CLSS public abstract interface !annotation jakarta.json.bind.annotation.JsonbTypeDeserializer
 anno 0 jakarta.json.bind.annotation.JsonbAnnotation()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[ANNOTATION_TYPE, TYPE, FIELD, METHOD])
intf java.lang.annotation.Annotation
meth public abstract java.lang.Class<? extends jakarta.json.bind.serializer.JsonbDeserializer> value()

CLSS public abstract interface !annotation jakarta.json.bind.annotation.JsonbTypeSerializer
 anno 0 jakarta.json.bind.annotation.JsonbAnnotation()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[ANNOTATION_TYPE, TYPE, FIELD, METHOD])
intf java.lang.annotation.Annotation
meth public abstract java.lang.Class<? extends jakarta.json.bind.serializer.JsonbSerializer> value()

CLSS public abstract interface !annotation jakarta.json.bind.annotation.JsonbVisibility
 anno 0 jakarta.json.bind.annotation.JsonbAnnotation()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[ANNOTATION_TYPE, TYPE, PACKAGE])
intf java.lang.annotation.Annotation
meth public abstract java.lang.Class<? extends jakarta.json.bind.config.PropertyVisibilityStrategy> value()

CLSS public final jakarta.json.bind.config.BinaryDataStrategy
fld public final static java.lang.String BASE_64 = "BASE_64"
fld public final static java.lang.String BASE_64_URL = "BASE_64_URL"
fld public final static java.lang.String BYTE = "BYTE"
supr java.lang.Object

CLSS public abstract interface jakarta.json.bind.config.PropertyNamingStrategy
fld public final static java.lang.String CASE_INSENSITIVE = "CASE_INSENSITIVE"
fld public final static java.lang.String IDENTITY = "IDENTITY"
fld public final static java.lang.String LOWER_CASE_WITH_DASHES = "LOWER_CASE_WITH_DASHES"
fld public final static java.lang.String LOWER_CASE_WITH_UNDERSCORES = "LOWER_CASE_WITH_UNDERSCORES"
fld public final static java.lang.String UPPER_CAMEL_CASE = "UPPER_CAMEL_CASE"
fld public final static java.lang.String UPPER_CAMEL_CASE_WITH_SPACES = "UPPER_CAMEL_CASE_WITH_SPACES"
meth public abstract java.lang.String translateName(java.lang.String)

CLSS public final jakarta.json.bind.config.PropertyOrderStrategy
fld public final static java.lang.String ANY = "ANY"
fld public final static java.lang.String LEXICOGRAPHICAL = "LEXICOGRAPHICAL"
fld public final static java.lang.String REVERSE = "REVERSE"
supr java.lang.Object

CLSS public abstract interface jakarta.json.bind.config.PropertyVisibilityStrategy
meth public abstract boolean isVisible(java.lang.reflect.Field)
meth public abstract boolean isVisible(java.lang.reflect.Method)

CLSS public abstract interface jakarta.json.bind.serializer.DeserializationContext
meth public abstract <%0 extends java.lang.Object> {%%0} deserialize(java.lang.Class<{%%0}>,jakarta.json.stream.JsonParser)
meth public abstract <%0 extends java.lang.Object> {%%0} deserialize(java.lang.reflect.Type,jakarta.json.stream.JsonParser)

CLSS public abstract interface jakarta.json.bind.serializer.JsonbDeserializer<%0 extends java.lang.Object>
meth public abstract {jakarta.json.bind.serializer.JsonbDeserializer%0} deserialize(jakarta.json.stream.JsonParser,jakarta.json.bind.serializer.DeserializationContext,java.lang.reflect.Type)

CLSS public abstract interface jakarta.json.bind.serializer.JsonbSerializer<%0 extends java.lang.Object>
meth public abstract void serialize({jakarta.json.bind.serializer.JsonbSerializer%0},jakarta.json.stream.JsonGenerator,jakarta.json.bind.serializer.SerializationContext)

CLSS public abstract interface jakarta.json.bind.serializer.SerializationContext
meth public abstract <%0 extends java.lang.Object> void serialize(java.lang.String,{%%0},jakarta.json.stream.JsonGenerator)
meth public abstract <%0 extends java.lang.Object> void serialize({%%0},jakarta.json.stream.JsonGenerator)

CLSS public abstract jakarta.json.bind.spi.JsonbProvider
cons protected <init>()
meth public abstract jakarta.json.bind.JsonbBuilder create()
meth public static jakarta.json.bind.spi.JsonbProvider provider()
meth public static jakarta.json.bind.spi.JsonbProvider provider(java.lang.String)
supr java.lang.Object
hfds DEFAULT_PROVIDER

CLSS public jakarta.security.auth.message.AuthException
cons public <init>()
cons public <init>(java.lang.String)
supr javax.security.auth.login.LoginException
hfds serialVersionUID

CLSS public jakarta.security.auth.message.AuthStatus
fld public final static jakarta.security.auth.message.AuthStatus FAILURE
fld public final static jakarta.security.auth.message.AuthStatus SEND_CONTINUE
fld public final static jakarta.security.auth.message.AuthStatus SEND_FAILURE
fld public final static jakarta.security.auth.message.AuthStatus SEND_SUCCESS
fld public final static jakarta.security.auth.message.AuthStatus SUCCESS
meth public java.lang.String toString()
supr java.lang.Object
hfds value

CLSS public abstract interface jakarta.security.auth.message.ClientAuth
meth public abstract jakarta.security.auth.message.AuthStatus secureRequest(jakarta.security.auth.message.MessageInfo,javax.security.auth.Subject) throws jakarta.security.auth.message.AuthException
meth public abstract jakarta.security.auth.message.AuthStatus validateResponse(jakarta.security.auth.message.MessageInfo,javax.security.auth.Subject,javax.security.auth.Subject) throws jakarta.security.auth.message.AuthException
meth public abstract void cleanSubject(jakarta.security.auth.message.MessageInfo,javax.security.auth.Subject) throws jakarta.security.auth.message.AuthException

CLSS public abstract interface jakarta.security.auth.message.MessageInfo
meth public abstract java.lang.Object getRequestMessage()
meth public abstract java.lang.Object getResponseMessage()
meth public abstract java.util.Map getMap()
meth public abstract void setRequestMessage(java.lang.Object)
meth public abstract void setResponseMessage(java.lang.Object)

CLSS public jakarta.security.auth.message.MessagePolicy
cons public <init>(jakarta.security.auth.message.MessagePolicy$TargetPolicy[],boolean)
innr public abstract interface static ProtectionPolicy
innr public abstract interface static Target
innr public static TargetPolicy
meth public boolean isMandatory()
meth public jakarta.security.auth.message.MessagePolicy$TargetPolicy[] getTargetPolicies()
supr java.lang.Object
hfds mandatory,targetPolicies

CLSS public abstract interface static jakarta.security.auth.message.MessagePolicy$ProtectionPolicy
 outer jakarta.security.auth.message.MessagePolicy
fld public final static java.lang.String AUTHENTICATE_CONTENT = "#authenticateContent"
fld public final static java.lang.String AUTHENTICATE_RECIPIENT = "#authenticateRecipient"
fld public final static java.lang.String AUTHENTICATE_SENDER = "#authenticateSender"
meth public abstract java.lang.String getID()

CLSS public abstract interface static jakarta.security.auth.message.MessagePolicy$Target
 outer jakarta.security.auth.message.MessagePolicy
meth public abstract java.lang.Object get(jakarta.security.auth.message.MessageInfo)
meth public abstract void put(jakarta.security.auth.message.MessageInfo,java.lang.Object)
meth public abstract void remove(jakarta.security.auth.message.MessageInfo)

CLSS public static jakarta.security.auth.message.MessagePolicy$TargetPolicy
 outer jakarta.security.auth.message.MessagePolicy
cons public <init>(jakarta.security.auth.message.MessagePolicy$Target[],jakarta.security.auth.message.MessagePolicy$ProtectionPolicy)
meth public jakarta.security.auth.message.MessagePolicy$ProtectionPolicy getProtectionPolicy()
meth public jakarta.security.auth.message.MessagePolicy$Target[] getTargets()
supr java.lang.Object
hfds protectionPolicy,targets

CLSS public abstract interface jakarta.security.auth.message.ServerAuth
meth public abstract jakarta.security.auth.message.AuthStatus secureResponse(jakarta.security.auth.message.MessageInfo,javax.security.auth.Subject) throws jakarta.security.auth.message.AuthException
meth public abstract jakarta.security.auth.message.AuthStatus validateRequest(jakarta.security.auth.message.MessageInfo,javax.security.auth.Subject,javax.security.auth.Subject) throws jakarta.security.auth.message.AuthException
meth public abstract void cleanSubject(jakarta.security.auth.message.MessageInfo,javax.security.auth.Subject) throws jakarta.security.auth.message.AuthException

CLSS public jakarta.security.auth.message.callback.CallerPrincipalCallback
cons public <init>(javax.security.auth.Subject,java.lang.String)
cons public <init>(javax.security.auth.Subject,java.security.Principal)
intf javax.security.auth.callback.Callback
meth public java.lang.String getName()
meth public java.security.Principal getPrincipal()
meth public javax.security.auth.Subject getSubject()
supr java.lang.Object
hfds name,principal,subject

CLSS public jakarta.security.auth.message.callback.CertStoreCallback
cons public <init>()
intf javax.security.auth.callback.Callback
meth public java.security.cert.CertStore getCertStore()
meth public void setCertStore(java.security.cert.CertStore)
supr java.lang.Object
hfds certStore

CLSS public jakarta.security.auth.message.callback.GroupPrincipalCallback
cons public <init>(javax.security.auth.Subject,java.lang.String[])
intf javax.security.auth.callback.Callback
meth public java.lang.String[] getGroups()
meth public javax.security.auth.Subject getSubject()
supr java.lang.Object
hfds groups,subject

CLSS public jakarta.security.auth.message.callback.PasswordValidationCallback
cons public <init>(javax.security.auth.Subject,java.lang.String,char[])
intf javax.security.auth.callback.Callback
meth public boolean getResult()
meth public char[] getPassword()
meth public java.lang.String getUsername()
meth public javax.security.auth.Subject getSubject()
meth public void clearPassword()
meth public void setResult(boolean)
supr java.lang.Object
hfds password,result,subject,username

CLSS public jakarta.security.auth.message.callback.PrivateKeyCallback
cons public <init>(jakarta.security.auth.message.callback.PrivateKeyCallback$Request)
innr public abstract interface static Request
innr public static AliasRequest
innr public static DigestRequest
innr public static IssuerSerialNumRequest
innr public static SubjectKeyIDRequest
intf javax.security.auth.callback.Callback
meth public jakarta.security.auth.message.callback.PrivateKeyCallback$Request getRequest()
meth public java.security.PrivateKey getKey()
meth public java.security.cert.Certificate[] getChain()
meth public void setKey(java.security.PrivateKey,java.security.cert.Certificate[])
supr java.lang.Object
hfds chain,key,request

CLSS public static jakarta.security.auth.message.callback.PrivateKeyCallback$AliasRequest
 outer jakarta.security.auth.message.callback.PrivateKeyCallback
cons public <init>(java.lang.String)
intf jakarta.security.auth.message.callback.PrivateKeyCallback$Request
meth public java.lang.String getAlias()
supr java.lang.Object
hfds alias

CLSS public static jakarta.security.auth.message.callback.PrivateKeyCallback$DigestRequest
 outer jakarta.security.auth.message.callback.PrivateKeyCallback
cons public <init>(byte[],java.lang.String)
intf jakarta.security.auth.message.callback.PrivateKeyCallback$Request
meth public byte[] getDigest()
meth public java.lang.String getAlgorithm()
supr java.lang.Object
hfds algorithm,digest

CLSS public static jakarta.security.auth.message.callback.PrivateKeyCallback$IssuerSerialNumRequest
 outer jakarta.security.auth.message.callback.PrivateKeyCallback
cons public <init>(javax.security.auth.x500.X500Principal,java.math.BigInteger)
intf jakarta.security.auth.message.callback.PrivateKeyCallback$Request
meth public java.math.BigInteger getSerialNum()
meth public javax.security.auth.x500.X500Principal getIssuer()
supr java.lang.Object
hfds issuer,serialNum

CLSS public abstract interface static jakarta.security.auth.message.callback.PrivateKeyCallback$Request
 outer jakarta.security.auth.message.callback.PrivateKeyCallback

CLSS public static jakarta.security.auth.message.callback.PrivateKeyCallback$SubjectKeyIDRequest
 outer jakarta.security.auth.message.callback.PrivateKeyCallback
cons public <init>(byte[])
intf jakarta.security.auth.message.callback.PrivateKeyCallback$Request
meth public byte[] getSubjectKeyID()
supr java.lang.Object
hfds id

CLSS public jakarta.security.auth.message.callback.SecretKeyCallback
cons public <init>(jakarta.security.auth.message.callback.SecretKeyCallback$Request)
innr public abstract interface static Request
innr public static AliasRequest
intf javax.security.auth.callback.Callback
meth public jakarta.security.auth.message.callback.SecretKeyCallback$Request getRequest()
meth public javax.crypto.SecretKey getKey()
meth public void setKey(javax.crypto.SecretKey)
supr java.lang.Object
hfds key,request

CLSS public static jakarta.security.auth.message.callback.SecretKeyCallback$AliasRequest
 outer jakarta.security.auth.message.callback.SecretKeyCallback
cons public <init>(java.lang.String)
intf jakarta.security.auth.message.callback.SecretKeyCallback$Request
meth public java.lang.String getAlias()
supr java.lang.Object
hfds alias

CLSS public abstract interface static jakarta.security.auth.message.callback.SecretKeyCallback$Request
 outer jakarta.security.auth.message.callback.SecretKeyCallback

CLSS public jakarta.security.auth.message.callback.TrustStoreCallback
cons public <init>()
intf javax.security.auth.callback.Callback
meth public java.security.KeyStore getTrustStore()
meth public void setTrustStore(java.security.KeyStore)
supr java.lang.Object
hfds trustStore

CLSS public abstract interface jakarta.security.auth.message.config.AuthConfig
meth public abstract boolean isProtected()
meth public abstract java.lang.String getAppContext()
meth public abstract java.lang.String getAuthContextID(jakarta.security.auth.message.MessageInfo)
meth public abstract java.lang.String getMessageLayer()
meth public abstract void refresh()

CLSS public abstract jakarta.security.auth.message.config.AuthConfigFactory
cons public <init>()
fld public final static java.lang.String DEFAULT_FACTORY_SECURITY_PROPERTY = "authconfigprovider.factory"
fld public final static java.lang.String GET_FACTORY_PERMISSION_NAME = "getProperty.authconfigprovider.factory"
fld public final static java.lang.String PROVIDER_REGISTRATION_PERMISSION_NAME = "setProperty.authconfigfactory.provider"
fld public final static java.lang.String SET_FACTORY_PERMISSION_NAME = "setProperty.authconfigprovider.factory"
fld public final static java.security.SecurityPermission getFactorySecurityPermission
fld public final static java.security.SecurityPermission providerRegistrationSecurityPermission
fld public final static java.security.SecurityPermission setFactorySecurityPermission
innr public abstract interface static RegistrationContext
meth public abstract boolean removeRegistration(java.lang.String)
meth public abstract jakarta.security.auth.message.config.AuthConfigFactory$RegistrationContext getRegistrationContext(java.lang.String)
meth public abstract jakarta.security.auth.message.config.AuthConfigProvider getConfigProvider(java.lang.String,java.lang.String,jakarta.security.auth.message.config.RegistrationListener)
meth public abstract java.lang.String registerConfigProvider(jakarta.security.auth.message.config.AuthConfigProvider,java.lang.String,java.lang.String,java.lang.String)
meth public abstract java.lang.String registerConfigProvider(java.lang.String,java.util.Map,java.lang.String,java.lang.String,java.lang.String)
meth public abstract java.lang.String[] detachListener(jakarta.security.auth.message.config.RegistrationListener,java.lang.String,java.lang.String)
meth public abstract java.lang.String[] getRegistrationIDs(jakarta.security.auth.message.config.AuthConfigProvider)
meth public abstract void refresh()
meth public static jakarta.security.auth.message.config.AuthConfigFactory getFactory()
meth public static void setFactory(jakarta.security.auth.message.config.AuthConfigFactory)
supr java.lang.Object
hfds PROVIDER_SECURITY_PROPERTY,factory

CLSS public abstract interface static jakarta.security.auth.message.config.AuthConfigFactory$RegistrationContext
 outer jakarta.security.auth.message.config.AuthConfigFactory
meth public abstract boolean isPersistent()
meth public abstract java.lang.String getAppContext()
meth public abstract java.lang.String getDescription()
meth public abstract java.lang.String getMessageLayer()

CLSS public abstract interface jakarta.security.auth.message.config.AuthConfigProvider
meth public abstract jakarta.security.auth.message.config.ClientAuthConfig getClientAuthConfig(java.lang.String,java.lang.String,javax.security.auth.callback.CallbackHandler) throws jakarta.security.auth.message.AuthException
meth public abstract jakarta.security.auth.message.config.ServerAuthConfig getServerAuthConfig(java.lang.String,java.lang.String,javax.security.auth.callback.CallbackHandler) throws jakarta.security.auth.message.AuthException
meth public abstract void refresh()

CLSS public abstract interface jakarta.security.auth.message.config.ClientAuthConfig
intf jakarta.security.auth.message.config.AuthConfig
meth public abstract jakarta.security.auth.message.config.ClientAuthContext getAuthContext(java.lang.String,javax.security.auth.Subject,java.util.Map) throws jakarta.security.auth.message.AuthException

CLSS public abstract interface jakarta.security.auth.message.config.ClientAuthContext
intf jakarta.security.auth.message.ClientAuth

CLSS public abstract interface jakarta.security.auth.message.config.RegistrationListener
meth public abstract void notify(java.lang.String,java.lang.String)

CLSS public abstract interface jakarta.security.auth.message.config.ServerAuthConfig
intf jakarta.security.auth.message.config.AuthConfig
meth public abstract jakarta.security.auth.message.config.ServerAuthContext getAuthContext(java.lang.String,javax.security.auth.Subject,java.util.Map) throws jakarta.security.auth.message.AuthException

CLSS public abstract interface jakarta.security.auth.message.config.ServerAuthContext
intf jakarta.security.auth.message.ServerAuth

CLSS public abstract interface jakarta.security.auth.message.module.ClientAuthModule
intf jakarta.security.auth.message.ClientAuth
meth public abstract java.lang.Class[] getSupportedMessageTypes()
meth public abstract void initialize(jakarta.security.auth.message.MessagePolicy,jakarta.security.auth.message.MessagePolicy,javax.security.auth.callback.CallbackHandler,java.util.Map) throws jakarta.security.auth.message.AuthException

CLSS public abstract interface jakarta.security.auth.message.module.ServerAuthModule
intf jakarta.security.auth.message.ServerAuth
meth public abstract java.lang.Class[] getSupportedMessageTypes()
meth public abstract void initialize(jakarta.security.auth.message.MessagePolicy,jakarta.security.auth.message.MessagePolicy,javax.security.auth.callback.CallbackHandler,java.util.Map) throws jakarta.security.auth.message.AuthException

CLSS public abstract interface jakarta.validation.BootstrapConfiguration
meth public abstract boolean isExecutableValidationEnabled()
meth public abstract java.lang.String getClockProviderClassName()
meth public abstract java.lang.String getConstraintValidatorFactoryClassName()
meth public abstract java.lang.String getDefaultProviderClassName()
meth public abstract java.lang.String getMessageInterpolatorClassName()
meth public abstract java.lang.String getParameterNameProviderClassName()
meth public abstract java.lang.String getTraversableResolverClassName()
meth public abstract java.util.Map<java.lang.String,java.lang.String> getProperties()
meth public abstract java.util.Set<jakarta.validation.executable.ExecutableType> getDefaultValidatedExecutableTypes()
meth public abstract java.util.Set<java.lang.String> getConstraintMappingResourcePaths()
meth public abstract java.util.Set<java.lang.String> getValueExtractorClassNames()

CLSS public abstract interface jakarta.validation.ClockProvider
meth public abstract java.time.Clock getClock()

CLSS public abstract interface jakarta.validation.Configuration<%0 extends jakarta.validation.Configuration<{jakarta.validation.Configuration%0}>>
meth public abstract jakarta.validation.BootstrapConfiguration getBootstrapConfiguration()
meth public abstract jakarta.validation.ClockProvider getDefaultClockProvider()
meth public abstract jakarta.validation.ConstraintValidatorFactory getDefaultConstraintValidatorFactory()
meth public abstract jakarta.validation.MessageInterpolator getDefaultMessageInterpolator()
meth public abstract jakarta.validation.ParameterNameProvider getDefaultParameterNameProvider()
meth public abstract jakarta.validation.TraversableResolver getDefaultTraversableResolver()
meth public abstract jakarta.validation.ValidatorFactory buildValidatorFactory()
meth public abstract {jakarta.validation.Configuration%0} addMapping(java.io.InputStream)
meth public abstract {jakarta.validation.Configuration%0} addProperty(java.lang.String,java.lang.String)
meth public abstract {jakarta.validation.Configuration%0} addValueExtractor(jakarta.validation.valueextraction.ValueExtractor<?>)
meth public abstract {jakarta.validation.Configuration%0} clockProvider(jakarta.validation.ClockProvider)
meth public abstract {jakarta.validation.Configuration%0} constraintValidatorFactory(jakarta.validation.ConstraintValidatorFactory)
meth public abstract {jakarta.validation.Configuration%0} ignoreXmlConfiguration()
meth public abstract {jakarta.validation.Configuration%0} messageInterpolator(jakarta.validation.MessageInterpolator)
meth public abstract {jakarta.validation.Configuration%0} parameterNameProvider(jakarta.validation.ParameterNameProvider)
meth public abstract {jakarta.validation.Configuration%0} traversableResolver(jakarta.validation.TraversableResolver)

CLSS public abstract interface !annotation jakarta.validation.Constraint
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[ANNOTATION_TYPE])
intf java.lang.annotation.Annotation
meth public abstract java.lang.Class<? extends jakarta.validation.ConstraintValidator<?,?>>[] validatedBy()

CLSS public jakarta.validation.ConstraintDeclarationException
cons public <init>()
cons public <init>(java.lang.String)
cons public <init>(java.lang.String,java.lang.Throwable)
cons public <init>(java.lang.Throwable)
supr jakarta.validation.ValidationException

CLSS public jakarta.validation.ConstraintDefinitionException
cons public <init>()
cons public <init>(java.lang.String)
cons public <init>(java.lang.String,java.lang.Throwable)
cons public <init>(java.lang.Throwable)
supr jakarta.validation.ValidationException

CLSS public final !enum jakarta.validation.ConstraintTarget
fld public final static jakarta.validation.ConstraintTarget IMPLICIT
fld public final static jakarta.validation.ConstraintTarget PARAMETERS
fld public final static jakarta.validation.ConstraintTarget RETURN_VALUE
meth public static jakarta.validation.ConstraintTarget valueOf(java.lang.String)
meth public static jakarta.validation.ConstraintTarget[] values()
supr java.lang.Enum<jakarta.validation.ConstraintTarget>

CLSS public abstract interface jakarta.validation.ConstraintValidator<%0 extends java.lang.annotation.Annotation, %1 extends java.lang.Object>
meth public abstract boolean isValid({jakarta.validation.ConstraintValidator%1},jakarta.validation.ConstraintValidatorContext)
meth public void initialize({jakarta.validation.ConstraintValidator%0})

CLSS public abstract interface jakarta.validation.ConstraintValidatorContext
innr public abstract interface static ConstraintViolationBuilder
meth public abstract <%0 extends java.lang.Object> {%%0} unwrap(java.lang.Class<{%%0}>)
meth public abstract jakarta.validation.ClockProvider getClockProvider()
meth public abstract jakarta.validation.ConstraintValidatorContext$ConstraintViolationBuilder buildConstraintViolationWithTemplate(java.lang.String)
meth public abstract java.lang.String getDefaultConstraintMessageTemplate()
meth public abstract void disableDefaultConstraintViolation()

CLSS public abstract interface static jakarta.validation.ConstraintValidatorContext$ConstraintViolationBuilder
 outer jakarta.validation.ConstraintValidatorContext
innr public abstract interface static ContainerElementNodeBuilderCustomizableContext
innr public abstract interface static ContainerElementNodeBuilderDefinedContext
innr public abstract interface static ContainerElementNodeContextBuilder
innr public abstract interface static LeafNodeBuilderCustomizableContext
innr public abstract interface static LeafNodeBuilderDefinedContext
innr public abstract interface static LeafNodeContextBuilder
innr public abstract interface static NodeBuilderCustomizableContext
innr public abstract interface static NodeBuilderDefinedContext
innr public abstract interface static NodeContextBuilder
meth public abstract jakarta.validation.ConstraintValidatorContext addConstraintViolation()
meth public abstract jakarta.validation.ConstraintValidatorContext$ConstraintViolationBuilder$ContainerElementNodeBuilderCustomizableContext addContainerElementNode(java.lang.String,java.lang.Class<?>,java.lang.Integer)
meth public abstract jakarta.validation.ConstraintValidatorContext$ConstraintViolationBuilder$LeafNodeBuilderCustomizableContext addBeanNode()
meth public abstract jakarta.validation.ConstraintValidatorContext$ConstraintViolationBuilder$NodeBuilderCustomizableContext addPropertyNode(java.lang.String)
meth public abstract jakarta.validation.ConstraintValidatorContext$ConstraintViolationBuilder$NodeBuilderDefinedContext addNode(java.lang.String)
meth public abstract jakarta.validation.ConstraintValidatorContext$ConstraintViolationBuilder$NodeBuilderDefinedContext addParameterNode(int)

CLSS public abstract interface static jakarta.validation.ConstraintValidatorContext$ConstraintViolationBuilder$ContainerElementNodeBuilderCustomizableContext
 outer jakarta.validation.ConstraintValidatorContext$ConstraintViolationBuilder
meth public abstract jakarta.validation.ConstraintValidatorContext addConstraintViolation()
meth public abstract jakarta.validation.ConstraintValidatorContext$ConstraintViolationBuilder$ContainerElementNodeBuilderCustomizableContext addContainerElementNode(java.lang.String,java.lang.Class<?>,java.lang.Integer)
meth public abstract jakarta.validation.ConstraintValidatorContext$ConstraintViolationBuilder$ContainerElementNodeContextBuilder inIterable()
meth public abstract jakarta.validation.ConstraintValidatorContext$ConstraintViolationBuilder$LeafNodeBuilderCustomizableContext addBeanNode()
meth public abstract jakarta.validation.ConstraintValidatorContext$ConstraintViolationBuilder$NodeBuilderCustomizableContext addPropertyNode(java.lang.String)

CLSS public abstract interface static jakarta.validation.ConstraintValidatorContext$ConstraintViolationBuilder$ContainerElementNodeBuilderDefinedContext
 outer jakarta.validation.ConstraintValidatorContext$ConstraintViolationBuilder
meth public abstract jakarta.validation.ConstraintValidatorContext addConstraintViolation()
meth public abstract jakarta.validation.ConstraintValidatorContext$ConstraintViolationBuilder$ContainerElementNodeBuilderCustomizableContext addContainerElementNode(java.lang.String,java.lang.Class<?>,java.lang.Integer)
meth public abstract jakarta.validation.ConstraintValidatorContext$ConstraintViolationBuilder$LeafNodeBuilderCustomizableContext addBeanNode()
meth public abstract jakarta.validation.ConstraintValidatorContext$ConstraintViolationBuilder$NodeBuilderCustomizableContext addPropertyNode(java.lang.String)

CLSS public abstract interface static jakarta.validation.ConstraintValidatorContext$ConstraintViolationBuilder$ContainerElementNodeContextBuilder
 outer jakarta.validation.ConstraintValidatorContext$ConstraintViolationBuilder
meth public abstract jakarta.validation.ConstraintValidatorContext addConstraintViolation()
meth public abstract jakarta.validation.ConstraintValidatorContext$ConstraintViolationBuilder$ContainerElementNodeBuilderCustomizableContext addContainerElementNode(java.lang.String,java.lang.Class<?>,java.lang.Integer)
meth public abstract jakarta.validation.ConstraintValidatorContext$ConstraintViolationBuilder$ContainerElementNodeBuilderDefinedContext atIndex(java.lang.Integer)
meth public abstract jakarta.validation.ConstraintValidatorContext$ConstraintViolationBuilder$ContainerElementNodeBuilderDefinedContext atKey(java.lang.Object)
meth public abstract jakarta.validation.ConstraintValidatorContext$ConstraintViolationBuilder$LeafNodeBuilderCustomizableContext addBeanNode()
meth public abstract jakarta.validation.ConstraintValidatorContext$ConstraintViolationBuilder$NodeBuilderCustomizableContext addPropertyNode(java.lang.String)

CLSS public abstract interface static jakarta.validation.ConstraintValidatorContext$ConstraintViolationBuilder$LeafNodeBuilderCustomizableContext
 outer jakarta.validation.ConstraintValidatorContext$ConstraintViolationBuilder
meth public abstract jakarta.validation.ConstraintValidatorContext addConstraintViolation()
meth public abstract jakarta.validation.ConstraintValidatorContext$ConstraintViolationBuilder$LeafNodeBuilderCustomizableContext inContainer(java.lang.Class<?>,java.lang.Integer)
meth public abstract jakarta.validation.ConstraintValidatorContext$ConstraintViolationBuilder$LeafNodeContextBuilder inIterable()

CLSS public abstract interface static jakarta.validation.ConstraintValidatorContext$ConstraintViolationBuilder$LeafNodeBuilderDefinedContext
 outer jakarta.validation.ConstraintValidatorContext$ConstraintViolationBuilder
meth public abstract jakarta.validation.ConstraintValidatorContext addConstraintViolation()

CLSS public abstract interface static jakarta.validation.ConstraintValidatorContext$ConstraintViolationBuilder$LeafNodeContextBuilder
 outer jakarta.validation.ConstraintValidatorContext$ConstraintViolationBuilder
meth public abstract jakarta.validation.ConstraintValidatorContext addConstraintViolation()
meth public abstract jakarta.validation.ConstraintValidatorContext$ConstraintViolationBuilder$LeafNodeBuilderDefinedContext atIndex(java.lang.Integer)
meth public abstract jakarta.validation.ConstraintValidatorContext$ConstraintViolationBuilder$LeafNodeBuilderDefinedContext atKey(java.lang.Object)

CLSS public abstract interface static jakarta.validation.ConstraintValidatorContext$ConstraintViolationBuilder$NodeBuilderCustomizableContext
 outer jakarta.validation.ConstraintValidatorContext$ConstraintViolationBuilder
meth public abstract jakarta.validation.ConstraintValidatorContext addConstraintViolation()
meth public abstract jakarta.validation.ConstraintValidatorContext$ConstraintViolationBuilder$ContainerElementNodeBuilderCustomizableContext addContainerElementNode(java.lang.String,java.lang.Class<?>,java.lang.Integer)
meth public abstract jakarta.validation.ConstraintValidatorContext$ConstraintViolationBuilder$LeafNodeBuilderCustomizableContext addBeanNode()
meth public abstract jakarta.validation.ConstraintValidatorContext$ConstraintViolationBuilder$NodeBuilderCustomizableContext addNode(java.lang.String)
meth public abstract jakarta.validation.ConstraintValidatorContext$ConstraintViolationBuilder$NodeBuilderCustomizableContext addPropertyNode(java.lang.String)
meth public abstract jakarta.validation.ConstraintValidatorContext$ConstraintViolationBuilder$NodeBuilderCustomizableContext inContainer(java.lang.Class<?>,java.lang.Integer)
meth public abstract jakarta.validation.ConstraintValidatorContext$ConstraintViolationBuilder$NodeContextBuilder inIterable()

CLSS public abstract interface static jakarta.validation.ConstraintValidatorContext$ConstraintViolationBuilder$NodeBuilderDefinedContext
 outer jakarta.validation.ConstraintValidatorContext$ConstraintViolationBuilder
meth public abstract jakarta.validation.ConstraintValidatorContext addConstraintViolation()
meth public abstract jakarta.validation.ConstraintValidatorContext$ConstraintViolationBuilder$ContainerElementNodeBuilderCustomizableContext addContainerElementNode(java.lang.String,java.lang.Class<?>,java.lang.Integer)
meth public abstract jakarta.validation.ConstraintValidatorContext$ConstraintViolationBuilder$LeafNodeBuilderCustomizableContext addBeanNode()
meth public abstract jakarta.validation.ConstraintValidatorContext$ConstraintViolationBuilder$NodeBuilderCustomizableContext addNode(java.lang.String)
meth public abstract jakarta.validation.ConstraintValidatorContext$ConstraintViolationBuilder$NodeBuilderCustomizableContext addPropertyNode(java.lang.String)

CLSS public abstract interface static jakarta.validation.ConstraintValidatorContext$ConstraintViolationBuilder$NodeContextBuilder
 outer jakarta.validation.ConstraintValidatorContext$ConstraintViolationBuilder
meth public abstract jakarta.validation.ConstraintValidatorContext addConstraintViolation()
meth public abstract jakarta.validation.ConstraintValidatorContext$ConstraintViolationBuilder$ContainerElementNodeBuilderCustomizableContext addContainerElementNode(java.lang.String,java.lang.Class<?>,java.lang.Integer)
meth public abstract jakarta.validation.ConstraintValidatorContext$ConstraintViolationBuilder$LeafNodeBuilderCustomizableContext addBeanNode()
meth public abstract jakarta.validation.ConstraintValidatorContext$ConstraintViolationBuilder$NodeBuilderCustomizableContext addNode(java.lang.String)
meth public abstract jakarta.validation.ConstraintValidatorContext$ConstraintViolationBuilder$NodeBuilderCustomizableContext addPropertyNode(java.lang.String)
meth public abstract jakarta.validation.ConstraintValidatorContext$ConstraintViolationBuilder$NodeBuilderDefinedContext atIndex(java.lang.Integer)
meth public abstract jakarta.validation.ConstraintValidatorContext$ConstraintViolationBuilder$NodeBuilderDefinedContext atKey(java.lang.Object)

CLSS public abstract interface jakarta.validation.ConstraintValidatorFactory
meth public abstract <%0 extends jakarta.validation.ConstraintValidator<?,?>> {%%0} getInstance(java.lang.Class<{%%0}>)
meth public abstract void releaseInstance(jakarta.validation.ConstraintValidator<?,?>)

CLSS public abstract interface jakarta.validation.ConstraintViolation<%0 extends java.lang.Object>
meth public abstract <%0 extends java.lang.Object> {%%0} unwrap(java.lang.Class<{%%0}>)
meth public abstract jakarta.validation.Path getPropertyPath()
meth public abstract jakarta.validation.metadata.ConstraintDescriptor<?> getConstraintDescriptor()
meth public abstract java.lang.Class<{jakarta.validation.ConstraintViolation%0}> getRootBeanClass()
meth public abstract java.lang.Object getExecutableReturnValue()
meth public abstract java.lang.Object getInvalidValue()
meth public abstract java.lang.Object getLeafBean()
meth public abstract java.lang.Object[] getExecutableParameters()
meth public abstract java.lang.String getMessage()
meth public abstract java.lang.String getMessageTemplate()
meth public abstract {jakarta.validation.ConstraintViolation%0} getRootBean()

CLSS public jakarta.validation.ConstraintViolationException
cons public <init>(java.lang.String,java.util.Set<? extends jakarta.validation.ConstraintViolation<?>>)
cons public <init>(java.util.Set<? extends jakarta.validation.ConstraintViolation<?>>)
meth public java.util.Set<jakarta.validation.ConstraintViolation<?>> getConstraintViolations()
supr jakarta.validation.ValidationException
hfds constraintViolations

CLSS public final !enum jakarta.validation.ElementKind
fld public final static jakarta.validation.ElementKind BEAN
fld public final static jakarta.validation.ElementKind CONSTRUCTOR
fld public final static jakarta.validation.ElementKind CONTAINER_ELEMENT
fld public final static jakarta.validation.ElementKind CROSS_PARAMETER
fld public final static jakarta.validation.ElementKind METHOD
fld public final static jakarta.validation.ElementKind PARAMETER
fld public final static jakarta.validation.ElementKind PROPERTY
fld public final static jakarta.validation.ElementKind RETURN_VALUE
meth public static jakarta.validation.ElementKind valueOf(java.lang.String)
meth public static jakarta.validation.ElementKind[] values()
supr java.lang.Enum<jakarta.validation.ElementKind>

CLSS public jakarta.validation.GroupDefinitionException
cons public <init>()
cons public <init>(java.lang.String)
cons public <init>(java.lang.String,java.lang.Throwable)
cons public <init>(java.lang.Throwable)
supr jakarta.validation.ValidationException

CLSS public abstract interface !annotation jakarta.validation.GroupSequence
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[TYPE])
intf java.lang.annotation.Annotation
meth public abstract java.lang.Class<?>[] value()

CLSS public abstract interface jakarta.validation.MessageInterpolator
innr public abstract interface static Context
meth public abstract java.lang.String interpolate(java.lang.String,jakarta.validation.MessageInterpolator$Context)
meth public abstract java.lang.String interpolate(java.lang.String,jakarta.validation.MessageInterpolator$Context,java.util.Locale)

CLSS public abstract interface static jakarta.validation.MessageInterpolator$Context
 outer jakarta.validation.MessageInterpolator
meth public abstract <%0 extends java.lang.Object> {%%0} unwrap(java.lang.Class<{%%0}>)
meth public abstract jakarta.validation.metadata.ConstraintDescriptor<?> getConstraintDescriptor()
meth public abstract java.lang.Object getValidatedValue()

CLSS public jakarta.validation.NoProviderFoundException
cons public <init>()
cons public <init>(java.lang.String)
cons public <init>(java.lang.String,java.lang.Throwable)
cons public <init>(java.lang.Throwable)
supr jakarta.validation.ValidationException

CLSS public abstract interface !annotation jakarta.validation.OverridesAttribute
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Repeatable(java.lang.Class<? extends java.lang.annotation.Annotation> value=class jakarta.validation.OverridesAttribute$List)
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[METHOD])
innr public abstract interface static !annotation List
intf java.lang.annotation.Annotation
meth public abstract !hasdefault int constraintIndex() value= -1
meth public abstract !hasdefault java.lang.String name() value= ""
meth public abstract java.lang.Class<? extends java.lang.annotation.Annotation> constraint()

CLSS public abstract interface static !annotation jakarta.validation.OverridesAttribute$List
 outer jakarta.validation.OverridesAttribute
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[METHOD])
intf java.lang.annotation.Annotation
meth public abstract jakarta.validation.OverridesAttribute[] value()

CLSS public abstract interface jakarta.validation.ParameterNameProvider
meth public abstract java.util.List<java.lang.String> getParameterNames(java.lang.reflect.Constructor<?>)
meth public abstract java.util.List<java.lang.String> getParameterNames(java.lang.reflect.Method)

CLSS public abstract interface jakarta.validation.Path
innr public abstract interface static BeanNode
innr public abstract interface static ConstructorNode
innr public abstract interface static ContainerElementNode
innr public abstract interface static CrossParameterNode
innr public abstract interface static MethodNode
innr public abstract interface static Node
innr public abstract interface static ParameterNode
innr public abstract interface static PropertyNode
innr public abstract interface static ReturnValueNode
intf java.lang.Iterable<jakarta.validation.Path$Node>
meth public abstract java.lang.String toString()

CLSS public abstract interface static jakarta.validation.Path$BeanNode
 outer jakarta.validation.Path
intf jakarta.validation.Path$Node
meth public abstract java.lang.Class<?> getContainerClass()
meth public abstract java.lang.Integer getTypeArgumentIndex()

CLSS public abstract interface static jakarta.validation.Path$ConstructorNode
 outer jakarta.validation.Path
intf jakarta.validation.Path$Node
meth public abstract java.util.List<java.lang.Class<?>> getParameterTypes()

CLSS public abstract interface static jakarta.validation.Path$ContainerElementNode
 outer jakarta.validation.Path
intf jakarta.validation.Path$Node
meth public abstract java.lang.Class<?> getContainerClass()
meth public abstract java.lang.Integer getTypeArgumentIndex()

CLSS public abstract interface static jakarta.validation.Path$CrossParameterNode
 outer jakarta.validation.Path
intf jakarta.validation.Path$Node

CLSS public abstract interface static jakarta.validation.Path$MethodNode
 outer jakarta.validation.Path
intf jakarta.validation.Path$Node
meth public abstract java.util.List<java.lang.Class<?>> getParameterTypes()

CLSS public abstract interface static jakarta.validation.Path$Node
 outer jakarta.validation.Path
meth public abstract <%0 extends jakarta.validation.Path$Node> {%%0} as(java.lang.Class<{%%0}>)
meth public abstract boolean isInIterable()
meth public abstract jakarta.validation.ElementKind getKind()
meth public abstract java.lang.Integer getIndex()
meth public abstract java.lang.Object getKey()
meth public abstract java.lang.String getName()
meth public abstract java.lang.String toString()

CLSS public abstract interface static jakarta.validation.Path$ParameterNode
 outer jakarta.validation.Path
intf jakarta.validation.Path$Node
meth public abstract int getParameterIndex()

CLSS public abstract interface static jakarta.validation.Path$PropertyNode
 outer jakarta.validation.Path
intf jakarta.validation.Path$Node
meth public abstract java.lang.Class<?> getContainerClass()
meth public abstract java.lang.Integer getTypeArgumentIndex()

CLSS public abstract interface static jakarta.validation.Path$ReturnValueNode
 outer jakarta.validation.Path
intf jakarta.validation.Path$Node

CLSS public abstract interface jakarta.validation.Payload

CLSS public abstract interface !annotation jakarta.validation.ReportAsSingleViolation
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[ANNOTATION_TYPE])
intf java.lang.annotation.Annotation

CLSS public abstract interface jakarta.validation.TraversableResolver
meth public abstract boolean isCascadable(java.lang.Object,jakarta.validation.Path$Node,java.lang.Class<?>,jakarta.validation.Path,java.lang.annotation.ElementType)
meth public abstract boolean isReachable(java.lang.Object,jakarta.validation.Path$Node,java.lang.Class<?>,jakarta.validation.Path,java.lang.annotation.ElementType)

CLSS public jakarta.validation.UnexpectedTypeException
cons public <init>()
cons public <init>(java.lang.String)
cons public <init>(java.lang.String,java.lang.Throwable)
cons public <init>(java.lang.Throwable)
supr jakarta.validation.ConstraintDeclarationException

CLSS public abstract interface !annotation jakarta.validation.Valid
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[METHOD, FIELD, CONSTRUCTOR, PARAMETER, TYPE_USE])
intf java.lang.annotation.Annotation

CLSS public jakarta.validation.Validation
cons public <init>()
meth public static <%0 extends jakarta.validation.Configuration<{%%0}>, %1 extends jakarta.validation.spi.ValidationProvider<{%%0}>> jakarta.validation.bootstrap.ProviderSpecificBootstrap<{%%0}> byProvider(java.lang.Class<{%%1}>)
meth public static jakarta.validation.ValidatorFactory buildDefaultValidatorFactory()
meth public static jakarta.validation.bootstrap.GenericBootstrap byDefaultProvider()
supr java.lang.Object
hcls DefaultValidationProviderResolver,GenericBootstrapImpl,GetValidationProviderListAction,NewProviderInstance,ProviderSpecificBootstrapImpl

CLSS public jakarta.validation.ValidationException
cons public <init>()
cons public <init>(java.lang.String)
cons public <init>(java.lang.String,java.lang.Throwable)
cons public <init>(java.lang.Throwable)
supr java.lang.RuntimeException

CLSS public abstract interface jakarta.validation.ValidationProviderResolver
meth public abstract java.util.List<jakarta.validation.spi.ValidationProvider<?>> getValidationProviders()

CLSS public abstract interface jakarta.validation.Validator
meth public abstract !varargs <%0 extends java.lang.Object> java.util.Set<jakarta.validation.ConstraintViolation<{%%0}>> validate({%%0},java.lang.Class<?>[])
meth public abstract !varargs <%0 extends java.lang.Object> java.util.Set<jakarta.validation.ConstraintViolation<{%%0}>> validateProperty({%%0},java.lang.String,java.lang.Class<?>[])
meth public abstract !varargs <%0 extends java.lang.Object> java.util.Set<jakarta.validation.ConstraintViolation<{%%0}>> validateValue(java.lang.Class<{%%0}>,java.lang.String,java.lang.Object,java.lang.Class<?>[])
meth public abstract <%0 extends java.lang.Object> {%%0} unwrap(java.lang.Class<{%%0}>)
meth public abstract jakarta.validation.executable.ExecutableValidator forExecutables()
meth public abstract jakarta.validation.metadata.BeanDescriptor getConstraintsForClass(java.lang.Class<?>)

CLSS public abstract interface jakarta.validation.ValidatorContext
meth public abstract jakarta.validation.Validator getValidator()
meth public abstract jakarta.validation.ValidatorContext addValueExtractor(jakarta.validation.valueextraction.ValueExtractor<?>)
meth public abstract jakarta.validation.ValidatorContext clockProvider(jakarta.validation.ClockProvider)
meth public abstract jakarta.validation.ValidatorContext constraintValidatorFactory(jakarta.validation.ConstraintValidatorFactory)
meth public abstract jakarta.validation.ValidatorContext messageInterpolator(jakarta.validation.MessageInterpolator)
meth public abstract jakarta.validation.ValidatorContext parameterNameProvider(jakarta.validation.ParameterNameProvider)
meth public abstract jakarta.validation.ValidatorContext traversableResolver(jakarta.validation.TraversableResolver)

CLSS public abstract interface jakarta.validation.ValidatorFactory
intf java.lang.AutoCloseable
meth public abstract <%0 extends java.lang.Object> {%%0} unwrap(java.lang.Class<{%%0}>)
meth public abstract jakarta.validation.ClockProvider getClockProvider()
meth public abstract jakarta.validation.ConstraintValidatorFactory getConstraintValidatorFactory()
meth public abstract jakarta.validation.MessageInterpolator getMessageInterpolator()
meth public abstract jakarta.validation.ParameterNameProvider getParameterNameProvider()
meth public abstract jakarta.validation.TraversableResolver getTraversableResolver()
meth public abstract jakarta.validation.Validator getValidator()
meth public abstract jakarta.validation.ValidatorContext usingContext()
meth public abstract void close()

CLSS public abstract interface jakarta.validation.bootstrap.GenericBootstrap
meth public abstract jakarta.validation.Configuration<?> configure()
meth public abstract jakarta.validation.bootstrap.GenericBootstrap providerResolver(jakarta.validation.ValidationProviderResolver)

CLSS public abstract interface jakarta.validation.bootstrap.ProviderSpecificBootstrap<%0 extends jakarta.validation.Configuration<{jakarta.validation.bootstrap.ProviderSpecificBootstrap%0}>>
meth public abstract jakarta.validation.bootstrap.ProviderSpecificBootstrap<{jakarta.validation.bootstrap.ProviderSpecificBootstrap%0}> providerResolver(jakarta.validation.ValidationProviderResolver)
meth public abstract {jakarta.validation.bootstrap.ProviderSpecificBootstrap%0} configure()

CLSS public abstract interface !annotation jakarta.validation.constraints.AssertFalse
 anno 0 jakarta.validation.Constraint(java.lang.Class<? extends jakarta.validation.ConstraintValidator<?,?>>[] validatedBy=[])
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Repeatable(java.lang.Class<? extends java.lang.annotation.Annotation> value=class jakarta.validation.constraints.AssertFalse$List)
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE])
innr public abstract interface static !annotation List
intf java.lang.annotation.Annotation
meth public abstract !hasdefault java.lang.Class<? extends jakarta.validation.Payload>[] payload() value= []
meth public abstract !hasdefault java.lang.Class<?>[] groups() value= []
meth public abstract !hasdefault java.lang.String message() value= "{jakarta.validation.constraints.AssertFalse.message}"

CLSS public abstract interface static !annotation jakarta.validation.constraints.AssertFalse$List
 outer jakarta.validation.constraints.AssertFalse
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE])
intf java.lang.annotation.Annotation
meth public abstract jakarta.validation.constraints.AssertFalse[] value()

CLSS public abstract interface !annotation jakarta.validation.constraints.AssertTrue
 anno 0 jakarta.validation.Constraint(java.lang.Class<? extends jakarta.validation.ConstraintValidator<?,?>>[] validatedBy=[])
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Repeatable(java.lang.Class<? extends java.lang.annotation.Annotation> value=class jakarta.validation.constraints.AssertTrue$List)
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE])
innr public abstract interface static !annotation List
intf java.lang.annotation.Annotation
meth public abstract !hasdefault java.lang.Class<? extends jakarta.validation.Payload>[] payload() value= []
meth public abstract !hasdefault java.lang.Class<?>[] groups() value= []
meth public abstract !hasdefault java.lang.String message() value= "{jakarta.validation.constraints.AssertTrue.message}"

CLSS public abstract interface static !annotation jakarta.validation.constraints.AssertTrue$List
 outer jakarta.validation.constraints.AssertTrue
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE])
intf java.lang.annotation.Annotation
meth public abstract jakarta.validation.constraints.AssertTrue[] value()

CLSS public abstract interface !annotation jakarta.validation.constraints.DecimalMax
 anno 0 jakarta.validation.Constraint(java.lang.Class<? extends jakarta.validation.ConstraintValidator<?,?>>[] validatedBy=[])
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Repeatable(java.lang.Class<? extends java.lang.annotation.Annotation> value=class jakarta.validation.constraints.DecimalMax$List)
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE])
innr public abstract interface static !annotation List
intf java.lang.annotation.Annotation
meth public abstract !hasdefault boolean inclusive() value= true
meth public abstract !hasdefault java.lang.Class<? extends jakarta.validation.Payload>[] payload() value= []
meth public abstract !hasdefault java.lang.Class<?>[] groups() value= []
meth public abstract !hasdefault java.lang.String message() value= "{jakarta.validation.constraints.DecimalMax.message}"
meth public abstract java.lang.String value()

CLSS public abstract interface static !annotation jakarta.validation.constraints.DecimalMax$List
 outer jakarta.validation.constraints.DecimalMax
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE])
intf java.lang.annotation.Annotation
meth public abstract jakarta.validation.constraints.DecimalMax[] value()

CLSS public abstract interface !annotation jakarta.validation.constraints.DecimalMin
 anno 0 jakarta.validation.Constraint(java.lang.Class<? extends jakarta.validation.ConstraintValidator<?,?>>[] validatedBy=[])
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Repeatable(java.lang.Class<? extends java.lang.annotation.Annotation> value=class jakarta.validation.constraints.DecimalMin$List)
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE])
innr public abstract interface static !annotation List
intf java.lang.annotation.Annotation
meth public abstract !hasdefault boolean inclusive() value= true
meth public abstract !hasdefault java.lang.Class<? extends jakarta.validation.Payload>[] payload() value= []
meth public abstract !hasdefault java.lang.Class<?>[] groups() value= []
meth public abstract !hasdefault java.lang.String message() value= "{jakarta.validation.constraints.DecimalMin.message}"
meth public abstract java.lang.String value()

CLSS public abstract interface static !annotation jakarta.validation.constraints.DecimalMin$List
 outer jakarta.validation.constraints.DecimalMin
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE])
intf java.lang.annotation.Annotation
meth public abstract jakarta.validation.constraints.DecimalMin[] value()

CLSS public abstract interface !annotation jakarta.validation.constraints.Digits
 anno 0 jakarta.validation.Constraint(java.lang.Class<? extends jakarta.validation.ConstraintValidator<?,?>>[] validatedBy=[])
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Repeatable(java.lang.Class<? extends java.lang.annotation.Annotation> value=class jakarta.validation.constraints.Digits$List)
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE])
innr public abstract interface static !annotation List
intf java.lang.annotation.Annotation
meth public abstract !hasdefault java.lang.Class<? extends jakarta.validation.Payload>[] payload() value= []
meth public abstract !hasdefault java.lang.Class<?>[] groups() value= []
meth public abstract !hasdefault java.lang.String message() value= "{jakarta.validation.constraints.Digits.message}"
meth public abstract int fraction()
meth public abstract int integer()

CLSS public abstract interface static !annotation jakarta.validation.constraints.Digits$List
 outer jakarta.validation.constraints.Digits
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE])
intf java.lang.annotation.Annotation
meth public abstract jakarta.validation.constraints.Digits[] value()

CLSS public abstract interface !annotation jakarta.validation.constraints.Email
 anno 0 jakarta.validation.Constraint(java.lang.Class<? extends jakarta.validation.ConstraintValidator<?,?>>[] validatedBy=[])
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Repeatable(java.lang.Class<? extends java.lang.annotation.Annotation> value=class jakarta.validation.constraints.Email$List)
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE])
innr public abstract interface static !annotation List
intf java.lang.annotation.Annotation
meth public abstract !hasdefault jakarta.validation.constraints.Pattern$Flag[] flags() value= []
meth public abstract !hasdefault java.lang.Class<? extends jakarta.validation.Payload>[] payload() value= []
meth public abstract !hasdefault java.lang.Class<?>[] groups() value= []
meth public abstract !hasdefault java.lang.String message() value= "{jakarta.validation.constraints.Email.message}"
meth public abstract !hasdefault java.lang.String regexp() value= ".*"

CLSS public abstract interface static !annotation jakarta.validation.constraints.Email$List
 outer jakarta.validation.constraints.Email
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE])
intf java.lang.annotation.Annotation
meth public abstract jakarta.validation.constraints.Email[] value()

CLSS public abstract interface !annotation jakarta.validation.constraints.Future
 anno 0 jakarta.validation.Constraint(java.lang.Class<? extends jakarta.validation.ConstraintValidator<?,?>>[] validatedBy=[])
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Repeatable(java.lang.Class<? extends java.lang.annotation.Annotation> value=class jakarta.validation.constraints.Future$List)
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE])
innr public abstract interface static !annotation List
intf java.lang.annotation.Annotation
meth public abstract !hasdefault java.lang.Class<? extends jakarta.validation.Payload>[] payload() value= []
meth public abstract !hasdefault java.lang.Class<?>[] groups() value= []
meth public abstract !hasdefault java.lang.String message() value= "{jakarta.validation.constraints.Future.message}"

CLSS public abstract interface static !annotation jakarta.validation.constraints.Future$List
 outer jakarta.validation.constraints.Future
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE])
intf java.lang.annotation.Annotation
meth public abstract jakarta.validation.constraints.Future[] value()

CLSS public abstract interface !annotation jakarta.validation.constraints.FutureOrPresent
 anno 0 jakarta.validation.Constraint(java.lang.Class<? extends jakarta.validation.ConstraintValidator<?,?>>[] validatedBy=[])
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Repeatable(java.lang.Class<? extends java.lang.annotation.Annotation> value=class jakarta.validation.constraints.FutureOrPresent$List)
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE])
innr public abstract interface static !annotation List
intf java.lang.annotation.Annotation
meth public abstract !hasdefault java.lang.Class<? extends jakarta.validation.Payload>[] payload() value= []
meth public abstract !hasdefault java.lang.Class<?>[] groups() value= []
meth public abstract !hasdefault java.lang.String message() value= "{jakarta.validation.constraints.FutureOrPresent.message}"

CLSS public abstract interface static !annotation jakarta.validation.constraints.FutureOrPresent$List
 outer jakarta.validation.constraints.FutureOrPresent
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE])
intf java.lang.annotation.Annotation
meth public abstract jakarta.validation.constraints.FutureOrPresent[] value()

CLSS public abstract interface !annotation jakarta.validation.constraints.Max
 anno 0 jakarta.validation.Constraint(java.lang.Class<? extends jakarta.validation.ConstraintValidator<?,?>>[] validatedBy=[])
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Repeatable(java.lang.Class<? extends java.lang.annotation.Annotation> value=class jakarta.validation.constraints.Max$List)
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE])
innr public abstract interface static !annotation List
intf java.lang.annotation.Annotation
meth public abstract !hasdefault java.lang.Class<? extends jakarta.validation.Payload>[] payload() value= []
meth public abstract !hasdefault java.lang.Class<?>[] groups() value= []
meth public abstract !hasdefault java.lang.String message() value= "{jakarta.validation.constraints.Max.message}"
meth public abstract long value()

CLSS public abstract interface static !annotation jakarta.validation.constraints.Max$List
 outer jakarta.validation.constraints.Max
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE])
intf java.lang.annotation.Annotation
meth public abstract jakarta.validation.constraints.Max[] value()

CLSS public abstract interface !annotation jakarta.validation.constraints.Min
 anno 0 jakarta.validation.Constraint(java.lang.Class<? extends jakarta.validation.ConstraintValidator<?,?>>[] validatedBy=[])
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Repeatable(java.lang.Class<? extends java.lang.annotation.Annotation> value=class jakarta.validation.constraints.Min$List)
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE])
innr public abstract interface static !annotation List
intf java.lang.annotation.Annotation
meth public abstract !hasdefault java.lang.Class<? extends jakarta.validation.Payload>[] payload() value= []
meth public abstract !hasdefault java.lang.Class<?>[] groups() value= []
meth public abstract !hasdefault java.lang.String message() value= "{jakarta.validation.constraints.Min.message}"
meth public abstract long value()

CLSS public abstract interface static !annotation jakarta.validation.constraints.Min$List
 outer jakarta.validation.constraints.Min
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE])
intf java.lang.annotation.Annotation
meth public abstract jakarta.validation.constraints.Min[] value()

CLSS public abstract interface !annotation jakarta.validation.constraints.Negative
 anno 0 jakarta.validation.Constraint(java.lang.Class<? extends jakarta.validation.ConstraintValidator<?,?>>[] validatedBy=[])
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Repeatable(java.lang.Class<? extends java.lang.annotation.Annotation> value=class jakarta.validation.constraints.Negative$List)
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE])
innr public abstract interface static !annotation List
intf java.lang.annotation.Annotation
meth public abstract !hasdefault java.lang.Class<? extends jakarta.validation.Payload>[] payload() value= []
meth public abstract !hasdefault java.lang.Class<?>[] groups() value= []
meth public abstract !hasdefault java.lang.String message() value= "{jakarta.validation.constraints.Negative.message}"

CLSS public abstract interface static !annotation jakarta.validation.constraints.Negative$List
 outer jakarta.validation.constraints.Negative
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE])
intf java.lang.annotation.Annotation
meth public abstract jakarta.validation.constraints.Negative[] value()

CLSS public abstract interface !annotation jakarta.validation.constraints.NegativeOrZero
 anno 0 jakarta.validation.Constraint(java.lang.Class<? extends jakarta.validation.ConstraintValidator<?,?>>[] validatedBy=[])
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Repeatable(java.lang.Class<? extends java.lang.annotation.Annotation> value=class jakarta.validation.constraints.NegativeOrZero$List)
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE])
innr public abstract interface static !annotation List
intf java.lang.annotation.Annotation
meth public abstract !hasdefault java.lang.Class<? extends jakarta.validation.Payload>[] payload() value= []
meth public abstract !hasdefault java.lang.Class<?>[] groups() value= []
meth public abstract !hasdefault java.lang.String message() value= "{jakarta.validation.constraints.NegativeOrZero.message}"

CLSS public abstract interface static !annotation jakarta.validation.constraints.NegativeOrZero$List
 outer jakarta.validation.constraints.NegativeOrZero
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE])
intf java.lang.annotation.Annotation
meth public abstract jakarta.validation.constraints.NegativeOrZero[] value()

CLSS public abstract interface !annotation jakarta.validation.constraints.NotBlank
 anno 0 jakarta.validation.Constraint(java.lang.Class<? extends jakarta.validation.ConstraintValidator<?,?>>[] validatedBy=[])
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Repeatable(java.lang.Class<? extends java.lang.annotation.Annotation> value=class jakarta.validation.constraints.NotBlank$List)
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE])
innr public abstract interface static !annotation List
intf java.lang.annotation.Annotation
meth public abstract !hasdefault java.lang.Class<? extends jakarta.validation.Payload>[] payload() value= []
meth public abstract !hasdefault java.lang.Class<?>[] groups() value= []
meth public abstract !hasdefault java.lang.String message() value= "{jakarta.validation.constraints.NotBlank.message}"

CLSS public abstract interface static !annotation jakarta.validation.constraints.NotBlank$List
 outer jakarta.validation.constraints.NotBlank
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE])
intf java.lang.annotation.Annotation
meth public abstract jakarta.validation.constraints.NotBlank[] value()

CLSS public abstract interface !annotation jakarta.validation.constraints.NotEmpty
 anno 0 jakarta.validation.Constraint(java.lang.Class<? extends jakarta.validation.ConstraintValidator<?,?>>[] validatedBy=[])
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Repeatable(java.lang.Class<? extends java.lang.annotation.Annotation> value=class jakarta.validation.constraints.NotEmpty$List)
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE])
innr public abstract interface static !annotation List
intf java.lang.annotation.Annotation
meth public abstract !hasdefault java.lang.Class<? extends jakarta.validation.Payload>[] payload() value= []
meth public abstract !hasdefault java.lang.Class<?>[] groups() value= []
meth public abstract !hasdefault java.lang.String message() value= "{jakarta.validation.constraints.NotEmpty.message}"

CLSS public abstract interface static !annotation jakarta.validation.constraints.NotEmpty$List
 outer jakarta.validation.constraints.NotEmpty
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE])
intf java.lang.annotation.Annotation
meth public abstract jakarta.validation.constraints.NotEmpty[] value()

CLSS public abstract interface !annotation jakarta.validation.constraints.NotNull
 anno 0 jakarta.validation.Constraint(java.lang.Class<? extends jakarta.validation.ConstraintValidator<?,?>>[] validatedBy=[])
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Repeatable(java.lang.Class<? extends java.lang.annotation.Annotation> value=class jakarta.validation.constraints.NotNull$List)
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE])
innr public abstract interface static !annotation List
intf java.lang.annotation.Annotation
meth public abstract !hasdefault java.lang.Class<? extends jakarta.validation.Payload>[] payload() value= []
meth public abstract !hasdefault java.lang.Class<?>[] groups() value= []
meth public abstract !hasdefault java.lang.String message() value= "{jakarta.validation.constraints.NotNull.message}"

CLSS public abstract interface static !annotation jakarta.validation.constraints.NotNull$List
 outer jakarta.validation.constraints.NotNull
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE])
intf java.lang.annotation.Annotation
meth public abstract jakarta.validation.constraints.NotNull[] value()

CLSS public abstract interface !annotation jakarta.validation.constraints.Null
 anno 0 jakarta.validation.Constraint(java.lang.Class<? extends jakarta.validation.ConstraintValidator<?,?>>[] validatedBy=[])
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Repeatable(java.lang.Class<? extends java.lang.annotation.Annotation> value=class jakarta.validation.constraints.Null$List)
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE])
innr public abstract interface static !annotation List
intf java.lang.annotation.Annotation
meth public abstract !hasdefault java.lang.Class<? extends jakarta.validation.Payload>[] payload() value= []
meth public abstract !hasdefault java.lang.Class<?>[] groups() value= []
meth public abstract !hasdefault java.lang.String message() value= "{jakarta.validation.constraints.Null.message}"

CLSS public abstract interface static !annotation jakarta.validation.constraints.Null$List
 outer jakarta.validation.constraints.Null
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE])
intf java.lang.annotation.Annotation
meth public abstract jakarta.validation.constraints.Null[] value()

CLSS public abstract interface !annotation jakarta.validation.constraints.Past
 anno 0 jakarta.validation.Constraint(java.lang.Class<? extends jakarta.validation.ConstraintValidator<?,?>>[] validatedBy=[])
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Repeatable(java.lang.Class<? extends java.lang.annotation.Annotation> value=class jakarta.validation.constraints.Past$List)
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE])
innr public abstract interface static !annotation List
intf java.lang.annotation.Annotation
meth public abstract !hasdefault java.lang.Class<? extends jakarta.validation.Payload>[] payload() value= []
meth public abstract !hasdefault java.lang.Class<?>[] groups() value= []
meth public abstract !hasdefault java.lang.String message() value= "{jakarta.validation.constraints.Past.message}"

CLSS public abstract interface static !annotation jakarta.validation.constraints.Past$List
 outer jakarta.validation.constraints.Past
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE])
intf java.lang.annotation.Annotation
meth public abstract jakarta.validation.constraints.Past[] value()

CLSS public abstract interface !annotation jakarta.validation.constraints.PastOrPresent
 anno 0 jakarta.validation.Constraint(java.lang.Class<? extends jakarta.validation.ConstraintValidator<?,?>>[] validatedBy=[])
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Repeatable(java.lang.Class<? extends java.lang.annotation.Annotation> value=class jakarta.validation.constraints.PastOrPresent$List)
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE])
innr public abstract interface static !annotation List
intf java.lang.annotation.Annotation
meth public abstract !hasdefault java.lang.Class<? extends jakarta.validation.Payload>[] payload() value= []
meth public abstract !hasdefault java.lang.Class<?>[] groups() value= []
meth public abstract !hasdefault java.lang.String message() value= "{jakarta.validation.constraints.PastOrPresent.message}"

CLSS public abstract interface static !annotation jakarta.validation.constraints.PastOrPresent$List
 outer jakarta.validation.constraints.PastOrPresent
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE])
intf java.lang.annotation.Annotation
meth public abstract jakarta.validation.constraints.PastOrPresent[] value()

CLSS public abstract interface !annotation jakarta.validation.constraints.Pattern
 anno 0 jakarta.validation.Constraint(java.lang.Class<? extends jakarta.validation.ConstraintValidator<?,?>>[] validatedBy=[])
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Repeatable(java.lang.Class<? extends java.lang.annotation.Annotation> value=class jakarta.validation.constraints.Pattern$List)
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE])
innr public abstract interface static !annotation List
innr public final static !enum Flag
intf java.lang.annotation.Annotation
meth public abstract !hasdefault jakarta.validation.constraints.Pattern$Flag[] flags() value= []
meth public abstract !hasdefault java.lang.Class<? extends jakarta.validation.Payload>[] payload() value= []
meth public abstract !hasdefault java.lang.Class<?>[] groups() value= []
meth public abstract !hasdefault java.lang.String message() value= "{jakarta.validation.constraints.Pattern.message}"
meth public abstract java.lang.String regexp()

CLSS public final static !enum jakarta.validation.constraints.Pattern$Flag
 outer jakarta.validation.constraints.Pattern
fld public final static jakarta.validation.constraints.Pattern$Flag CANON_EQ
fld public final static jakarta.validation.constraints.Pattern$Flag CASE_INSENSITIVE
fld public final static jakarta.validation.constraints.Pattern$Flag COMMENTS
fld public final static jakarta.validation.constraints.Pattern$Flag DOTALL
fld public final static jakarta.validation.constraints.Pattern$Flag MULTILINE
fld public final static jakarta.validation.constraints.Pattern$Flag UNICODE_CASE
fld public final static jakarta.validation.constraints.Pattern$Flag UNIX_LINES
meth public int getValue()
meth public static jakarta.validation.constraints.Pattern$Flag valueOf(java.lang.String)
meth public static jakarta.validation.constraints.Pattern$Flag[] values()
supr java.lang.Enum<jakarta.validation.constraints.Pattern$Flag>
hfds value

CLSS public abstract interface static !annotation jakarta.validation.constraints.Pattern$List
 outer jakarta.validation.constraints.Pattern
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE])
intf java.lang.annotation.Annotation
meth public abstract jakarta.validation.constraints.Pattern[] value()

CLSS public abstract interface !annotation jakarta.validation.constraints.Positive
 anno 0 jakarta.validation.Constraint(java.lang.Class<? extends jakarta.validation.ConstraintValidator<?,?>>[] validatedBy=[])
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Repeatable(java.lang.Class<? extends java.lang.annotation.Annotation> value=class jakarta.validation.constraints.Positive$List)
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE])
innr public abstract interface static !annotation List
intf java.lang.annotation.Annotation
meth public abstract !hasdefault java.lang.Class<? extends jakarta.validation.Payload>[] payload() value= []
meth public abstract !hasdefault java.lang.Class<?>[] groups() value= []
meth public abstract !hasdefault java.lang.String message() value= "{jakarta.validation.constraints.Positive.message}"

CLSS public abstract interface static !annotation jakarta.validation.constraints.Positive$List
 outer jakarta.validation.constraints.Positive
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE])
intf java.lang.annotation.Annotation
meth public abstract jakarta.validation.constraints.Positive[] value()

CLSS public abstract interface !annotation jakarta.validation.constraints.PositiveOrZero
 anno 0 jakarta.validation.Constraint(java.lang.Class<? extends jakarta.validation.ConstraintValidator<?,?>>[] validatedBy=[])
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Repeatable(java.lang.Class<? extends java.lang.annotation.Annotation> value=class jakarta.validation.constraints.PositiveOrZero$List)
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE])
innr public abstract interface static !annotation List
intf java.lang.annotation.Annotation
meth public abstract !hasdefault java.lang.Class<? extends jakarta.validation.Payload>[] payload() value= []
meth public abstract !hasdefault java.lang.Class<?>[] groups() value= []
meth public abstract !hasdefault java.lang.String message() value= "{jakarta.validation.constraints.PositiveOrZero.message}"

CLSS public abstract interface static !annotation jakarta.validation.constraints.PositiveOrZero$List
 outer jakarta.validation.constraints.PositiveOrZero
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE])
intf java.lang.annotation.Annotation
meth public abstract jakarta.validation.constraints.PositiveOrZero[] value()

CLSS public abstract interface !annotation jakarta.validation.constraints.Size
 anno 0 jakarta.validation.Constraint(java.lang.Class<? extends jakarta.validation.ConstraintValidator<?,?>>[] validatedBy=[])
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Repeatable(java.lang.Class<? extends java.lang.annotation.Annotation> value=class jakarta.validation.constraints.Size$List)
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE])
innr public abstract interface static !annotation List
intf java.lang.annotation.Annotation
meth public abstract !hasdefault int max() value= 2147483647
meth public abstract !hasdefault int min() value= 0
meth public abstract !hasdefault java.lang.Class<? extends jakarta.validation.Payload>[] payload() value= []
meth public abstract !hasdefault java.lang.Class<?>[] groups() value= []
meth public abstract !hasdefault java.lang.String message() value= "{jakarta.validation.constraints.Size.message}"

CLSS public abstract interface static !annotation jakarta.validation.constraints.Size$List
 outer jakarta.validation.constraints.Size
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE])
intf java.lang.annotation.Annotation
meth public abstract jakarta.validation.constraints.Size[] value()

CLSS public abstract interface !annotation jakarta.validation.constraintvalidation.SupportedValidationTarget
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[TYPE])
intf java.lang.annotation.Annotation
meth public abstract jakarta.validation.constraintvalidation.ValidationTarget[] value()

CLSS public final !enum jakarta.validation.constraintvalidation.ValidationTarget
fld public final static jakarta.validation.constraintvalidation.ValidationTarget ANNOTATED_ELEMENT
fld public final static jakarta.validation.constraintvalidation.ValidationTarget PARAMETERS
meth public static jakarta.validation.constraintvalidation.ValidationTarget valueOf(java.lang.String)
meth public static jakarta.validation.constraintvalidation.ValidationTarget[] values()
supr java.lang.Enum<jakarta.validation.constraintvalidation.ValidationTarget>

CLSS public final !enum jakarta.validation.executable.ExecutableType
fld public final static jakarta.validation.executable.ExecutableType ALL
fld public final static jakarta.validation.executable.ExecutableType CONSTRUCTORS
fld public final static jakarta.validation.executable.ExecutableType GETTER_METHODS
fld public final static jakarta.validation.executable.ExecutableType IMPLICIT
fld public final static jakarta.validation.executable.ExecutableType NONE
fld public final static jakarta.validation.executable.ExecutableType NON_GETTER_METHODS
meth public static jakarta.validation.executable.ExecutableType valueOf(java.lang.String)
meth public static jakarta.validation.executable.ExecutableType[] values()
supr java.lang.Enum<jakarta.validation.executable.ExecutableType>

CLSS public abstract interface jakarta.validation.executable.ExecutableValidator
meth public abstract !varargs <%0 extends java.lang.Object> java.util.Set<jakarta.validation.ConstraintViolation<{%%0}>> validateConstructorParameters(java.lang.reflect.Constructor<? extends {%%0}>,java.lang.Object[],java.lang.Class<?>[])
meth public abstract !varargs <%0 extends java.lang.Object> java.util.Set<jakarta.validation.ConstraintViolation<{%%0}>> validateConstructorReturnValue(java.lang.reflect.Constructor<? extends {%%0}>,{%%0},java.lang.Class<?>[])
meth public abstract !varargs <%0 extends java.lang.Object> java.util.Set<jakarta.validation.ConstraintViolation<{%%0}>> validateParameters({%%0},java.lang.reflect.Method,java.lang.Object[],java.lang.Class<?>[])
meth public abstract !varargs <%0 extends java.lang.Object> java.util.Set<jakarta.validation.ConstraintViolation<{%%0}>> validateReturnValue({%%0},java.lang.reflect.Method,java.lang.Object,java.lang.Class<?>[])

CLSS public abstract interface !annotation jakarta.validation.executable.ValidateOnExecution
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[CONSTRUCTOR, METHOD, TYPE, PACKAGE])
intf java.lang.annotation.Annotation
meth public abstract !hasdefault jakarta.validation.executable.ExecutableType[] type() value= [IMPLICIT]

CLSS public abstract interface !annotation jakarta.validation.groups.ConvertGroup
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Repeatable(java.lang.Class<? extends java.lang.annotation.Annotation> value=class jakarta.validation.groups.ConvertGroup$List)
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[METHOD, FIELD, CONSTRUCTOR, PARAMETER, TYPE_USE])
innr public abstract interface static !annotation List
intf java.lang.annotation.Annotation
meth public abstract !hasdefault java.lang.Class<?> from() value= class jakarta.validation.groups.Default
meth public abstract java.lang.Class<?> to()

CLSS public abstract interface static !annotation jakarta.validation.groups.ConvertGroup$List
 outer jakarta.validation.groups.ConvertGroup
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[METHOD, FIELD, CONSTRUCTOR, PARAMETER, TYPE_USE])
intf java.lang.annotation.Annotation
meth public abstract jakarta.validation.groups.ConvertGroup[] value()

CLSS public abstract interface jakarta.validation.groups.Default

CLSS public abstract interface jakarta.validation.metadata.BeanDescriptor
intf jakarta.validation.metadata.ElementDescriptor
meth public abstract !varargs jakarta.validation.metadata.ConstructorDescriptor getConstraintsForConstructor(java.lang.Class<?>[])
meth public abstract !varargs jakarta.validation.metadata.MethodDescriptor getConstraintsForMethod(java.lang.String,java.lang.Class<?>[])
meth public abstract !varargs java.util.Set<jakarta.validation.metadata.MethodDescriptor> getConstrainedMethods(jakarta.validation.metadata.MethodType,jakarta.validation.metadata.MethodType[])
meth public abstract boolean isBeanConstrained()
meth public abstract jakarta.validation.metadata.PropertyDescriptor getConstraintsForProperty(java.lang.String)
meth public abstract java.util.Set<jakarta.validation.metadata.ConstructorDescriptor> getConstrainedConstructors()
meth public abstract java.util.Set<jakarta.validation.metadata.PropertyDescriptor> getConstrainedProperties()

CLSS public abstract interface jakarta.validation.metadata.CascadableDescriptor
meth public abstract boolean isCascaded()
meth public abstract java.util.Set<jakarta.validation.metadata.GroupConversionDescriptor> getGroupConversions()

CLSS public abstract interface jakarta.validation.metadata.ConstraintDescriptor<%0 extends java.lang.annotation.Annotation>
meth public abstract <%0 extends java.lang.Object> {%%0} unwrap(java.lang.Class<{%%0}>)
meth public abstract boolean isReportAsSingleViolation()
meth public abstract jakarta.validation.ConstraintTarget getValidationAppliesTo()
meth public abstract jakarta.validation.metadata.ValidateUnwrappedValue getValueUnwrapping()
meth public abstract java.lang.String getMessageTemplate()
meth public abstract java.util.List<java.lang.Class<? extends jakarta.validation.ConstraintValidator<{jakarta.validation.metadata.ConstraintDescriptor%0},?>>> getConstraintValidatorClasses()
meth public abstract java.util.Map<java.lang.String,java.lang.Object> getAttributes()
meth public abstract java.util.Set<jakarta.validation.metadata.ConstraintDescriptor<?>> getComposingConstraints()
meth public abstract java.util.Set<java.lang.Class<? extends jakarta.validation.Payload>> getPayload()
meth public abstract java.util.Set<java.lang.Class<?>> getGroups()
meth public abstract {jakarta.validation.metadata.ConstraintDescriptor%0} getAnnotation()

CLSS public abstract interface jakarta.validation.metadata.ConstructorDescriptor
intf jakarta.validation.metadata.ExecutableDescriptor

CLSS public abstract interface jakarta.validation.metadata.ContainerDescriptor
meth public abstract java.util.Set<jakarta.validation.metadata.ContainerElementTypeDescriptor> getConstrainedContainerElementTypes()

CLSS public abstract interface jakarta.validation.metadata.ContainerElementTypeDescriptor
intf jakarta.validation.metadata.CascadableDescriptor
intf jakarta.validation.metadata.ContainerDescriptor
intf jakarta.validation.metadata.ElementDescriptor
meth public abstract java.lang.Class<?> getContainerClass()
meth public abstract java.lang.Integer getTypeArgumentIndex()

CLSS public abstract interface jakarta.validation.metadata.CrossParameterDescriptor
intf jakarta.validation.metadata.ElementDescriptor
meth public abstract java.lang.Class<?> getElementClass()

CLSS public abstract interface jakarta.validation.metadata.ElementDescriptor
innr public abstract interface static ConstraintFinder
meth public abstract boolean hasConstraints()
meth public abstract jakarta.validation.metadata.ElementDescriptor$ConstraintFinder findConstraints()
meth public abstract java.lang.Class<?> getElementClass()
meth public abstract java.util.Set<jakarta.validation.metadata.ConstraintDescriptor<?>> getConstraintDescriptors()

CLSS public abstract interface static jakarta.validation.metadata.ElementDescriptor$ConstraintFinder
 outer jakarta.validation.metadata.ElementDescriptor
meth public abstract !varargs jakarta.validation.metadata.ElementDescriptor$ConstraintFinder declaredOn(java.lang.annotation.ElementType[])
meth public abstract !varargs jakarta.validation.metadata.ElementDescriptor$ConstraintFinder unorderedAndMatchingGroups(java.lang.Class<?>[])
meth public abstract boolean hasConstraints()
meth public abstract jakarta.validation.metadata.ElementDescriptor$ConstraintFinder lookingAt(jakarta.validation.metadata.Scope)
meth public abstract java.util.Set<jakarta.validation.metadata.ConstraintDescriptor<?>> getConstraintDescriptors()

CLSS public abstract interface jakarta.validation.metadata.ExecutableDescriptor
intf jakarta.validation.metadata.ElementDescriptor
meth public abstract boolean hasConstrainedParameters()
meth public abstract boolean hasConstrainedReturnValue()
meth public abstract boolean hasConstraints()
meth public abstract jakarta.validation.metadata.CrossParameterDescriptor getCrossParameterDescriptor()
meth public abstract jakarta.validation.metadata.ElementDescriptor$ConstraintFinder findConstraints()
meth public abstract jakarta.validation.metadata.ReturnValueDescriptor getReturnValueDescriptor()
meth public abstract java.lang.String getName()
meth public abstract java.util.List<jakarta.validation.metadata.ParameterDescriptor> getParameterDescriptors()
meth public abstract java.util.Set<jakarta.validation.metadata.ConstraintDescriptor<?>> getConstraintDescriptors()

CLSS public abstract interface jakarta.validation.metadata.GroupConversionDescriptor
meth public abstract java.lang.Class<?> getFrom()
meth public abstract java.lang.Class<?> getTo()

CLSS public abstract interface jakarta.validation.metadata.MethodDescriptor
intf jakarta.validation.metadata.ExecutableDescriptor

CLSS public final !enum jakarta.validation.metadata.MethodType
fld public final static jakarta.validation.metadata.MethodType GETTER
fld public final static jakarta.validation.metadata.MethodType NON_GETTER
meth public static jakarta.validation.metadata.MethodType valueOf(java.lang.String)
meth public static jakarta.validation.metadata.MethodType[] values()
supr java.lang.Enum<jakarta.validation.metadata.MethodType>

CLSS public abstract interface jakarta.validation.metadata.ParameterDescriptor
intf jakarta.validation.metadata.CascadableDescriptor
intf jakarta.validation.metadata.ContainerDescriptor
intf jakarta.validation.metadata.ElementDescriptor
meth public abstract int getIndex()
meth public abstract java.lang.String getName()

CLSS public abstract interface jakarta.validation.metadata.PropertyDescriptor
intf jakarta.validation.metadata.CascadableDescriptor
intf jakarta.validation.metadata.ContainerDescriptor
intf jakarta.validation.metadata.ElementDescriptor
meth public abstract java.lang.String getPropertyName()

CLSS public abstract interface jakarta.validation.metadata.ReturnValueDescriptor
intf jakarta.validation.metadata.CascadableDescriptor
intf jakarta.validation.metadata.ContainerDescriptor
intf jakarta.validation.metadata.ElementDescriptor

CLSS public final !enum jakarta.validation.metadata.Scope
fld public final static jakarta.validation.metadata.Scope HIERARCHY
fld public final static jakarta.validation.metadata.Scope LOCAL_ELEMENT
meth public static jakarta.validation.metadata.Scope valueOf(java.lang.String)
meth public static jakarta.validation.metadata.Scope[] values()
supr java.lang.Enum<jakarta.validation.metadata.Scope>

CLSS public final !enum jakarta.validation.metadata.ValidateUnwrappedValue
fld public final static jakarta.validation.metadata.ValidateUnwrappedValue DEFAULT
fld public final static jakarta.validation.metadata.ValidateUnwrappedValue SKIP
fld public final static jakarta.validation.metadata.ValidateUnwrappedValue UNWRAP
meth public static jakarta.validation.metadata.ValidateUnwrappedValue valueOf(java.lang.String)
meth public static jakarta.validation.metadata.ValidateUnwrappedValue[] values()
supr java.lang.Enum<jakarta.validation.metadata.ValidateUnwrappedValue>

CLSS public abstract interface jakarta.validation.spi.BootstrapState
meth public abstract jakarta.validation.ValidationProviderResolver getDefaultValidationProviderResolver()
meth public abstract jakarta.validation.ValidationProviderResolver getValidationProviderResolver()

CLSS public abstract interface jakarta.validation.spi.ConfigurationState
meth public abstract boolean isIgnoreXmlConfiguration()
meth public abstract jakarta.validation.ClockProvider getClockProvider()
meth public abstract jakarta.validation.ConstraintValidatorFactory getConstraintValidatorFactory()
meth public abstract jakarta.validation.MessageInterpolator getMessageInterpolator()
meth public abstract jakarta.validation.ParameterNameProvider getParameterNameProvider()
meth public abstract jakarta.validation.TraversableResolver getTraversableResolver()
meth public abstract java.util.Map<java.lang.String,java.lang.String> getProperties()
meth public abstract java.util.Set<jakarta.validation.valueextraction.ValueExtractor<?>> getValueExtractors()
meth public abstract java.util.Set<java.io.InputStream> getMappingStreams()

CLSS public abstract interface jakarta.validation.spi.ValidationProvider<%0 extends jakarta.validation.Configuration<{jakarta.validation.spi.ValidationProvider%0}>>
meth public abstract jakarta.validation.Configuration<?> createGenericConfiguration(jakarta.validation.spi.BootstrapState)
meth public abstract jakarta.validation.ValidatorFactory buildValidatorFactory(jakarta.validation.spi.ConfigurationState)
meth public abstract {jakarta.validation.spi.ValidationProvider%0} createSpecializedConfiguration(jakarta.validation.spi.BootstrapState)

CLSS public abstract interface !annotation jakarta.validation.valueextraction.ExtractedValue
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[TYPE_USE])
intf java.lang.annotation.Annotation
meth public abstract !hasdefault java.lang.Class<?> type() value= class void

CLSS public abstract interface !annotation jakarta.validation.valueextraction.UnwrapByDefault
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[TYPE])
intf java.lang.annotation.Annotation

CLSS public abstract interface jakarta.validation.valueextraction.Unwrapping
innr public abstract interface static Skip
innr public abstract interface static Unwrap

CLSS public abstract interface static jakarta.validation.valueextraction.Unwrapping$Skip
 outer jakarta.validation.valueextraction.Unwrapping
intf jakarta.validation.Payload

CLSS public abstract interface static jakarta.validation.valueextraction.Unwrapping$Unwrap
 outer jakarta.validation.valueextraction.Unwrapping
intf jakarta.validation.Payload

CLSS public abstract interface jakarta.validation.valueextraction.ValueExtractor<%0 extends java.lang.Object>
innr public abstract interface static ValueReceiver
meth public abstract void extractValues({jakarta.validation.valueextraction.ValueExtractor%0},jakarta.validation.valueextraction.ValueExtractor$ValueReceiver)

CLSS public abstract interface static jakarta.validation.valueextraction.ValueExtractor$ValueReceiver
 outer jakarta.validation.valueextraction.ValueExtractor
meth public abstract void indexedValue(java.lang.String,int,java.lang.Object)
meth public abstract void iterableValue(java.lang.String,java.lang.Object)
meth public abstract void keyedValue(java.lang.String,java.lang.Object,java.lang.Object)
meth public abstract void value(java.lang.String,java.lang.Object)

CLSS public jakarta.validation.valueextraction.ValueExtractorDeclarationException
cons public <init>()
cons public <init>(java.lang.String)
cons public <init>(java.lang.String,java.lang.Throwable)
cons public <init>(java.lang.Throwable)
supr jakarta.validation.ValidationException

CLSS public jakarta.validation.valueextraction.ValueExtractorDefinitionException
cons public <init>()
cons public <init>(java.lang.String)
cons public <init>(java.lang.String,java.lang.Throwable)
cons public <init>(java.lang.Throwable)
supr jakarta.validation.ValidationException

CLSS public abstract interface java.io.Serializable

CLSS public abstract interface java.lang.AutoCloseable
meth public abstract void close() throws java.lang.Exception

CLSS public abstract interface java.lang.Comparable<%0 extends java.lang.Object>
meth public abstract int compareTo({java.lang.Comparable%0})

CLSS public abstract java.lang.Enum<%0 extends java.lang.Enum<{java.lang.Enum%0}>>
cons protected <init>(java.lang.String,int)
intf java.io.Serializable
intf java.lang.Comparable<{java.lang.Enum%0}>
meth protected final java.lang.Object clone() throws java.lang.CloneNotSupportedException
meth protected final void finalize()
meth public final boolean equals(java.lang.Object)
meth public final int compareTo({java.lang.Enum%0})
meth public final int hashCode()
meth public final int ordinal()
meth public final java.lang.Class<{java.lang.Enum%0}> getDeclaringClass()
meth public final java.lang.String name()
meth public java.lang.String toString()
meth public static <%0 extends java.lang.Enum<{%%0}>> {%%0} valueOf(java.lang.Class<{%%0}>,java.lang.String)
supr java.lang.Object
hfds name,ordinal

CLSS public java.lang.Exception
cons protected <init>(java.lang.String,java.lang.Throwable,boolean,boolean)
cons public <init>()
cons public <init>(java.lang.String)
cons public <init>(java.lang.String,java.lang.Throwable)
cons public <init>(java.lang.Throwable)
supr java.lang.Throwable
hfds serialVersionUID

CLSS public abstract interface !annotation java.lang.FunctionalInterface
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[TYPE])
intf java.lang.annotation.Annotation

CLSS public abstract interface java.lang.Iterable<%0 extends java.lang.Object>
meth public abstract java.util.Iterator<{java.lang.Iterable%0}> iterator()
meth public java.util.Spliterator<{java.lang.Iterable%0}> spliterator()
meth public void forEach(java.util.function.Consumer<? super {java.lang.Iterable%0}>)

CLSS public java.lang.Object
cons public <init>()
meth protected java.lang.Object clone() throws java.lang.CloneNotSupportedException
meth protected void finalize() throws java.lang.Throwable
meth public boolean equals(java.lang.Object)
meth public final java.lang.Class<?> getClass()
meth public final void notify()
meth public final void notifyAll()
meth public final void wait() throws java.lang.InterruptedException
meth public final void wait(long) throws java.lang.InterruptedException
meth public final void wait(long,int) throws java.lang.InterruptedException
meth public int hashCode()
meth public java.lang.String toString()

CLSS public java.lang.RuntimeException
cons protected <init>(java.lang.String,java.lang.Throwable,boolean,boolean)
cons public <init>()
cons public <init>(java.lang.String)
cons public <init>(java.lang.String,java.lang.Throwable)
cons public <init>(java.lang.Throwable)
supr java.lang.Exception
hfds serialVersionUID

CLSS public java.lang.Throwable
cons protected <init>(java.lang.String,java.lang.Throwable,boolean,boolean)
cons public <init>()
cons public <init>(java.lang.String)
cons public <init>(java.lang.String,java.lang.Throwable)
cons public <init>(java.lang.Throwable)
intf java.io.Serializable
meth public final java.lang.Throwable[] getSuppressed()
meth public final void addSuppressed(java.lang.Throwable)
meth public java.lang.StackTraceElement[] getStackTrace()
meth public java.lang.String getLocalizedMessage()
meth public java.lang.String getMessage()
meth public java.lang.String toString()
meth public java.lang.Throwable fillInStackTrace()
meth public java.lang.Throwable getCause()
meth public java.lang.Throwable initCause(java.lang.Throwable)
meth public void printStackTrace()
meth public void printStackTrace(java.io.PrintStream)
meth public void printStackTrace(java.io.PrintWriter)
meth public void setStackTrace(java.lang.StackTraceElement[])
supr java.lang.Object
hfds CAUSE_CAPTION,EMPTY_THROWABLE_ARRAY,NULL_CAUSE_MESSAGE,SELF_SUPPRESSION_MESSAGE,SUPPRESSED_CAPTION,SUPPRESSED_SENTINEL,UNASSIGNED_STACK,backtrace,cause,detailMessage,serialVersionUID,stackTrace,suppressedExceptions
hcls PrintStreamOrWriter,SentinelHolder,WrappedPrintStream,WrappedPrintWriter

CLSS public abstract interface java.lang.annotation.Annotation
meth public abstract boolean equals(java.lang.Object)
meth public abstract int hashCode()
meth public abstract java.lang.Class<? extends java.lang.annotation.Annotation> annotationType()
meth public abstract java.lang.String toString()

CLSS public abstract interface !annotation java.lang.annotation.Documented
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[ANNOTATION_TYPE])
intf java.lang.annotation.Annotation

CLSS public abstract interface !annotation java.lang.annotation.Inherited
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[ANNOTATION_TYPE])
intf java.lang.annotation.Annotation

CLSS public abstract interface !annotation java.lang.annotation.Repeatable
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[ANNOTATION_TYPE])
intf java.lang.annotation.Annotation
meth public abstract java.lang.Class<? extends java.lang.annotation.Annotation> value()

CLSS public abstract interface !annotation java.lang.annotation.Retention
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[ANNOTATION_TYPE])
intf java.lang.annotation.Annotation
meth public abstract java.lang.annotation.RetentionPolicy value()

CLSS public abstract interface !annotation java.lang.annotation.Target
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[ANNOTATION_TYPE])
intf java.lang.annotation.Annotation
meth public abstract java.lang.annotation.ElementType[] value()

CLSS public java.security.GeneralSecurityException
cons public <init>()
cons public <init>(java.lang.String)
cons public <init>(java.lang.String,java.lang.Throwable)
cons public <init>(java.lang.Throwable)
supr java.lang.Exception
hfds serialVersionUID

CLSS public java.util.concurrent.ExecutionException
cons protected <init>()
cons protected <init>(java.lang.String)
cons public <init>(java.lang.String,java.lang.Throwable)
cons public <init>(java.lang.Throwable)
supr java.lang.Exception
hfds serialVersionUID

CLSS public abstract interface java.util.concurrent.Executor
meth public abstract void execute(java.lang.Runnable)

CLSS public abstract interface java.util.concurrent.ExecutorService
intf java.util.concurrent.Executor
meth public abstract <%0 extends java.lang.Object> java.util.List<java.util.concurrent.Future<{%%0}>> invokeAll(java.util.Collection<? extends java.util.concurrent.Callable<{%%0}>>) throws java.lang.InterruptedException
meth public abstract <%0 extends java.lang.Object> java.util.List<java.util.concurrent.Future<{%%0}>> invokeAll(java.util.Collection<? extends java.util.concurrent.Callable<{%%0}>>,long,java.util.concurrent.TimeUnit) throws java.lang.InterruptedException
meth public abstract <%0 extends java.lang.Object> java.util.concurrent.Future<{%%0}> submit(java.lang.Runnable,{%%0})
meth public abstract <%0 extends java.lang.Object> java.util.concurrent.Future<{%%0}> submit(java.util.concurrent.Callable<{%%0}>)
meth public abstract <%0 extends java.lang.Object> {%%0} invokeAny(java.util.Collection<? extends java.util.concurrent.Callable<{%%0}>>) throws java.lang.InterruptedException,java.util.concurrent.ExecutionException
meth public abstract <%0 extends java.lang.Object> {%%0} invokeAny(java.util.Collection<? extends java.util.concurrent.Callable<{%%0}>>,long,java.util.concurrent.TimeUnit) throws java.lang.InterruptedException,java.util.concurrent.ExecutionException,java.util.concurrent.TimeoutException
meth public abstract boolean awaitTermination(long,java.util.concurrent.TimeUnit) throws java.lang.InterruptedException
meth public abstract boolean isShutdown()
meth public abstract boolean isTerminated()
meth public abstract java.util.List<java.lang.Runnable> shutdownNow()
meth public abstract java.util.concurrent.Future<?> submit(java.lang.Runnable)
meth public abstract void shutdown()

CLSS public abstract interface java.util.concurrent.ScheduledExecutorService
intf java.util.concurrent.ExecutorService
meth public abstract <%0 extends java.lang.Object> java.util.concurrent.ScheduledFuture<{%%0}> schedule(java.util.concurrent.Callable<{%%0}>,long,java.util.concurrent.TimeUnit)
meth public abstract java.util.concurrent.ScheduledFuture<?> schedule(java.lang.Runnable,long,java.util.concurrent.TimeUnit)
meth public abstract java.util.concurrent.ScheduledFuture<?> scheduleAtFixedRate(java.lang.Runnable,long,long,java.util.concurrent.TimeUnit)
meth public abstract java.util.concurrent.ScheduledFuture<?> scheduleWithFixedDelay(java.lang.Runnable,long,long,java.util.concurrent.TimeUnit)

CLSS public abstract interface java.util.concurrent.ThreadFactory
meth public abstract java.lang.Thread newThread(java.lang.Runnable)

CLSS public abstract interface javax.security.auth.callback.Callback

CLSS public javax.security.auth.login.LoginException
cons public <init>()
cons public <init>(java.lang.String)
supr java.security.GeneralSecurityException
hfds serialVersionUID

