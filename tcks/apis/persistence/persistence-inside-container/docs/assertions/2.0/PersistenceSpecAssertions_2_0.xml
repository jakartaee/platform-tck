<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE spec SYSTEM "https://raw.githubusercontent.com/eclipse-ee4j/jakartaee-tck/master/internal/docs/dtd/spec_assertions.dtd">
<!--

    Copyright (c) 2018, 2020 Oracle and/or its affiliates. All rights reserved.

    This program and the accompanying materials are made available under the
    terms of the Eclipse Public License v. 2.0, which is available at
    http://www.eclipse.org/legal/epl-2.0.

    This Source Code may also be made available under the following Secondary
    Licenses when the conditions for such availability set forth in the
    Eclipse Public License v. 2.0 are satisfied: GNU General Public License,
    version 2 with the GNU Classpath Exception, which is available at
    https://www.gnu.org/software/classpath/license.html.

    SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0

-->

<?xml-stylesheet type="text/xsl" href="https://raw.githubusercontent.com/eclipse-ee4j/jakartaee-tck/master/internal/docs/xsl/spec_assertions.xsl"?>
<spec>
    <next-available-id/>
    <previous-id/>
    <technology>PERSISTENCE</technology>
    <id>PERSISTENCE</id>
    <name>Java(TM) Persistence API</name>
    <version>2.0</version>
    <location-names>
        <chapters>
            <chapter id="2" name="Entities">
                <sections>
                    <section id="1" name="Requirements on the Entity Class"/>
                    <section id="1.1" name="Persistent Fields and Properties"/>
                    <section id="1.2" name="Example"/>
                    <section id="1.3" name="Entity Instance Creation"/>
                    <section id="1.4" name="Primary Keys and Entity Identity"/>
                    <section id="1.5" name="Embeddable Classes"/>
                    <section id="1.6" name="Mapping Defaults for Non-Relationship Fields or Properties"/>
                    <section id="1.7" name="entity Relationships"/>
                    <section id="1.8" name="Relationship Mapping Defaults"/>
                    <section id="1.8.1" name="One-to-One Bidirectional Relationships"/>
                    <section id="1.8.2" name="Many-to-One/One-to-Many Bidirectional Relationships"/>
                    <section id="1.8.3" name="UniDirectional Single-Valued Relationships"/>
                    <section id="1.8.3.1" name="UniDirectional OneToOne Relationships"/>
                    <section id="1.8.3.2" name="UniDirectional ManyToOne Relationships"/>
                    <section id="1.8.4" name="Many-to-Many Bidirectional Relationships"/>
                    <section id="1.8.5" name="UniDirectional Multi-Valued Relationships"/>
                    <section id="1.8.5.1" name="UniDirectional OneToMany Relationships"/>
                    <section id="1.8.5.2" name="UniDirectional ManyToMany Relationships"/>
                    <section id="1.9" name="Inheritance"/>
                    <section id="1.9.1" name="Abstract Entity Classes"/>
                    <section id="1.9.2" name="Mapped SuperClasses"/>
                    <section id="1.9.3" name="Non-Entity Classes in the Entity Inheritance Hierarchy"/>
                    <section id="1.10" name="Inheritance Mapping Strategies"/>
                    <section id="1.10.1" name="Single Table per Class Hierachy Strategy"/>
                    <section id="1.10.2" name="Table per Class Strategy"/>
                    <section id="1.10.3" name="Joined Subclass Strategy"/>
                </sections>
            </chapter>
            <chapter id="3" name="Entity Operations">
                <sections>
                    <section id="1" name="EntityManager"/>
                    <section id="1.1" name="EntityManager Interface"/>
                    <section id="1.2" name="Examples of Use of EntityManager API"/>
                    <section id="2" name="Entity Instance Life Cycle"/>
                    <section id="2.1" name="Persisting an Entity Instance"/>
                    <section id="2.2" name="Removal"/>
                    <section id="2.3" name="Synchronization to the Database"/>
                    <section id="2.4" name="Detached Entities"/>
                    <section id="2.4.1" name="Merging Detached Entity State"/>
                    <section id="2.4.2" name="Detached Entities and Lazy Loading"/>
                    <section id="2.5" name="Managed Instances"/>
                    <section id="3" name="Persistence Context"/>
                    <section id="3.1" name="Transaction Commit"/>
                    <section id="3.2" name="Transaction Rollback"/>
                    <section id="4" name="Optimistic Locking and Concurrency"/>
                    <section id="4.1" name="Optimistic Locking"/>
                    <section id="4.2" name="Version Attributes"/>
                    <section id="4.3" name="LockModes"/>
                    <section id="4.4" name="OptimisticLockException"/>
                    <section id="5" name="Entity Listeners and Callback Methods"/>
                    <section id="5.1" name="Lifecycle Callback Methods "/>
                    <section id="5.2" name="Semantics of the Life Cycle Callback Methods for Entities"/>
                    <section id="5.3" name="Example"/>
                    <section id="5.4" name="Multiple Lifecycle Callback Methods for an Entity Lifecycle Event"/>
                    <section id="5.5" name="Example"/>
                    <section id="5.6" name="Exceptions"/>
                    <section id="5.7"
                             name="Specification of Callback Listener Classes and Lifecycle Methods in the XML"/>
                    <section id="5.8" name="Specification of Callback Listeners"/>
                    <section id="5.9" name="Specification of the Binding of Entity Listener Classes to Entities"/>
                    <section id="6" name="Query API"/>
                    <section id="6.1" name="Query Interface"/>
                    <section id="6.1.1" name="Example"/>
                    <section id="6.2" name="Queries and FlushMode"/>
                    <section id="6.3" name="Named Parameters"/>
                    <section id="6.4" name="Named Queries"/>
                    <section id="6.5" name="PolyMorphic Queries"/>
                    <section id="6.6" name="SQL Queries"/>
                    <section id="7" name="Summary of Exceptions"/>
                </sections>
            </chapter>
            <chapter id="4" name="Query Language">
                <sections>
                    <section id="1" name="Overview"/>
                    <section id="2" name="Statement Types "/>
                    <section id="2.1" name="Select Statement "/>
                    <section id="2.2" name="Update and Delete Statements "/>
                    <section id="3" name="Abstract Schema Types and Query Domains"/>
                    <section id="3.1" name="Naming"/>
                    <section id="3.2" name="Example"/>
                    <section id="4" name="The FROM Clause and Navigational Declarations"/>
                    <section id="4.1" name="Identifiers"/>
                    <section id="4.2" name="Identification Variables"/>
                    <section id="4.3" name="Range Variable Declarations"/>
                    <section id="4.4" name="Path Expressions"/>
                    <section id="4.5" name="Joins"/>
                    <section id="4.5.1" name="Inner Joins (Relationship Joins)"/>
                    <section id="4.5.2" name="Left Outer Joins"/>
                    <section id="4.5.3" name="Fetch Joins"/>
                    <section id="4.6" name="Collection Member Declarations"/>
                    <section id="4.7" name="FROM Clause and SQL"/>
                    <section id="4.8" name="Polymorphism"/>
                    <section id="5" name="WHERE Clause"/>
                    <section id="6" name="Conditional Expressions"/>
                    <section id="6.1" name="Literals"/>
                    <section id="6.2" name="Identification Variables"/>
                    <section id="6.3" name="Path Expressions"/>
                    <section id="6.4" name="Input Parameters"/>
                    <section id="6.4.1" name="Positional Parameters"/>
                    <section id="6.4.2" name="Named Parameters"/>
                    <section id="6.5" name="Conditional Expression Composition"/>
                    <section id="6.6" name="Operators and Operator Precedence"/>
                    <section id="6.7" name="Between Expressions"/>
                    <section id="6.8" name="In Expressions"/>
                    <section id="6.9" name="Like Expressions"/>
                    <section id="6.10" name="Null Comparison Expression"/>
                    <section id="6.11" name="Empty Collection Comparison Expressions"/>
                    <section id="6.12" name="Collection Member Expressions"/>
                    <section id="6.13" name="Exists Expressions"/>
                    <section id="6.14" name="All or Any Expressions"/>
                    <section id="6.15" name="Subqueries"/>
                    <section id="6.16" name="Functional Expressions"/>
                    <section id="6.16.1" name="String Functions"/>
                    <section id="6.16.2" name="Arithmetic Functions"/>
                    <section id="6.16.3" name="Datetime Functions"/>
                    <section id="7" name="GROUP BY, HAVING Clause"/>
                    <section id="8" name="SELECT Clause"/>
                    <section id="8.1" name="Result Type of the SELECT Clause"/>
                    <section id="8.2" name="Constructor Expressions in the SELECT Clause"/>
                    <section id="8.3" name="Null Values in the Query Result"/>
                    <section id="8.4" name="Aggregate Functions in the SELECT Clause"/>
                    <section id="8.4.1" name="Examples"/>
                    <section id="9" name="ORDER BY Clause"/>
                    <section id="10" name="Bulk Update and Delete Operations"/>
                    <section id="11" name="Null Values"/>
                    <section id="12" name="Equality and Comparison Semantics"/>
                    <section id="13" name="Examples"/>
                    <section id="13.1" name="Simple Queries"/>
                    <section id="13.2" name="Queries with Relationships"/>
                    <section id="13.3" name="Queries Using Input Parameters"/>
                    <section id="14" name="BNF"/>
                </sections>
            </chapter>
            <chapter id="5" name="Entity Managers and Persistence Contexts">
                <sections>
                    <section id="1" name="Persistence Contexts"/>
                    <section id="2" name="Obtaining the EntityManager"/>
                    <section id="1.1" name="Container-managed Entity Managers"/>
                    <section id="1.2" name="Application-managed Entity Managers"/>
                    <section id="1.2.1" name="The EntityManagerFactory Interface"/>
                    <section id="1.2.2" name="Control of the Application-Managed EntityManager Lifecycle"/>
                    <section id="2" name="Controlling Transactions"/>
                    <section id="2.1" name="JTA Entity Managers"/>
                    <section id="2.2" name="Resource-local Entity Managers"/>
                    <section id="2.2.1" name="The EntityTransaction Interface"/>
                    <section id="3" name="Persistence Contexts"/>
                    <section id="6" name="Container-managed Persistence Contexts"/>
                    <section id="6.1" name="Container-managed Transaction-scoped Persistence Context"/>
                    <section id="6.2" name="Container-managed Extended Persistence Context"/>
                    <section id="6.2.1" name="Inheritance of Extended Persistence Context"/>
                    <section id="6.3" name="Persistence  Context Propagation"/>
                    <section id="6.3.1" name="Requirements for Persistence Context Propagation"/>
                    <section id="6.4" name="Examples"/>
                    <section id="6.4.1" name="Container-Managed Transaction-Scoped Persistence Context"/>
                    <section id="6.4.2" name="Container-Managed Extended Persistence Context"/>
                    <section id="7" name="Application-managed Persistence Contexts"/>
                    <section id="7.1" name="Examples"/>
                    <section id="7.1.1" name="Application-managed Persistence Context used in Stateless Session Bean"/>
                    <section id="7.1.2" name="Application-managed Persistence Context used in Stateless Session Bean"/>
                    <section id="7.1.3" name="Application-managed Persistence Context used in Stateful Session Bean"/>
                    <section id="7.1.4" name="Application-managed Persistence Context with Resource Transaction"/>
                    <section id="8" name="Requirements on the Container"/>
                    <section id="8.1" name="Application-managed Persistence Contexts"/>
                    <section id="8.2" name="Container Managed Persistence Contexts"/>
                    <section id="9" name="Runtime Contracts Between the Container and Persistence Provider"/>
                    <section id="9.1" name="Container Responsibilities"/>
                    <section id="9.2" name="Provider Responsibilities"/>
                </sections>
            </chapter>
            <chapter id="6" name="Entity Packaging">
                <sections>
                    <section id="1" name="Persistence Unit"/>
                    <section id="2" name="Persistence Unit Packaging"/>
                    <section id="2.1" name="persistence.xml file"/>
                    <section id="2.1.1" name="name"/>
                    <section id="2.1.2" name="transaction-type"/>
                    <section id="2.1.3" name="description"/>
                    <section id="2.1.4" name="provider"/>
                    <section id="2.1.5" name="jta-data-source, non-jta-data-source"/>
                    <section id="2.1.6" name="mapping-file, jar-file, class, exclude-unllisted-classes"/>
                    <section id="2.1.7" name="properties"/>
                    <section id="2.1.8" name="Examples"/>
                    <section id="2.2" name="Persistence Unit Scope"/>
                    <section id="3" name="persistence.xml Schema"/>
                </sections>
            </chapter>
            <chapter id="7" name="Container and Provider Contracts for Deployment and Bootstrapping">
                <sections>
                    <section id="1" name="JavaEE Deployment"/>
                    <section id="1.1" name="Responsibilities of the Container"/>
                    <section id="1.2" name="Responsibilities of the Persistence Provider"/>
                    <section id="1.3" name="jakarta.persistence.spi.PersistenceProvider"/>
                    <section id="1.3.1" name="Persistence Unit Properties"/>
                    <section id="1.4" name="jakarta.persistence.spi.PersistenceUnitInfo Inerface"/>
                    <section id="2" name="Bootstrapping in Java SE Environments"/>
                    <section id="1.5" name="jakarta.persistence.Persistence Class"/>
                </sections>
            </chapter>
            <chapter id="8" name="MetaData Annotations">
                <sections>
                    <section id="1" name="Entity"/>
                    <section id="2" name="Callback Annotations"/>
                    <section id="3" name="Annotations for Queries"/>
                    <section id="3.1" name="NamedQuery Annotation"/>
                    <section id="3.2" name="NamedNativeQuery Annotation"/>
                    <section id="1.1" name="Annotations for SQL Query Result Set Mappings"/>
                    <section id="4" name="References to EntityManager and EntityManagerFactory"/>
                    <section id="4.1" name="PersistenceContext Annotation"/>
                    <section id="4.2" name="PersistenceUnit Annotation"/>
                </sections>
            </chapter>
            <chapter id="9" name="MetaData for Object/Relational Mapping">
                <sections>
                    <section id="1" name="Annotations for Object/Relational Mapping"/>
                    <section id="1.1" name="Table Annotation"/>
                    <section id="1.2" name="SecondaryTable Annotation"/>
                    <section id="1.3" name="SecondaryTables Annotation"/>
                    <section id="1.4" name="UniqueConstraint Annotation"/>
                    <section id="1.5" name="Column Annotation"/>
                    <section id="1.6" name="JoinColumn Annotation"/>
                    <section id="1.7" name="JoinColumns Annotation"/>
                    <section id="1.8" name="Id Annotation"/>
                    <section id="1.9" name="GeneratedValue Annotation"/>
                    <section id="1.10" name="AttributeOverride Annotation"/>
                    <section id="1.11" name="AttributeOverrides Annotation"/>
                    <section id="1.12" name="AssociationOverride Annotation"/>
                    <section id="1.13" name="AssociationOverrides Annotation"/>
                    <section id="1.14" name="EmbeddedId Annotation"/>
                    <section id="1.15" name="IdClass Annotation"/>
                    <section id="1.16" name="Transient Annotation"/>
                    <section id="1.17" name="Version Annotation"/>
                    <section id="1.18" name="Basic Annotation"/>
                    <section id="1.19" name="Lob Annotation"/>
                    <section id="1.20" name="Temporal Annotation"/>
                    <section id="1.21" name="Enumerated Annotation"/>
                    <section id="1.22" name="ManyToOne Annotation"/>
                    <section id="1.23" name="OneToOneAnnotation"/>
                    <section id="1.24" name="OneToMany Annotation"/>
                    <section id="1.25" name="JoinTable Annotation"/>
                    <section id="1.26" name="ManyToMany Annotation"/>
                    <section id="1.27" name="MapKey Annotation"/>
                    <section id="1.28" name="OrderBy Annotation"/>
                    <section id="1.29" name="Inheritance Annotation"/>
                    <section id="1.30" name="DiscriminatorColumn Annotation"/>
                    <section id="1.31" name="DiscriminatorValue Annotation"/>
                    <section id="1.32" name="PrimaryKeyJoinColumn Annotation"/>
                    <section id="1.33" name="PrimaryKeyColumns Annotation"/>
                    <section id="1.34" name="Embeddable Annotation"/>
                    <section id="1.35" name="Embedded Annotation"/>
                    <section id="1.36" name="MappedSuperclass Annotation"/>
                    <section id="1.37" name="SequenceGenerator Annotation"/>
                    <section id="1.38" name="TableGenertor Annotation"/>
                </sections>
            </chapter>
            <chapter id="10" name="XML Descriptor">
                <sections>
                    <section id="1" name="XML Overriding Rules"/>
                    <section id="1.1" name="persistence-unit-defaults Subelements"/>
                    <section id="1.1.1" name="schema"/>
                    <section id="1.1.2" name="catalog"/>
                    <section id="1.1.3" name="access"/>
                    <section id="1.1.4" name="cascade-persist"/>
                    <section id="1.1.5" name="entity-listeners"/>
                    <section id="1.2" name="Other Subelements of the entity-mapping element"/>
                    <section id="1.2.1" name="package"/>
                    <section id="1.2.2" name="schema"/>
                    <section id="1.2.3" name="catalog"/>
                    <section id="1.2.4" name="access"/>
                    <section id="1.2.5" name="sequence-generator"/>
                    <section id="1.2.6" name="table-generator"/>
                    <section id="1.2.7" name="named-query"/>
                    <section id="1.2.8" name="named-native-query"/>
                    <section id="1.2.9" name="sql-result-set-mapping"/>
                    <section id="1.2.10" name="entity"/>
                    <section id="1.2.11" name="mapped-superclass"/>
                    <section id="1.2.12" name="embeddable"/>
                    <section id="1.3" name="entity Subelements"/>
                    <section id="1.3.1" name="table"/>
                    <section id="1.3.2" name="secondary-table"/>
                    <section id="1.1.1" name="primary-key-join-column"/>
                    <section id="1.3.4" name="id-class"/>
                    <section id="1.3.5" name="inheritance"/>
                    <section id="1.3.6" name="discriminator"/>
                    <section id="1.3.7" name="discriminator-column"/>
                    <section id="1.3.8" name="sequence-generator"/>
                    <section id="1.3.9" name="table-generator"/>
                    <section id="1.3.10" name="attribute-override"/>
                    <section id="1.3.11" name="association-override"/>
                    <section id="1.3.12" name="named-query"/>
                    <section id="1.3.13" name="named-native-query"/>
                    <section id="1.3.14" name="sql-result-set-mapping"/>
                    <section id="1.3.15" name="exclude-default-listeners"/>
                    <section id="1.3.16" name="exclude-superclass-listeners"/>
                    <section id="1.3.17" name="entity-listeners"/>
                    <section id="1.3.18" name="pre-persist, post-persist, pre-remove, post-remove, pre-update, post-update"/>
                    <section id="1.3.19" name="id"/>
                    <section id="1.3.20" name="embedded-id"/>
                    <section id="1.3.21" name="basic"/>
                    <section id="1.3.22" name="version"/>
                    <section id="1.3.23" name="many-to-one"/>
                    <section id="1.3.24" name="one-to-many"/>
                    <section id="1.3.25" name="one-to-one"/>
                    <section id="1.3.26" name="many-to-many"/>
                    <section id="1.3.27" name="embedded"/>
                    <section id="1.3.28" name="transient"/>
                    <section id="1.4" name="mapped-superclass Subelements"/>
                    <section id="1.4.1" name="id-class"/>
                    <section id="1.4.2" name="exclude-default-listeners"/>
                    <section id="1.4.3" name="exclude-superclass-listeners"/>
                    <section id="1.4.4" name="entity-listeners"/>
                    <section id="1.4.5" name="pre-persist, post-persist, pre-remove, post-remove, pre-update, post-update"/>
                    <section id="1.4.6" name="id"/>
                    <section id="1.4.7" name="embedded-id"/>
                    <section id="1.4.8" name="basic"/>
                    <section id="1.4.9" name="version"/>
                    <section id="1.4.10" name="many-to-one"/>
                    <section id="1.4.11" name="one-to-many"/>
                    <section id="1.4.12" name="one-to-one"/>
                    <section id="1.4.13" name="many-to-many"/>
                    <section id="1.4.14" name="embedded"/>
                    <section id="1.4.15" name="transient"/>
                    <section id="1.5" name="embeddable Subelements"/>
                    <section id="1.5.1" name="basic"/>
                    <section id="1.5.2" name="transient"/>
                    <section id="2" name="XML Schema"/>
                </sections>
            </chapter>
        </chapters>
    </location-names>
    <assertions>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:312</id>
            <description>
                A select statement must always have a SELECT and a FROM clause.
            </description>
            <keywords>
                <keyword>application-role</keyword>
                <keyword>application-server-role</keyword>
            </keywords>
            <location chapter="4" section="2.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:316</id>
            <description>Reserved identifiers are case insensitive.</description>
            <location chapter="4" section="4.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:317</id>
            <description>
                Identification variables designate instances of a particular entity abstract schema type. The FROM
                clause can contain multiple identification variable declarations separated by a comma:
            </description>
            <location chapter="4" section="4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:317.1</id>
            <description>range_variable_declaration</description>
            <location chapter="4" section="4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:317.2</id>
            <description>collection_member_declaration</description>
            <location chapter="4" section="4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:317.3</id>
            <description>join_spec</description>
            <location chapter="4" section="4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:318</id>
            <description>
                An identification variable must not be a reserved identifier or have the same name as any of the
                followng in the same persistence unit:
            </description>
            <keywords>
                <keyword>application-role</keyword>
                <keyword>application-server-role</keyword>
            </keywords>
            <location chapter="4" section="4.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:318.3</id>
            <description>
                entity name (as defined by the Entity annotation or entity-name XML deployment descriptor element
            </description>
            <location chapter="4" section="4.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:319</id>
            <description>Identification variables are case insensitive.</description>
            <location chapter="4" section="4.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:320</id>
            <description>
                In order to select values by comparing more than one instance of an entity abstract schema type, more
                than one identification variable ranging over the entity's abstract schema type is needed in the FROM
                clause.
            </description>
            <location chapter="4" section="4.3"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:321</id>
            <description>
                An identification variable of a collection member declaration is declared using a special operator, the
                reserved identifier IN. The argument to the IN operator takes a collection valued path expression.
            </description>
            <location chapter="4" section="4.6"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:322</id>
            <description>
                A single_valued_association_field is designated by the name of an association-field in a one-to-one or
                many-to-one relationship. The type of a single_valued_association_field and thus a
                single_valued_association_path_expression is the abstract schema type of the related entity.
            </description>
            <location chapter="4" section="4.4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:323</id>
            <description>
                A collection_valued_association_field is designated by the name of an association-field in a one-to-many
                or a many-to-many relationship. The type of a collection_valued_association_field is a collection of
                values of the abstract schema type of the related entity.
            </description>
            <location chapter="4" section="4.4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>PERSISTENCE:SPEC:325</id>
            <description>
                A path expression that ends in a simple state-field, rather than an embedded class, is terminal and
                cannot be further composed.
            </description>
            <location chapter="4" section="4.4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>PERSISTENCE:SPEC:326</id>
            <description>
                A path expression that leads to an association-field may be further composed. Path expressions can be
                composed from other path expression if the original path expression evaluates to a single-valued type
                (not a collection) corresponding to an association-field.
            </description>
            <location chapter="4" section="4.4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:328</id>
            <description>
                The evaluation of a path expression terminating in a state-field results in the abstract schema type
                corresponding to the Java type designed by the state-field.
            </description>
            <location chapter="4" section="4.4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:329</id>
            <description>
                Path expression navigability is composed using "inner join" semantics. That is, if the value of a
                non-terminal association-field in the path expression is null, the path is considered to have no value,
                and does not participate in the determination of the result.
            </description>
            <location chapter="4" section="4.4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:330</id>
            <description>
                A string literal is enclosed in single quotes. A string literal that includes a single quote is
                represented by two single quotes. EJB-QL string literals are like Java String literals in that they use
                unicode character encoding.
            </description>
            <location chapter="4" section="6.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:331</id>
            <description>
                An exact numeric literal is a numeric value without a decimal point. Exact numeric literals support
                numbers in the range of Java long.
            </description>
            <location chapter="4" section="6.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:332</id>
            <description>
                Although predefined reserved literals appear in upper case, they are case insensitive.
            </description>
            <location chapter="4" section="6.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:333</id>
            <description>
                An approximate numeric literal is a value in scientific notation. Approximate numeric literal support
                numbers in the range of Java double.
            </description>
            <location chapter="4" section="6.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:334</id>
            <description>The boolean literals are TRUE and FALSE.</description>
            <location chapter="4" section="6.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:336</id>
            <description>
                If an input parameter is NULL, arithmetic operations involving the input parameter will return an
                UNKNOWN value
            </description>
            <location chapter="4" section="6.4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:337</id>
            <description>
                If an input parameter is NULL, comparison operations involving the input parameter will return an
                UNKNOWN value. NOTE: Duplicate assertion to: PERSISTENCE:SPEC:342. Recheck tagged test code and remedy
                list accordingly.
            </description>
            <location chapter="4" section="6.4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:338</id>
            <description>Input parameters are numbered starting from 1</description>
            <location chapter="4" section="6.4.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:341</id>
            <description>
                An input parameter evaluates to the abstract schema type of the corresponding parameter defined in the
                signature of the finder or select method with which the query is associated. It is the responsible of
                the Container to map the input parameter to the appropriate abstract schema type value.
            </description>
            <location chapter="4" section="6.4.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:342</id>
            <description>
                Note that if an input parameter is Null, comparison operations involving the input parameter will return
                an unknown value.
            </description>
            <location chapter="4" section="6.4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:343</id>
            <description>
                Note that if an input parameter is Null, arithmetic operations involving the input parameter will return
                an unknown value.
            </description>
            <location chapter="4" section="6.4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:344</id>
            <description>Arithmetic operations use numeric promotion.</description>
            <location chapter="4" section="6.5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:345</id>
            <description>
                Conditional expressions are composed of other conditional expressions, comparison operators, logical
                operations, path expressions that evaluate to boolean values and boolean literals.
            </description>
            <location chapter="4" section="6.5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:346</id>
            <description>
                Standard bracketing for ordering expression evaluation is supported.
            </description>
            <location chapter="4" section="6.5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:347</id>
            <description>
                Arithmetic expressions can be used in comparison expressions.
            </description>
            <location chapter="4" section="6.5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:348</id>
            <description>
                Operators and Operator Precedence. The operators listed below in order of descreasing precedence.
            </description>
            <location chapter="4" section="6.6"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:348.1</id>
            <description>Navigation Operator</description>
            <location chapter="4" section="6.6"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:348.2</id>
            <description>
                Arithmetic Operators (+,- unary - *,/ multiplication, division - +.- addition, substraction)
            </description>
            <location chapter="4" section="6.6"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:348.3</id>
            <description>Comparison Operators</description>
            <location chapter="4" section="6.6"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:348.4</id>
            <description>Logical Operators: NOT, AND, OR</description>
            <location chapter="4" section="6.6"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:349</id>
            <description>
                The syntax for the use of the comparison operator [NOT] BETWEEN in a conditional expression is as
                follows: arithmetic_expression [NOT] BETWEEN arithmetic-expr AND arithmetic-expr
            </description>
            <location chapter="4" section="6.7"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:349.1</id>
            <description>
                string_expression [NOT] BETWEEN string-expression AND string-expression
            </description>
            <location chapter="4" section="6.7"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:349.2</id>
            <description>
                datetime_expression [NOT] BETWEEN datetime-expression AND datetime-expression
            </description>
            <location chapter="4" section="6.7"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:350</id>
            <description>
                The BETWEEN expression x BETWEEN y and z is semantically equivalent to: y less than = x AND x less than
                = z
            </description>
            <location chapter="4" section="6.7"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:351</id>
            <description>
                If the value of a state_field_path_expression in an IN or NOT IN expression is NULL or UNKNOWN, the
                value of the expression is UNKNOWN.
            </description>
            <location chapter="4" section="6.8"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:352</id>
            <description>
                The syntax for the use of the comparison operator IN in a conditional expression is as follows:
                state_field_path_expression [NOT] IN({literal | input parameter} [, {literal | input_parameter}]*} |
                subquery). The state_field_path_expression must have a string or numeric value.
            </description>
            <keywords>
                <keyword>application-role</keyword>
                <keyword>application-server-role</keyword>
            </keywords>
            <location chapter="4" section="6.8"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:352.1</id>
            <description>
                The literal and/or input parameter values must be like the same abstract schema type of the
                state_field_path_expression in type.
            </description>
            <keywords>
                <keyword>application-role</keyword>
                <keyword>application-server-role</keyword>
            </keywords>
            <location chapter="4" section="6.8"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:352.2</id>
            <description>
                The results of the subquery must be like the same abstract schema type of the
                state_field_path_expression in type.
            </description>
            <keywords>
                <keyword>application-role</keyword>
                <keyword>application-server-role</keyword>
            </keywords>
            <location chapter="4" section="6.8"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:353</id>
            <description>
                There must be at least one element in the comma separated list that defines the set of values for the IN
                expression.
            </description>
            <keywords>
                <keyword>application-role</keyword>
                <keyword>application-server-role</keyword>
            </keywords>
            <location chapter="4" section="6.8"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:354</id>
            <description>
                The expression o.country IN ('UK', 'US', 'France') is equivalent to the expression (o.country = 'UK') OR
                (o.country = 'US') OR (o.country = 'France')
            </description>
            <location chapter="4" section="6.8"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:355</id>
            <description>
                The expression o.country NOT IN ('UK', 'US', 'France') is equivalent to the expression NOT (o.country =
                'UK') OR (o.country = 'US') OR (o.country = 'France')
            </description>
            <location chapter="4" section="6.8"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:356</id>
            <description>
                If the value of a single-valued path expression or pattern_value is NULL or UNKNOWN, the value of the
                LIKE expression is UNKNOWN.
            </description>
            <location chapter="4" section="6.9"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:357</id>
            <description>
                If the escape_character is specified as a NULL, the value of the LIKE expression is iunknown.
            </description>
            <location chapter="4" section="6.9"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:358</id>
            <description>
                The syntax for the use of the comparison operator [NOT] LIKE in a conditional expression is as follows:
                state_field_path_expression [NOT] LIKE pattern-value [ESCAPE escape-character]. The
                state_field_path_expression must have a String value. The pattern-value is a string literal or a
                string-valued input parameter in which an underscore stands for any single character, a percent
                character stands for any sequence of characters and all other characters stand for themselves. The
                optional escape-character is a single character string literal or a character-valued input parameter
                (i.e., char or Character) and is used to escape the special meaning of the underscore and percent
                characters in pattern-value.
            </description>
            <location chapter="4" section="6.9"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:359</id>
            <description>
                The syntax for the use of the comparison operator IS [NOT] NULL in a conditional expression is as
                follows: single_valued_path_expression | input parameter IS [NOT] NULL. A null comparison expression
                tests whether or not the single valued path expression is a NULL value.
            </description>
            <location chapter="4" section="6.10"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>PERSISTENCE:SPEC:360</id>
            <description>
                The collection designated by the collection-valued path expression used in an empty collection
                comparison expression must not be used in the FROM clause for the declaration of an identification
                variable.
            </description>
            <location chapter="4" section="6.11"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:361</id>
            <description>
                The syntax for the use of the comparison operator IS [NOT] EMPTY in an
                empty_collection_comparison_expression is as follows: collection_valued_path_expression IS [NOT] EMPTY
                This expression tests whether or not the collection designated by the collection-valued path expression
                is empty (that is, it has no elements).
            </description>
            <location chapter="4" section="6.11"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:361.1</id>
            <description>input_parameter</description>
            <location chapter="4" section="6.12"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:362</id>
            <description>
                If the value of the collection-valued path expression in an empty collection comparison expression is
                unknown, the value of the empty comparison expression is unknown.
            </description>
            <location chapter="4" section="6.11"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:363</id>
            <description>
                The syntax for the use of the comparison operator MEMBER OF in a collection_member_expression is as
                follows: entity_expression [NOT] MEMBER [OF] collection_valued_path_expression. entity_expression::=
                This expression tests whether the designated value is a member of the collection designated by the
                collection-valued path expression.
            </description>
            <location chapter="4" section="6.12"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:363.1</id>
            <description>single_valued_association_path_expression</description>
            <location chapter="4" section="6.12"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:363.2</id>
            <description>identification variable</description>
            <location chapter="4" section="6.12"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:364</id>
            <description>
                If the value of the collection-valued path expression or single-valued association-field path expression
                in the collection member expression is NULL, the value of the collection member expression is unknown.
            </description>
            <location chapter="4" section="6.12"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:365</id>
            <description>
                If the collection valued path expression designates an empty collection, the value of the the MEMBER OF
                expression is FALSE and the value of the NOT MEMBER OF expression is TRUE.
            </description>
            <location chapter="4" section="6.12"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:366</id>
            <description>
                If the value of the single-valued association-field path expression in the collection member expression
                is unknown, the value of the empty comparison expression is unknown. If the collection valued path
                expressiuon designates an empty collection, the value of the expression is FALSE.
            </description>
            <location chapter="4" section="6.12"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:367</id>
            <description>
                If the value of any argument to a functional expression is NULL or UNKNOWN, the value of the functional
                expression is UNKNOWN.
            </description>
            <location chapter="4" section="6.16"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:368</id>
            <description>
                Numeric arguments to these functions may correspond to the numeric Java object types as well as the
                primitive numeric types.
            </description>
            <location chapter="4" section="6.16.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:369</id>
            <description>
                Java Persistence QL includes the following built-in Arithmetic functions which may be used in the WHERE
                clause of a query:
            </description>
            <location chapter="4" section="6.16.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:369.1</id>
            <description>
                CONCAT(string_expression, string_expression). The CONCAT function returns a string that is a
                concatenation of its arguments.
            </description>
            <location chapter="4" section="6.16.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:369.2</id>
            <description>
                SUBSTRING(string_expression, arithmetic expression, arithmetic-expression). The second and third
                argument of the SUBSTRING denote the starting position and length of the substring to be returned. These
                arguments are integers. The firstd position of a string is denoted by 1. The SUBSTRING function returns
                a string.
            </description>
            <location chapter="4" section="6.16.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:369.3</id>
            <description>
                LOCATE(string_expression, string_expression[,arithmetic_expression]). The LOCATE function returns the
                position of a given string within a string starting the search at a specified position. (NOTE: Not all
                databases support the use of the third argument to LOCATE; use of this argument may result in queries
                that are not portable.)
            </description>
            <location chapter="4" section="6.16"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:369.4</id>
            <description>
                LENGTH(string_expression). The LENGTH function returns the length of the string in characters as an
                integer.
            </description>
            <location chapter="4" section="6.16.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:369.5</id>
            <description>
                ABS(arithmetic_expression). The ABS function takes a nueric argument and returns a number (integer,
                float, double) of the same type as the argument to the function.
            </description>
            <location chapter="4" section="6.16.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:369.6</id>
            <description>
                SQRT(arithmetic_expression). The SQRT function takes a nuneric argument and returns a double.
            </description>
            <location chapter="4" section="6.16.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:369.7</id>
            <description>
                MOD(arithmetic_expression, arithmetic_expression). The MOD function takes two integer argumetns and
                returns an integer.
            </description>
            <location chapter="4" section="6.16.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:369.8</id>
            <description>
                SIZE(collection_valued_path_expression). The SIZE function returns an integer value, the number of
                elements of the collection. If the collection is empty, the SIZE function evaluates to zero.
            </description>
            <location chapter="4" section="6.16.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:369.9</id>
            <description>
                TRIM([[trim_sepcification] [trim_character] FROM] string_expression). trim_specification ::=[LEADING |
                TRAILING | BOTH] The TRIM function trims the specified character from a string.If the character to be
                trimmed is note specified, it is assumed to be space (or blank). The optional trim_character is a
                single-character string liuteral or character-valued input parameter (i.e. char or Character). The TRIM
                function returns the trimmed string.(NOTE: Not all databases support the use of the trim_character other
                than a space character; use of this argument may result in queries that are not portable.)
            </description>
            <location chapter="4" section="6.16.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:369.10</id>
            <description>
                LOWER(string_expression). The LOWER function converts a string to upper case. LOWER returns a string.
            </description>
            <location chapter="4" section="6.16.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:369.11</id>
            <description>
                UPPER (string_expression). The UPPER function converts a string to upper case. UPPER returns a string.
            </description>
            <location chapter="4" section="6.16.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:371</id>
            <description>
                If the query is specified for a method whose result type is java.util.Set, but does not specify
                DISTINCT, the container must interpret the query as if SELECT DISTINCT had been specified.
            </description>
            <location chapter="4" section="8"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:372</id>
            <description>
                The SELECT clause may contain one or more of the following elements:
            </description>
            <location chapter="4" section="8"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:372.1</id>
            <description>a single range variable</description>
            <location chapter="4" section="8"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:372.2</id>
            <description>
                identification variable that ranges over an entity abstract schema type
            </description>
            <location chapter="4" section="8"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:372.3</id>
            <description>a single-valued path expression</description>
            <location chapter="4" section="8"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:372.4</id>
            <description>an aggregate select expression</description>
            <location chapter="4" section="8"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:372.5</id>
            <description>a constructor expression</description>
            <location chapter="4" section="8"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:373</id>
            <description>
                All standalone identification variables in the SELECT clause may optionally be qualified by the OBJECT
                operator.
            </description>
            <location chapter="4" section="8"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:374</id>
            <description>
                The DISTINCT keyword is used to specify that duplicate values must be eliminated from the query result.
            </description>
            <location chapter="4" section="8"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:375</id>
            <description>
                If the result of an query corresponds to an association-field or state-field whose value is null, that
                null value is returned in the result of the query method.
            </description>
            <location chapter="4" section="8.3"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:376</id>
            <description>
                The IS NOT NULL construct can be used to eliminate the null from the result set of the query.
            </description>
            <location chapter="4" section="8.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:379</id>
            <description>
                Note, however, that state-field types in terms of Java numeric primitive types cannot produce NULL
                values in the query results. An query that returns such a state-field type as a result type MUST NOT
                return a null value.
            </description>
            <location chapter="4" section="8.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:380</id>
            <description>
                The aggregate function AVG can be used in the SELECT clause of an query.
            </description>
            <location chapter="4" section="8.4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:381</id>
            <description>
                The aggregate function MIN can be used in the SELECT clause of an query.
            </description>
            <location chapter="4" section="8.4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:382</id>
            <description>
                The aggregate function MAX can be used in the SELECT clause of an query.
            </description>
            <location chapter="4" section="8.4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:383</id>
            <description>
                The aggregate function SUM can be used in the SELECT clause of an query.
            </description>
            <location chapter="4" section="8.4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:384</id>
            <description>
                The aggregate COUNT function can be used in the SELECT clause of an query.
            </description>
            <location chapter="4" section="8.4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:389</id>
            <description>
                The path expression argument to COUNT may terminate in a state-field.
            </description>
            <location chapter="4" section="8.4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:390</id>
            <description>
                The path expression argument to COUNT may terminate in a association-field.
            </description>
            <location chapter="4" section="8.4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:391</id>
            <description>
                The argument to COUNT may be an identification variable.
            </description>
            <location chapter="4" section="8.4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:392</id>
            <description>
                The argument to an aggregate function may be preceded by the keyword DISTINCT to specify that duplicate
                values are to be eliminated before the aggregate function is applied. (NOTE: It is legal to specify
                DISTINCT with MAX or MIN but it does not affect the result.)
            </description>
            <location chapter="4" section="8.4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:393</id>
            <description>
                Null values are eliminated before the aggregate function is applied regardless whether the keyword
                DISTINCT is specified.
            </description>
            <location chapter="4" section="8.4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:394</id>
            <description>
                The result type of an identification_variable is type of the entity to which that identification
                variable corresponds or a subtype as determined by the o/r mapping.
            </description>
            <location chapter="4" section="8.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:395</id>
            <description>
                The result type of a constructor_expression is the type of the class for which the constructor is
                defined.
            </description>
            <location chapter="4" section="8.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:399</id>
            <description>
                When Order By clause is used, the SELECT clause of the query MUST be one of the following
            </description>
            <location chapter="4" section="9"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:399.1</id>
            <description>
                a single_valued_association_path_expression. For a single_valued_association_path_expression, each
                orderby_item MUST be an orderable state-field of the entity bean abstract schema type value returned by
                the SELECT clause
            </description>
            <location chapter="4" section="9"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:399.2</id>
            <description>
                an Identification Variable. For an identification variable, each orderby_item MUST be an orderable
                state-field of the entity bean abstract schema type value returned by the SELECT clause
            </description>
            <location chapter="4" section="9"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:399.3</id>
            <description>
                a state_field_path_expression. For state_field_path_expression, the orderby_item MUST evaluate to the
                same state-field of the same entity bean abstract schema type as the state_field_path_expression in the
                SELECT clause.
            </description>
            <location chapter="4" section="9"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:400</id>
            <description>
                If more than one orderby_item is specified, the left-to-right sequence of the orderby_item elements
                determines the precedence, whereby the leftmost orderby_item has the highest precedence.
            </description>
            <location chapter="4" section="9"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:401</id>
            <description>
                The keyword ASC specifies that ascending order is used. DEFAULT.
            </description>
            <location chapter="4" section="9"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:402</id>
            <description>
                The keyword DESC specified that descending order is used.
            </description>
            <location chapter="4" section="9"/>
        </assertion>
        <assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:403</id>
            <description>
                SQL rules for ordering of NULLS apply: that is, all null values MUST appear before all non-null values
                in the ordering or all null values MUST appear before all non-null values in the ordering, but it is not
                specified which.
            </description>
            <location chapter="4" section="9"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:404</id>
            <description>
                The ordering of the query result is preserved in the result of the query method if the ORDER BY clause
                is used.
            </description>
            <location chapter="4" section="9"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:406</id>
            <description>
                The type of the query result specified by the SELECT clause of a query is an entity abstract schema
                type, a state-field type, the result of an aggregate function, the result of a construction operation,
                or some sequence of these.
            </description>
            <location chapter="4" section="8.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:408</id>
            <description>
                The result of the SELECT clause is defined by the result types of the select_expressions contained in
                it. When multiple select_expressions are used in the SELECT clause, the result of the query is of type
                Object[] and the elements in this result correspond in order to the order of their specification in the
                SELECT caluse and in type to the result types of each select_expressions.
            </description>
            <location chapter="4" section="8.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:409</id>
            <description>
                The result type of the select_expression is a single_valued_path_expression that is a
                state_field_path_expression results in an object of the same type as the corresponding state field of
                the entity. If the state field of the entity is a primitive type, the corresponding object type is
                returned.
            </description>
            <location chapter="4" section="8.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:410</id>
            <description>
                The result type of the select_expression is a single_valued_path_expression that is a
                single_valued_association_path_expression results in an entity object of the type as the relationship
                field or the subtype of the relationship field of the entity as determined by the o/r mapping.
            </description>
            <location chapter="4" section="8.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>PERSISTENCE:SPEC:413</id>
            <description>
                If the query is specified for a method whose return type is java.util.Collection, the collection of
                values returned by the Container may contain duplicates if DISTINCT is not specified in the SELECT
                clause.
            </description>
            <location chapter="4" section="8"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:415</id>
            <description>
                Two NULL values are not considered to be equal, the comparison yield an UNKNOWN value.
            </description>
            <location chapter="4" section="11"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:416</id>
            <description>
                Comparison operations with a NULL value always yield an UNKNOWN value.
            </description>
            <location chapter="4" section="11"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:417</id>
            <description>
                Comparison operations with an UNKNOWN value always yield an UNKNOWN value.
            </description>
            <location chapter="4" section="11"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:418</id>
            <description>
                Arithmetic operators with a NULL value always yield an UNKNOWN value.
            </description>
            <location chapter="4" section="11"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:419</id>
            <description>
                Arithmetic operators with an UNKNOWN value always yield an UNKNOWN value.
            </description>
            <location chapter="4" section="11"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:422</id>
            <description>
                The IS NOT NULL operators convert a NULL state-field into the respective TRUE or FALSE value.
            </description>
            <location chapter="4" section="11"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:423</id>
            <description>
                The IS NOT NULL operators convert a NULL single-valued-association-field into the respective TRUE or
                FALSE value.
            </description>
            <location chapter="4" section="11"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:424</id>
            <description>
                Boolean operators use three valued logic: Table 7: Definition of the AND Operator
            </description>
            <location chapter="4" section="11"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:425</id>
            <description>
                Boolean operators use three valued logic: Table 8: Definition of the OR Operator
            </description>
            <location chapter="4" section="11"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:426</id>
            <description>
                Boolean operators use three valued logic: Table 9: Definition of the NOT Operator
            </description>
            <location chapter="4" section="11"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:427</id>
            <description>
                Two entities of the same abstract schema type are equal if and only if they have the same primary key
                value.
            </description>
            <location chapter="4" section="12"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:428</id>
            <description>
                Only equality/inequality comparisons over enums are required to be supported.
            </description>
            <location chapter="4" section="12"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:430</id>
            <description>
                Only the values of like types can be compared. There is one exception to this rule: it is valid to
                compare numeric values for which the rule of numeric promotion apply. Conditional expression attempting
                to compare non-like type values are disallowed except for this numeric case.
            </description>
            <location chapter="4" section="12"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:500</id>
            <description>The entity class must:</description>
            <keywords>
                <keyword>application-role</keyword>
                <keyword>application-server-role</keyword>
            </keywords>
            <location chapter="2" section="1"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:501</id>
                    <description>be annotated with the Entity annotation</description>
                    <keywords>
                        <keyword>application-role</keyword>
                        <keyword>application-server-role</keyword>
                    </keywords>
                    <location chapter="2" section="1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:502</id>
                    <description>be denoted in the deployment descriptor as an Entity</description>
                    <keywords>
                        <keyword>application-role</keyword>
                        <keyword>application-server-role</keyword>
                    </keywords>
                    <location chapter="2" section="1"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:503</id>
            <description>The entity must have a no-arg constructor.</description>
            <keywords>
                <keyword>application-role</keyword>
            </keywords>
            <location chapter="2" section="1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:504</id>
            <description>The entity may have other constructors as well.</description>
            <keywords>
                <keyword>application-role</keyword>
            </keywords>
            <location chapter="2" section="1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:505</id>
            <description>The no-arg constructor must be public or protected.</description>
            <keywords>
                <keyword>application-role</keyword>
            </keywords>
            <location chapter="2" section="1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:506</id>
            <description>If the entity is to be passed by value as a detached object (e.g., through a remote interface),
                it must implement the Serializable interface.
            </description>
            <keywords>
                <keyword>application-role</keyword>
            </keywords>
            <location chapter="2" section="1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:507</id>
            <description>The entity class must not be final.</description>
            <keywords>
                <keyword>application-role</keyword>
            </keywords>
            <location chapter="2" section="1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:508</id>
            <description>No methods or persistent instances of the entity class may be final.</description>
            <location chapter="2" section="1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:509</id>
            <description>Both abstract and concrete classes can be entities.</description>
            <location chapter="2" section="1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:510</id>
            <description>Entities may extend non-entity classes as well as entity classes and non-entity classes may
                extend entity classes.
            </description>
            <location chapter="2" section="1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:511</id>
            <description>Instance variables must not be accessed by clients of the entity. The state of the entity is
                available to clients only through the entity's accessor methods or other business methods.
            </description>
            <keywords>
                <keyword>application-role</keyword>
                <keyword>application-server-role</keyword>
            </keywords>
            <location chapter="2" section="1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:512</id>
            <description>Instance variables must be private, protected, or package visibility independent of whether
                field access
                or property access is used.
            </description>
            <keywords>
                <keyword>application-role</keyword>
            </keywords>
            <location chapter="2" section="1.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:513</id>
            <description>If the entity is field-based access, the persistence provider runtime accesses instance
                variables directly and all non-transient instance variables that are not annotated with the Transient
                annotation are persistent.
            </description>
            <location chapter="2" section="1.3.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:514</id>
            <description>If the entity is property-based access, the persistence provider accesses persistent state via
                the property accessor methods and all properties not annotated with the Transient annotation are
                persistent.
            </description>
            <location chapter="2" section="1.3.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:515</id>
            <description>The property accessor methods must be public or protected.</description>
            <keywords>
                <keyword>application-role</keyword>
            </keywords>
            <location chapter="2" section="1.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:516</id>
            <description>It is required that the entity class follow the method conventions for a JavaBean when
                property-based access is used.
            </description>
            <keywords>
                <keyword>application-role</keyword>
                <keyword>application-server-role</keyword>
            </keywords>
            <location chapter="2" section="1.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:517</id>
            <description>Collection-valued peristent fields and properties must be defned in terms of the
                java.util.Collection or java.util.Set interfaces regardless of whether the entity class otherwise
                adheres to the JavaBeans conventions noted above.
            </description>
            <keywords>
                <keyword>application-role</keyword>
                <keyword>application-server-role</keyword>
            </keywords>
            <location chapter="2" section="1.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:518</id>
            <description>The following collection interfaces are supported: java.util.Collection, java.util.set,
                java.util.List, java.util.Map
            </description>
            <keywords>
                <keyword>application-role</keyword>
                <keyword>application-server-role</keyword>
            </keywords>
            <location chapter="2" section="1.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:519</id>
            <description>For collection-valued persistent properties, type T must be one of these Collection interface
                types in the method signatures above. Generic variants of these Collection types may also
                be used.
            </description>
            <keywords>
                <keyword>application-role</keyword>
                <keyword>application-server-role</keyword>
            </keywords>
            <location chapter="2" section="1.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:520</id>
            <description>In addition to returning and setting persistent state of the instance, the property accessor
                methods may contain other business logic as well, for example, to perform validation. THe persistence
                provider runtime executes this logic when property-based access is used.
            </description>
            <location chapter="2" section="1.1"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:521</id>
                    <description>Runtime exceptions thrown by property accessor methods will cause the current
                        transaction to be rolled back.
                    </description>
                    <location chapter="2" section="1.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:522</id>
                    <description>Exceptions thrown by such methos when used by the persistence runtime to load or store
                        persistent state cause the persistence runtime to rollback the current transaction and to throw
                        a PersistenceException that wraps the application exception.
                    </description>
                    <location chapter="2" section="1.1"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:523</id>
            <description>Entity subclasses are permitted to override the property accessor methods of the entity.
                However, portable applications must not override the object/relational mapping metadata that applies to
                the persistent fields or properties of entity superclasses.
            </description>
            <keywords>
                <keyword>application-role</keyword>
            </keywords>
            <location chapter="2" section="1.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:524</id>
            <description>The persistent fields or properties of an entity may be one of the following types:
            </description>
            <keywords>
                <keyword>application-role</keyword>
                <keyword>application-server-role</keyword>
            </keywords>
            <location chapter="2" section="1.1"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:525</id>
                    <description>Java primitive types</description>
                    <location chapter="2" section="1.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:526</id>
                    <description>java.lang.String</description>
                    <location chapter="2" section="1.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:527</id>
                    <description>other Java serializable types (including wrappers of the primitive types,
                        java.math.BigInteger, java.math.BigDecimal, java.util.Date,
                        java.util.Calendar, java.sql.Date, java.sql.Time, java.sql.TimeStamp
                    </description>
                    <location chapter="2" section="1.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:528</id>
                    <description>user-defined serializable types, byte[], Byte[], char[], and Character[]</description>
                    <location chapter="2" section="1.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:529</id>
                    <description>enums</description>
                    <location chapter="2" section="1.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:530</id>
                    <description>entity types</description>
                    <location chapter="2" section="1.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:531</id>
                    <description>collection of entity types</description>
                    <location chapter="2" section="1.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:532</id>
                    <description>embeddable classes</description>
                    <location chapter="2" section="1.1"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:533</id>
            <description>Every entity must have a primary key.</description>
            <keywords>
                <keyword>application-role</keyword>
            </keywords>
            <location chapter="2" section="1.4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:534</id>
            <description>A simple primary key must correspond to a single persistent field or property of the entity
                class.
            </description>
            <keywords>
                <keyword>application-role</keyword>
                <keyword>application-server-role</keyword>
            </keywords>
            <location chapter="2" section="1.4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:535</id>
            <description>A composite primary key must correspond to either a single persistent field or property or to a
                set of such fields or properties.
            </description>
            <keywords>
                <keyword>application-role</keyword>
                <keyword>application-server-role</keyword>
            </keywords>
            <location chapter="2" section="1.4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:536</id>
            <description>The primary key must be one of the following types:</description>
            <keywords>
                <keyword>application-role</keyword>
                <keyword>application-server-role</keyword>
            </keywords>
            <location chapter="2" section="1.4"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:537</id>
                    <description>any Java primitive type</description>
                    <location chapter="2" section="1.4"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:538</id>
                    <description>any primitive wrapper type</description>
                    <location chapter="2" section="1.4"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:539</id>
                    <description>java.lang.String</description>
                    <location chapter="2" section="1.4"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:540</id>
                    <description>java.util.Date. If java.util.Date is used as a primary key field or property,the
                        temporal type should be specified as DATE.
                    </description>
                    <location chapter="2" section="1.4"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:541</id>
                    <description>java.sql.Date</description>
                    <location chapter="2" section="1.4"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:542</id>
            <description>The access type (field- or property-based access) of a primary key class is determined by the
                access type of the entity for which it is the primary key.
            </description>
            <keywords>
                <keyword>application-role</keyword>
                <keyword>application-server-role</keyword>
            </keywords>
            <location chapter="2" section="1.4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:543</id>
            <description>The following rules apply for composite primary keys:</description>
            <location chapter="2" section="1.4"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:544</id>
                    <description>The primary key class must be public and must have a public no-arg constructor.
                    </description>
                    <keywords>
                        <keyword>application-role</keyword>
                    </keywords>
                    <location chapter="2" section="1.4"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:545</id>
                    <description>The primary key class must be serializable.</description>
                    <keywords>
                        <keyword>application-role</keyword>
                    </keywords>
                    <location chapter="2" section="1.4"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:546</id>
                    <description>If property-based access is used, the properties of the primary key class must be
                        public or protected.
                    </description>
                    <keywords>
                        <keyword>application-role</keyword>
                    </keywords>
                    <location chapter="2" section="1.4"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:547</id>
                    <description>The composite primary key must define equals and hashCode methods.</description>
                    <keywords>
                        <keyword>application-role</keyword>
                    </keywords>
                    <location chapter="2" section="1.4"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:548</id>
                    <description>A composite primary key must either be represented and mapped as an embeddable class
                        (EmbeddedId annotation) or must be represented and mapped to multiple fields or properties of
                        the entity class (IdClass annotation).
                    </description>
                    <keywords>
                        <keyword>application-role</keyword>
                    </keywords>
                    <location chapter="2" section="1.4"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:549</id>
                    <description>If the composite primary key class is mapped to multiple fields or properties of the
                        entity class, then the names of the primary key fields or properties in the primary key class
                        and those of the entity class must correspond and their types must be the same.
                    </description>
                    <keywords>
                        <keyword>application-role</keyword>
                    </keywords>
                    <location chapter="2" section="1.4"/>
                </assertion>
                <assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="false">
                    <id>PERSISTENCE:SPEC:550</id>
                    <description>The application must not change the value of the primary key. The behavior is undefined
                        if this occurs.
                    </description>
                    <keywords>
                        <keyword>application-role</keyword>
                    </keywords>
                    <location chapter="2" section="1.4"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="false">
            <id>PERSISTENCE:SPEC:551</id>
            <description>Such embedded objects belong strictly to their owning entity and are not shareable across
                persistent entities. Attempting to share an embedded object across entities has undefined semantics.
            </description>
            <location chapter="2" section="1.6"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="removed" testable="true">
            <id>PERSISTENCE:SPEC:552</id>
            <description>Collection of embedded objects are supported.</description>
            <location chapter="2" section="1.6"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:553</id>
            <description>Embeddable classes must adhere to the requirements as specified in section 2.1 for entities
                with the exception that embeddable classes are not annotated as Entity.
            </description>
            <keywords>
                <keyword>application-role</keyword>
                <keyword>application-server-role</keyword>
            </keywords>
            <location chapter="2" section="1.6"/>
        </assertion>
        <assertion required="false" impl-spec="false" defined-by="technology" status="removed" testable="false">
            <id>PERSISTENCE:SPEC:554</id>
            <description>Unlike entities, embeddable classes do not support polymorphism and inheritance.</description>
            <location chapter="2" section="1.5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:555</id>
            <description>If a persistent field or property other than a relationship property is not annotated with a
                mapping annotation, the the following default mappings rules are applied.
            </description>
            <location chapter="2" section="1.9"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:556</id>
                    <description>If the type of the field or property is one of the following, it is mapped as @Basic:
                        Java primitive types, wrappers of primitive types, java.lang.String, java.math.BigInteger,
                        java.math.BigDecimal, java.util.Date, java.util.Calendar,java.sql.Date, java.sql.Time,
                        java.sql.TimeStamp, byte[], Byte[], char[], Character[], enums, any other types that implement
                        Serializable.
                    </description>
                    <location chapter="2" section="1.9"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:557</id>
                    <description>If the type is a class that is annotated with the @Embeddable annotation, it is mapped
                        as @Embedded.
                    </description>
                    <location chapter="2" section="1.9"/>
                </assertion>
                <assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:560</id>
                    <description>It is an error if no annotation is present and none of the above rules apply.
                    </description>
                    <keywords>
                        <keyword>application-role</keyword>
                        <keyword>application-server-role</keyword>
                    </keywords>
                    <location chapter="2" section="1.9"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:561</id>
            <description>If there is an association between two entities, one of the following relationship modeling
                annotations must be applied to the corresponding property or instance variable of the referencing
                entity:
            </description>
            <keywords>
                <keyword>application-role</keyword>
                <keyword>application-server-role</keyword>
            </keywords>
            <location chapter="2" section="1.10"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:562</id>
                    <description>OneToOne</description>
                    <location chapter="2" section="1.10"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:563</id>
                    <description>OneToMany</description>
                    <location chapter="2" section="1.10"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:564</id>
                    <description>ManyToOne</description>
                    <location chapter="2" section="1.10"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:565</id>
                    <description>ManyToMany</description>
                    <location chapter="2" section="1.10"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:566</id>
            <description>For associations that do not specify the targe type (e.g., where Java generic types are not
                used for collections) it is necessary to also specify the entity that is the target of the relationship.
            </description>
            <keywords>
                <keyword>application-role</keyword>
                <keyword>application-server-role</keyword>
            </keywords>
            <location chapter="2" section="1.10"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:567</id>
            <description>A bidirectional relationship has both an owning side and an inverse side.</description>
            <location chapter="2" section="1.10"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:568</id>
            <description>A unidirectional relationship has only an owning side.</description>
            <location chapter="2" section="1.10"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:569</id>
            <description>The following rules apply to bidirectional relationships:</description>
            <location chapter="2" section="1.10"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:570</id>
                    <description>The inverse side of a bidirectional relationship must refer to its owning side by use
                        of the mappedBy element of the OneToOne, OneToMany, or ManyToMany annotation.
                    </description>
                    <keywords>
                        <keyword>application-role</keyword>
                        <keyword>application-server-role</keyword>
                    </keywords>
                    <location chapter="2" section="1.10"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:571</id>
                    <description>The mappedBy element designates the property or field in the entity that is the owner
                        of the relationship.
                    </description>
                    <location chapter="2" section="1.10"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:572</id>
                    <description>The many side of one-to-many/many-to-one bidirectional relationships must be the owning
                        side, hence the mappedBy element cannot be specified on the ManyToOne annotation.
                    </description>
                    <keywords>
                        <keyword>application-role</keyword>
                        <keyword>application-server-role</keyword>
                    </keywords>
                    <location chapter="2" section="1.10"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:573</id>
                    <description>For one-to-one bidirectional relationships, the owning side corresponds to the side
                        that contains the corresponding foreign key.
                    </description>
                    <location chapter="2" section="1.10"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:574</id>
                    <description>For many-to-many bidirectional relationships, either side may be the owning side.
                    </description>
                    <location chapter="2" section="1.10"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:575</id>
            <description>The cascade=REMOVE specification should only be applied to associations that are specified as
                OneToOne or OneToMany.
            </description>
            <keywords>
                <keyword>application-role</keyword>
                <keyword>application-server-role</keyword>
            </keywords>
            <location chapter="2" section="1.10"/>
        </assertion>
        <assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:576</id>
            <description>Applications that apply cascade=REMOVE to other assocations [ManyToMany, ManyToOne] are not
                portable.
            </description>
            <keywords>
                <keyword>application-role</keyword>
                <keyword>application-server-role</keyword>
            </keywords>
            <location chapter="2" section="1.10"/>
        </assertion>
        <assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:577</id>
            <description>A foreign key mapping may be used for a unidirectional one-to-many mapping. Any such overriding
                must be consistent with the relationship modeling annotation that is specified.
            </description>
            <keywords>
                <keyword>application-role</keyword>
                <keyword>application-server-role</keyword>
            </keywords>
            <location chapter="2" section="1.10"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:578</id>
            <description>Bidirectional OneToOne Relationships</description>
            <location chapter="2" section="1.11.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:579</id>
            <description>Bidirectional ManyToOne/OneToMany Relationships</description>
            <location chapter="2" section="1.11.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:580</id>
            <description>Unidirectional Single-Valued Relationships</description>
            <location chapter="2" section="1.11.3"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:581</id>
            <description>Unidirectional OneToOne Relationships</description>
            <location chapter="2" section="1.11.3.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:582</id>
            <description>Unidirectional ManyToOne Relationships</description>
            <location chapter="2" section="1.11.3.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:583</id>
            <description>Bidirectional ManyToMany Relationships</description>
            <location chapter="2" section="1.11.4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:584</id>
            <description>Unidirectional Multi-Valued Relationships</description>
            <location chapter="2" section="1.11.5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:585</id>
            <description>Unidirectional OneToMany Relationships</description>
            <location chapter="2" section="1.11.5.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:586</id>
            <description>Unidirectional ManyToMany Relationships</description>
            <location chapter="2" section="1.11.5.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:587</id>
            <description>When an entity is defined as a subclass of another entity, the primary keys of the entities
                must be of the same type.
            </description>
            <keywords>
                <keyword>application-role</keyword>
            </keywords>
            <location chapter="2" section="1.9"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:588</id>
            <description>An abstract entity class is annotated with the Entity annotation or denoted in the XML
                descriptor as an entity.
            </description>
            <location chapter="2" section="1.12.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:588.1</id>
            <description>An abstract entity is mapped as an entity and can be the target of queries (which will operate
                over and/or retrieve instances of its concrete subclass).
            </description>
            <location chapter="2" section="1.12.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:589</id>
            <description>An entity may have a non-entity superclass which may be either a concrete or abstract class.
            </description>
            <location chapter="2" section="1.12.3"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:590</id>
            <description>The state of a non-entity superclass is not persistent.</description>
            <location chapter="2" section="1.12.3"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:591</id>
            <description>Any state inherited from non-entity superclasses is non-persistent in an inheriting entity
                class. This non-persistent state is not managed
                by the EntityManager, nor is it required to be retained across transactions.
            </description>
            <location chapter="2" section="1.12.3"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:592</id>
            <description>Non-entity classes cannot be passed as arguments to methods of the EntityManager or Query
                interfaces and cannot bear mapping information.
            </description>
            <location chapter="2" section="1.12.3"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:593</id>
            <description>An entity may have an mapped superclass, which provides persistent entity state and mapping
                information, but which is not an entity itself.
            </description>
            <location chapter="2" section="1.12.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:594</id>
            <description>A mapped superclass, unlike an entity, is not queryable and cannot be passed as an argument to
                EntityManager or Query operations.
            </description>
            <location chapter="2" section="1.12.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:595</id>
            <description>An mapped superclass cannot be the target of a persistent relationship.</description>
            <location chapter="2" section="1.12.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:596</id>
            <description>Both abstract or concrete classes may be specified as mapped superclasses.</description>
            <location chapter="2" section="1.12.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:597</id>
            <description>The MappedSuperclass annotation (or mapped-superclass XML descriptor element) is used to
                designate an mapped superclass.
            </description>
            <location chapter="2" section="1.12.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:598</id>
            <description>A class designated as an mapped superclass has no separate table defined for it. Its mapping
                information is applied to entities that inherit from it.
            </description>
            <location chapter="2" section="1.12.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:599</id>
            <description>A classes designated as MappedSuperclass can be mapped in the same way as an entity except that
                the mapping will only apply to its subclesses since no table exists for the mapped superclass. When
                applied to the subclasses the inherited mappings will apply in the context of the subclass tables.
            </description>
            <location chapter="2" section="1.12.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:600</id>
            <description>Mapping information may be overriden in such subclasses by using the AttributeOverride
                annotation or attribute-override XML element.
            </description>
            <location chapter="2" section="1.12.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:601</id>
            <description>All other entity mapping defaults apply equally to a class designated as MappedSuperclass.
            </description>
            <location chapter="2" section="1.12.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:602</id>
            <description>There are three basic strategies that are used when mapping a class or class hierarchy to a
                relational database schema:
            </description>
            <location chapter="2" section="1.13"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:603</id>
                    <description>Single Table per Class Hierarchy Strategy. An implementation is required to support the
                        single table per class hierachy inheritance mapping strategy.
                    </description>
                    <location chapter="2" section="1.13.1"/>
                </assertion>
                <assertion required="false" impl-spec="true" defined-by="technology" status="active" testable="false">
                    <id>PERSISTENCE:SPEC:604</id>
                    <description>Table Per Concrete Class Strategy</description>
                    <location chapter="2" section="1.13.2"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:605</id>
                    <description>Joined Subclass Strategy</description>
                    <location chapter="2" section="1.13.3"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:606</id>
            <description>The persist, merge, remove, flush, and refresh methods must be invoked within a transaction
                context when an entity
                manager with a transaction-scoped persistence context is used. If there is no transaction context, the
                jakarta.persistence. TransactionRequiredException
                is thrown.
            </description>
            <location chapter="3" section="1.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:607</id>
            <description>The find and getReference methods are not required to be invoked within a transaction context.
                If an entity manager with transaction-
                scoped persistence context is in use, the resulting entities will be detached; if an entity manager with
                an extended persistence context is used,
                they will be managed.
            </description>
            <location chapter="3" section="1.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:608</id>
            <description>The Query and EntityTransaction objects obtained from an entity manager are valid while that
                entity manager is open.
            </description>
            <location chapter="3" section="1.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:609</id>
            <description>If the argument to the createQuery method is not a valid QL query string, the
                IllegalArgumentException may be thrown
                or the query execution will fail.
            </description>
            <location chapter="3" section="1.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>PERSISTENCE:SPEC:610</id>
            <description>If a native query is not a valid query for the database in use or if the results set
                specification is incompatible with the result
                of the query, the query execution will fail and a PersistenceException will be thrown when the query is
                executed. The PersistenceException
                should wrap the underlying database exception when possible.
            </description>
            <location chapter="3" section="1.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:611</id>
            <description>Runtime exceptions thrown by the methods of the EntityManager interface will cause the current
                transaction to
                be marked for roll back.
            </description>
            <location chapter="3" section="1.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:612</id>
            <description>The methods close, isOpen, joinTransaction and getTransaction are used to managed
                application-managed
                entity managers and their life cycle.
            </description>
            <location chapter="3" section="1.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:613</id>
            <description>Entity Instance's Life Cycle:</description>
            <location chapter="3" section="2"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:614</id>
                    <description>A new entity instance has no persistent identity and is not yet associated with a
                        persistence context.
                    </description>
                    <location chapter="3" section="2"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:615</id>
                    <description>A managed entity instance is an instance with a persistent identity that is currently
                        associated with a persistence context.
                    </description>
                    <location chapter="3" section="2"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:616</id>
                    <description>A detached entity is an instance with a persistent identity that is not (or no longer)
                        associated with a persistence context.
                    </description>
                    <location chapter="3" section="2"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:617</id>
                    <description>A removed entity instance is an instance with a persistent identity associated with a
                        persistence context that will be removed from the database.
                    </description>
                    <location chapter="3" section="2"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:618</id>
            <description>The new entity instance becomes both managed and persistent by
                invoking the persist method on it or by cascading the persist operation. The semantics of the persist
                operation, applied to an entity X, are as follows:
            </description>
            <location chapter="3" section="2.1"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:619</id>
                    <description>If X is a new entity, it becomes managed.</description>
                    <location chapter="3" section="2.1"/>
                </assertion>
                <assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:620</id>
                    <description>The entity X will be entered into the database at or before transaction commit or as a
                        result of the flush operation.
                    </description>
                    <location chapter="3" section="2.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:621</id>
                    <description>If X is a preexisting managed entity, it is ignored by the persist operation.
                    </description>
                    <location chapter="3" section="2.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:622</id>
                    <description>However, the persist operation is cascaded to entities referenced by X, if the
                        relationship from X to these other entities is annotated with cascade=PERSIST annotation
                        element.
                    </description>
                    <location chapter="3" section="2.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:623</id>
                    <description>However, the persist operation is cascaded to entities referenced by X, if the
                        relationship from X to these other entities is annotated with cascade=ALL annotation element.
                    </description>
                    <location chapter="3" section="2.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:624</id>
                    <description>If X is a removed entity, it becomes managed.</description>
                    <location chapter="3" section="2.1"/>
                </assertion>
                <assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:625</id>
                    <description>If X is a detached object, an IllegalArgumentException will be thrown by the persist
                        operation (or the transaction comit will fail).
                    </description>
                    <location chapter="3" section="2.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:626</id>
                    <description>For all entities Y referenced by a relationship from X, if the relationship to Y has
                        been annotated with the cascade element value cascade=PERSIST, the persist operation is applied
                        to Y.
                    </description>
                    <location chapter="3" section="2.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:627</id>
                    <description>For all entities Y referenced by a relationship from X, if the relationship to Y has
                        been annotated with the cascade element value cascade=ALL, the persist operation is applied to
                        Y.
                    </description>
                    <location chapter="3" section="2.1"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:628</id>
            <description>A managed entity instance becomes removed by invoking the
                remove method on it or by cascading the remove operation. The semantics of the remove operation, applied
                to an entity X, are as follows:
            </description>
            <location chapter="3" section="2.2"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:629</id>
                    <description>If X is a new entity, it is ignored by the remove operation.</description>
                    <location chapter="3" section="2.2"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:630</id>
                    <description>However, the remove operation is cascaded to entities referenced by X, if the
                        relationship from X to these other entities is annotated with cascade=REMOVE annotation element.
                    </description>
                    <location chapter="3" section="2.2"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:631</id>
                    <description>However, the remove operation is cascaded to entities referenced by X, if the
                        relationship from X to these other entities is annotated with cascade=ALL annotation element.
                    </description>
                    <location chapter="3" section="2.2"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:632</id>
                    <description>If X is a managed entity, the remove operation causes it to transition to the removed
                        state.
                    </description>
                    <location chapter="3" section="2.2"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:633</id>
                    <description>The remove operation is cascaded to entities referenced by X, if the relationship from
                        X to these other entities is annotated with cascade=REMOVE annotation element.
                    </description>
                    <location chapter="3" section="2.2"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:634</id>
                    <description>The remove operation is cascaded to entities referenced by X, if the relationship from
                        X to these other entities is annotated with cascade=ALL annotation element.
                    </description>
                    <location chapter="3" section="2.2"/>
                </assertion>
                <assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:635</id>
                    <description>If X is a detached entity, an IllegalArgumentException will be thrown by the remove
                        operation (or the transaction commit will fail).
                    </description>
                    <location chapter="3" section="2.2"/>
                </assertion>
                <assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:636</id>
                    <description>If X is a removed entity, it is ignored by the remove operation.</description>
                    <location chapter="3" section="2.2"/>
                </assertion>
                <assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:637</id>
                    <description>A removed entity X will be removed from the database at or before transaction commit or
                        as a result of the flush operation.
                    </description>
                    <location chapter="3" section="2.2"/>
                </assertion>
                <assertion required="false" impl-spec="true" defined-by="technology" status="active" testable="false">
                    <id>PERSISTENCE:SPEC:638</id>
                    <description>Accessing an entity in the removed state is undefined.</description>
                    <location chapter="3" section="2.2"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:639</id>
            <description>The state of persistent entities is synchronized with the database at transaction commit.
            </description>
            <location chapter="3" section="2.3"/>
        </assertion>
        <assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="false">
            <id>PERSISTENCE:SPEC:640</id>
            <description>The persistence provider runtime is permitted to perform [database] synchronization at other
                times as well, for example, before query execution.
            </description>
            <location chapter="3" section="2.3"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:641</id>
            <description>The flush method can be used to force synchronization. It applies to entities associated with a
                persistence context. The semantics of the flush operation, applied to entity X are as follows:
            </description>
            <location chapter="3" section="2.3"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:642</id>
                    <description>If X is a managed entity, it is synchronized to the database.</description>
                    <location chapter="3" section="2.3"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:643</id>
                    <description>For all entities Y referenced by a relationship from X, if the relationship to Y has
                        been annotated with the cascade element value cascade=PERSIST, the persist operation is applied
                        to Y.
                    </description>
                    <location chapter="3" section="2.3"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:644</id>
                    <description>For all entities Y referenced by a relationship from X, if the relationship to Y has
                        been annotated with the cascade element value cascade=ALL, the persist operation is applied to
                        Y.
                    </description>
                    <location chapter="3" section="2.3"/>
                </assertion>
                <assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:645</id>
                    <description>For any new entity Y referenced by a relationship from X, where the relationship to Y
                        has not been annotated with the cascade element cascade=PERSIST or cascade=ALL, an exception
                        will be thrown by the flush operation or the transaction commit will fail.
                    </description>
                    <location chapter="3" section="2.3"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:646</id>
                    <description>For any detached entity Y referenced by a relationship from X, where the relationship
                        to Y has not been annotated with the cascade element value cascade=PERSIST or cascade=ALL, the
                        semantics depend upon the ownership of the relationship: If X owns the relationship, any changes
                        to the relationship are synchronized with the database.
                    </description>
                    <location chapter="3" section="2.3"/>
                </assertion>
                <assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="false">
                    <id>PERSISTENCE:SPEC:647</id>
                    <description>For any detached entity Y referenced by a relationship from X, where the relationship
                        to Y has not been annotated with the cascade element value cascade=PERSIST or cascade=ALL, the
                        semantics depend upon the ownership of the relationship: If Y owns the relationships, the
                        behavior is undefined.
                    </description>
                    <location chapter="3" section="2.3"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:648</id>
                    <description>If X is a removed entity, it is removed from the database.</description>
                    <location chapter="3" section="2.3"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:649</id>
            <description>When the persistence context ends, managed entity instances associated with the context become
                detached.
                The application may safely access their available state of available detached entity instances after the
                persistence context ends. The available state includes:
            </description>
            <location chapter="3" section="2.6"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:650</id>
                    <description>Any persistent field or property not marked fetch=LAZY</description>
                    <location chapter="3" section="2.6"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:651</id>
                    <description>Any persistent field or property that was accessed by the application.</description>
                    <location chapter="3" section="2.6"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:652</id>
            <description>If the persistent field or property is an associationm, the state of an associated instance may
                only be safely accessed if the associated instance is available.
                The available instances include:
            </description>
            <location chapter="3" section="2.6"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:653</id>
                    <description>All entity instances retrieved using find().</description>
                    <location chapter="3" section="2.6"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:654</id>
                    <description>Any entity instances retrieved using a query or explictly requested in the FETCH JOIN
                        clause.
                    </description>
                    <location chapter="3" section="2.6"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:655</id>
                    <description>Any entity instance for which an instance variable holding non-primary-key persistent
                        state was accessed by the application.
                    </description>
                    <location chapter="3" section="2.6"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:656</id>
                    <description>Any entity instance that may be reached from another available instance by navigating
                        associations marked fetch=EAGER.
                    </description>
                    <location chapter="3" section="2.6"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:657</id>
            <description>A detached entity may also result by serializing an entity, or otherwise passing it by value
                (e.g., to a separate application tier,through a remote inteface, etc.) and the same rules apply.
            </description>
            <location chapter="3" section="2.6"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:658</id>
            <description>The merge operation allows for the propagation of state from detached entities onto persistent
                entities managed by the Entity Manager. The semantics of the merge operation applied to an entity X are
                as follows:
            </description>
            <location chapter="3" section="2.6.1"/>
            <sub-assertions>
                <assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:659</id>
                    <description>If X is a detached entity, it is copied onto pre-existing managed entity instance X1 of
                        the same identity or a new managed copy of X is created.
                    </description>
                    <location chapter="3" section="2.6.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:660</id>
                    <description>If X is a new entity instance, a new managed entity instance X1 is created and the
                        state of X is copied into the new managed entity instance X1.
                    </description>
                    <location chapter="3" section="2.6.1"/>
                </assertion>
                <assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:661</id>
                    <description>If X is a removed entity instance, an IllegalArgumentException will be thrown by the
                        merge operation (or the transaction commit will fail).
                    </description>
                    <location chapter="3" section="2.6.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:662</id>
                    <description>If X is a managed entity, it is ignored by the merge operation, however, the merge
                        operation is cascaded to entities referenced by relationships from X if these relationships have
                        been annotated with the cascade element value cascade=MERGE annotation.
                    </description>
                    <location chapter="3" section="2.6.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:663</id>
                    <description>If X is a managed entity, it is ignored by the merge operation, however, the merge
                        operation is cascaded to entities referenced by relationships from X if these relationships have
                        been annotated with the cascade element value cascade=ALL annotation.
                    </description>
                    <location chapter="3" section="2.6.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:664</id>
                    <description>For all entities Y referenced by relationships from X having the cascade element value
                        cascade=MERGE, Y is merged recursively as Y1. For all such Y referenced by X, X1 is set to
                        reference Y1.
                    </description>
                    <location chapter="3" section="2.6.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:665</id>
                    <description>For all entities Y referenced by relationships from X having the cascade element value
                        cascade=ALL, Y is merged recursively as Y1. For all such Y referenced by X, X1 is set to
                        reference Y1.
                    </description>
                    <location chapter="3" section="2.6.1"/>
                </assertion>
                <assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:666</id>
                    <description>Version colunms used by the entity should be checked by the persistence runtime
                        implementation during the merge operation or at flush or commit time.
                    </description>
                    <location chapter="3" section="2.6.1"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:667</id>
            <description>The contains method [used to determine whether an entity instance is in the managed state]
                returns true:
            </description>
            <location chapter="3" section="2.7"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:668</id>
                    <description>If the entity has been retrieved from the database or has returned by the
                        getReference,and has not been removed or detached.
                    </description>
                    <location chapter="3" section="2.5"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:669</id>
                    <description>If the entity instance is new and the persist method has been called on the entity.
                    </description>
                    <location chapter="3" section="2.7"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:670</id>
                    <description>If the entity instance is new and the persist operation has been cascaded to it.
                    </description>
                    <location chapter="3" section="2.7"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:671</id>
            <description>The contains method [used to determine whether an entity instance is in the managed state]
                returns false:
            </description>
            <location chapter="3" section="2.7"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:672</id>
                    <description>If the instance is detached.</description>
                    <location chapter="3" section="2.7"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:673</id>
                    <description>If the remove method has been called on the entity.</description>
                    <location chapter="3" section="2.7"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:674</id>
                    <description>If the remove operation has been cascaded to it.</description>
                    <location chapter="3" section="2.7"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:675</id>
                    <description>If the entity instance is new and the persist method has not been called on the entity.
                    </description>
                    <location chapter="3" section="2.7"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:676</id>
                    <description>If the entity instance is new and the persist operation has not been cascaded to it.
                    </description>
                    <location chapter="3" section="2.7"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:677</id>
            <description>Not that the effect of cascading persist,merge,remove,or evict is immediately visible to the
                contains method, whereas, the actual
                insertion or deletion of the database representation for the entity may be deferred until the end of the
                transaction.
            </description>
            <location chapter="3" section="2.7"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:678</id>
            <description>The enum PersistenceContextType is used to define persistence context lifetime scope for
                container-managed entity managers.
            </description>
            <location chapter="3" section="3"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:679</id>
            <description>By default, a persistence context's lifecycle corresponds to the scope of a transaction
                (PersistenceContextType.TRANSACTION).
            </description>
            <location chapter="3" section="3"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:680</id>
            <description>When an extended persistence context is used, the extended persistence contexts exists from the
                time the EntityManager instance is created
                until it is closed. This persistence context might span multiple transactions and non-transactional
                invocations of the EntityManager.
            </description>
            <location chapter="3" section="3"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:681</id>
            <description>An EntityManager with an extended persistence context maintains its references to the entity
                objects after a transaction has committed.
                Those objects remain managed by the EntityManager and they may be updated as managed objects between
                transactions.
            </description>
            <location chapter="3" section="3"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:682</id>
            <description>Navigation from a managed object in an extended persistence context results in one or more
                other managed objects regardless of
                whether a transaction is active.
            </description>
            <location chapter="3" section="3"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:683</id>
            <description>When an EntityManager with an extended persistence context is used, the persist, remove, merge
                and refresh operations
                may be called regardless of whether a transaction is active. The effects of these operations will be
                committed to the database when the
                extended persistence context is entlisted in a transaction and the transaction commits.
            </description>
            <location chapter="3" section="3"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:684</id>
            <description>The scope of the persistence context of an application-managed entity manager is extended. It
                is the responsibility
                of the application to manage the lifecycle of the persistence context.
            </description>
            <location chapter="3" section="3"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:685</id>
            <description>The managed entities of a transaction-scoped persistence context become detached when the
                transaction commits.
            </description>
            <location chapter="3" section="3.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:686</id>
            <description>The managed entities of an extended persistence context remain managed.</description>
            <location chapter="3" section="3.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:687</id>
            <description>For both transaction-scoped and extended persistence contexts, transaction rollback causes all
                pre-existng managed instances and removed
                instances to become detached.
            </description>
            <location chapter="3" section="3.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:688</id>
            <description>Optmistic Locking and Concurrency</description>
            <location chapter="3" section="4"/>
        </assertion>
        <assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:689</id>
            <description>Optimistic Locking</description>
            <location chapter="3" section="4.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:690</id>
            <description>Version Attributes</description>
            <location chapter="3" section="4.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:691</id>
            <description>Lock Modes</description>
            <location chapter="3" section="4.3"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:692</id>
            <description>OptimisticLockException</description>
            <location chapter="3" section="4.4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:693</id>
            <description>OptimisticLockException always causes the transaction to be marked for roll back.</description>
            <location chapter="3" section="4.4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:694</id>
            <description>Lifecycle callback methods and entity listener classes are defined by means of metadata
                annotations or in the XML descriptor.
            </description>
            <location chapter="3" section="5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:695</id>
            <description>When annotations are used, one or more entity listener classes are denoted using the
                EntityListeners annoation on the
                entity class or mapped superclass.
            </description>
            <location chapter="3" section="5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:696</id>
            <description>If multiple entity listeners are defined, the order in wihch they are invoked is determined by
                the order in which they are specified
                in the EntityListeners annotation.
            </description>
            <location chapter="3" section="5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:697</id>
            <description>The XML descriptor may be used as an alternative to specify the invocation order of the entity
                listeners or to override the order specified in metadata annotations..
            </description>
            <location chapter="3" section="5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:698</id>
            <description>Any subset or combination of annotations may be specified on an entity class, mapped
                superclass, of listener class..
            </description>
            <keywords>
                <keyword>application-role</keyword>
            </keywords>
            <location chapter="3" section="5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:699</id>
            <description>A single class may not have more than one lifecycle callback method for the same lifecycle
                event. The same method may be used for multiple callback events.
            </description>
            <keywords>
                <keyword>application-role</keyword>
            </keywords>
            <location chapter="3" section="5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:700</id>
            <description>Multple entity classes and mapped superclasses in an inheritance hierarchy may define listener
                classes and/or lifecycle callback methods directly on the class.
            </description>
            <keywords>
                <keyword>application-role</keyword>
            </keywords>
            <location chapter="3" section="5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:701</id>
            <description>The entity listener class must have a public no-arg constructor.</description>
            <keywords>
                <keyword>application-role</keyword>
            </keywords>
            <location chapter="3" section="5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:702</id>
            <description>The following rules apply to callbacks:</description>
            <location chapter="3" section="5"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:703</id>
                    <description>Callback methods may throw unchecked/runtime exceptions.</description>
                    <keywords>
                        <keyword>application-role</keyword>
                    </keywords>
                    <location chapter="3" section="5"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:704</id>
                    <description>A runtime exception thrown by a callback method that executes within a transaction
                        causes that transaction to be marked for roll back.
                    </description>
                    <location chapter="3" section="5"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:705</id>
                    <description>Lifecycle callbacks can invoke JNDI, JDBC, JMS, and enterprise beans.</description>
                    <keywords>
                        <keyword>application-role</keyword>
                        <keyword>application-server-role</keyword>
                    </keywords>
                    <location chapter="3" section="5"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
                    <id>PERSISTENCE:SPEC:706</id>
                    <description>In general, portable applications should not invoke EntityManager
                        or Query operations, access other entity instances or modify relationships within the same
                        persistent context.
                    </description>
                    <location chapter="3" section="5"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:707</id>
                    <description>When invoked from within a JavaEE environment, the callback listener for an entity
                        share the enterprise
                        naming context of the invoking component, and the entity callback methods are invoked in the
                        transaction and
                        security contexts of the calling component at the time at which the callback method is invoked.
                    </description>
                    <location chapter="3" section="5"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:708</id>
            <description>The PrePersist and PreRemove callback methods are invoked for a given entity before the
                respective EntityManager persist and remove operation for that entity are executed
                These callbacks will also be invoked on entities to which these operations are cascaded.
            </description>
            <location chapter="3" section="5.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:709</id>
            <description>The PrePersist and PreRemove callbacks will always be invoked on all entities which these
                operations are cascaded.
            </description>
            <location chapter="3" section="5.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:710</id>
            <description>For entities which the merge operation has been applied and causes the creation of newly
                managed instaced, the PrePersist callback methods
                will be invoked for the managed instance after the entity state has been copied to it.
            </description>
            <location chapter="3" section="5.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:711</id>
            <description>The PrePersist and PreRemove callbacks will always be invoked as part of the synchronous
                persist, merge, and remove operations..
            </description>
            <location chapter="3" section="5.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:712</id>
            <description>The PostPersist and PostRemove callback methods are invoked after the entity has been made
                persistent or removed.
                These callbacks will also be invoked on entities to which these operations are cascaded.
            </description>
            <location chapter="3" section="5.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:713</id>
            <description>The PostPersist and PostRemove methods will be invoked after the database insert and delete
                operations respectively.
            </description>
            <location chapter="3" section="5.2"/>
        </assertion>
        <assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="false">
            <id>PERSISTENCE:SPEC:714</id>
            <description>These database operations may occur directly after the persist, merge, or remove operations
                have been invoked or they may occur directly
                after a flush operation has occurred (which may be at the end of the transaction).
            </description>
            <location chapter="3" section="5.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:715</id>
            <description>Generated primary key values are available in the PostPersist method.</description>
            <location chapter="3" section="5.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:716</id>
            <description>The PreUpdate and PostUpdate callbacks occur before and after the database update operations to
                entity data respectively.
            </description>
            <location chapter="3" section="5.2"/>
        </assertion>
        <assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="false">
            <id>PERSISTENCE:SPEC:717</id>
            <description>These database operations may be at the time the entity state is updated or it may be at the
                time state is flushed to the database which may be at the end of a transaction.
            </description>
            <location chapter="3" section="5.2"/>
        </assertion>
        <assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="false">
            <id>PERSISTENCE:SPEC:718</id>
            <description>Note it is implementation-dependent as to whether PreUpdate and PostUpdate callbacks occur when
                an entity is created and subsequently modified in a single transaction or when an entity is modified and
                subsequently removed within a single transaction. Portable applications should not rely on such
                behavior.
            </description>
            <location chapter="3" section="5.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:719</id>
            <description>The PostLoad method is invoked after an entity has been loaded into the current persistence
                context from the database.
            </description>
            <location chapter="3" section="5.2"/>
        </assertion>
        <assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:720</id>
            <description>This PostLoad method is invoked before a query result is returned or accessed or before an
                association is traversed.
            </description>
            <location chapter="3" section="5.2"/>
        </assertion>
        <assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="false">
            <id>PERSISTENCE:SPEC:721</id>
            <description>It is implementation-dependent as to whether callback methods are invoked before or after the
                cascading of the lifecycle events to
                related entities. Applications should not depend on this ordering.
            </description>
            <location chapter="3" section="5.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:722</id>
            <description>Default listeners, if any, are invoked first, in the order specified in the XML descriptor.
                Default listeners
                apply to all entities in the persistence unit, unless explicitly excluded by means of the
                ExcludeDefaultListeners annotation
                or exclude-default-listeners XML element.
            </description>
            <location chapter="3" section="5.4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:723</id>
            <description>The lifecycle callback methods defined on the entity listener classes for an entity class or
                mapped superclass are invoked
                in the same order as the specification of the entity listener classes in the EntityListeners annotation.
            </description>
            <location chapter="3" section="5.4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:724</id>
            <description>If multiple classes in an inheritance hierarchy - entity classes and/or mapped superclasses -
                define entity listeners
                the listeners defined for a superclass are invoked before the listeners and defined for its subclasses
                in this order.
            </description>
            <location chapter="3" section="5.4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:725</id>
            <description>The ExcludeSuperclassListeners annotation or exclude-superclass-listeners XML element may be
                applied to an
                entity class or mapped super class to exclude the invocation of the listeners defined on the entity
                listener classes for the
                superclasses of the entity or maped supeclass. The excluded listeners are excluded from the class to
                which the
                ExcludeSuperclassListeners annotation is specified and its subclasses.
            </description>
            <location chapter="3" section="5.4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:726</id>
            <description>Excluded listeners may reintroduced on an entity class by listing them explicitly in the
                EntityListeners annotation or XML entity-listeners element.
            </description>
            <location chapter="3" section="5.4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:727</id>
            <description>The ExcludeSuperclassListeners or exclude-superclass-listeners XML element does not cause the
                default entity listeners to be excluded from invocation.
            </description>
            <location chapter="3" section="5.4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:728</id>
            <description>The elements of a query result whos SELECT clause consists of more than one value are of type
                Object[].
            </description>
            <location chapter="3" section="6"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:729</id>
            <description>An IllegalArgumentException is thrown if:</description>
            <location chapter="3" section="6"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:730</id>
                    <description>a parameter name is specified that does not correspond to a named parameter in the
                        query string
                    </description>
                    <location chapter="3" section="6"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:731</id>
                    <description>a positional value is specified that does not correspond to a positional parameter in
                        the query string
                    </description>
                    <location chapter="3" section="6"/>
                </assertion>
                <assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:732</id>
                    <description>If the type of the parameter is not valid for the query. This exception may be thrown
                        when the parameter is bound, or the execution of the query may fail.
                    </description>
                    <location chapter="3" section="6"/>
                </assertion>
                <assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:733</id>
                    <description>This exception may be thrown when the parameter is bound, or the execution of the query
                        may fail.
                    </description>
                    <location chapter="3" section="6"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:734</id>
            <description>A named parameter is an identifier that is prefixed by the ":" symbol.</description>
            <location chapter="3" section="6.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:735</id>
            <description>By default, all queries are polymorphic.</description>
            <location chapter="3" section="6.4"/>
        </assertion>
        <assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:736</id>
            <description>The SQL query facility is intended to provide support for those cases where it is necessary to
                use the native SQL of the target database in use (and/or where Java Persistence QL cannot be used).
                Native SQL queries are not expected to be portable across databases.
            </description>
            <keywords>
                <keyword>application-role</keyword>
            </keywords>
            <location chapter="3" section="6.5"/>
        </assertion>
        <assertion required="false" impl-spec="true" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:737</id>
            <description>The use of named parameters is not defined for native queries. Only positional parameter
                binding may be portably used.
            </description>
            <keywords>
                <keyword>application-role</keyword>
            </keywords>
            <location chapter="3" section="6.5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:738</id>
            <description>Summary of Exceptions</description>
            <location chapter="3" section="7"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:739</id>
                    <description>PersistenceException</description>
                    <location chapter="3" section="7"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:740</id>
                    <description>TransactionRequiredException</description>
                    <location chapter="3" section="7"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:741</id>
                    <description>RollbackException</description>
                    <location chapter="3" section="7"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:742</id>
                    <description>EntityExistsException</description>
                    <location chapter="3" section="7"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:743</id>
                    <description>EntityNotFoundException</description>
                    <location chapter="3" section="7"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:744</id>
                    <description>NoResultException</description>
                    <location chapter="3" section="7"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:745</id>
                    <description>NonUniqueResultException</description>
                    <location chapter="3" section="7"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:746</id>
            <description>An query language statement may be either:</description>
            <location chapter="4" section="2"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:746.1</id>
                    <description>a select statement</description>
                    <location chapter="4" section="2"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:746.2</id>
                    <description>an update statement</description>
                    <location chapter="4" section="2"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:746.3</id>
                    <description>a delete statement</description>
                    <location chapter="4" section="2"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:750</id>
            <description>Any query language statement may be constructed dymically or may be statically defined in a
                metadata annotation or XML descriptor element.
            </description>
            <location chapter="4" section="2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:751</id>
            <description>All query language statement types may have parameters.</description>
            <location chapter="4" section="2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:752</id>
            <description>An query language select statement is a string which consists of the following clauses:
            </description>
            <location chapter="4" section="2.1"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:753</id>
                    <description>a SELECT clause, which determines the type of the objects or values to be selected.
                    </description>
                    <location chapter="4" section="2.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:754</id>
                    <description>a FROM clause, which provides declaration that designate the domain to which the
                        expressions specified in the other clauses of the query apply
                    </description>
                    <location chapter="4" section="2.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:755</id>
                    <description>an optional WHERE clause, which may be used to restrict the results that are returned
                        by the query
                    </description>
                    <location chapter="4" section="2.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:756</id>
                    <description>an optional GROUP BY clause, which allows query results to be aggregated in terms of
                        groups
                    </description>
                    <location chapter="4" section="2.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:757</id>
                    <description>an optional HAVING clause, which allows filtering over aggregated groups</description>
                    <location chapter="4" section="2.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:758</id>
                    <description>an optional ORDER BY clause, which may be used to order the results that are returned
                        by the query
                    </description>
                    <location chapter="4" section="2.1"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:312</id>
            <description>A select statement must always have a SELECT and a FROM clause.</description>
            <keywords>
                <keyword>application-role</keyword>
                <keyword>application-server-role</keyword>
            </keywords>
            <location chapter="4" section="2.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:759</id>
            <description>Update and delete statements provide bulk operations over sets of entities. The update and
                delete clauses determine the type
                of the entities to be updated or deleted. The WHERE clause may be used to restrict the scope of the
                update or delete operation.
                Compatibility Note: Update and delete statements are not supported for EJB 2.1 entity beans with
                container-managed persistence.
            </description>
            <location chapter="4" section="2.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:760</id>
            <description>The abstract schema type of an entity is derived from the entity class and the metadata
                information provided by Java Language annotations or in the XML descriptor.
            </description>
            <location chapter="4" section="3"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:761</id>
            <description>The domain of a query consists of the abstract schema types of all entities that are defined in
                the same persistence unit.
            </description>
            <location chapter="4" section="3"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:762</id>
            <description>The abstract schema name is defined by the name element of the Entity annotation (or
                entity-name XML descriptor element), and
                defaults to the unqualified name of the entity class.
            </description>
            <location chapter="4" section="3.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:317</id>
            <description>Identification variables designate instances of a particular entity abstract schema type. The
                FROM clause can contain
                multiple identification variable declarations separated by a comma:
            </description>
            <location chapter="4" section="4"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:317.1</id>
                    <description>range_variable_declaration
                    </description>
                    <location chapter="4" section="4"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:317.2</id>
                    <description>collection_member_declaration
                    </description>
                    <location chapter="4" section="4"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:317.3</id>
                    <description>join_spec</description>
                    <location chapter="4" section="4"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:316</id>
            <description>Reserved identifiers are case insensitive.</description>
            <location chapter="4" section="4.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:763</id>
            <description>Reserved identifiers must not be used as identification variables.</description>
            <location chapter="4" section="4.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:764</id>
            <description>All identification variables must be declared in teh FROM clause. Identification variables
                cannot be declared in other clauses.
            </description>
            <location chapter="4" section="4.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:318</id>
            <description>An identification variable must not be a reserved identifier or have the same name as any of
                the followng in the same persistence unit:
            </description>
            <keywords>
                <keyword>application-role</keyword>
                <keyword>application-server-role</keyword>
            </keywords>
            <location chapter="4" section="4.2"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:318.3</id>
                    <description>entity name (as defined by the Entity annotation or entity-name XML deployment
                        descriptor element
                    </description>
                    <location chapter="4" section="4.2"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:319</id>
            <description>Identification variables are case insensitive.</description>
            <location chapter="4" section="4.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:320</id>
            <description>In order to select values by comparing more than one instance of an entity abstract schema
                type, more than one identification variable ranging over the entity's abstract schema type is needed in
                the FROM clause.
            </description>
            <location chapter="4" section="4.3"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:322</id>
            <description>A single_valued_association_field is designated by the name of an association-field in a
                one-to-one or many-to-one relationship. The type of a single_valued_association_field and thus a
                single_valued_association_path_expression is the abstract schema type of the related entity.
            </description>
            <location chapter="4" section="4.4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:323</id>
            <description>A collection_valued_association_field is designated by the name of an association-field in a
                one-to-many or a many-to-many relationship. The type of a collection_valued_association_field is a
                collection of values of the abstract schema type of the related entity.
            </description>
            <location chapter="4" section="4.4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>PERSISTENCE:SPEC:325</id>
            <description>A path expression that ends in a simple state-field, rather than an embedded class, is terminal
                and cannot be further composed.
            </description>
            <location chapter="4" section="4.4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:326</id>
            <description>A path expression that leads to an association-field may be further composed. Path expressions
                can be composed from other path expression if the original path expression evaluates to a single-valued
                type (not a collection) corresponding to an association-field.
            </description>
            <location chapter="4" section="4.4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:328</id>
            <description>The evaluation of a path expression terminating in a state-field results in the abstract schema
                type corresponding to the Java type designed by the state-field.
            </description>
            <location chapter="4" section="4.4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:329</id>
            <description>Path expression navigability is composed using "inner join" semantics. That is, if the value of
                a non-terminal association-field in the path expression is null, the path is considered to have no
                value, and does not participate in the determination of the result.
            </description>
            <location chapter="4" section="4.4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:765</id>
            <description>The syntax for single-valued path expressions and collection valued path expression is as
                follows:
            </description>
            <location chapter="4" section="4.4"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:766</id>
                    <description>single_valued_path_expression ::= state_field_path_expression |
                        single_valued_association_path_expression
                    </description>
                    <location chapter="4" section="4.4"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:767</id>
                    <description>state_field_path_expression ::= {identification_variable |
                        single_valued_association_path_expression}.state_field
                    </description>
                    <location chapter="4" section="4.4"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:768</id>
                    <description>single_valued_association_path_expression ::=
                        identification_variable.{single_valued_association_field.}*single_valued_association_field
                    </description>
                    <location chapter="4" section="4.4"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:769</id>
                    <description>collection_valued_path_expression ::=
                        identification_variable.{single_valued_association_field.}*collection_valued_association_field
                    </description>
                    <location chapter="4" section="4.4"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:770</id>
                    <description>state_field := simple_state_field | {embedded_class_state_field.}*simple_state_field
                    </description>
                    <location chapter="4" section="4.4"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:771</id>
            <description>Navigation to a related entity results in a value of the related entity's abstract schema type.
            </description>
            <location chapter="4" section="4.4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:772</id>
            <description>The evaluation of a path expression terminating in a state-field results in the abstract schema
                type corresponding to the Java type designated by the state-field.
            </description>
            <location chapter="4" section="4.4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:773</id>
            <description>An inner join may be implicitly specified by the use of a cartesian product in the FROM clause
                and a join condition in the WHERE clause.
            </description>
            <location chapter="4" section="4.5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:774</id>
            <description>The syntax for explicit join operations is as follows:</description>
            <location chapter="4" section="4.5"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:775</id>
                    <description>join ::= join_spec association_path_expression [AS] identification_variable
                    </description>
                    <location chapter="4" section="4.5"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:776</id>
                    <description>fetch_join ::= join_spec FETCH association_path_expression</description>
                    <location chapter="4" section="4.5"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:777</id>
                    <description>association_path_expression ::= collection_valued_path_expression |
                        single_valued_association_path_expression
                    </description>
                    <location chapter="4" section="4.5"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:778</id>
                    <description>join ::= join_spec::=[LEFT [OUTER] | INNER] JOIN</description>
                    <location chapter="4" section="4.5"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:779</id>
            <description>The syntax for the inner join operation is: [INNER] JOIN association_path_expression [AS]
                identification_variable
            </description>
            <location chapter="4" section="4.5.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:780</id>
            <description>LEFT JOIN and LEFT OUTER JOIN are synonymous. They enable retrieval of a set of entities where
                matching values in the join condition
                may be absent. The syntax for a left outer join is: LEFT [OUTER] JOIN association_path_expression [AS]
                identification_variable
            </description>
            <location chapter="4" section="4.5.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:781</id>
            <description>A FETCH JOIN enables the fetching of an association as a side effect of the execution of a
                query. A FETCH JOIN is specified over an entity and its related entities.
                The syntax for a fetch join is: fetch_join ::= [LEFT [OUTER] | INNER ] JOIN FETCH
                association_path_expression
            </description>
            <location chapter="4" section="4.5.3"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:782</id>
            <description>The association referenced by the right side of the FETCH JOIN clause must be an association
                that belongs to an entity that is returned
                as a result of the query. It is not permitted to specify an identification variable for the entities
                referenced by the right side of the FETCH JOIN clause, and hence
                references to the implicitly fetched entities cannot appear elsewhere in the query.
            </description>
            <location chapter="4" section="4.5.3"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:321</id>
            <description>An identification variable of a collection member declaration is declared using a special
                operator, the reserved identifier IN. The argument to the IN operator takes a collection valued path
                expression.
            </description>
            <location chapter="4" section="4.6"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:783</id>
            <description>The path expression evaluates to a collection type specified as a result of navigation to a
                collection-valued association-field of an entity abstract schena type.
            </description>
            <location chapter="4" section="4.6"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:784</id>
            <description>Java Persistence queries are automatically polymorphic. The FROM clause of a query designates
                not only instances of the specific entity class(es) to which explictly refers but of subclasses as well.
                The instances returned by a query include instances of the subclasses that satisfy the query criteria.
            </description>
            <location chapter="4" section="4.8"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:785</id>
            <description>The WHERE clause restricts the result set of a select statement or the scope of an update or
                delete operation.
                A WHERE clause is defined as follows: where_clause ::= WHERE conditional_expression
            </description>
            <location chapter="4" section="5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:330</id>
            <description>A string literal is enclosed in single quotes. A string literal that includes a single quote is
                represented by two single quotes. EJB-QL string literals are like Java String literals in that they use
                unicode character encoding.
            </description>
            <location chapter="4" section="6.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:331</id>
            <description>An exact numeric literal is a numeric value without a decimal point. Exact numeric literals
                support numbers in the range of Java long.
            </description>
            <location chapter="4" section="6.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:332</id>
            <description>Although predefined reserved literals appear in upper case, they are case insensitive.
            </description>
            <location chapter="4" section="6.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:333</id>
            <description>An approximate numeric literal is a value in scientific notation. Approximate numeric literal
                support numbers in the range of Java double.
            </description>
            <location chapter="4" section="6.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:334</id>
            <description>The boolean literals are TRUE and FALSE.</description>
            <location chapter="4" section="6.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:786</id>
            <description>All identification variables used in the WHERE or HAVING clause of a SELECT or DELETE statement
                must be declared
                in the FROM clause.
            </description>
            <location chapter="4" section="6.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:787</id>
            <description>The identification variables used in the WHERE clause of an UPDATE statement must be declared
                in the UPDATE clause.
            </description>
            <location chapter="4" section="6.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:788</id>
            <description>It is illegal to use a collection_valued_path_expression within a WHERE or HAVING clause as
                part of a conditional
                expression except in an empty_collection_comparison_expression or collection_member_expression, or as an
                argument to the SIZE operator.
            </description>
            <location chapter="4" section="6.3"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:336</id>
            <description>If an input parameter is NULL, arithmetic operations involving the input
                parameter will return an UNKNOWN value
            </description>
            <location chapter="4" section="6.4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:337</id>
            <description>If an input parameter is NULL, comparison operations involving the input parameter will return
                an UNKNOWN value. NOTE: Duplicate assertion to: PERSISTENCE:SPEC:342. Recheck tagged test code and
                remedy list accordingly.
            </description>
            <location chapter="4" section="6.4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:338</id>
            <description>Input parameters are numbered starting from 1</description>
            <location chapter="4" section="6.4.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:341</id>
            <description>An input parameter evaluates to the abstract schema type of the corresponding parameter defined
                in the signature of the finder or select method with which the query is associated. It is the
                responsible of the Container to map the input parameter to the appropriate abstract schema type value.
            </description>
            <location chapter="4" section="6.4.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:789</id>
            <description>A named parameter is an identifier that is prefixed by the ":" symbol. It follows the rules for
                identifiers in Section 3.4.1.
            </description>
            <location chapter="4" section="6.4.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:342</id>
            <description>Note that if an input parameter is Null, comparison operations involving the input parameter
                will return an unknown value.
            </description>
            <location chapter="4" section="6.4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:343</id>
            <description>Note that if an input parameter is Null, arithmetic operations involving the input parameter
                will return an unknown value.
            </description>
            <location chapter="4" section="6.4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:344</id>
            <description>Arithmetic operations use numeric promotion.</description>
            <location chapter="4" section="6.5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:345</id>
            <description>Conditional expressions are composed of other conditional expressions, comparison operators,
                logical operations, path expressions that evaluate to boolean values and boolean literals.
            </description>
            <location chapter="4" section="6.5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:346</id>
            <description>Standard bracketing for ordering expression evaluation is supported.</description>
            <location chapter="4" section="6.5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:347</id>
            <description>Arithmetic expressions can be used in comparison expressions.</description>
            <location chapter="4" section="6.5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:348</id>
            <description>Operators and Operator Precedence. The operators listed below in order of descreasing
                precedence.
            </description>
            <location chapter="4" section="6.6"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:348.1</id>
                    <description>Navigation Operator</description>
                    <location chapter="4" section="6.6"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:348.2</id>
                    <description>Arithmetic Operators (+,- unary - *,/ multiplication, division - +.- addition,
                        substraction)
                    </description>
                    <location chapter="4" section="6.6"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:348.3</id>
                    <description>Comparison Operators</description>
                    <location chapter="4" section="6.6"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:348.4</id>
                    <description>Logical Operators: NOT, AND, OR</description>
                    <location chapter="4" section="6.6"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:349</id>
            <description>The syntax for the use of the comparison operator [NOT] BETWEEN in a conditional expression is
                as follows: arithmetic_expression [NOT] BETWEEN arithmetic-expr AND arithmetic-expr
            </description>
            <location chapter="4" section="6.7"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:349.1</id>
                    <description>string_expression [NOT] BETWEEN string-expression AND string-expression</description>
                    <location chapter="4" section="6.7"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:349.2</id>
                    <description>datetime_expression [NOT] BETWEEN datetime-expression AND datetime-expression
                    </description>
                    <location chapter="4" section="6.7"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:350</id>
            <description>The BETWEEN expression x BETWEEN y and z is semantically equivalent to: y less than = x AND x
                less than = z
            </description>
            <location chapter="4" section="6.7"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:351</id>
            <description>If the value of a state_field_path_expression in an IN or NOT IN expression is
                NULL or UNKNOWN, the value of the expression is UNKNOWN.
            </description>
            <location chapter="4" section="6.8"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:352</id>
            <description>The syntax for the use of the comparison operator IN in a conditional expression is as follows:
                state_field_path_expression [NOT] IN({literal | input parameter} [, {literal | input_parameter}]*} |
                subquery). The state_field_path_expression must have a string or numeric value.
            </description>
            <keywords>
                <keyword>application-role</keyword>
                <keyword>application-server-role</keyword>
            </keywords>
            <location chapter="4" section="6.8"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:352.1</id>
            <description>The literal and/or input parameter values must be like the same abstract schema type of the
                state_field_path_expression in type.
            </description>
            <keywords>
                <keyword>application-role</keyword>
                <keyword>application-server-role</keyword>
            </keywords>
            <location chapter="4" section="6.8"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:352.2</id>
            <description>The results of the subquery must be like the same abstract schema type of the
                state_field_path_expression in type.
            </description>
            <keywords>
                <keyword>application-role</keyword>
                <keyword>application-server-role</keyword>
            </keywords>
            <location chapter="4" section="6.8"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:353</id>
            <description>There must be at least one element in the comma separated list that defines the set of values
                for the IN expression.
            </description>
            <keywords>
                <keyword>application-role</keyword>
                <keyword>application-server-role</keyword>
            </keywords>
            <location chapter="4" section="6.8"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:354</id>
            <description>The expression o.country IN ('UK', 'US', 'France') is equivalent to the expression (o.country =
                'UK') OR (o.country = 'US') OR (o.country = 'France')
            </description>
            <location chapter="4" section="6.8"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:355</id>
            <description>The expression o.country NOT IN ('UK', 'US', 'France') is equivalent to the expression NOT
                (o.country = 'UK') OR (o.country = 'US') OR (o.country = 'France')
            </description>
            <location chapter="4" section="6.8"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:356</id>
            <description>If the value of a single-valued path expression or pattern_value is NULL or UNKNOWN, the value
                of the
                LIKE expression is UNKNOWN.
            </description>
            <location chapter="4" section="6.9"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:357</id>
            <description>If the escape_character is specified as a NULL, the value of the LIKE expression is iunknown.
            </description>
            <location chapter="4" section="6.9"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:358</id>
            <description>The syntax for the use of the comparison operator [NOT] LIKE in a conditional expression is as
                follows: state_field_path_expression [NOT] LIKE pattern-value [ESCAPE escape-character]. The
                state_field_path_expression must have a String value. The pattern-value is a string
                literal or a string-valued input parameter in which an underscore stands for any single character, a
                percent character stands for any sequence of characters and all other characters stand for themselves.
                The optional escape-character is a single character string literal or a character-valued input parameter
                (i.e., char or Character) and is used to escape the special meaning of the underscore and percent
                characters in pattern-value.
            </description>
            <location chapter="4" section="6.9"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:359</id>
            <description>The syntax for the use of the comparison operator IS [NOT] NULL in a conditional expression is
                as follows: single_valued_path_expression | input parameter IS [NOT] NULL. A null comparison expression
                tests whether or not the single valued path expression is a NULL value.
            </description>
            <location chapter="4" section="6.10"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>PERSISTENCE:SPEC:360</id>
            <description>The collection designated by the collection-valued path expression used in an empty collection
                comparison expression must not be used in the FROM clause for the declaration of an identification
                variable.
            </description>
            <location chapter="4" section="6.11"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:361</id>
            <description>The syntax for the use of the comparison operator IS [NOT] EMPTY in an
                empty_collection_comparison_expression is as follows: collection_valued_path_expression IS [NOT] EMPTY
                This expression tests whether or not the collection designated by the collection-valued
                path expression is empty (that is, it has no elements).
            </description>
            <location chapter="4" section="6.11"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:362</id>
            <description>If the value of the collection-valued path expression in an empty collection comparison
                expression is unknown, the value of the
                empty comparison expression is unknown.
            </description>
            <location chapter="4" section="6.11"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:363</id>
            <description>The syntax for the use of the comparison operator MEMBER OF in a collection_member_expression
                is as follows: entity_expression [NOT] MEMBER [OF] collection_valued_path_expression.
                entity_expression::=
                This expression tests whether the designated value is a member of the collection designated by the
                collection-valued path expression.
            </description>
            <location chapter="4" section="6.12"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:363.1</id>
                    <description>single_valued_association_path_expression</description>
                    <location chapter="4" section="6.12"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:363.2</id>
                    <description>identification variable</description>
                    <location chapter="4" section="6.12"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:361.1</id>
                    <description>input_parameter</description>
                    <location chapter="4" section="6.12"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:364</id>
            <description>If the value of the collection-valued path expression or single-valued association-field path
                expression in the collection member expression is NULL, the value of the collection member expression is
                unknown.
            </description>
            <location chapter="4" section="6.12"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:365</id>
            <description>If the collection valued path expression designates an empty collection, the value of the the
                MEMBER OF expression is FALSE and the value of the NOT MEMBER OF expression is TRUE.
            </description>
            <location chapter="4" section="6.12"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:366</id>
            <description>If the value of the single-valued association-field path expression in the collection member
                expression is unknown, the value of the empty comparison expression is unknown. If the collection valued
                path expressiuon designates an empty collection, the value of the expression is FALSE.
            </description>
            <location chapter="4" section="6.12"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:791</id>
            <description>An EXISTS expression is a predicate that is true only if the result of the subquery consists of
                one or more values and that is false otherwise.
            </description>
            <location chapter="4" section="6.13"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:792</id>
            <description>The syntax of an exists expression is: exists_expression::= [NOT] EXISTS (subquery)
            </description>
            <location chapter="4" section="6.13"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:793</id>
            <description>An ALL conditional expression is a predicate that is true if the comparison operation is true
                for all values in the result of the subquery, and that is otherwise false. If the result of the subquery
                is empty, the ALL condition is true.
            </description>
            <location chapter="4" section="6.14"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:794</id>
            <description>An ANY conditional expression is a predicate that is true if the comparison operation is true
                for all values in the result of the subquery, and that is otherwise false.
            </description>
            <location chapter="4" section="6.14"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:795</id>
            <description>The keyword SOME is synonymous with ANY.</description>
            <location chapter="4" section="6.14"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:796</id>
            <description>If the result of the subquery is empty, the ANY or SOME condition is false.</description>
            <location chapter="4" section="6.14"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:797</id>
            <description>The comparison operators used with ALL or ANY conditional expressions are =, &lt;, &lt;=, &gt;,
                &gt;=, &lt;&gt;. The result of the subquery must be like that of the other argument to the comparison
                operator in type.
            </description>
            <location chapter="4" section="6.14"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:798</id>
            <description>The syntax of an ALL or ANY expression is specified as follows: all_or_any_expression ::= {ALL
                | ANY | SOME} (subquery)
            </description>
            <location chapter="4" section="6.14"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:799</id>
            <description>Subqueries may be used in the WHERE or HAVING clause.</description>
            <location chapter="4" section="6.15"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:800</id>
            <description>The syntax for subqueries is as follows.</description>
            <location chapter="4" section="6.15"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:801</id>
                    <description>subquery ::= simple_select_clause from_clause [where_clause] [groupby_clause]
                        [having_clause]
                    </description>
                    <location chapter="4" section="6.15"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:802</id>
                    <description>simple_select_clause ::= SELECT [DISTINCT] select_expression</description>
                    <location chapter="4" section="6.15"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:367</id>
            <description>If the value of any argument to a functional expression is NULL or UNKNOWN, the value of the
                functional expression is UNKNOWN.
            </description>
            <location chapter="4" section="6.16"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:369</id>
            <description>Java Persistence QL includes the following built-in String functions which may be used in the
                WHERE clause of a query.
            </description>
            <location chapter="4" section="6.16.1"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:369.1</id>
                    <description>CONCAT(string_expression, string_expression). The CONCAT function returns a string that
                        is a concatenation of its arguments.
                    </description>
                    <location chapter="4" section="6.16.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:369.2</id>
                    <description>SUBSTRING(string_expression, arithmetic expression, arithmetic-expression). The second
                        and third argument of the SUBSTRING denote the starting
                        position and length of the substring to be returned. These arguments are integers. The firstd
                        position of a string is denoted by 1. The SUBSTRING function
                        returns a string.
                    </description>
                    <location chapter="4" section="6.16.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:369.3</id>
                    <description>LOCATE(string_expression, string_expression[,arithmetic_expression]). The LOCATE
                        function returns the position of a given string within a string
                        starting the search at a specified position. (NOTE: Not all databases support the use of the
                        third argument to LOCATE; use of this argument may result in queries that
                        are not portable.)
                    </description>
                    <location chapter="4" section="6.16"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:369.4</id>
                    <description>LENGTH(string_expression). The LENGTH function returns the length of the string in
                        characters as an integer.
                    </description>
                    <location chapter="4" section="6.16.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:369.9</id>
                    <description>TRIM([[trim_sepcification] [trim_character] FROM] string_expression).
                        trim_specification ::=[LEADING | TRAILING | BOTH]
                        The TRIM function trims the specified character from a string.If the character to be trimmed is
                        note specified, it is assumed to be space (or blank).
                        The optional trim_character is a single-character string liuteral or character-valued input
                        parameter (i.e. char or Character). The TRIM function
                        returns the trimmed string.(NOTE: Not all databases support the use of the trim_character other
                        than a space character; use of this argument may result in queries
                        that are not portable.)
                    </description>
                    <location chapter="4" section="6.16.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:369.10</id>
                    <description>LOWER(string_expression). The LOWER function converts a string to upper case. LOWER
                        returns a string.
                    </description>
                    <location chapter="4" section="6.16.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:369.11</id>
                    <description>UPPER (string_expression). The UPPER function converts a string to upper case. UPPER
                        returns a string.
                    </description>
                    <location chapter="4" section="6.16.1"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:369</id>
            <description>Java Persistence QL includes the following built-in Arithmetic functions which may be used in
                the WHERE clause of a query:
            </description>
            <location chapter="4" section="6.16.2"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:369.5</id>
                    <description>ABS(arithmetic_expression). The ABS function takes a nueric argument and returns a
                        number (integer, float, double) of the same type as the argument to the function.
                    </description>
                    <location chapter="4" section="6.16.2"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:369.6</id>
                    <description>SQRT(arithmetic_expression). The SQRT function takes a nuneric argument and returns a
                        double.
                    </description>
                    <location chapter="4" section="6.16.2"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:369.7</id>
                    <description>MOD(arithmetic_expression, arithmetic_expression). The MOD function takes two integer
                        argumetns and returns an integer.
                    </description>
                    <location chapter="4" section="6.16.2"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:369.8</id>
                    <description>SIZE(collection_valued_path_expression). The SIZE function returns an integer value,
                        the number of elements of the collection. If the collection is empty, the
                        SIZE function evaluates to zero.
                    </description>
                    <location chapter="4" section="6.16.2"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:368</id>
            <description>Numeric arguments to these functions may correspond to the numeric Java object types as well as
                the primitive numeric types.
            </description>
            <location chapter="4" section="6.16.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:803</id>
            <description>The GROUP BY construct enables the aggregation of values according to a set of properties. The
                HAVING construct enables conditions to be specified that further restrict the query result. Such
                conditions are restrictions upon the groups.
            </description>
            <location chapter="4" section="7"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:804</id>
            <description>The syntax of the GROUP BY and HAVING clauses is as follows:</description>
            <location chapter="4" section="7"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:805</id>
                    <description>groupby_clause ::= GROUP BY groupby_item[,groupby_item]*</description>
                    <location chapter="4" section="7"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:806</id>
                    <description>groupby_item ::= state_field_path_expression</description>
                    <location chapter="4" section="7"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:807</id>
                    <description>having_clause ::= HAVING conditional_expression</description>
                    <location chapter="4" section="7"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:808</id>
            <description>If the query contains both a WHERE clause and a GROUP BY clause, the effect is that of first
                applying the where clause, and then forming the groups and filtering them to the HAVING clause. The
                HAVING cluase causes those groups to be retained that satisfy the conditiona of the HAVING clause.
            </description>
            <location chapter="4" section="7"/>
        </assertion>
        <assertion required="false" impl-spec="true" defined-by="technology" status="active" testable="false">
            <id>PERSISTENCE:SPEC:809</id>
            <description>If there is no GROUP BY clause and the HAVING clause is used, the effect is that of treating
                the result fo the query as a single group. The use of HAVING in the absence of GROUP BY is not required
                to be supported by an implementataion of this specification. Portable applications should not rely on
                HAVING without the use of GROUP BY.
            </description>
            <location chapter="4" section="7"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:810</id>
            <description>The requirements for the SELECT clause when GROUP BY is used follow those of SQL; namely, any
                property that appears in the SELECT clause (other than as an argument to an aggregate function) must
                also appear in the GROUP BY clause. In forming groups. null values are treated as the same for grouping
                purposes.
            </description>
            <location chapter="4" section="7"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:811</id>
            <description>The SELECT clause denotes the query result. More than one value may be returned from the SELECT
                clause of a query.
            </description>
            <location chapter="4" section="8"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:372</id>
            <description>The SELECT clause may contain one or more of the following elements:</description>
            <location chapter="4" section="8"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:372.1</id>
                    <description>a single range variable</description>
                    <location chapter="4" section="8"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:372.2</id>
                    <description>identification variable that ranges over an entity abstract schema type</description>
                    <location chapter="4" section="8"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:372.3</id>
                    <description>a single-valued path expression</description>
                    <location chapter="4" section="8"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:372.4</id>
                    <description>an aggregate select expression</description>
                    <location chapter="4" section="8"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:372.5</id>
                    <description>a constructor expression</description>
                    <location chapter="4" section="8"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:814</id>
            <description>The SELECT clause has the following syntax:</description>
            <location chapter="4" section="8"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:815</id>
                    <description>select_clause ::= SELECT [DISTINCT] select_expression[,select_expression]*
                    </description>
                    <location chapter="4" section="8"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:816</id>
                    <description>select_expression ::= {single_valued_path_expression | aggregate_select_expression |
                        identification_variable | OBJECT(identification variable) | constructor_expression
                    </description>
                    <location chapter="4" section="8"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:817</id>
                    <description>constructor_expression ::= NEW constructor_name([single_valued_path_expression |
                        aggregate_select_expression} [,{single_valued_patch_expression | aggregate_select_expression}]*)
                    </description>
                    <location chapter="4" section="8"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:818</id>
                    <description>aggregate_select_expression ::= {AVG | MAX | MIN | SUM | COUNT}([DISTINCT]
                        state_field_path_expression) | COUNT ([DISTINCT] identification_variable |
                        single_valued_association_path_expression)
                    </description>
                    <location chapter="4" section="8"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:373</id>
            <description>All standalone identification variables in the SELECT clause may optionally be qualified by the
                OBJECT operator.
            </description>
            <location chapter="4" section="8"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:374</id>
            <description>The DISTINCT keyword is used to specify that duplicate values must be eliminated from the query
                result.
            </description>
            <location chapter="4" section="8"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:371</id>
            <description>If the query is specified for a method whose result type is java.util.Set, but does not specify
                DISTINCT, the container must interpret the query as if SELECT DISTINCT had been specified.
            </description>
            <location chapter="4" section="8"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>PERSISTENCE:SPEC:413</id>
            <description>If the query is specified for a method whose return type is java.util.Collection, the
                collection of values returned by the Container may contain duplicates if DISTINCT is not specified in
                the SELECT clause.
            </description>
            <location chapter="4" section="8"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:406</id>
            <description>The type of the query result specified by the SELECT clause of a query is an entity abstract
                schema type, a state-field type, the result of an aggregate function, the result of a construction
                operation, or some sequence of these.
            </description>
            <location chapter="4" section="8.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:408</id>
            <description>The result of the SELECT clause is defined by the result types of the select_expressions
                contained in it. When multiple select_expressions are used in the SELECT clause, the result of the query
                is of type Object[] and the elements in this result correspond in order to the order of their
                specification in the SELECT caluse and in type to the result types of each select_expressions.
            </description>
            <location chapter="4" section="8.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:409</id>
            <description>The result type of the select_expression is a single_valued_path_expression that is a
                state_field_path_expression results in an object of the same type as the corresponding state field of
                the entity. If the state field of the entity is a primitive type, the corresponding object type is
                returned.
            </description>
            <location chapter="4" section="8.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:410</id>
            <description>The result type of the select_expression is a single_valued_path_expression that is a
                single_valued_association_path_expression results in an entity object of the type as the relationship
                field or the subtype of the relationship field of the entity as determined by the o/r mapping.
            </description>
            <location chapter="4" section="8.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:394</id>
            <description>The result type of an identification_variable is type of the entity to which that
                identification variable corresponds or a subtype as determined by the o/r mapping.
            </description>
            <location chapter="4" section="8.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:395</id>
            <description>The result type of a constructor_expression is the type of the class for which the constructor
                is defined.
            </description>
            <location chapter="4" section="8.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:819</id>
            <description>A constructor expression may be used in the SELECT list to return a collection of Java
                instances. The specified class is not required to be an entity or to be mapped to the database.
            </description>
            <location chapter="4" section="8.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:820</id>
            <description>If an entity name is specified in the SELECT NEW clause, the resulting entity instances are in
                the new state.
            </description>
            <location chapter="4" section="8.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:375</id>
            <description>If the result of an query corresponds to an association-field or state-field whose value is
                null, that null value is returned in the result of the query method.
            </description>
            <location chapter="4" section="8.3"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:376</id>
            <description>The IS NOT NULL construct can be used to eliminate the null from the result set of the query.
            </description>
            <location chapter="4" section="8.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:379</id>
            <description>Note, however, that state-field types in terms of Java numeric primitive types cannot produce
                NULL values in the query results. An query that returns such a state-field type as a result type MUST
                NOT return a null value.
            </description>
            <location chapter="4" section="8.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:380</id>
            <description>The aggregate function AVG can be used in the SELECT clause of an query.</description>
            <location chapter="4" section="8.4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:381</id>
            <description>The aggregate function MIN can be used in the SELECT clause of an query.</description>
            <location chapter="4" section="8.4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:382</id>
            <description>The aggregate function MAX can be used in the SELECT clause of an query.</description>
            <location chapter="4" section="8.4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:383</id>
            <description>The aggregate function SUM can be used in the SELECT clause of an query.</description>
            <location chapter="4" section="8.4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:384</id>
            <description>The aggregate COUNT function can be used in the SELECT clause of an query.</description>
            <location chapter="4" section="8.4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:389</id>
            <description>The path expression argument to COUNT may terminate in a state-field.</description>
            <location chapter="4" section="8.4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:390</id>
            <description>The path expression argument to COUNT may terminate in a association-field.</description>
            <location chapter="4" section="8.4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:391</id>
            <description>The argument to COUNT may be an identification variable.</description>
            <location chapter="4" section="8.4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:821</id>
            <description>Arguments to the functions SUM and AVG must be numeric.</description>
            <location chapter="4" section="8.4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:822</id>
            <description>Arguments to the functions MAX and MIN must correspond to orderable state-field types (i.e.,
                numeric types,
                string types, character types, or date type).
            </description>
            <location chapter="4" section="8.4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:823</id>
            <description>The Java type that is contained in the result of a query using an aggregate function is as
                follows [with 3.0 entities]:
            </description>
            <location chapter="4" section="8.4"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:824</id>
                    <description>COUNT returns long</description>
                    <location chapter="4" section="8.4"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:825</id>
                    <description>MAX, MIN return the type of the state-field to which they are applied</description>
                    <location chapter="4" section="8.4"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:826</id>
                    <description>AVG returns Double</description>
                    <location chapter="4" section="8.4"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:827</id>
                    <description>SUM returns Long when applied to state-fields of integral types (other than
                        BigInteger); Double when applied to state-fields of
                        floating-point types; BigInteger when applied to state-fields of type BigInteger, and BigDecimal
                        when applied to state-fields of type BigDecimal.
                    </description>
                    <location chapter="4" section="8.4"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:828</id>
            <description>If SUM, AVG, MAX, or MIN is used, and there are no values to which the aggreate function can be
                applied, the
                result of the aggregate function is NULL.
            </description>
            <location chapter="4" section="8.4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:829</id>
            <description>If COUNT is used, and there are no values to which COUNT can be applied, the result of the
                aggregate function is 0.
            </description>
            <location chapter="4" section="8.4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:392</id>
            <description>The argument to an aggregate function may be preceded by the keyword DISTINCT to specify that
                duplicate values are to be eliminated before
                the aggregate function is applied. (NOTE: It is legal to specify DISTINCT with MAX or MIN but it does
                not affect the result.)
            </description>
            <location chapter="4" section="8.4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:393</id>
            <description>Null values are eliminated before the aggregate function is applied regardless whether the
                keyword DISTINCT is specified.
            </description>
            <location chapter="4" section="8.4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:399</id>
            <description>When Order By clause is used, the SELECT clause of the query MUST be one of the following
            </description>
            <location chapter="4" section="9"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:399.1</id>
                    <description>a single_valued_association_path_expression.
                        For a single_valued_association_path_expression, each orderby_item MUST be an orderable
                        state-field of the entity
                        bean abstract schema type value returned by the SELECT clause
                    </description>
                    <location chapter="4" section="9"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:399.2</id>
                    <description>an Identification Variable.
                        For an identification variable, each orderby_item MUST be an orderable state-field of the entity
                        bean abstract schema type value returned by the SELECT clause
                    </description>
                    <location chapter="4" section="9"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:399.3</id>
                    <description>a state_field_path_expression.
                        For state_field_path_expression, the orderby_item MUST evaluate to the same state-field of the
                        same entity bean abstract schema type as the state_field_path_expression in the SELECT clause.
                    </description>
                    <location chapter="4" section="9"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:400</id>
            <description>If more than one orderby_item is specified, the left-to-right sequence of the
                orderby_item elements determines the precedence, whereby the leftmost orderby_item has the highest
                precedence.
            </description>
            <location chapter="4" section="9"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:401</id>
            <description>The keyword ASC specifies that ascending order is used. DEFAULT.</description>
            <location chapter="4" section="9"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:402</id>
            <description>The keyword DESC specified that descending order is used.</description>
            <location chapter="4" section="9"/>
        </assertion>
        <assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:403</id>
            <description>SQL rules for ordering of NULLS apply: that is, all null values MUST appear before all non-null
                values in the ordering or all null values MUST appear before all non-null values in the ordering, but it
                is not specified which.
            </description>
            <location chapter="4" section="9"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:404</id>
            <description>The ordering of the query result is preserved in the result of the query method if the ORDER BY
                clause is used.
            </description>
            <location chapter="4" section="9"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:834</id>
            <description>Bulk update and delete operations apply to entities of a single entity class (together with its
                subclasses, if any).
                Only one entity abstract schema type may be specified in the FROM or UPDATE clause.
            </description>
            <location chapter="4" section="10"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:835</id>
            <description>A delete operation only applies to entities of the specified class and its subclasses. It does
                not cascade to
                related entities.
            </description>
            <location chapter="4" section="10"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:836</id>
            <description>The syntax of these operations are as follows:</description>
            <location chapter="4" section="10"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:837</id>
                    <description>update_statement ::=update_clause[where_clause]</description>
                    <location chapter="4" section="10"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:838</id>
                    <description>update_clause ::=UPDATE abstract_schema_name[[AS] identification_variable] SET
                        update_item {,update_item}*
                    </description>
                    <location chapter="4" section="10"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:839</id>
                    <description>update_item ::=[identification_variable].state_field=new_value</description>
                    <location chapter="4" section="10"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:840</id>
                    <description>delete_statement ::=delete_clause [where_clause]</description>
                    <location chapter="4" section="10"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:841</id>
                    <description>delete_clause ::= DELETE FROM abstract_schema_name [[AS] identificationo_variable]
                    </description>
                    <location chapter="4" section="10"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:415</id>
            <description>Two NULL values are not considered to be equal, the comparison yield an UNKNOWN value.
            </description>
            <location chapter="4" section="11"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:416</id>
            <description>Comparison operations with a NULL value always yield an UNKNOWN value.</description>
            <location chapter="4" section="11"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:417</id>
            <description>Comparison operations with an UNKNOWN value always yield an UNKNOWN value.</description>
            <location chapter="4" section="11"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:418</id>
            <description>Arithmetic operators with a NULL value always yield an UNKNOWN value.</description>
            <location chapter="4" section="11"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:419</id>
            <description>Arithmetic operators with an UNKNOWN value always yield an UNKNOWN value.</description>
            <location chapter="4" section="11"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:422</id>
            <description>The IS NOT NULL operators convert a NULL state-field into the respective TRUE or FALSE value.
            </description>
            <location chapter="4" section="11"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:423</id>
            <description>The IS NOT NULL operators convert a NULL single-valued-association-field into the respective
                TRUE or FALSE value.
            </description>
            <location chapter="4" section="11"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:424</id>
            <description>Boolean operators use three valued logic: Table 7: Definition of the AND Operator</description>
            <location chapter="4" section="11"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:425</id>
            <description>Boolean operators use three valued logic: Table 8: Definition of the OR Operator</description>
            <location chapter="4" section="11"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:426</id>
            <description>Boolean operators use three valued logic: Table 9: Definition of the NOT Operator</description>
            <location chapter="4" section="11"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:427</id>
            <description>Two entities of the same abstract schema type are equal if and only if they have the same
                primary key value.
            </description>
            <location chapter="4" section="12"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:428</id>
            <description>Only equality/inequality comparisons over enums are required to be supported.</description>
            <location chapter="4" section="12"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:430</id>
            <description>Only the values of like types can be compared. There is one exception to this rule: it is valid
                to compare numeric values for which the rule of numeric promotion apply. Conditional expression
                attempting to compare non-like type values are disallowed except for this numeric case.
            </description>
            <location chapter="4" section="12"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:842</id>
            <description>Both container-managed and application-managed entity managers and their persistence contexts
                are required to be supported in JavaEE web containers and EJB containers.
            </description>
            <location chapter="5" section="1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:843</id>
            <description>In Java SE and in Java EE application client containers, only application-managed entity
                managers are required to be supported.
                [NOTE the use of JTA is not required to be supported in application client containers.]
            </description>
            <location chapter="5" section="1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:844</id>
            <description>A container-managed entity manager is obtained by the application through dependency injection
                or through JNDI lookup.
            </description>
            <location chapter="5" section="2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:845</id>
            <description>The PersistenceContext annotation is used for entity manager injection.</description>
            <location chapter="5" section="2.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:846</id>
            <description>The unitName element may optionally be specified to designate the persistence unit whose
                factory is used by the container.
            </description>
            <location chapter="5" section="2.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:847</id>
            <description>The type element specifies whether a transaction-scoped or extended persistence context is to
                be used.
            </description>
            <location chapter="5" section="2.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:848</id>
            <description>The EntityManagerFactory interface is used to create an application-managed entity manager and
                manage its lifecycle.
            </description>
            <location chapter="5" section="3"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:849</id>
            <description>More than one entity manager factory instance may be available simultaneously in the JVM.
            </description>
            <location chapter="5" section="3"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:850</id>
            <description>Within a JavaEE environment, an entity manager factory may be injected using the
                PersistenceUnit annotation or obtained through JNDI lookup.
            </description>
            <location chapter="5" section="3.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:851</id>
            <description>Outside the JavaEE container environment, the jakarta.persistence.Persistence class is the
                bootstrap class that provides access to an entity
                manager factory. The application creates an entity manager factory by called the
                createEntityManagerFactory method of the jakarta.persistence.Persistence class.
            </description>
            <location chapter="5" section="3.2"/>
            <comment>STANDALONE</comment>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:852</id>
            <description>The EntityManagerFactoryInterface is the interface used by the application to create a new
                application-managed entity
                manager or to get a provider-managed entity manager that is bound to the current JTA transaction
                context.
            </description>
            <location chapter="5" section="4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>PERSISTENCE:SPEC:853</id>
            <description>When the application has finished using the entity manager factory, and/or at application
                shutdown, the application should close the entity manager factory.
            </description>
            <location chapter="5" section="4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:854</id>
            <description>Any number of vendor-specific properties may be included in the map passed to
                createEntityManager. Properties not recognized by a vendor must be ignored.
            </description>
            <location chapter="5" section="4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:855</id>
            <description>An entity manager is defined to be of a given transaction type - JTA or resource-local - at the
                time its underlying entity manager factory is configured and created.
            </description>
            <location chapter="5" section="5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:856</id>
            <description>Both JTA entity managers and resource-local entity managers are required to be supported in
                JavaEE web and EJB containers.
            </description>
            <location chapter="5" section="5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>PERSISTENCE:SPEC:857</id>
            <description>In general, in JavaSE environments, only resource-local entity managers are supported.
            </description>
            <location chapter="5" section="5"/>
            <comment>STANDALONE</comment>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:858</id>
            <description>Container-managed entity managers must be a JTA entity manager. JTA entity managers are only
                specified for use in JavaEE containers.
            </description>
            <location chapter="5" section="5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:859</id>
            <description>Application-managed entity managers may either be JTA or resource-local entity managers.
            </description>
            <location chapter="5" section="5.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:860</id>
            <description>An entity manager whose transactions are controlled by the application through the
                EntityTransaction API is a resource-local entity manager.
                The EntityManager.getTransaction() method returns the EntityTransaction Interface.
            </description>
            <location chapter="5" section="5.2.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:861</id>
            <description>When a container-managed entity manager is used, the lifecycle of the persistence context is
                always managed automatically, transparently to the application,
                and the persistence context is propagated with the JTA transaction.
            </description>
            <location chapter="5" section="6"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:862</id>
            <description>Container-managed Transaction-scoped Persistence Context: A new persistence context begins when
                a container-managed entity manager is invoked in the scope
                of an active JTA transaction and there is no current persistence context already associated with the JTA
                transaction. The persistence context is then associated with the
                current JTA transaction.
            </description>
            <location chapter="5" section="6.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:863</id>
            <description>Container-managed Transaction-scoped Persistence Context: The persistent context ends when the
                associated JTA transaction completes and al entites that were
                managed by the EntityManager become detached.
            </description>
            <location chapter="5" section="6.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:864</id>
            <description>Container-managed Transaction-scoped Persistence Context: If the entity manager is invoked
                outside the scope of a transaction, a persistence context is
                created and destroyed to service the method call only and any entities loaded from the database will
                immediately become detached at the end of the method call.
            </description>
            <location chapter="5" section="6.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:865</id>
            <description>Container-managed Extended Persistence Context: An extended persistence context exists from the
                point at which the stateful session bean declares a dependency on an entity manager of type
                PersistenceContextType.EXTENDED is created and bound to the stateful session bean.
            </description>
            <location chapter="5" section="6.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:866</id>
            <description>Container-managed Extended Persistence Context: The dependency on the extended persistence
                context is declared by means of the PersistenceContext annoation or the persistence-context-ref
                deployment descriptor element.
            </description>
            <location chapter="5" section="6.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:867</id>
            <description>Container-managed Extended Persistence Context can only be initiated within the scope of a
                stateful
                session bean.
            </description>
            <location chapter="5" section="6.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:868</id>
            <description>If a stateful session bean with an extended persistence context instantiates another stateful
                session bean with an
                extended persistence context, the extended persistence context is inherited by the second stateful
                session bean and bound to it, and this rule
                recursively applies - independently of whether transactions are active or not at the point of the
                creation of the stateful session beans.
            </description>
            <location chapter="5" section="6.2.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:869</id>
            <description>IIf the persistence context has been inherited by any stateful session beans, the container
                does not close the
                persistence context until all such stateful session beans have been removed or otherwise destroyed.
            </description>
            <location chapter="5" section="6.2.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:870</id>
            <description>The persistence context is propagated across the entity manager instances as the JTA
                transaction is propagated. Propagation of
                persistence contexts only applies within a local environment. Persistence contexts are not propagated to
                remote tiers.
            </description>
            <location chapter="5" section="6.3"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:871</id>
            <description>If a component is called and there is no JTA transaction or the JTA transaction is not
                propagated, the
                persistence context is not propagated.
            </description>
            <location chapter="5" section="6.3.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:872</id>
            <description>If an entity manager is invoked from within the component:</description>
            <location chapter="5" section="6.3.1"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:873</id>
                    <description>Invocation of an entity manager defined with PersistsenceContextType.TRANSACTION will
                        result in use of a new
                        persistence context.
                    </description>
                    <location chapter="5" section="6.3.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:874</id>
                    <description>Invocation of an entity manager defined with the PersistenceContextType.EXTENDED will
                        result in the use of the
                        existing extended persistence context bound to that component.
                    </description>
                    <location chapter="5" section="6.3.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:875</id>
                    <description>If the entity manager is invoked within a JTA transaction the persistence context will
                        be boud to the JTA transaction.
                    </description>
                    <location chapter="5" section="6.3.1"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:876</id>
            <description>If a component is called and the JTA transaction is propagated into that component:
            </description>
            <location chapter="5" section="6.3.1"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:877</id>
                    <description>If the component is a stateful session bean to which an extended persistence context
                        has been bound
                        and there is a different persistence context bound to the JTA transaction, an EJBException is
                        thrown by the container.
                    </description>
                    <location chapter="5" section="6.3.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:878</id>
                    <description>Otherwise, if there is a persistence context bound to the JTA transaction, that
                        persistence context is propagated and used.
                    </description>
                    <location chapter="5" section="6.3.1"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:879</id>
            <description>Application-managedPersistence Context: When an applicatio-managed entity manager is used, the
                application interacts directly with the persistence provider's entity manager factory to
                manage the entity manager lifecycle and to obtain and destroy persistence contexts All such
                application-managed persistence contexts are extended in scope and may span multiple transactions.
            </description>
            <location chapter="5" section="7"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:880</id>
            <description>The EntityManager close and isOpen methods are used to manage the lifecycle of an
                application-managed entity manager and its associated persistence context.
            </description>
            <location chapter="5" section="7"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:881</id>
            <description>The EntityManager.close() closes the entity manager to release its persistence context and any
                other resources.
            </description>
            <location chapter="5" section="7"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:882</id>
            <description>After calling close, the application must not invoke
                any further methods on the EntityManager instance except for getTransaction or IsOpen or the
                IllegalStateException will be thrown.
            </description>
            <location chapter="5" section="7"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:883</id>
            <description>If the close method is invoked when a transaction is active, the persistence context remains
                managed until the transaction completes.
            </description>
            <location chapter="5" section="7"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:884</id>
            <description>The EntityManager.isOpen() method will return true unless the entity manager has been closed.
            </description>
            <location chapter="5" section="4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:885</id>
            <description>Application-managed Extended Persistence Context: The extended persistence context exists from
                the point at which the entity manager hs been created
                using EntityManagerFactory.createEntityManager until the entity manager is closed by the means of
                EntityManager.close. The extended persistence context obtained from the application-managed entity
                manager is a stand-alone persistence context - it is not propagated with the transaction.
            </description>
            <location chapter="5" section="7"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:886</id>
            <description>When a JTA application-managed entity manager is used, if the entity manager is created outside
                the scope of the current JTA transaction, it is the responsibility of the application to associate
                the entity manager with the transaction, if desired, by calling EntityManager.joinTransaction.
            </description>
            <location chapter="5" section="7"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:887</id>
            <description>Requirements on the Container</description>
            <location chapter="5" section="8"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:888</id>
                    <description>Application Managed Persistence Contexts</description>
                    <location chapter="5" section="8.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:889</id>
                    <description>Container Managed Persistence Contexts</description>
                    <location chapter="5" section="8.2"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:890</id>
            <description>
                Runtime Contracts between the Container and Persistence Provider
            </description>
            <location chapter="5" section="9"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:891</id>
            <description>Container Responsibilities</description>
            <location chapter="5" section="9.1"/>
        </assertion>
        <assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:892</id>
            <description>Provider Responsibilities</description>
            <location chapter="5" section="9.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:893</id>
            <description>Within JavaEE environments, an EJB-JAR, WAR, or EAR can define a persistence unit. Any number
                of persistence archives may be deployed within an EJB-JAR, WAR, or EAR.
            </description>
            <location chapter="6" section="2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:894</id>
            <description>A persistence unit may be packaged:</description>
            <location chapter="6" section="2"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:895</id>
                    <description>within one or more jar files contained within a WAR</description>
                    <location chapter="6" section="2"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:896</id>
                    <description>one or more jar files contained within an EAR</description>
                    <location chapter="6" section="2"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:897</id>
                    <description>as a set of classes within an EJB-JAR file</description>
                    <location chapter="6" section="2"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:898</id>
                    <description>a set of classes in the WAR classes directory</description>
                    <location chapter="6" section="2"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:899</id>
                    <description>as a combination of these</description>
                    <location chapter="6" section="2"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:900</id>
            <description>A persistence unit is defined by a persistence.xml file. The jar file or directory whose
                META-INF directory contains the persistence.xml is termed the root of the persistence unit.
                In Java EE, the root of a persistence unit may be one of the following:
            </description>
            <location chapter="6" section="2"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:901</id>
                    <description>an EJB-JAR file</description>
                    <location chapter="6" section="2"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:902</id>
                    <description>the WEB-INF classes directory of a WAR file [the root of the persistence unit - in this
                        case - is the WEB-INF/classes directory; the
                        persistence.xml file is therefore contained in the WEB-INF/classes/META-INF directory.
                    </description>
                    <location chapter="6" section="2"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:903</id>
                    <description>a jar file in the WEB-INF/lib directory of a WAR file</description>
                    <location chapter="6" section="2"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:904</id>
                    <description>a jar file in the root of the EAR</description>
                    <location chapter="6" section="2"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:905</id>
                    <description>a jar file in the EAR lib directory</description>
                    <location chapter="6" section="2"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:906</id>
                    <description>an application client jar file</description>
                    <location chapter="6" section="2"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:907</id>
            <description>It is not required that na EJB-JAR or WAR containing a persistence unit be packaged in an EAR
                unless
                the persistence unit contains persistence classes in addition to those contained in the EJB-JAR or WAR.
            </description>
            <location chapter="6" section="2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:908</id>
            <description>A persistence unit must have a name.</description>
            <location chapter="6" section="2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:909</id>
            <description>Only one persistence unit of any given name may be defined:</description>
            <location chapter="6" section="2"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:910</id>
                    <description>within a single EJB-JAR file</description>
                    <location chapter="6" section="2"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:911</id>
                    <description>within a single WAR file</description>
                    <location chapter="6" section="2"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:912</id>
                    <description>within a single application client jar</description>
                    <location chapter="6" section="2"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:913</id>
                    <description>within an EAR in the EAR root</description>
                    <location chapter="6" section="2"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:914</id>
                    <description>within an EAR in the lib directory</description>
                    <location chapter="6" section="2"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:915</id>
            <description>The persistence.xml file may be used to designate more thanone persistnece unit within the same
                scope.
            </description>
            <location chapter="6" section="2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:916</id>
            <description>All persistence classes defined at the level of the Java EE EAR must be accessible to all other
                J2EE components in the application such
                that if the same entity class is referenced by two different Java EE components (which may be using
                different persistence units),
                the referenced class is the same identifical class.
            </description>
            <location chapter="6" section="2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>PERSISTENCE:SPEC:917</id>
            <description>In Java SE environments, the metadata mapping files, jar files, and classes described in the
                following sections can be used.
                To insure portability of a Java SE application, it is necessary to explicitly list the managed
                persistence classes that are inclulded in the persistence unit.
            </description>
            <location chapter="6" section="2"/>
            <comment>STANDALONE</comment>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:918</id>
            <description>The persistence.xml file defines a persistence unit. It may be used to specify managed
                persistence classes included in the
                persistence unit, and the o/r mapping information for those classes, and other configuration information
                for the persistence unit
                and entity manager(s) and the entity manager factory for the persistence unit. The persistence.xml file
                is located in the META-INF
                directory of the root of the persistence unit. This information may be defined by containment or by
                reference.
            </description>
            <location chapter="6" section="2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:919</id>
            <description>The o/r mapping information may take the form of:</description>
            <location chapter="6" section="2.1"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:920</id>
                    <description>annotations on the managed persistence classes included in the persistence unit
                    </description>
                    <location chapter="6" section="2.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:921</id>
                    <description>one or more XML files contained in the root of the persistence unit</description>
                    <location chapter="6" section="2.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:922</id>
                    <description>one or more XML files outside the persistence archive on the classpath and referenced
                        from the persistence.xml
                    </description>
                    <location chapter="6" section="2.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:923</id>
                    <description>a combination of above</description>
                    <location chapter="6" section="2.1"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:924</id>
            <description>The managed persistence classes may either be:</description>
            <location chapter="6" section="2.1"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:925</id>
                    <description>contained within the persistence archive</description>
                    <location chapter="6" section="2.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:926</id>
                    <description>specified by reference that are accessible on the application classpath</description>
                    <location chapter="6" section="2.1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:927</id>
                    <description>specified by come combination of above</description>
                    <location chapter="6" section="2.1"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:928</id>
            <description>The persistence element consists of one or more persistence-unit elements.</description>
            <location chapter="6" section="2.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:929</id>
            <description>The persistence-unit element consists of the following sub-elements and attributes:
            </description>
            <location chapter="6" section="2.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:930</id>
            <description>The name attribute is required; the other attributes and elements are optional.</description>
            <location chapter="6" section="2.1.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:931</id>
            <description>The description element provides optional descriptive information about the persistence unit.
            </description>
            <location chapter="6" section="2.1.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:932</id>
            <description>The name attribute defines the name for the persistence unit. This name is used to identify the
                persistence unit referred to by the PersistenceContext and PersistenceUnit annotations and
                the programmatic API for creating EntityManagers and EntityManager Factories.
            </description>
            <location chapter="6" section="2.1.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>PERSISTENCE:SPEC:933</id>
            <description>The provider element specifies the name of the persistence provider's
                jakarta.persistence.spi.PersistenceProvider class.
            </description>
            <location chapter="6" section="2.1.3"/>
            <comment>STANDALONE</comment>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>PERSISTENCE:SPEC:934</id>
            <description>The provider element must be specified if a third-party provider implementation is used.
            </description>
            <location chapter="6" section="2.1.3"/>
            <comment>STANDALONE</comment>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>PERSISTENCE:SPEC:935</id>
            <description>In J2SE environments, the persistence provider must be specified [either by this means or
                vendor-specific-means].
            </description>
            <location chapter="6" section="2.1.3"/>
            <comment>STANDALONE</comment>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:936</id>
            <description>The transaction-type attribute is used to specify whether the entity managers provided by the
                entity
                manager factory for the persistence unit must be JTA entity managers or resource-local entity managers.
            </description>
            <location chapter="6" section="2.1.4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:937</id>
            <description>The value of this element is JTA or RESOURCE_LOCAL.</description>
            <location chapter="6" section="2.1.4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:938</id>
            <description>IIf this element is not specified, the default is JTA.</description>
            <location chapter="6" section="2.1.4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:939</id>
            <description>In Java EE environments, the jta-data-source and non-jta-data-source elements is used to
                specify the global JNDI name of the JTA and/or non-JTA data source
                to be used by the persistence provider.
            </description>
            <location chapter="6" section="2.1.5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:940</id>
            <description>If neither is specified, the deployer must specify a JTA datasource at deployment or a JTA data
                source must be provided by the container and
                a JTA EntityManagerFactory will be created to correspond to it.
            </description>
            <location chapter="6" section="2.1.5"/>
        </assertion>
        <assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="false">
            <id>PERSISTENCE:SPEC:941</id>
            <description>These elements name the data source in the local environment; the format of these names and the
                ability
                to specify the names are product specific.
            </description>
            <location chapter="6" section="2.1.5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>PERSISTENCE:SPEC:942</id>
            <description>In Java SE environments, these elements may be used or the datasource information may be
                specified by other means -
                depending upon the requirements of the provider.
            </description>
            <location chapter="6" section="2.1.5"/>
            <comment>STANDALONE</comment>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:943</id>
            <description>The following classes must be implicitly or explicitly denoted as managed persistence classes
                to be included within a persistence unit:
                entity classes; embeddadble classes; mapped superclasses.
            </description>
            <location chapter="6" section="2.1.6"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:944</id>
            <description>The set of classes that are managed by a persistence unit is defined by using one or more of
                the following:
            </description>
            <location chapter="6" section="2.1.6"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:945</id>
                    <description>One or more o/r mapping XML file</description>
                    <location chapter="6" section="2.1.6"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:946</id>
                    <description>One or more jar files that will be searched for classes</description>
                    <location chapter="6" section="2.1.6"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:947</id>
                    <description>An explicit list of the classes</description>
                    <location chapter="6" section="2.1.6"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:948</id>
                    <description>The annotated managed persistence classes contained in the root of the persistence unit
                        (unless the exclude-unlisted-classes element is specified)
                    </description>
                    <location chapter="6" section="2.1.6"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:949</id>
            <description>An orm.xml file:</description>
            <location chapter="6" section="2.1.6"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:950</id>
                    <description>may be specified in the META-INF directory in the root of the persistence unit
                    </description>
                    <location chapter="6" section="2.1.6"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:951</id>
                    <description>or in the META-INF directory of any jar file referenced by the persistence.xml
                    </description>
                    <location chapter="6" section="2.1.6"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:952</id>
                    <description>and/or one or more mapping files may be referenced by the mapping-file elements of the
                        persistence-unit element [of the persistence.xml file]
                    </description>
                    <location chapter="6" section="2.1.6"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:953</id>
            <description>If a mapping file is specified, the classes and mapping information specified in the mapping
                file will be used.
            </description>
            <location chapter="6" section="2.1.6"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:954</id>
            <description>If multiple mapping files are specified (possibly including an orm.xml file), the resulting
                mappings are obtained by combining the mappings from all the files
            </description>
            <location chapter="6" section="2.1.6"/>
        </assertion>
        <assertion required="false" impl-spec="true" defined-by="technology" status="active" testable="false">
            <id>PERSISTENCE:SPEC:955</id>
            <description>The result is undefined if multiple mappings referenced within a single persistence unit
                contain overlapping mapping information for any given class.
            </description>
            <location chapter="6" section="2.1.6"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>PERSISTENCE:SPEC:956</id>
            <description>The o/r mapping information contained in any mapping file referenced within the persistence
                unit must be disjoint at the class level from o/r mapping information contained in any other such
                mappings.
            </description>
            <location chapter="6" section="2.1.6"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:957</id>
            <description>One or more jar files may be specified using the jar-file elements instead of, or in addition
                to the mapping files specified in the mapping-files elements.
                If specified, these JAR files will be searched for managed persistence classes and any mapping
                metadata annotations found on them will be processed or they will be mapped using the mapping annotation
                defaults defined by this specification.
                Such JAR files are specified relative to the root of the persistence unit.
            </description>
            <location chapter="6" section="2.1.6"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:958</id>
            <description>A list of named managed persistence classes may also be specified instead of, or in addition
                to, the JAR files and mapping files. Any mapping
                metadata annotations found on them will be processed or they will be mapped using the mapping annotation
                defaults defined by this specification.
            </description>
            <location chapter="6" section="2.1.6"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:959</id>
            <description>The class element is used to list a managed persistence class.</description>
            <location chapter="6" section="2.1.6"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>PERSISTENCE:SPEC:960</id>
            <description>A list of all named managed persistence classes must be specified in Java SE environments to
                insure portability. Portable
                JavaSE applications should not rely on the other mechanisms described here to specify the managed
                persistence classes of a
                persistence unit. Persistence providers my also require that the set of entity classes and classes that
                are to be managed
                must be fully enumerated in each of the persistence.xml files in Java SE environments.
            </description>
            <location chapter="6" section="2.1.6"/>
            <comment>STANDALONE</comment>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:961</id>
            <description>All classes contained in the persistence unit are also searched for annotated managed
                persistence classes and any mapping metadata annotations found
                on them will be processed, or they will be mapped using the mapping annotation defaults.
            </description>
            <location chapter="6" section="2.1.6"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:962</id>
            <description>If it is not intended that the annoted persistence classes contained in the root of the
                persistence unit be included in the persistence unit,
                the exclude-unlisted-classes should be used.
            </description>
            <location chapter="6" section="2.1.6"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:963</id>
            <description>The exclude-unlisted-classes element is not intended for use in Java SE environments.
            </description>
            <location chapter="6" section="2.1.6"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:964</id>
            <description>The resulting set of entities managed by the persistence unit is the union of these four
                sources with the mapping metadata annotations (or annotation defaults)
                for any given class being overridden by the XML mapping information file if there are both annotations
                as well as XML mappings for that class.
            </description>
            <location chapter="6" section="2.1.6"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>PERSISTENCE:SPEC:966</id>
            <description>All classes and/or jars that are named as part of a persistence unit must be on the classpath;
                referencing them from the persistence.xml does not cause them
                to be placed on the classpath.
            </description>
            <location chapter="6" section="2.1.6"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>PERSISTENCE:SPEC:967</id>
            <description>All classes must be on the classpath to ensure that entity managers from different persistence
                units that map the same class will be accessing the same identical class.
            </description>
            <location chapter="6" section="2.1.6"/>
        </assertion>
        <assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="false">
            <id>PERSISTENCE:SPEC:968</id>
            <description>The properties element is used to specify vendor-specific properties that apply to the
                persistence unit and its entity manager factory configurations.
            </description>
            <location chapter="6" section="2.1.7"/>
        </assertion>
        <assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:969</id>
            <description>If a persistence provider does not recognize properties (other than those defined by this
                specification), the provider must ignore those properties.
            </description>
            <location chapter="6" section="2.1.7"/>
        </assertion>
        <assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:970</id>
            <description>An EJB-JAR, WAR, application client or EAR can define a persistence unit. The visibility of the
                persistence unit is determined by its point of definition.
            </description>
            <location chapter="6" section="2.2"/>
        </assertion>
        <assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:971</id>
            <description>A persistence unit that is defined at the level of an EJB-JAR, WAR, or application client jar
                is scoped to that EJB-JAR, WAR, or application-client jar
                respectively. It is visible to the components defined in that jar or war, but is not visible as a
                persistence unit to other parts of the application.
            </description>
            <location chapter="6" section="2.2"/>
        </assertion>
        <assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:972</id>
            <description>A persistence unit that is to be visible to the application as whole must be defined at EAR
                level (in EAR root or in the lib directory).
            </description>
            <location chapter="6" section="2.2"/>
        </assertion>
        <assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:973</id>
            <description>A persistence unit is defined at the level of the EAR is generally visible to all components of
                the application. However, if a persistence unit of the same name is defiend by an EJB-JAR, WAR or
                application client jar file within the EAR, the persistence unit of that name defined at the EAR level
                will not be visible to the components defined by that EJB-JAR, WAR, or
                application jar file.
            </description>
            <location chapter="6" section="2.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:974</id>
            <description>Each persistence unit deployed into a Java EE container consists of a single persistence.xml
                file, any number
                of mapping files and any number of classes.
            </description>
            <location chapter="7" section="1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:975</id>
            <description>At deployment time the container is responsible for scanning locations specified in 6.2 and
                discovering the persistence.xml files and processing them.
            </description>
            <location chapter="7" section="1.1"/>
        </assertion>
        <assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:976</id>
            <description>When the container finds a persistence.xml file, it processes the persistence unit definitions
                that it contains. Provider or data source information not specified in the persistence.xml file must be
                provided
                at deployment or defaulted by the container.
            </description>
            <location chapter="7" section="1.1"/>
        </assertion>
        <assertion required="false" impl-spec="true" defined-by="technology" status="active" testable="false">
            <id>PERSISTENCE:SPEC:977</id>
            <description>The container may optionally add its own container-specific properties to be passed to the
                provider when creating the entity manager factory for the persistence unit.
            </description>
            <location chapter="7" section="1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>PERSISTENCE:SPEC:978</id>
            <description>When a persistence unit is redeployed the container must call the
                createContainerEntityManagerFactory method again, with the required PersistenceUnitInfo metadata, to
                indicate the redeployment.
            </description>
            <location chapter="7" section="1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:979</id>
            <description>The persistence provider must implement the PersistenceProvider SPI and be able to process the
                metadata that is passed to it at the time createContainerEntityManagerFactory method is called.
            </description>
            <location chapter="7" section="1.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:980</id>
            <description>An instance of EntityManagerFactory is created and the metadata for the named EntityManager is
                associated with the factory. The factory is then returned to the container.
            </description>
            <location chapter="7" section="1.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:981</id>
            <description>The interface jakarta.persistence.spi.PersistenceProvider is implemented by the persistence
                provider.
            </description>
            <location chapter="7" section="1.3"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:982</id>
                    <description>It is invoked by the container in Java EE environments.</description>
                    <location chapter="7" section="1.3"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
                    <id>PERSISTENCE:SPEC:983</id>
                    <description>It is invoked by the jakarta.persistence.Persistence class in Java SE environments.
                    </description>
                    <location chapter="7" section="1.3"/>
                    <comment>STANDALONE</comment>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
                    <id>PERSISTENCE:SPEC:984</id>
                    <description>It is not intended to be used by the application.</description>
                    <location chapter="7" section="1.3"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>PERSISTENCE:SPEC:985</id>
            <description>The PersistenceProvider class must have a public no-arg constructor.</description>
            <location chapter="7" section="1.3"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:986</id>
            <description>Persistence unit properties may be passed to persistence providers in the Map parameter of the
                createEntityManagerFactory(String, Map) method.
                These properties correspond to the elements of the persistence.xml file. When any of these properties
                are specified in the Map parameter, their
                values override the values of the corresponding elements in the persistence.xml file for the named
                persistene unit. They also override any defaults
                that the provider may have applied.
            </description>
            <location chapter="7" section="1..3.1"/>
            <comment>STANDALONE</comment>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>PERSISTENCE:SPEC:987</id>
            <description>The properties listed below are defined by this specification.</description>
            <location chapter="7" section="1.3.1"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
                    <id>PERSISTENCE:SPEC:988</id>
                    <description>jakarta.persistence.provider - corresponds to the provider element in the persistence.xml
                    </description>
                    <location chapter="7" section="1.3.1"/>
                    <comment>STANDALONE</comment>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
                    <id>PERSISTENCE:SPEC:989</id>
                    <description>jakarta.persistence.transactionType - corresponds to the transaction-type attribute of
                        the persistence-unit element in the persistence.xml
                    </description>
                    <location chapter="7" section="1.3.1"/>
                    <comment>STANDALONE</comment>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
                    <id>PERSISTENCE:SPEC:990</id>
                    <description>jakarta.persistence.jtaDataSource - corresponds to the jta-data-source element in the
                        persistence.xml
                    </description>
                    <location chapter="7" section="1.3.1"/>
                    <comment>STANDALONE</comment>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
                    <id>PERSISTENCE:SPEC:991</id>
                    <description>jakarta.persistence.nonJtaDataSource - corresponds to the jnon-ta-data-source element in
                        the persistence.xml
                    </description>
                    <location chapter="7" section="1.3.1"/>
                    <comment>STANDALONE</comment>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:992</id>
            <description>BootStrapping in Java SE Environments</description>
            <location chapter="7" section="2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:993</id>
            <description>Entity Annotation</description>
            <location chapter="8" section="1"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:994</id>
                    <description>The name annotation element specifies the entity name. It defaults to the unqualified
                        name of
                        the entity class.
                    </description>
                    <location chapter="8" section="1"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:995</id>
                    <description>This name [annotation element] is used to refer to the entity in queries. The name must
                        not be a reserved literal in the query.
                    </description>
                    <keywords>
                        <keyword>application-role</keyword>
                        <keyword>application-server-role</keyword>
                    </keywords>
                    <location chapter="8" section="1"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:997</id>
            <description>Callback Annotations</description>
            <location chapter="8" section="2"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:998</id>
                    <description>The EntityListener annotation specifies the callback listener class to be used for an
                        entity.
                    </description>
                    <location chapter="8" section="2"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:999</id>
                    <description>The callback annotations [see Persistence JavaDoc assertion list] are used to specify
                        callbackmethods for the corresponding lifecycle events. These annotations may be applied to
                        methods of an entity class, of a mapped superclass, or of an EntityListener class.
                    </description>
                    <keywords>
                        <keyword>application-role</keyword>
                        <keyword>application-server-role</keyword>
                    </keywords>
                    <location chapter="8" section="2"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1004</id>
            <description>The NamedQuery annotation is used to specify a named query in the Java Persistent query
                language. The name element is used to refer to the query when using the EntityManager methods that
                create query objects.
            </description>
            <location chapter="8" section="3.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1005</id>
            <description>The NamedNativeQuery annotation is used to specify a native SQL named query. The name element
                is used to refer to the query when using the EntityManager methods that create query objects.
            </description>
            <location chapter="8" section="3.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1006</id>
            <description>The [NamedNativeQuery] resultClass element refers to the class of the result.</description>
            <location chapter="8" section="3.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1007</id>
            <description>The value of the [NamedNativeQuery] resultSetMapping element is the name of a
                SQLResultSetMapping as defined in the metadata.
            </description>
            <location chapter="8" section="3.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1008</id>
            <description>Annotations for SQL Query Result Set Mappings</description>
            <location chapter="8" section="3.4"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:1009</id>
                    <description>The SqlResultSetMapping is used to specify the mapping of the result of a native SQL
                        query.
                    </description>
                    <location chapter="8" section="3.4"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:1010</id>
                    <description>The name element is the name given to the result set mapping and used to refer to it in
                        the methods of the Query API.
                    </description>
                    <location chapter="8" section="3.4"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:1011</id>
                    <description>The entities and columns elements are used to specify the mapping to entities and to
                        scalar values respectively.
                    </description>
                    <location chapter="8" section="3.4"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:1012</id>
                    <description>The entityClass element specified the class of the result.</description>
                    <location chapter="8" section="3.4"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:1013</id>
                    <description>The discriminatorColumn element is used to specify the column name (or alias) of the
                        column in the SELECT list that is used to determine the type of the entity instance.
                    </description>
                    <location chapter="8" section="3.4"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:1014</id>
                    <description>The fields element is used to map the columns specified in the SELECT list of the query
                        to the properies or fields of the entity class.
                    </description>
                    <location chapter="8" section="3.4"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:1015</id>
                    <description>The name element [of FieldResult] is the name of the persistent field or property of
                        the class.
                    </description>
                    <location chapter="8" section="3.4"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:1016</id>
                    <description>The column element [of FieldResult] is the column name (or alias) as specified in the
                        SELECT list.
                    </description>
                    <location chapter="8" section="3.4"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1018</id>
            <description>References to EntityManager and EntityManagerFactory</description>
            <location chapter="8" section="4"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:1019</id>
                    <description>The PersistenceContext annotation is used to express a dependency on an EntityManager
                        persistence context.
                    </description>
                    <location chapter="8" section="4"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:1020</id>
                    <description>The [PersistenceContext] name element refers to the name by which the EntityManager is
                        to be known in the environment referencing context and is not needed when dependency injection
                        is used.
                    </description>
                    <location chapter="8" section="4"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:1021</id>
                    <description>The [PersistenceContext] unitName element refers to the name of the persistence unit.
                        It must be specified if there is more than one persistence unit.
                    </description>
                    <location chapter="8" section="4"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:1022</id>
                    <description>The [PersistenceContext] type element specifies whether a transaction-scoped or
                        extended persistence context is to be used.
                    </description>
                    <location chapter="8" section="4"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:1023</id>
                    <description>The PersistenceUnit annotation is used to express a dependency on an
                        EntityManagerFactory.
                    </description>
                    <location chapter="8" section="4"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:1024</id>
                    <description>The [PersistenceUnit] name element refers to the name by which the EntityManagerFactory
                        is to be known in the environment referencing context and is not needed when dependency
                        injection is used.
                    </description>
                    <location chapter="8" section="4"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:1025</id>
                    <description>The [PersistenceUnit unitName element refers to the name of the persistence unit. It
                        must be specified if there is more thatn one persistence unit.
                    </description>
                    <location chapter="8" section="4"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1026</id>
            <description>The implementation of this specification must assume the application logic to be dependent upon
                the object/relational mapping expressed in metadata.
            </description>
            <location chapter="9" section="1"/>
        </assertion>
        <assertion required="false" impl-spec="true" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1027</id>
            <description>It is permitted, but not required, that DDL generation be supported by an implementation of
                this specification. The annotation elements that specify such DDL are intended as hints to the
                implementation for DDL generation. Use of such hings is not portable.
            </description>
            <location chapter="9" section="1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1028</id>
            <description>The Table annotation specifies the primary table for the annotated entity.</description>
            <location chapter="9" section="1.42"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1028.1</id>
            <description>If no Table annotation is specified for an entity, all of the default values defined by the
                Table annotation will apply to the entity.
            </description>
            <location chapter="9" section="1.42"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1029</id>
            <description>Specifying one or more secondary tables indicates that the entity data is stored across
                multiple tables.
            </description>
            <location chapter="9" section="1.39"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1030</id>
            <description>If no SecondaryTable is specified, it is assumed that all properties of the entity are mapped
                to the primary table.
            </description>
            <location chapter="9" section="1.39"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1031</id>
            <description>If no primary join column is specified, the join columns are assumed to reference the primary
                key columns of the primary table and have the same names and types as the referenced primary key columns
                of the primary table.
            </description>
            <location chapter="9" section="1.39"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status=" removed" testable="true">
            <id>PERSISTENCE:SPEC:1032</id>
            <description>If there is a single secondary table, the join column or columns may be specified outside the
                SecondaryTable annotation.
            </description>
            <location chapter="9" section="1.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="removed" testable="true">
            <id>PERSISTENCE:SPEC:1033</id>
            <description>If there are multiple secondary tables and the join columns are not uniformly named, then the
                nested JoinColumn annotation will be required.
            </description>
            <location chapter="9" section="1.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="removed" testable="true">
            <id>PERSISTENCE:SPEC:1034</id>
            <description>Note that the secondaryTable element of the JoinColumn annotation will be ignored whtn the
                JoinColumn element is used to join a primary table to a secondary table.
            </description>
            <location chapter="9" section="1.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1035</id>
            <description>An entity may have multiple secondary tables. In this case, they must be enclosed within a
                SecondaryTables annotation. A SecondaryTables annotation takes an array of SecondaryTable annotations as
                its single annotation element.
            </description>
            <location chapter="9" section="1.40"/>
        </assertion>
        <assertion required="false" impl-spec="true" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1036</id>
            <description>The UniqueConstraint annotation is used to specify that a unique constraint should be included
                in the generated DDL for a primary or secondary table. It is only specified as a nested annotation
                within the Table or SecondaryTable annotation.
            </description>
            <location chapter="9" section="1.46"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1037</id>
            <description>Column annotation is used to specify a mapped column for a persistent property or field.
            </description>
            <location chapter="9" section="1.8"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1037.1</id>
            <description>If a Column annotation is not specified, or the name annotation element is missing, the column
                name defaults to the persistent property or field name.
            </description>
            <location chapter="9" section="1.8"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1038</id>
            <description>The JoinColumn annotation is used to specify a mapped column for joining an entity association
                or element collection.
            </description>
            <location chapter="9" section="1.20"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1039</id>
            <description>The name annotation element defines the name of the foreign key column.</description>
            <location chapter="9" section="1.20"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1040</id>
            <description>If the referencedColumnName element is missing, the foreign key is assumed to refer to the
                primary key of the referenced table.
            </description>
            <location chapter="9" section="1.20"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1041</id>
            <description>If the name annotation element is missing, or if no JoinColumn annotation is specified, the
                join columns are assumed to have the same names as the primary key columns of the referenced table.
            </description>
            <location chapter="9" section="1.20"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1042</id>
            <description>If no JoinColumn annotation is specified, a single join column is assumed.</description>
            <location chapter="9" section="1.20"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1043</id>
            <description>If there is a single join column, then:</description>
            <location chapter="9" section="1.20"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:1044</id>
                    <description>If the name annotation element is missing, the join column name is formed as the
                        concatenation of the following: the name of the referencing relationship property or field of
                        the referencing entity; "_"; the name of the referenced primary key column.
                    </description>
                    <location chapter="9" section="1.20"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:1045</id>
                    <description>If the referencedColumnName element is missing, the foreign key is assumed to refer to
                        the primary key of the referenced table.
                    </description>
                    <location chapter="9" section="1.20"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="false" impl-spec="true" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1046</id>
            <description>If there is more than one join column, a JoinColumn annotation myust be specified for each join
                column. Both the name and referencedColumnName elements must be specified in each such JoinColumn
                annotation.
            </description>
            <keywords>
                <keyword>application-role</keyword>
            </keywords>
            <location chapter="9" section="1.6"/>
        </assertion>
        <assertion required="false" impl-spec="true" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1047</id>
            <description>Support for referenced columns that are not the primary key of the referenced table is optional
                in this release, but will be required in the next.
            </description>
            <keywords>
                <keyword>application-role</keyword>
            </keywords>
            <location chapter="9" section="1.6"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1048</id>
            <description>Composite keys are supported via the JoinColumns annotation. This allows grouping a number of
                JoinColumn specifications for the same relationship or table association.
            </description>
            <location chapter="9" section="1.21"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1049</id>
            <description>The Id annotation specifies the primary key property or field of an entity. The Id annotatoin
                may be applied in an entity or mapped superclass.
            </description>
            <location chapter="9" section="1.17"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1050</id>
            <description>By default, the mapped column for the primary key of the entity is assumed to be the primary
                key of the primary table. If no Column annotation is specified, the primary key column name is assumed
                to be the name of the identifier property or field.
            </description>
            <location chapter="9" section="1.17"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1051</id>
            <description>The types of the primary key generation are defined by the GenerationType enum.</description>
            <location chapter="9" section="1.16"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:1052</id>
                    <description>The TABLE generator type value indicates that the persistence provider must assign
                        primary keys for the entity using an underlying database table to ensure uniqueness.
                    </description>
                    <location chapter="9" section="1.16"/>
                </assertion>
                <assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:1053</id>
                    <description>The SEQUENCE and IDENTITY values specify the use of a database sequence or identity
                        column, respectively.
                    </description>
                    <location chapter="9" section="1.16"/>
                </assertion>
                <assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:1055</id>
                    <description>AUTO indicates that the persistence provider should pick an appropriate strategy for
                        the particular database.
                    </description>
                    <location chapter="9" section="1.16"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:1057</id>
                    <description>The GeneratedValue annotation provides for the specification of generation strategies
                        for the value of primary keys. The GeneratedValue annotation may be applied
                        to a primary key property or field of an entity or mapped superclass in conjunction with the Id
                        annotation.
                    </description>
                    <location chapter="9" section="1.16"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1059</id>
            <description>The AttributeOverride annotation is used to override mappings of a Basic property or field or
                Id property or field.
            </description>
            <location chapter="9" section="1.10"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="removed" testable="true">
            <id>PERSISTENCE:SPEC:1060</id>
            <description>Columns in the overrides apply to the current primary table for the class that contains the
                annotation.
            </description>
            <location chapter="9" section="1.4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="removed" testable="true">
            <id>PERSISTENCE:SPEC:1061</id>
            <description>The AttributeOverride annotation may be used on an entity that extends a mapped superclass or
                on an embeddable class.
            </description>
            <location chapter="9" section="1.10"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1062</id>
            <description>The mappings of multiple properties or fields may be overridden. The AttributesOverrides
                annotation is used for this purpose.
            </description>
            <location chapter="9" section="1.5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1062.0</id>
            <description>The AssociationOverride annotation is used to override a many-to-one or one-to-one mapping of
                property or field for an entity relationship.
            </description>
            <location chapter="9" section="1.5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1062.1</id>
            <description>If the AssociationOverride annotation is not specified, the join column is mapped the same as
                in the original mapping. The joinColumns element refers to the table for the class that contains the
                annotation.
            </description>
            <location chapter="9" section="1.5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1063</id>
            <description>The EmbeddedId annotation is used to denote a composite primary key that is an embeddable
                class. It may be applied to a persistent field or property of the entity class.
            </description>
            <location chapter="9" section="1.14"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1064</id>
            <description>There should only be one EmbeddedId annotation and no Id annotation when the EmbeddedId
                annotation is used.
            </description>
            <location chapter="9" section="1.14"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1065</id>
            <description>The IdClass annotation is applied to an entity class or a mapped superclass to specify a
                composite primary key class that is mapped to multiple fields or properties of the entity. The names of
                the fields
                or properties in the primary key class and the primary key fields or properties of the entity must
                correspond and
                their types must match.
            </description>
            <location chapter="9" section="1.18"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1066</id>
            <description>The Id annotation must also be applied to the corresponding fields or properties of the entity.
            </description>
            <location chapter="9" section="1.18"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1067</id>
            <description>The Transient annotation is used to annotate a property or field of the entity class. It
                specifies the property or field is not persistent.
            </description>
            <location chapter="9" section="1.45"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1068</id>
            <description>The Version annotation is a marker annotation that keeps track of the version property
                (optimistic lock value) of an entity class. This is used to ensure integrity when reattaching and for
                overall optimistic concurrency control.
            </description>
            <location chapter="9" section="1.47"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1069</id>
            <description>The Basic annotation is the simplest type of mapping to a database column.</description>
            <location chapter="9" section="1.6"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:1070</id>
                    <description>The Basic annotation can optionally be applied to any persistent property or instance
                        variable of the following type: Java primitive types
                    </description>
                    <location chapter="9" section="1.6"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:1071</id>
                    <description>The Basic annotation can optionally be applied to any persistent property or instance
                        variable of the following type: java.lang.String
                    </description>
                    <location chapter="9" section="1.6"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:1072</id>
                    <description>The Basic annotation can optionally be applied to any persistent property or instance
                        variable of the following types: wrappers of the primitive types
                    </description>
                    <location chapter="9" section="1.6"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:1073</id>
                    <description>The Basic annotation can optionally be applied to any persistent property or instance
                        variable of the following type: byte[]
                    </description>
                    <location chapter="9" section="1.6"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:1074</id>
                    <description>The Basic annotation can optionally be applied to any persistent property or instance
                        variable of the following type: Byte[]
                    </description>
                    <location chapter="9" section="1.6"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:1075</id>
                    <description>The Basic annotation can optionally be applied to any persistent property or instance
                        variable of the following type: char[]
                    </description>
                    <location chapter="9" section="1.6"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:1076</id>
                    <description>The Basic annotation can optionally be applied to any persistent property or instance
                        variable of the following type: Character[]
                    </description>
                    <location chapter="9" section="1.6"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:1077</id>
                    <description>The Basic annotation can optionally be applied to any persistent property or instance
                        variable of the following type: java.math.BigInteger
                    </description>
                    <location chapter="9" section="1.6"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:1078</id>
                    <description>The Basic annotation can optionally be applied to any persistent property or instance
                        variable of the following type: java.math.BigDecimal
                    </description>
                    <location chapter="9" section="1.6"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:1079</id>
                    <description>The Basic annotation can optionally be applied to any persistent property or instance
                        variable of the following type: java.util.Date
                    </description>
                    <location chapter="9" section="1.6"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:1080</id>
                    <description>The Basic annotation can optionally be applied to any persistent property or instance
                        variable of the following type: java.util.Calendar
                    </description>
                    <location chapter="9" section="1.6"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:1081</id>
                    <description>The Basic annotation can optionally be applied to any persistent property or instance
                        variable of the following type: java.sql.Date
                    </description>
                    <location chapter="9" section="1.6"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:1082</id>
                    <description>The Basic annotation can optionally be applied to any persistent property or instance
                        variable of the following type: java.sql.Time
                    </description>
                    <location chapter="9" section="1.6"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:1083</id>
                    <description>The Basic annotation can optionally be applied to any persistent property or instance
                        variable of the following type: java.sql.TimeStamp
                    </description>
                    <location chapter="9" section="1.6"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1084</id>
            <description>The [FetchType] LAZY strategy is a hint to the persistence provider runtime that data should be
                fetched lazily when it is first accessed.
            </description>
            <location chapter="9" section="1.6"/>
        </assertion>
        <assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1085</id>
            <description>The implementation is permitted to eagerly fetch data for which the LAZY strategy hint hasd
                been specified.
            </description>
            <location chapter="9" section="1.6"/>
        </assertion>
        <assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1086</id>
            <description>For Basic properties, lazy fetching might only be available for properties which are always
                accessed via the get/set pair.
            </description>
            <location chapter="9" section="1.6"/>
        </assertion>
        <assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="false">
            <id>PERSISTENCE:SPEC:1087</id>
            <description>The optional element can be used a a hint as to whether the value of the field or property may
                be null.
            </description>
            <location chapter="9" section="1.6"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1088</id>
            <description>[The optional element] is disregarded for primitive types.</description>
            <location chapter="9" section="1.6"/>
        </assertion>
        <assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1089</id>
            <description>A Lob annotation specifies that a persistent property or field should be persisted as a large
                object to a database-supported large object type.
            </description>
            <location chapter="9" section="1.23"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1090.0</id>
            <description>The Temporal annotation must be specified for persistent fields or properties of type
                java.util.Date and java.util.Calendar. It may only be specified for fields or properties of those types.
            </description>
            <location chapter="9" section="1.20"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1090.1</id>
            <description>The Enumerated annotation specifies that a persistent property or field should be persisted as
                enumerated type.
            </description>
            <location chapter="9" section="1.15"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1090.2</id>
            <description>An enum can be mapped as either string or integer. The EnumType enum defines the mapping for
                enumerated types.
            </description>
            <location chapter="9" section="1.15"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1090.3</id>
            <description>If the enumerated type is not specified or the Enumerated annotation is not used, the
                enumerated type is assumed to be ORDINAL.
            </description>
            <location chapter="9" section="1.15"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1090</id>
            <description>The ManyToOne annotation defines a single-valued association to another entity class that has a
                many-to-one multiplicity. It is not normally necessary to specify the name of the associated target
                entity explicitly since it can usually be inferred from the type of the object being referenced.
            </description>
            <location chapter="9" section="1.44"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1091</id>
            <description>The cascade element set will cause the specified cascadable operations to be propagated to the
                associated entity.
            </description>
            <location chapter="9" section="1.24"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1092</id>
            <description>Multiple operations may be included in the [cascade] set.</description>
            <location chapter="9" section="1.24"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1093</id>
            <description>The value cascade=ALL is equivalent to cascade={PERSIST, MERGE, REMOVE, REFRESH}.</description>
            <location chapter="9" section="1.24"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1094</id>
            <description>The OneToOne annotation defines a single-valued association to another entity class that ha s a
                one-to-one multiplicity. It is not normally necessary to specify the name of the associated target
                entity explicitly since it can usually b e inferred from the type of the object being referenced.
            </description>
            <location chapter="9" section="1.34"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1095</id>
            <description>The OneToMany annotation defines a many-valued association with one-to-many multiplicity. If
                the Collection is defined using generics to specify the element type then the associated target entity
                type need not be specified; Otherwise it must be specified.
            </description>
            <location chapter="9" section="1.33"/>
        </assertion>
        <assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1096</id>
            <description>Unidirectional one-to-many relationships may be implemented using one-to-many foreign key
                mappings.
            </description>
            <keywords>
                <keyword>application-role</keyword>
            </keywords>
            <location chapter="9" section="1.33"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1097</id>
            <description>A JoinTable annotation is used in the mapping of associations. A JoinTable annotation is
                specified on the owning side of the association. The JoinTable annotation is missing, the default values
                of the annotation elements apply. The name of the JoinTable is assumed to be the tables names of the
                associated primary tables concatenated together (owning side first) using an underscore.
            </description>
            <location chapter="9" section="1.22"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1098</id>
            <description>The ManyToMany annotation defines a many-valued association with many-to-many multiplicity. If
                the Collection is defined using generics to specify the element type then the associated target entity
                type need not be specified. If a regular Collection or Set is used then the target entity of the class
                must be included.
            </description>
            <location chapter="9" section="1.24"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1099</id>
            <description>Every many-to-many association has two sides, the owning side and the non-owning or inverse
                side. The association table is specified on the owning side.
            </description>
            <location chapter="9" section="1.24"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable=" true">
            <id>PERSISTENCE:SPEC:1100</id>
            <description>The MapKey annotation is used to specify the map key for associations of type java.util.Map.
                When the mapkey is itself the primary key or a persistent field or property of the entity that is the
                value of the map.
            </description>
            <location chapter="9" section="1.26"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable=" true">
            <id>PERSISTENCE:SPEC:1101</id>
            <description>The name element [of the MapKey annotation] designates the name of the persistent field or
                property of the associated entity that is used as the map key.
                If name element is not specified,the primary key of the associated entity is used as the map key.
            </description>
            <location chapter="9" section="1.26"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable=" true">
            <id>PERSISTENCE:SPEC:1102</id>
            <description>If the primary key is a composite primary key and is mapped as IdClass, an instance of the
                primary key class is used as the key.
            </description>
            <location chapter="9" section="1.26"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable=" true">
            <id>PERSISTENCE:SPEC:1103</id>
            <description>The OrderyBy annnotation specifies the ordering of the elements of a collection valued
                associate at the point when the association is retrieved.
            </description>
            <location chapter="9" section="1.35"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1104</id>
            <description>The syntax of the ordering element is as follows:</description>
            <location chapter="9" section="1.35"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:1105</id>
                    <description>ORDER BY orderby_list</description>
                    <location chapter="9" section="1.35"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:1106</id>
                    <description>orderby_list::=orderby_item[,orderby_item]*</description>
                    <location chapter="9" section="1.35"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
                    <id>PERSISTENCE:SPEC:1107</id>
                    <description>orderby_item::=property_or_field_name[ASC|DESC]</description>
                    <location chapter="9" section="1.35"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable=" true">
            <id>PERSISTENCE:SPEC:1108</id>
            <description>If ASC or DESC is not specified, ASC (ascending order) is assumed.</description>
            <location chapter="9" section="1.35"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable=" true">
            <id>PERSISTENCE:SPEC:1109</id>
            <description>The property or field name specified as an Orderby_item must correspond to a basic persistent
                property or field of the associated class or embedded class within it.
            </description>
            <location chapter="9" section="1.35"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable=" true">
            <id>PERSISTENCE:SPEC:1110</id>
            <description>The properties or fields used in the ordering must correspond to columns for which comparison
                operators are supported.
            </description>
            <location chapter="9" section="1.35"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable=" true">
            <id>PERSISTENCE:SPEC:1111</id>
            <description>The OrderyBy annnotation specifies the ordering of the elements of a collection-valued
                association or element collection at the point when the association is retrieved.
            </description>
            <location chapter="9" section="1.35"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1112</id>
            <description>The Inheritance annotation defines the inheritance strategy to be used for an entity class
                hierarchy. The three inheritance mapping strategies are:
            </description>
            <location chapter="9" section="1.19"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable=" true">
                    <id>PERSISTENCE:SPEC:1113</id>
                    <description>Single Table per Class Hierarchy</description>
                    <location chapter="9" section="1.19"/>
                </assertion>
                <assertion required="false" impl-spec="true" defined-by="technology" status="active" testable=" true">
                    <id>PERSISTENCE:SPEC:1114</id>
                    <description>Table per Class [NOTE: Support for TABLE_PER_CLASS mapping strategy is optional in this
                        release but will be required in the next.]
                    </description>
                    <location chapter="9" section="1.19"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable=" true">
                    <id>PERSISTENCE:SPEC:1115</id>
                    <description>Joined Subclass</description>
                    <location chapter="9" section="1.19"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1116</id>
            <description>For the SINGLE_TABLE mapping strategy, the persistence provider will use a discriminator
                column. The supported discriminator types are defined by the DiscriminatorType enum: STRING, CHAR,
                INTEGER.
            </description>
            <location chapter="9" section="1.19"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1118</id>
            <description>The strategy and discriminatorType are only specified once per class hierarchy (in the root
                class), while the discriminatorValue should be specified for each class in the hierarchy.
            </description>
            <location chapter="9" section="1.19"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1119</id>
            <description>If no inheritance type is specified for a class hierarchy, the single table per class hierarchy
                strategy is used.
            </description>
            <location chapter="9" section="1.19"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1126</id>
            <description>The DiscriminatorColumn annotation is used to define the discriminator column for SINGLE_TABLE
                and JOINED inheritance mapping strategies.
            </description>
            <location chapter="9" section="1.9"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1126.1</id>
            <description>The DiscriminatorColumn annotation can be specified on an entity class (including on an
                abstract entity class).
            </description>
            <location chapter="9" section="1.9"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1126.2</id>
            <description>If the DiscriminatorColumn annotation is missing, and a discriminator column is required, the
                name of the discriminator column defaults to "DTYPE" and the discriminator type to STRING.
            </description>
            <location chapter="9" section="1.9"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1126.3</id>
            <description>The DiscriminatorValue annotation is used to specify the value of the discriminator column for
                entities of the given type. The DiscriminatorValue annotation can only be specified on a concrete entity
                class. If the DiscriminatorValue annotation is not specified and a discriminator column is used, a
                provider-specific function will be used to generate a value representing the entity type.
            </description>
            <location chapter="9" section="1.10"/>
        </assertion>
        <assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1126.4</id>
            <description>If the DiscriminatorValue annotation is not specified and a discriminator column is used, a
                provider-specific function will be used to generate a value representing the entity type.
            </description>
            <location chapter="9" section="1.10"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1120</id>
            <description>The PrimaryKeyJoinColumn annotation specifies the primary key columns that are used as a
                foreign key to join to another table.
            </description>
            <location chapter="9" section="1.37"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1121</id>
            <description>The PrimaryKeyJoinColumn annotated is used:</description>
            <location chapter="9" section="1.37"/>
            <sub-assertions>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable=" true">
                    <id>PERSISTENCE:SPEC:1122</id>
                    <description>to join the primary table of an entity subclass in the JOINED mapping strategy to the
                        primary table of its superclass
                    </description>
                    <location chapter="9" section="1.37"/>
                </assertion>
                <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable=" true">
                    <id>PERSISTENCE:SPEC:1123</id>
                    <description>in a OneToOne mapping in which the primary key of the referencing entity is used as a
                        foreign key to the referenced entity.
                    </description>
                    <location chapter="9" section="1.37"/>
                </assertion>
            </sub-assertions>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1124</id>
            <description>If no PrimaryKeyJoinColumn annotation is specified, the foreign key columns are assumed to have
                the same names as the primary key columns of the primary table of the superclass.
            </description>
            <location chapter="9" section="1.37"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1125</id>
            <description>Composite keys are supported via the PrimaryKeyJoinColumns annotation.</description>
            <location chapter="9" section="1.38"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1127</id>
            <description>The Embeddable annotation is used to mark an object that is stored as an intrinisic part of an
                owning entity and shares the identify of that entity.
            </description>
            <location chapter="9" section="1.12"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="removed" testable="true">
            <id>PERSISTENCE:SPEC:1128</id>
            <description>Each of the persistent properties or fields of the embedded object is mapped to the database
                table. Only Basic, Column, Serialized, and Lob mapping annotations may be used to map embedded object.
            </description>
            <location chapter="9" section="1.34"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="removed" testable="true">
            <id>PERSISTENCE:SPEC:1129</id>
            <description>The Embedded annotation may be used in an entity class when it is using a shared embeddable
                class. The entity may override the column mappings declared within the embeddable class to apply to its
                own entity table.
            </description>
            <location chapter="9" section="1.35"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1130</id>
            <description>The MappedSuperclass annotation designates an embedded superclass A class designated as an
                embedded superclass has no separate table defined for it. Its mapping
                informationis applied to the entities that inherit from it.
            </description>
            <location chapter="9" section="1.32"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1131</id>
            <description>A class designated as MappedSuperclass can be mapped in the same way as an entity except that
                the mappings will apply only to its subcllesses since not table exits for the embedded superclass.
            </description>
            <location chapter="9" section="1.32"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1132</id>
            <description>When applied to the subclasses the inherited mappings will apply in the context of the subclass
                tables.
            </description>
            <location chapter="9" section="1.32"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1133</id>
            <description>Mapping information may be overridden in such subclasses by using the AttributreOverride and
                AttributeOverrides annotation.
            </description>
            <location chapter="9" section="1.32"/>
        </assertion>
        <assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="false">
            <id>PERSISTENCE:SPEC:1134</id>
            <description>The SequenceGenerator annotation defines a primary key or id generator which may be referenced
                by name when annotation the id attribute.
            </description>
            <location chapter="9" section="1.41"/>
        </assertion>
        <assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="false">
            <id>PERSISTENCE:SPEC:1135</id>
            <description>A generator may be defined at either the package, class, method, or field level. The level at
                which it is defined will depend upon the desired visibility and sharing of the generator. No scoping or
                visibility rules are actually enforced. However, it is good practice to define the generator at the
                level for which it will be used.
            </description>
            <location chapter="9" section="1.41"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1136</id>
            <description>The TableGenerator annotation defines a primary key or id generator which may be referenced by
                name when annotation the id attribute.
            </description>
            <location chapter="9" section="1.43"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1137</id>
            <description>A generator may be defined at either the package, class, method, or field level. The level
                at which it is defined will depend upon the desired visibility and sharing of the generator. No scoping
                or visibility rules are actually enforce
                d. However, it is good practice to define the generator at the level for which it will be used.
            </description>
            <location chapter="9" section="1.43"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1138</id>
            <description>XML Overriding Rules</description>
            <location chapter="10" section="1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1139</id>
            <description>persistent-unit-defaults Subelements</description>
            <location chapter="10" section="1.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1140</id>
            <description>Other Subelements of the entity-mapping element</description>
            <location chapter="10" section="1.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1141</id>
            <description>Entity Subelements</description>
            <location chapter="10" section="1.3"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1142</id>
            <description>mapped-superclass Subelements</description>
            <location chapter="10" section="1.4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1143</id>
            <description>Embeddable Subelements</description>
            <location chapter="10" section="1.5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1144</id>
            <description>XML Schema</description>
            <location chapter="10" section="2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable=" true">
            <id>PERSISTENCE:SPEC:1145</id>
            <description>An enum or interface must not be designated as an entity.</description>
            <location chapter="2" section="1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1146</id>
            <description>An instance variable must be directly accessed only from within the methods of the entity by
                the entity instance itself.
            </description>
            <location chapter="2" section="1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1147</id>
            <description>Collections of embeddable types</description>
            <location chapter="2" section="1.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1148</id>
            <description>Collections of basic types</description>
            <location chapter="2" section="1.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1149</id>
            <description>A single access type(field or property access) applies to an entity hierarchy.</description>
            <location chapter="2" section="1.3.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1150</id>
            <description>Mapping annotations must not be applied to fields or properties that are transient or
                Transient.
            </description>
            <location chapter="2" section="1.3.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1151</id>
            <description>All classes in entity hierarchy whose access type is defaulted must be consistent in placement
                of annotations ,either field or property, within the entire hierarchy.
            </description>
            <location chapter="2" section="1.3.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1152</id>
            <description>An access type for an individual entity class,mapped superclass,or embeddable class can be
                specified for that class independent of the default for the entity heirarchy by means of Access
                annotation applied to the class.
            </description>
            <location chapter="2" section="1.3.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1153</id>
            <description>To specify a persistent property for access by the persistence provider runtime, that property
                must be designated Access(PROPERTY.)
            </description>
            <location chapter="2" section="1.3.2"/>
        </assertion>
        <assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="false">
            <id>PERSISTENCE:SPEC:1154</id>
            <description>The behavior is undefined if mapping annotations are placed on any properties defined by the
                class for which Access(PROPERTY) is not specified.
            </description>
            <location chapter="2" section="1.3.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1155</id>
            <description>To specify a persistent instance variable for access by the persistence provider runtime, that
                instance variable must be designated Access(FIELD)
            </description>
            <location chapter="2" section="1.3.2"/>
        </assertion>
        <assertion required="true" impl-spec=" true" defined-by="technology" status="active" testable="false">
            <id>PERSISTENCE:SPEC:1156</id>
            <description>The behavior is undefined if mapping annotations are placed on any instance variables defined
                by the class for which Access(FIELD) is not specified.
            </description>
            <location chapter="2" section="1.3.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1157</id>
            <description>Every entity must have a primary key.</description>
            <location chapter="2" section="1.5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1158</id>
            <description>The primary key must be defined on the entity class that is the root of the entity hierarchy or
                on a mapped superclass that is a (direct or indirect) superclass of all entity classes in the entity
                hierarchy.
            </description>
            <location chapter="2" section="1.5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1159</id>
            <description>The primary key must be defined exactly once in an entity hierarchy.</description>
            <location chapter="2" section="1.5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1160</id>
            <description>A simple (i.e., non-composite) primary key must correspond to a single persistent field or
                property of the entity class. The Id annotation is used to denote a simple primary key.
            </description>
            <location chapter="2" section="1.5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1161</id>
            <description>Composite primary key must correspond to either a single persistent field or property or to a
                set of such fields or properties
            </description>
            <location chapter="2" section="1.5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1162</id>
            <description>A primary key class must be defined to represent a composite primary key.</description>
            <location chapter="2" section="1.5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1163</id>
            <description>A simple primary key or a field or property of a composite primary key should be one of the
                following types:
            </description>
            <location chapter="2" section="1.5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1164</id>
            <description>Any Java Primitive type</description>
            <location chapter="2" section="1.5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1165</id>
            <description>Any Primitive Wrapper type</description>
            <location chapter="2" section="1.5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1166</id>
            <description>java.lang.String</description>
            <location chapter="2" section="1.5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1167</id>
            <description>java.util.Date</description>
            <location chapter="2" section="1.5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1168</id>
            <description>java.sql.Date</description>
            <location chapter="2" section="1.5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1169</id>
            <description>java.math.BigDecimal</description>
            <location chapter="2" section="1.5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1170</id>
            <description>java.math.BigInteger</description>
            <location chapter="2" section="1.5"/>
        </assertion>
        <assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="false">
            <id>PERSISTENCE:SPEC:1171</id>
            <description>Entities whose primary keys use types other than the above will not be portable .</description>
            <location chapter="2" section="1.5"/>
        </assertion>
        <assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="false">
            <id>PERSISTENCE:SPEC:1172</id>
            <description>If generated primary keys are used, only integral types will be portable.</description>
            <location chapter="2" section="1.5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1173</id>
            <description>If java.util.Date is used as a primary key field or property, the temporal type should be
                specified as DATE.
            </description>
            <location chapter="2" section="1.5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1174</id>
            <description>The access type (field- or property-based access) of a primary key class is determined by the
                access type of the entity for which it is the primary key unless the primary key is a embedded id and a
                different access type is specified.
            </description>
            <location chapter="2" section="1.5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>PERSISTENCE:SPEC:1175</id>
            <description>A composite primary key must either be represented and mapped as an embeddable class or must be
                represented as an id class and mapped to multiple fields or properties of the entity class.
            </description>
            <location chapter="2" section="1.5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1176</id>
            <description>If the composite primary key class is represented as an id class, the names of primary key
                fields or properties in the primary key class and those of the entity class to which the id class is
                mapped must correspond and their types must be the same.
            </description>
            <location chapter="2" section="1.5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>PERSISTENCE:SPEC:1177</id>
            <description>primary key that corresponds to a derived identity must conform to the rules</description>
            <location chapter="2" section="1.5"/>
        </assertion>
        <assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="false">
            <id>PERSISTENCE:SPEC:1178</id>
            <description>The application must not change the value of the primary key. The behavior is undefined if this
                occurs.
            </description>
            <location chapter="2" section="1.5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1179</id>
            <description>The identity of an entity may be derived from the identity of another entity (the "parent"
                entity) when the former entity (the "dependent" entity) is the owner of a many-to-one or one-to-one
                relationship to the parent entity and a foreign key maps the relationship from dependent to parent.
            </description>
            <location chapter="2" section="1.5.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1180</id>
            <description>If the dependent entity class has primary key attributes in addition to those of the parent's
                primary key or if the parent has a composite primary key, an embedded id or id class must be used to
                specify the primary key of the dependent entity.
            </description>
            <location chapter="2" section="1.5.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1181</id>
            <description>A dependent entity may have more than one parent entity.</description>
            <location chapter="2" section="1.5.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1182</id>
            <description>If the dependent entity uses an id class to represent its primary key, the names of the fields
                or properties (attributes) of the id class and the Id attributes of the dependent entity class must
                correspond as follows:
            </description>
            <location chapter="2" section="1.5.1.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1183</id>
            <description>The Id attribute in the entity class and the corresponding attribute in the id class must have
                the same name.
            </description>
            <location chapter="2" section="1.5.1.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1184</id>
            <description>If an Id attribute in the entity class is of basic type, the corresponding attribute in the id
                class must have the same type.
            </description>
            <location chapter="2" section="1.5.1.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1185</id>
            <description>If an Id attribute in the entity is a many-to-one or one-to-one reference to a parent entity,
                the type of the corresponding attribute in the id class must be the same Java type as the id class or
                embedded id of the parent entity (if the parent entity has a composite primary key) or the type of the
                Id attribute of the parent entity (if the parent entity has a simple primary key).
            </description>
            <location chapter="2" section="1.5.1.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1186</id>
            <description>If the dependent entity uses an embedded id to represent its primary key, the primary key
                attribute corresponding to the relationship must be of the same type as the primary key of the
                referenced entity and must be designated by the MappedById annotation applied to the relationship
                attribute.
            </description>
            <location chapter="2" section="1.5.1.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1187</id>
            <description>The value element of the MappedById annotation must be used to specify the name of the primary
                key attribute to which the relationship corresponds.
            </description>
            <location chapter="2" section="1.5.1.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1188</id>
            <description>An entity may have collections of embeddables as well as single-valued embeddable attributes.
            </description>
            <location chapter="2" section="1.6"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1189</id>
            <description>Embeddable may be used as map keys and map values.</description>
            <location chapter="2" section="1.6"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1190</id>
            <description>Embeddable classes must be annotated as Embeddable or denoted in XML descriptors.</description>
            <location chapter="2" section="1.6"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1191</id>
            <description>An embedable class may be used to represent the state of another embeddable class.
            </description>
            <location chapter="2" section="1.6"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1192</id>
            <description>An embeddable class (including an embeddable class within another embeddable class) may contain
                a collection of a basic type or other embeddable class.
            </description>
            <location chapter="2" section="1.6"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1193</id>
            <description>An embeddable class may contain a relationship to an entity or collection of entities.
            </description>
            <location chapter="2" section="1.6"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>PERSISTENCE:SPEC:1194</id>
            <description>An embeddable class that is used as an embedded id or as map key must not contain such a
                relationship.
            </description>
            <location chapter="2" section="1.6"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1195</id>
            <description>A persistent field or property of an entity may correspond to a collection of a basic type or
                embeddable class .
            </description>
            <location chapter="2" section="1.7"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1196</id>
            <description>An embeddable class (including an embeddable class within another embeddable class) contained
                within an element collection must not contain an element collection, nor may it contain a relationship
                to an entity other than a many-to-one or one-to-one relationship.
            </description>
            <location chapter="2" section="1.7"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1197</id>
            <description>The embeddable class must be on the owning side of the relationship and the relationship must
                be mapped by a foreign key mapping.
            </description>
            <location chapter="2" section="1.7"/>
        </assertion>

        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1198</id>
            <description>Collections of elements and entity relationships can be represented as java.util.Map
                collections.
            </description>
            <location chapter="2" section="1.8"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1199</id>
            <description>The map key type and the target type independently can each be a basic type, embeddable class,
                or an entity.
            </description>
            <location chapter="2" section="1.8"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1200</id>
            <description>The ElementCollection, OneToMany, and ManyToMany annotations are used to specify the map as an
                element collection or entity relationship as appropriate.
            </description>
            <location chapter="2" section="1.8"/>
        </assertion>

        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>PERSISTENCE:SPEC:1201</id>
            <description>Bidirectional relationships represented as java.util.Map collections support the use of the Map
                datatype on one side of the relationship only.
            </description>
            <location chapter="2" section="1.8"/>
        </assertion>

        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1202</id>
            <description>If the map key type is a basic type, the MapKeyColumn annotation is used to specify the column
                mapping for the map key. If the MapKeyColumn annotation is not specified, the default values of the
                MapKeyColumn annotation apply.
            </description>
            <location chapter="2" section="1.8.1"/>
        </assertion>

        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1203</id>
            <description>If the map key type is an embeddable class, the mappings for the map key columns are defaulted
                according to the default column mappings for the embeddable class.
            </description>
            <location chapter="2" section="1.8.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1204</id>
            <description>If the map key type is an entity, the MapKeyJoinColumn and MapKeyJoinColumns annotations are
                used to specify the column mappings for the map key. If the primary key of the referenced entity is a
                simple primary key and the MapKeyJoinColumn annotation is not specified, the default values of the
                MapKeyJoinColumn annotation apply.
            </description>
            <location chapter="2" section="1.8.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1205</id>
            <description>If Java generic types are not used in the declaration of a relationship attribute of type
                java.util.Map, the MapKeyClass annotation must be used to specify the type of the key of the map.
            </description>
            <location chapter="2" section="1.8.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1206</id>
            <description>If Java generic types are not used, the ElementCollection annotation must be used to specify
                the value type for the map.
            </description>
            <location chapter="2" section="1.8.2"/>
        </assertion>

        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1207</id>
            <description>When the value type of the map is an entity, a join table is used to map for a many-to-many
                relationship or, by default, for a one-to-many unidirectional relationship.
            </description>
            <location chapter="2" section="1.8.2"/>
        </assertion>

        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1208</id>
            <description>If the relationship is a bidirectional one-to-many/many-to-one relationship, by default the map
                is mapped in the table of the entity that is the value of the map.
            </description>
            <location chapter="2" section="1.8.2"/>
        </assertion>
        <assertion required="true" impl-spec=" false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1209</id>
            <description>If Java generic types are not used, the targetEntity element of the OneToMany or ManyToMany
                annotation must be used to specify the value type for the map.
            </description>
            <location chapter="2" section="1.8.2"/>
        </assertion>

        <assertion required="false" impl-spec=" false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1210</id>
            <description>Relationships may be bidirectional or unidirectional.</description>
            <location chapter="2" section="1.10"/>
        </assertion>
        <assertion required="false" impl-spec=" false" defined-by="technology" status="active" testable="false">
            <id>PERSISTENCE:SPEC:1211</id>
            <description>This specification also requires support for the following alternative mapping strategies:
            </description>
            <location chapter="2" section="1.10"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1212</id>
            <description>Mapping of unidirectional one-to-many relationships by means of foreign key mappings.
            </description>
            <location chapter="2" section="1.10"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1213</id>
            <description>Mapping of unidirectional and bidirectional one-to-one relationships and bidirectional
                many-to-one/one-to-many relationships by means of join table mappings.
            </description>
            <location chapter="2" section="1.10"/>
        </assertion>

        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1214</id>
            <description>The JoinColumn and JoinTable annotations or corresponding XML elements must be used to
                explicitly specify non-default mappings.
            </description>
            <location chapter="2" section="1.10"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1215</id>
            <description>Schema-level mapping annotations must be specified on the owning side of the relationship.
            </description>
            <location chapter="2" section="1.10"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1216</id>
            <description>Any overriding of mapping defaults must be consistent with the relationship modeling annotation
                that is specified.
            </description>
            <location chapter="2" section="1.10"/>
        </assertion>

        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1217</id>
            <description>An entity may inherit from another entity class.
            </description>
            <location chapter="2" section="1.12"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1218</id>
            <description>Entities support inheritance,polymorphic associations, and polymorphic queries.
            </description>
            <location chapter="2" section="1.12"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1219</id>
            <description>Both abstract and concrete classes can be entities.
            </description>
            <location chapter="2" section="1.12"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1220</id>
            <description>Entities can extend non-entity classes and non-entity classes can extend entity classes.
            </description>
            <location chapter="2" section="1.12"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1221</id>
            <description>An entity can have a non-entity superclass, which may be either a concrete or abstract class.
                The superclass may not be an embeddable class or id class.
            </description>
            <location chapter="2" section="1.12.3"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1222</id>
            <description>The state of a managed entity instance is refreshed from the database by invoking the refresh
                method on it or by cascading the refresh operation. The semantics of the refresh operation, applied to
                an entity X are as follows:
            </description>
            <location chapter="3" section="2.4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1223</id>
            <description>If X is a managed entity, the state of X is refreshed from the database, overwriting any
                changes made to the entity, if any. The refresh operation is cascaded to entities referenced by X, if
                the relationship from X to these other entities is annotated with the cascade=REFRESH or cascade=ALL
                annotation element value.
            </description>
            <location chapter="3" section="2.4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1224</id>
            <description>A entity instance is removed from the persistence context when the evict method is invoked on
                it or cascaded to it.
            </description>
            <location chapter="3" section="2.5"/>
        </assertion>

        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1225</id>
            <description>Changes made to the entity, if any (including removal of the entity), must not be synchronized
                to the database after eviction has taken place.
            </description>
            <location chapter="3" section="2.5"/>
        </assertion>

        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1226</id>
            <description>Applications must use the flush method prior to the evict method to ensure portable semantics
                if changes have been made to the entity (including removal of the entity).
            </description>
            <location chapter="3" section="2.5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1227</id>
            <description>portable applications must not assume that changes have not been written to the database if the
                flush method has not been called prior to eviction.
            </description>
            <location chapter="3" section="2.5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1228</id>
            <description>If X is a managed entity, the evict operation causes it to become detached. The evict operation
                is cascaded to entities referenced by X, if the relationships from X to these other entities is
                annotated with the cascade=EVICT or cascade=ALL annotation element value. Entities which previously
                referenced X will continue to reference X.
            </description>
            <location chapter="3" section="2.5"/>
        </assertion>

        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1229</id>
            <description>If X is a new or detached entity,it is ignored by the evict operation.</description>
            <location chapter="3" section="2.5"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1230</id>
            <description>If X is a removed entity, the evict operation is cascaded to entities referenced by X, if the
                relationships from X to these other entities is annotated with the cascade=EVICT or cascade=ALL
                annotation element value. Entities which previously referenced X will continue to reference X. Portable
                applications should not pass removed entities that have been evicted from the persistence context to
                further Entity Manager operations.
            </description>
            <location chapter="3" section="2.5"/>
        </assertion>

        <assertion required="false" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>PERSISTENCE:SPEC:1231</id>
            <description>Serializing entities and merging those entities back into a persistence context may not be
                interoperable across vendors when lazy properties or fields and/or relationships are used.
            </description>
            <location chapter="3" section="2.6.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1232</id>
            <description>When interoperability across vendors is required, the application must not use lazy loading.
            </description>
            <location chapter="3" section="2.6.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1233</id>
            <description>If transaction T1 calls lock(entity, LockModeType.WRITE) on a versioned object, the entity
                manager must avoid the phenomena P1 and P2 (as with LockModeType.READ) and must also force an update
                (increment) to the entity's version column.
            </description>
            <location chapter="3" section="3.4.3"/>
        </assertion>
        <assertion required="false" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1234</id>
            <description>A forced version update may be performed immediately, or may be deferred until a flush or
                commit.
            </description>
            <location chapter="3" section="3.4.3"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="false">
            <id>PERSISTENCE:SPEC:1235</id>
            <description>Applications that call lock(entity, LockModeType.WRITE) on non-versioned objects will not be
                portable.
            </description>
            <location chapter="3" section="3.4.3"/>
        </assertion>

        <assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="false">
            <id>PERSISTENCE:SPEC:1236</id>
            <description>For portability, an application should not depend on vendor-specific hints or configuration to
                ensure repeatable read for objects that are not updated or removed via any mechanism other than the use
                of version attributes and the EntityManager lock method.
            </description>
            <location chapter="3" section="3.4.3"/>
        </assertion>
        <assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="false">
            <id>PERSISTENCE:SPEC:1237</id>
            <description>It should be noted that if an implementation has acquired upfront pessimistic locks on some
                database rows, then it is free to ignore lock(entity, LockModeType.READ) calls on the entity objects
                representing those rows.
            </description>
            <location chapter="3" section="3.4.3"/>
        </assertion>

        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1238</id>
            <description>The query element must specify a query string in the Java Persistence query language.
            </description>
            <location chapter="8" section="3.1"/>
        </assertion>

        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1239</id>
            <description>The Access annotation is used to specify an access type to be applied to an entity class,
                mapped superclass, or embeddable class, or to a specific attribute of such a class.
            </description>
            <location chapter="9" section="1.1"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1240</id>
            <description>The AssociationOverride annotation may be applied to an entity that extends a mapped superclass
                to override a many-to-one or one-to-one mapping defined by the mapped superclass.
            </description>
            <location chapter="9" section="1.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1241</id>
            <description>The AssociationOverride annotation may be used to override a relationship mapping from an
                embeddable within an entity to another entity when the embeddable is on the owning side of the
                relationship.
            </description>
            <location chapter="9" section="1.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1242</id>
            <description>When the AssociationOverride annotation is applied to override the mappings of an embeddable
                class used as a map value, "value." must be used to prefix the name of the attribute within the
                embeddable class that is being overridden in order to specify it as part of the map value.
            </description>
            <location chapter="9" section="1.2"/>
        </assertion>

        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1243</id>
            <description>If the relationship mapping uses a join table, the joinTableelement of the AssociationOverride
                element must be specified to override the mapping of the join table and/or its join columns.
            </description>
            <location chapter="9" section="1.2"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1244</id>
            <description>The AttributeOverride annotation may be applied to an entity that extends a mapped superclass
                or to an embedded field or property to override a Basic mapping or Id mapping defined by the mapped
                superclass or embeddable class (or embeddable class of one of its attributes).
            </description>
            <location chapter="9" section="1.4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1245</id>
            <description>When the AttributeOverride annotation is applied to a map, "key." or "value." must be used to
                prefix the name of the attribute that is being overridden in order to specify it as part of the map key
                or map value.
            </description>
            <location chapter="9" section="1.4"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1246</id>
            <description>The CollectionTable annotation specifies the table that is used for the mapping of the
                collection and is specified on the collection valued field or property.
            </description>
            <location chapter="9" section="1.7"/>
        </assertion>

        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1247</id>
            <description>To override the default properties of the column used for a basic type, the Column annotation
                is used on the collection-valued attribute in addition to the ElementCollection annotation. To override
                these defaults for an embeddable class, the AttributeOverride and/or AttributeOverrides annotations must
                be used.
            </description>
            <location chapter="9" section="1.7"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1248</id>
            <description>The basic or embeddable class that is the element type of the collection. Optional only if the
                collection field or property is defined using Java generics. Must be specified otherwise.
            </description>
            <location chapter="9" section="1.11"/>
        </assertion>
        <assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="false">
            <id>PERSISTENCE:SPEC:1249</id>
            <description>The EAGER strategy is a requirement on the persistence provider runtime that the collection
                elements must be eagerly fetched.
            </description>
            <location chapter="9" section="1.11"/>
        </assertion>


        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1250</id>
            <description>The Embedded annotation may be used to specify a persistent field or property of an entity or
                embeddable class whose value is an instance of an embedable class. The entity may override the column
                mappings declared or defaulted by the embeddable class.
            </description>
            <location chapter="9" section="1.13"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1251</id>
            <description>The AttributeOverride annotation may be used to override the column mappings declared within
                the embeddable class.
            </description>
            <location chapter="9" section="1.14"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1252</id>
            <description>The MappedById annotation may be used in conjunction with the EmbeddedId annotation to specify
                a derived primary key.
            </description>
            <location chapter="9" section="1.14"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1253</id>
            <description>The primary key generation strategy is that the persistence provider must generate the
                annotated entity primary key. The name of the primary key generator to be used as specified in the
                SequenceGenerator or TableGenerator annotation.
            </description>
            <location chapter="9" section="1.16"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1254</id>
            <description>Every many-to-many association has two sides, the owning side and the non-owning, or inverse,
                side. The join table, if not defaulted, is specified on the owning side. If the association is
                bidirectional, either side may be designated as the owning side.
            </description>
            <location chapter="9" section="1.24"/>
        </assertion>

        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1255</id>
            <description>The ManyToMany annotation may be used within an embeddable class contained within an entity
                class to specify a relationship to a collection of entities.
            </description>
            <location chapter="9" section="1.24"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1256</id>
            <description>If the relationship is bidirectional, the non-owning side must use the mappedBy element of the
                ManyToMany annotation to specify the relationship field or property of the embeddable class.
            </description>
            <location chapter="9" section="1.24"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1257</id>
            <description>ManyToOne annotation may be used within an embeddable class to specify a relationship from the
                embeddable class to an entity class.
            </description>
            <location chapter="9" section="1.25"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1258</id>
            <description>If the relationship is bidirectional, the non-owning OneToMany entity side must use the
                mappedBy element of the OneToMany annotation to specify the relationship field or property of the
                embeddable field or property on the owning side of the relationship.
            </description>
            <location chapter="9" section="1.25"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1259</id>
            <description>The dot (".") notation syntax must be used in the mappedBy element to indicate the relationship
                attribute within the embedded attribute.
            </description>
            <location chapter="9" section="1.25"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1260</id>
            <description>The MapKeyClass annotation and the type must be specified if Java generic types are not used.
            </description>
            <location chapter="9" section="1.27"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1261</id>
            <description>The MapKeyColumn annotation is used to specify the mapping for the key column of a map whose
                map key is a basic type.
            </description>
            <location chapter="9" section="1.28"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1262</id>
            <description>If there is more than one map key join column, a MapKeyJoinColumn annotation must be specified
                for each join column using the MapKeyJoinColumns annotation.
            </description>
            <location chapter="9" section="1.29"/>
        </assertion>

        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1263</id>
            <description>Both the name and the referencedColumnName elements must be specified in each such
                MapKeyJoinColumn annotation.
            </description>
            <location chapter="9" section="1.29"/>
        </assertion>

        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1264</id>
            <description>When the MapKeyJoinColumns annotation is used, both the name and the referencedColumnName
                elements must be specified in each of the grouped MapKeyJoinColumn annotations.
            </description>
            <location chapter="9" section="1.30"/>
        </assertion>

        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1265</id>
            <description>OneToMany annotation may be used within an embeddable class contained within an entity class to
                specify a relationship to a collection of entities. If the relationship is bidirectional, the
                mappedByelement must be used to specify the relationship field or property of the entity that is the
                owner of the relationship.
            </description>
            <location chapter="9" section="1.33"/>
        </assertion>

        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1266</id>
            <description>Portable applications must otherwise not depend upon a specific order of removal, and must not
                reassign an entity that has been orphaned to another relationship or otherwise attempt to persist it.
            </description>
            <location chapter="9" section="1.33"/>
        </assertion>

        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1267</id>
            <description>The OneToOne annotation may be used within an embeddable class to specify a relationship from
                the embeddable class to an entity class. If the relationship is bidirectional, the non-owning side must
                use the mappedBy element of the OneToOne annotation to specify the relationship field or property of the
                embeddable class.
            </description>
            <location chapter="9" section="1.33"/>
        </assertion>
        <assertion required="false" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1268</id>
            <description>The OrderBy annotation may be applied to an element collection. To specify an ordering by a
                basic type, the orderby_item is referred to as "value".
            </description>
            <location chapter="9" section="1.35"/>
        </assertion>

        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1269</id>
            <description>The contiguous element specifies whether the values of the order column need to be contiguous
                (the default) or may be sparse. If contiguous is true, the order column must be of integral type.
            </description>
            <location chapter="9" section="1.36"/>
        </assertion>
        <assertion required="true" impl-spec="true" defined-by="technology" status="active" testable="false">
            <id>PERSISTENCE:SPEC:1270</id>
            <description>If contiguous is false, the list order cannot be (portably) queried.
            </description>
            <location chapter="9" section="1.36"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1271</id>
            <description>By default: if the relationship is a many-to-many or unidirectional one-to-many relationship,
                the table is the join table for the relationship.
            </description>
            <location chapter="9" section="1.36"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1272</id>
            <description>The SecondaryTable annotation is used to specify a secondary table for the annotated entity
                class.
            </description>
            <location chapter="9" section="1.39"/>
        </assertion>
        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1273</id>
            <description>If no SecondaryTable annotation is specified, it is assumed that all persistent fields or
                properties of the entity are mapped to the primary table. Specifying one or more secondary tables
                indicates that the data for the entity class is stored across multiple tables.
            </description>
            <location chapter="9" section="1.39"/>
        </assertion>

        <assertion required="true" impl-spec="false" defined-by="technology" status="active" testable="true">
            <id>PERSISTENCE:SPEC:1274</id>
            <description>If no primary key join columns are specified, the join columns are assumed to reference the
                primary key columns of the primary table, and have the same names and types as the referenced primary
                key columns of the primary table.
            </description>
            <location chapter="9" section="1.39"/>
        </assertion>


    </assertions>
</spec>

